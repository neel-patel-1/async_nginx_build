diff -Naru -x .git -x .hgtags nginx-release-1.20.1/auto/cc/gcc ../asynch_mode_nginx/auto/cc/gcc
--- nginx-release-1.20.1/auto/cc/gcc	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/auto/cc/gcc	2022-03-15 13:23:40.536402806 -0500
@@ -1,6 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
 
 
 # gcc 2.7.2.3, 2.8.1, 2.95.4, egcs-1.1.2
@@ -48,9 +49,9 @@
 
 # optimizations
 
-#NGX_GCC_OPT="-O2"
+NGX_GCC_OPT="-O2 -D_FORTIFY_SOURCE=2 -fno-strict-overflow -fno-delete-null-pointer-checks -fwrapv"
 #NGX_GCC_OPT="-Os"
-NGX_GCC_OPT="-O"
+#NGX_GCC_OPT="-O"
 
 #CFLAGS="$CFLAGS -fomit-frame-pointer"
 
@@ -174,6 +175,10 @@
 # DragonFly's gcc3 generates DWARF
 #CFLAGS="$CFLAGS -g -gstabs"
 
+# required by Intel SDL
+CFLAGS="$CFLAGS -fstack-protector -fPIE -fPIC -Wformat -Wformat-security"
+CORE_LINK="-z noexecstack -z relro -z now -pie"
+
 if [ ".$CPP" = "." ]; then
     CPP="$CC -E"
 fi
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/auto/make ../asynch_mode_nginx/auto/make
--- nginx-release-1.20.1/auto/make	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/auto/make	2022-03-15 13:23:40.536402806 -0500
@@ -1,11 +1,13 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
 
 
 echo "creating $NGX_MAKEFILE"
 
 mkdir -p $NGX_OBJS/src/core $NGX_OBJS/src/event $NGX_OBJS/src/event/modules \
+         $NGX_OBJS/src/engine $NGX_OBJS/src/engine/modules \
          $NGX_OBJS/src/os/unix $NGX_OBJS/src/os/win32 \
          $NGX_OBJS/src/http $NGX_OBJS/src/http/v2 $NGX_OBJS/src/http/modules \
          $NGX_OBJS/src/http/modules/perl \
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/auto/modules ../asynch_mode_nginx/auto/modules
--- nginx-release-1.20.1/auto/modules	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/auto/modules	2022-03-15 13:23:40.536402806 -0500
@@ -1,6 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
 
 
 if [ $EVENT_SELECT = NO -a $EVENT_FOUND = NO ]; then
@@ -56,6 +57,10 @@
 fi
 
 
+SSL_ENGINE_MODULES="$SSL_ENGINE_MODULES $DASYNC_ENGINE_MODULE"
+CORE_SRCS="$CORE_SRCS $DASYNC_ENGINE_SRCS"
+
+
 if [ $HTTP = YES ]; then
     HTTP_MODULES=
     HTTP_DEPS=
@@ -1256,7 +1261,7 @@
 
 if [ $USE_OPENSSL = YES ]; then
     ngx_module_type=CORE
-    ngx_module_name=ngx_openssl_module
+    ngx_module_name=
     ngx_module_incs=
     ngx_module_deps=src/event/ngx_event_openssl.h
     ngx_module_srcs="src/event/ngx_event_openssl.c
@@ -1283,7 +1288,7 @@
 fi
 
 
-modules="$CORE_MODULES $EVENT_MODULES"
+modules="$CORE_MODULES $EVENT_MODULES $SSL_ENGINE_MODULES"
 
 
 # thread pool module should be initialized after events
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/auto/sources ../asynch_mode_nginx/auto/sources
--- nginx-release-1.20.1/auto/sources	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/auto/sources	2022-03-15 13:23:40.540402840 -0500
@@ -1,6 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
 
 
 CORE_MODULES="ngx_core_module ngx_errlog_module ngx_conf_module"
@@ -123,12 +124,20 @@
 IOCP_MODULE=ngx_iocp_module
 IOCP_SRCS=src/event/modules/ngx_iocp_module.c
 
+SSL_ENGINE_MODULES="ngx_ssl_engine_module ngx_ssl_engine_core_module"
+SSL_ENGINE_INCS="src/engine src/engine/modules"
+SSL_ENGINE_DEPS="src/engine/ngx_ssl_engine.h"
+SSL_ENGINE_SRCS="src/engine/ngx_ssl_engine.c"
+
+DASYNC_ENGINE_MODULE=ngx_ssl_engine_dasync_module
+DASYNC_ENGINE_SRCS=src/engine/modules/ngx_ssl_engine_dasync_module.c
+
 FILE_AIO_SRCS="src/os/unix/ngx_file_aio_read.c"
 LINUX_AIO_SRCS="src/os/unix/ngx_linux_aio_read.c"
 
-UNIX_INCS="$CORE_INCS $EVENT_INCS src/os/unix"
+UNIX_INCS="$CORE_INCS $EVENT_INCS $SSL_ENGINE_INCS src/os/unix"
 
-UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
+UNIX_DEPS="$CORE_DEPS $EVENT_DEPS $SSL_ENGINE_DEPS \
             src/os/unix/ngx_time.h \
             src/os/unix/ngx_errno.h \
             src/os/unix/ngx_alloc.h \
@@ -157,7 +166,7 @@
 #            src/os/unix/ngx_sunpro_sparc64.il \
 
 
-UNIX_SRCS="$CORE_SRCS $EVENT_SRCS \
+UNIX_SRCS="$CORE_SRCS $EVENT_SRCS $SSL_ENGINE_SRCS \
             src/os/unix/ngx_time.c \
             src/os/unix/ngx_errno.c \
             src/os/unix/ngx_alloc.c \
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/conf/nginx.conf ../asynch_mode_nginx/conf/nginx.conf
--- nginx-release-1.20.1/conf/nginx.conf	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/conf/nginx.conf	2022-03-15 13:23:40.540402840 -0500
@@ -99,6 +99,8 @@
     #    listen       443 ssl;
     #    server_name  localhost;
 
+    #    ssl_protocols       TLSv1.2;
+
     #    ssl_certificate      cert.pem;
     #    ssl_certificate_key  cert.key;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/conf/nginx.QAT-sample.conf ../asynch_mode_nginx/conf/nginx.QAT-sample.conf
--- nginx-release-1.20.1/conf/nginx.QAT-sample.conf	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/conf/nginx.QAT-sample.conf	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,68 @@
+
+worker_processes  1;
+
+load_module modules/ngx_http_qatzip_filter_module.so;
+load_module modules/ngx_ssl_engine_qat_module.so;
+
+events {
+    use epoll;
+    worker_connections 102400;
+    accept_mutex off;
+}
+
+# Enable QAT engine in heretic mode.
+ssl_engine {
+    use_engine qatengine;
+    default_algorithms RSA,EC,DH,DSA;
+    qat_engine {
+        qat_offload_mode async;
+        qat_notify_mode poll;
+        qat_poll_mode heuristic;
+        qat_sw_fallback on;
+    }
+}
+
+http {
+    gzip on;
+    gzip_min_length     128;
+    gzip_comp_level     1;
+    gzip_types  text/css text/javascript text/xml text/plain text/x-component application/javascript application/json application/xml application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;
+    gzip_vary            on;
+    gzip_disable        "msie6";
+    gzip_http_version   1.0;
+
+    qatzip_sw failover;
+    qatzip_min_length 128;
+    qatzip_comp_level 1;
+    qatzip_buffers 16 8k;
+    qatzip_types text/css text/javascript text/xml text/plain text/x-component application/javascript application/json application/xml application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml application/octet-stream image/jpeg;
+    qatzip_chunk_size   64k;
+    qatzip_stream_size  256k;
+    qatzip_sw_threshold 256;
+
+    # HTTP server with QATZip enabled.
+    server {
+        listen       80;
+        server_name  localhost;
+        location / {
+            root   html;
+            index  index.html index.htm;
+        }
+    }
+
+    # HTTPS server with async mode.
+    server {
+        #If QAT Engine enabled,  `asynch` need to add to `listen` directive or just add `ssl_asynch  on;` to the context.
+        listen       443 ssl asynch;
+        server_name  localhost;
+
+        ssl_protocols       TLSv1.2;
+        ssl_certificate      cert.pem;
+        ssl_certificate_key  cert.key;
+
+        location / {
+            root   html;
+            index  index.html index.htm;
+        }
+    }
+}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/config.example ../asynch_mode_nginx/config.example
--- nginx-release-1.20.1/config.example	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/config.example	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,57 @@
+# ============================================================================
+#
+# BSD LICENSE
+#
+# Copyright (c) 2014-2021, Intel Corporation.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#     * Redistributions of source code must retain the above copyright notice,
+#       this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in the
+#       documentation and/or other materials provided with the distribution.
+#     * Neither the name of the <ORGANIZATION> nor the names of its
+#       contributors may be used to endorse or promote products derived from
+#       this software without specific prior written permission.
+#
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+# THE POSSIBILITY OF SUCH DAMAGE.
+#
+#
+# ============================================================================
+
+#!/bin/bash -x
+if [ ! -d "$NGINX_INSTALL_DIR" ]; then
+   echo "NGINX install directory not been set or does not exist. Run:- export NGINX_INSTALL_DIR=<location you want to install the built nginx server to>\n"
+   exit 0
+fi
+
+if [ ! -d "$OPENSSL_LIB" ]; then
+   echo "OPENSSL_LIB has not been set or does not exist. Run:- export OPENSSL_LIB=<location you have installed the built openssl library to>\n"
+   exit 0
+fi
+
+./configure \
+--prefix=$NGINX_INSTALL_DIR \
+--without-http_rewrite_module \
+--with-http_ssl_module \
+--with-http_stub_status_module \
+--with-http_v2_module \
+--with-stream \
+--with-stream_ssl_module \
+--add-dynamic-module=modules/nginx_qatzip_module \
+--add-dynamic-module=modules/nginx_qat_module/ \
+--with-cc-opt="-DNGX_SECURE_MEM -I$OPENSSL_LIB/include -I$QZ_ROOT/include -Wno-error=deprecated-declarations" \
+--with-ld-opt="-Wl,-rpath=$OPENSSL_LIB/lib -L$OPENSSL_LIB/lib -L$QZ_ROOT/src -lqatzip -lz"
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/configure ../asynch_mode_nginx/configure
--- nginx-release-1.20.1/configure	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/configure	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,116 @@
+#!/bin/sh
+
+# Copyright (C) Igor Sysoev
+# Copyright (C) Nginx, Inc.
+
+
+LC_ALL=C
+export LC_ALL
+
+. auto/options
+. auto/init
+. auto/sources
+
+test -d $NGX_OBJS || mkdir -p $NGX_OBJS
+
+echo > $NGX_AUTO_HEADERS_H
+echo > $NGX_AUTOCONF_ERR
+
+echo "#define NGX_CONFIGURE \"$NGX_CONFIGURE\"" > $NGX_AUTO_CONFIG_H
+
+
+if [ $NGX_DEBUG = YES ]; then
+    have=NGX_DEBUG . auto/have
+fi
+
+
+if test -z "$NGX_PLATFORM"; then
+    echo "checking for OS"
+
+    NGX_SYSTEM=`uname -s 2>/dev/null`
+    NGX_RELEASE=`uname -r 2>/dev/null`
+    NGX_MACHINE=`uname -m 2>/dev/null`
+
+    echo " + $NGX_SYSTEM $NGX_RELEASE $NGX_MACHINE"
+
+    NGX_PLATFORM="$NGX_SYSTEM:$NGX_RELEASE:$NGX_MACHINE";
+
+    case "$NGX_SYSTEM" in
+        MINGW32_* | MINGW64_* | MSYS_*)
+            NGX_PLATFORM=win32
+        ;;
+    esac
+
+else
+    echo "building for $NGX_PLATFORM"
+    NGX_SYSTEM=$NGX_PLATFORM
+fi
+
+. auto/cc/conf
+
+if [ "$NGX_PLATFORM" != win32 ]; then
+    . auto/headers
+fi
+
+. auto/os/conf
+
+if [ "$NGX_PLATFORM" != win32 ]; then
+    . auto/unix
+fi
+
+. auto/threads
+. auto/modules
+. auto/lib/conf
+
+case ".$NGX_PREFIX" in
+    .)
+        NGX_PREFIX=${NGX_PREFIX:-/usr/local/nginx}
+        have=NGX_PREFIX value="\"$NGX_PREFIX/\"" . auto/define
+    ;;
+
+    .!)
+        NGX_PREFIX=
+    ;;
+
+    *)
+        have=NGX_PREFIX value="\"$NGX_PREFIX/\"" . auto/define
+    ;;
+esac
+
+if [ ".$NGX_CONF_PREFIX" != "." ]; then
+    have=NGX_CONF_PREFIX value="\"$NGX_CONF_PREFIX/\"" . auto/define
+fi
+
+have=NGX_SBIN_PATH value="\"$NGX_SBIN_PATH\"" . auto/define
+have=NGX_CONF_PATH value="\"$NGX_CONF_PATH\"" . auto/define
+have=NGX_PID_PATH value="\"$NGX_PID_PATH\"" . auto/define
+have=NGX_LOCK_PATH value="\"$NGX_LOCK_PATH\"" . auto/define
+have=NGX_ERROR_LOG_PATH value="\"$NGX_ERROR_LOG_PATH\"" . auto/define
+
+have=NGX_HTTP_LOG_PATH value="\"$NGX_HTTP_LOG_PATH\"" . auto/define
+have=NGX_HTTP_CLIENT_TEMP_PATH value="\"$NGX_HTTP_CLIENT_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_PROXY_TEMP_PATH value="\"$NGX_HTTP_PROXY_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_FASTCGI_TEMP_PATH value="\"$NGX_HTTP_FASTCGI_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_UWSGI_TEMP_PATH value="\"$NGX_HTTP_UWSGI_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_SCGI_TEMP_PATH value="\"$NGX_HTTP_SCGI_TEMP_PATH\""
+. auto/define
+
+. auto/make
+. auto/lib/make
+. auto/install
+
+# STUB
+. auto/stubs
+
+have=NGX_USER value="\"$NGX_USER\"" . auto/define
+have=NGX_GROUP value="\"$NGX_GROUP\"" . auto/define
+
+if [ ".$NGX_BUILD" != "." ]; then
+    have=NGX_BUILD value="\"$NGX_BUILD\"" . auto/define
+fi
+
+. auto/summary
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/dtd/change_log_conf.dtd ../asynch_mode_nginx/docs/dtd/change_log_conf.dtd
--- nginx-release-1.20.1/docs/dtd/change_log_conf.dtd	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/dtd/change_log_conf.dtd	1969-12-31 18:00:00.000000000 -0600
@@ -1,22 +0,0 @@
-
-<!ELEMENT configuration   (length, start, indent, changes+) >
-
-<!ELEMENT length          (#PCDATA) >
-<!ELEMENT start           (#PCDATA) >
-<!ELEMENT indent          (#PCDATA) >
-
-<!ELEMENT changes         (title, length,
-                           bugfix, feature, change, workaround,
-                           (month, month, month, month, month, month,
-                            month, month, month, month, month, month)?) >
-
-<!ATTLIST changes         lang ( ru | en) #REQUIRED>
-
-<!ELEMENT title           (#PCDATA) >
-
-<!ELEMENT bugfix          (#PCDATA) >
-<!ELEMENT feature         (#PCDATA) >
-<!ELEMENT change          (#PCDATA) >
-<!ELEMENT workaround      (#PCDATA) >
-
-<!ELEMENT month           (#PCDATA) >
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/dtd/changes.dtd ../asynch_mode_nginx/docs/dtd/changes.dtd
--- nginx-release-1.20.1/docs/dtd/changes.dtd	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/dtd/changes.dtd	1969-12-31 18:00:00.000000000 -0600
@@ -1,22 +0,0 @@
-
-<!ENTITY  nbsp         "&#xA0;" >
-<!ENTITY  mdash        "&#xA0;- " >
-
-
-<!ELEMENT change_log   (changes)* >
-<!ATTLIST change_log   title  CDATA #REQUIRED >
-
-<!ELEMENT changes      (change)* >
-<!ATTLIST changes      ver    CDATA #REQUIRED
-                       date   CDATA #REQUIRED
->
-
-<!ELEMENT change       (para)* >
-<!ATTLIST change       type (bugfix | feature | change | security | workaround) #IMPLIED >
-
-<!ELEMENT para         (#PCDATA | at | br | nobr)* >
-<!ATTLIST para         lang (ru | en) #REQUIRED >
-
-<!ELEMENT at           EMPTY >
-<!ELEMENT br           EMPTY >
-<!ELEMENT nobr         (#PCDATA) >
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/GNUmakefile ../asynch_mode_nginx/docs/GNUmakefile
--- nginx-release-1.20.1/docs/GNUmakefile	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/GNUmakefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,41 +0,0 @@
-
-VER=	$(shell grep 'define NGINX_VERSION' src/core/nginx.h		\
-		| sed -e 's/^.*"\(.*\)".*/\1/')
-NGINX=	nginx-$(VER)
-TEMP=	tmp
-XSLS?=	xslscript.pl
-
-
-all:		changes
-
-changes:	$(TEMP)/$(NGINX)/CHANGES.ru				\
-		$(TEMP)/$(NGINX)/CHANGES
-
-
-$(TEMP)/$(NGINX)/CHANGES.ru:	docs/dtd/changes.dtd			\
-				docs/xml/nginx/changes.xml		\
-				docs/xml/change_log_conf.xml		\
-				docs/xslt/changes.xslt
-
-	mkdir -p $(TEMP)/$(NGINX)
-
-	xmllint --noout --valid docs/xml/nginx/changes.xml
-	xsltproc --stringparam lang ru					\
-		-o $@ docs/xslt/changes.xslt docs/xml/nginx/changes.xml
-
-
-$(TEMP)/$(NGINX)/CHANGES:	docs/dtd/changes.dtd			\
-				docs/xml/nginx/changes.xml		\
-				docs/xml/change_log_conf.xml		\
-				docs/xslt/changes.xslt
-
-	mkdir -p $(TEMP)/$(NGINX)
-
-	xmllint --noout --valid docs/xml/nginx/changes.xml
-	xsltproc --stringparam lang en					\
-		-o $@ docs/xslt/changes.xslt docs/xml/nginx/changes.xml
-
-
-docs/xslt/changes.xslt:		docs/xsls/changes.xsls
-
-	$(XSLS) -o $@ $<
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/text/LICENSE ../asynch_mode_nginx/docs/text/LICENSE
--- nginx-release-1.20.1/docs/text/LICENSE	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/text/LICENSE	1969-12-31 18:00:00.000000000 -0600
@@ -1,26 +0,0 @@
-/* 
- * Copyright (C) 2002-2021 Igor Sysoev
- * Copyright (C) 2011-2021 Nginx, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/text/README ../asynch_mode_nginx/docs/text/README
--- nginx-release-1.20.1/docs/text/README	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/text/README	1969-12-31 18:00:00.000000000 -0600
@@ -1,3 +0,0 @@
-
-Documentation is available at http://nginx.org
-
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/xml/change_log_conf.xml ../asynch_mode_nginx/docs/xml/change_log_conf.xml
--- nginx-release-1.20.1/docs/xml/change_log_conf.xml	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/xml/change_log_conf.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,47 +0,0 @@
-<?xml version="1.0" ?>
-<!DOCTYPE configuration SYSTEM "../dtd/change_log_conf.dtd" >
-
-<configuration>
-
-<length>76</length>
-
-<start>    *) </start>
-<indent>       </indent>
-
-<changes lang="ru">
-    <title>Изменения в </title>
-    <length>66</length>
-
-    <bugfix>Исправление</bugfix>
-    <feature>Добавление</feature>
-    <change>Изменение</change>
-    <security>Безопасность</security>
-    <workaround>Изменение</workaround>
-</changes>
-
-<changes lang="en">
-    <title>Changes with </title>
-    <length>65</length>
-
-    <bugfix>Bugfix</bugfix>
-    <feature>Feature</feature>
-    <change>Change</change>
-    <security>Security</security>
-    <workaround>Workaround</workaround>
-
-    <month> Jan </month>
-    <month> Feb </month>
-    <month> Mar </month>
-    <month> Apr </month>
-    <month> May </month>
-    <month> Jun </month>
-    <month> Jul </month>
-    <month> Aug </month>
-    <month> Sep </month>
-    <month> Oct </month>
-    <month> Nov </month>
-    <month> Dec </month>
-
-</changes>
-
-</configuration>
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/xml/nginx/changes.xml ../asynch_mode_nginx/docs/xml/nginx/changes.xml
--- nginx-release-1.20.1/docs/xml/nginx/changes.xml	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/xml/nginx/changes.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,28859 +0,0 @@
-<?xml version="1.0" ?>
-<!DOCTYPE change_log SYSTEM "../../dtd/changes.dtd" >
-
-
-<change_log title="nginx">
-
-
-<changes ver="1.20.1" date="2021-05-25">
-
-<change type="security">
-<para lang="ru">
-при использовании директивы resolver
-во время обработки ответа DNS-сервера
-могла происходить перезапись одного байта памяти,
-что позволяло атакующему,
-имеющему возможность подделывать UDP-пакеты от DNS-сервера,
-вызвать падение рабочего процесса
-или, потенциально, выполнение произвольного кода (CVE-2021-23017).
-</para>
-<para lang="en">
-1-byte memory overwrite might occur
-during DNS server response processing
-if the "resolver" directive was used,
-allowing an attacker
-who is able to forge UDP packets from the DNS server
-to cause worker process crash
-or, potentially, arbitrary code execution (CVE-2021-23017).
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.20.0" date="2021-04-20">
-
-<change>
-<para lang="ru">
-Стабильная ветка 1.20.x.
-</para>
-<para lang="en">
-1.20.x stable branch.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.10" date="2021-04-13">
-
-<change type="change">
-<para lang="ru">
-в директиве keepalive_requests значение по умолчанию изменено на 1000.
-</para>
-<para lang="en">
-the default value of the "keepalive_requests" directive was changed to 1000.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива keepalive_time.
-</para>
-<para lang="en">
-the "keepalive_time" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $connection_time.
-</para>
-<para lang="en">
-the $connection_time variable.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании zlib-ng
-в логах появлялись сообщения "gzip filter failed to use preallocated memory".
-</para>
-<para lang="en">
-"gzip filter failed to use preallocated memory" alerts appeared in logs
-when using zlib-ng.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.9" date="2021-03-30">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с почтовым прокси-сервером,
-но без модуля ngx_mail_ssl_module;
-ошибка появилась в 1.19.8.
-</para>
-<para lang="en">
-nginx could not be built with the mail proxy module,
-but without the ngx_mail_ssl_module;
-the bug had appeared in 1.19.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при работе с gRPC-бэкендами могли возникать ошибки
-"upstream sent response body larger than indicated content length";
-ошибка появилась в 1.19.1.
-</para>
-<para lang="en">
-"upstream sent response body larger than indicated content length"
-errors might occur when working with gRPC backends;
-the bug had appeared in 1.19.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если клиент закрывал соединение в момент отбрасывания тела запроса,
-nginx мог не закрыть соединение до истечения keepalive-таймаута.
-</para>
-<para lang="en">
-nginx might not close a connection till keepalive timeout expiration
-if the connection was closed by the client while discarding the request body.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при ожидании задержки limit_req или auth_delay, а также при работе с бэкендами
-nginx мог не обнаружить, что соединение уже закрыто клиентом.
-</para>
-<para lang="en">
-nginx might not detect that a connection was already closed by the client
-when waiting for auth_delay or limit_req delay, or when working with backends.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в методе обработки соединений eventport.
-</para>
-<para lang="en">
-in the eventport method.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.8" date="2021-03-09">
-
-<change type="feature">
-<para lang="ru">
-в директиве proxy_cookie_flags теперь
-флаги можно задавать с помощью переменных.
-</para>
-<para lang="en">
-flags in the "proxy_cookie_flags" directive
-can now contain variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр proxy_protocol в директиве listen,
-директивы proxy_protocol и set_real_ip_from
-в почтовом прокси-сервере.
-</para>
-<para lang="en">
-the "proxy_protocol" parameter of the "listen" directive,
-the "proxy_protocol" and "set_real_ip_from" directives
-in mail proxy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-HTTP/2-соединения сразу закрывались
-при использовании "keepalive_timeout 0";
-ошибка появилась в 1.19.7.
-</para>
-<para lang="en">
-HTTP/2 connections were immediately closed
-when using "keepalive_timeout 0";
-the bug had appeared in 1.19.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-некоторые ошибки логгировались как неизвестные,
-если nginx был собран с glibc 2.32.
-</para>
-<para lang="en">
-some errors were logged as unknown
-if nginx was built with glibc 2.32.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в методе обработки соединений eventport.
-</para>
-<para lang="en">
-in the eventport method.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.7" date="2021-02-16">
-
-<change type="change">
-<para lang="ru">
-обработка соединений в HTTP/2 была изменена
-и теперь более соответствует HTTP/1.x;
-директивы http2_recv_timeout, http2_idle_timeout
-и http2_max_requests упразднены,
-вместо них следует использовать директивы
-keepalive_timeout и keepalive_requests.
-</para>
-<para lang="en">
-connections handling in HTTP/2 has been changed
-to better match HTTP/1.x;
-the "http2_recv_timeout", "http2_idle_timeout",
-and "http2_max_requests" directives have been removed,
-the "keepalive_timeout" and "keepalive_requests" directives
-should be used instead.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы http2_max_field_size и http2_max_header_size упразднены,
-вместо них следует использовать директиву large_client_header_buffers.
-</para>
-<para lang="en">
-the "http2_max_field_size" and "http2_max_header_size" directives
-have been removed,
-the "large_client_header_buffers" directive should be used instead.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при исчерпании свободных соединений
-nginx закрывает не только keepalive-соединения,
-но и соединения в lingering close.
-</para>
-<para lang="en">
-now, if free worker connections are exhausted,
-nginx starts closing not only keepalive connections,
-but also connections in lingering close.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в логах могли появляться сообщения "zero size buf in output",
-если бэкенд возвращал некорректный ответ
-при небуферизированном проксировании;
-ошибка появилась в 1.19.1.
-</para>
-<para lang="en">
-"zero size buf in output" alerts might appear in logs
-if an upstream server returned an incorrect response
-during unbuffered proxying;
-the bug had appeared in 1.19.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы return
-вместе с image_filter или xslt_stylesheet
-HEAD-запросы обрабатывались некорректно.
-</para>
-<para lang="en">
-HEAD requests were handled incorrectly
-if the "return" directive was used
-with the "image_filter" or "xslt_stylesheet" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве add_trailer.
-</para>
-<para lang="en">
-in the "add_trailer" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.6" date="2020-12-15">
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "no live upstreams",
-если server в блоке upstream был помечен как down.
-</para>
-<para lang="en">
-"no live upstreams" errors
-if a "server" inside "upstream" block was marked as "down".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTPS в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.19.5.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process if HTTPS was used;
-the bug had appeared in 1.19.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал ошибку 400 на запросы вида
-<nobr>"GET http://example.com?args HTTP/1.0"</nobr>.
-</para>
-<para lang="en">
-nginx returned the 400 response on requests like
-<nobr>"GET http://example.com?args HTTP/1.0"</nobr>.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модулях ngx_http_flv_module и ngx_http_mp4_module.<br/>
-Спасибо Chris Newton.
-</para>
-<para lang="en">
-in the ngx_http_flv_module and ngx_http_mp4_module.<br/>
-Thanks to Chris Newton.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.5" date="2020-11-24">
-
-<change type="feature">
-<para lang="ru">
-ключ -e.
-</para>
-<para lang="en">
-the -e switch.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при сборке дополнительных модулей
-теперь можно указывать одни и те же исходные файлы в разных модулях.
-</para>
-<para lang="en">
-the same source files can now be specified in different modules
-while building addon modules.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL shutdown не работал
-при закрытии соединений с ожиданием дополнительных данных (lingering close).
-</para>
-<para lang="en">
-SSL shutdown did not work
-when lingering close was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при работе с gRPC-бэкендами
-могли возникать ошибки "upstream sent frame for closed stream".
-</para>
-<para lang="en">
-"upstream sent frame for closed stream" errors might occur
-when working with gRPC backends.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-во внутреннем API для обработки тела запроса.
-</para>
-<para lang="en">
-in request body filters internal API.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.4" date="2020-10-27">
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_conf_command, proxy_ssl_conf_command, grpc_ssl_conf_command
-и uwsgi_ssl_conf_command.
-</para>
-<para lang="en">
-the "ssl_conf_command", "proxy_ssl_conf_command", "grpc_ssl_conf_command",
-and "uwsgi_ssl_conf_command" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_reject_handshake.
-</para>
-<para lang="en">
-the "ssl_reject_handshake" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_smtp_auth в почтовом прокси-сервере.
-</para>
-<para lang="en">
-the "proxy_smtp_auth" directive in mail proxy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.3" date="2020-09-29">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_set_module.
-</para>
-<para lang="en">
-the ngx_stream_set_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_cookie_flags.
-</para>
-<para lang="en">
-the "proxy_cookie_flags" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива userid_flags.
-</para>
-<para lang="en">
-the "userid_flags" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-расширение управления кэшированием stale-if-error
-ошибочно применялось, если бэкенд возвращал ответ
-с кодом 500, 502, 503, 504, 403, 404 или 429.
-</para>
-<para lang="en">
-the "stale-if-error" cache control extension
-was erroneously applied if backend returned a response
-with status code 500, 502, 503, 504, 403, 404, or 429.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовалось кэширование
-и бэкенд возвращал ответы с строкой заголовка Vary,
-в логах могли появляться сообщения "[crit] cache file ... has too long header".
-</para>
-<para lang="en">
-"[crit] cache file ... has too long header" messages might appear in logs
-if caching was used
-and the backend returned responses with the "Vary" header line.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании OpenSSL 1.1.1
-в логах могли появляться сообщения "[crit] SSL_write() failed".
-</para>
-<para lang="en">
-"[crit] SSL_write() failed" messages might appear in logs
-when using OpenSSL 1.1.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в логах могли появляться сообщения
-"SSL_shutdown() failed (SSL: ... bad write retry)";
-ошибка появилась в 1.19.2.
-</para>
-<para lang="en">
-"SSL_shutdown() failed (SSL: ... bad write retry)"
-messages might appear in logs;
-the bug had appeared in 1.19.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-в рабочем процессе мог произойти segmentation fault,
-если ошибки с кодом 400 с помощью директивы error_page
-перенаправлялись в проксируемый location.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using HTTP/2
-if errors with code 400 were redirected to a proxied location
-using the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании HTTP/2 и подзапросов в модуле njs.
-</para>
-<para lang="en">
-socket leak when using HTTP/2 and subrequests in the njs module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.2" date="2020-08-11">
-
-<change type="change">
-<para lang="ru">
-теперь nginx начинает закрывать keepalive-соединения,
-не дожидаясь исчерпания всех свободных соединений,
-а также пишет об этом предупреждение в лог ошибок.
-</para>
-<para lang="en">
-now nginx starts closing keepalive connections
-before all free worker connections are exhausted,
-and logs a warning about this to the error log.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-оптимизация чтения тела запроса
-при использовании chunked transfer encoding.
-</para>
-<para lang="en">
-optimization of client request body reading
-when using chunked transfer encoding.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при использовании директивы ssl_ocsp.
-</para>
-<para lang="en">
-memory leak if the "ssl_ocsp" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в логах могли появляться сообщения "zero size buf in output",
-если FastCGI-сервер возвращал некорректный ответ;
-ошибка появилась в 1.19.1.
-</para>
-<para lang="en">
-"zero size buf in output" alerts might appear in logs
-if a FastCGI server returned an incorrect response;
-the bug had appeared in 1.19.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если размеры large_client_header_buffers отличались
-в разных виртуальных серверах.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if different large_client_header_buffers sizes were used
-in different virtual servers.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL shutdown мог не работать.
-</para>
-<para lang="en">
-SSL shutdown might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в логах могли появляться сообщения
-"SSL_shutdown() failed (SSL: ... bad write retry)".
-</para>
-<para lang="en">
-"SSL_shutdown() failed (SSL: ... bad write retry)"
-messages might appear in logs.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_slice_module.
-</para>
-<para lang="en">
-in the ngx_http_slice_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_xslt_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_xslt_filter_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.1" date="2020-07-07">
-
-<change type="change">
-<para lang="ru">
-директивы lingering_close, lingering_time и lingering_timeout
-теперь работают при использовании HTTP/2.
-</para>
-<para lang="en">
-the "lingering_close", "lingering_time", and "lingering_timeout" directives
-now work when using HTTP/2.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь лишние данные, присланные бэкендом, всегда отбрасываются.
-</para>
-<para lang="en">
-now extra data sent by a backend are always discarded.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при получении слишком короткого ответа от FastCGI-сервера
-nginx пытается отправить клиенту доступную часть ответа,
-после чего закрывает соединение с клиентом.
-</para>
-<para lang="en">
-now after receiving a too short response from a FastCGI server
-nginx tries to send the available part of the response to the client,
-and then closes the client connection.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при получении ответа некорректной длины от gRPC-бэкенда
-nginx прекращает обработку ответа с ошибкой.
-</para>
-<para lang="en">
-now after receiving a response with incorrect length from a gRPC backend
-nginx stops response processing with an error.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр min_free в директивах proxy_cache_path, fastcgi_cache_path,
-scgi_cache_path и uwsgi_cache_path.<br/>
-Спасибо Adam Bambuch.
-</para>
-<para lang="en">
-the "min_free" parameter of the "proxy_cache_path", "fastcgi_cache_path",
-"scgi_cache_path", and "uwsgi_cache_path" directives.<br/>
-Thanks to Adam Bambuch.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не удалял unix domain listen-сокеты
-при плавном завершении по сигналу SIGQUIT.
-</para>
-<para lang="en">
-nginx did not delete unix domain listen sockets
-during graceful shutdown on the SIGQUIT signal.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-UDP-пакеты нулевого размера не проксировались.
-</para>
-<para lang="en">
-zero length UDP datagrams were not proxied.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-проксирование на uwsgi-бэкенды с использованием SSL могло не работать.<br/>
-Спасибо Guanzhong Chen.
-</para>
-<para lang="en">
-proxying to uwsgi backends using SSL might not work.<br/>
-Thanks to Guanzhong Chen.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при использовании директивы ssl_ocsp.
-</para>
-<para lang="en">
-in error handling when using the "ssl_ocsp" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании файловых систем XFS и NFS
-размер кэша на диске мог считаться некорректно.
-</para>
-<para lang="en">
-on XFS and NFS file systems
-disk cache size might be calculated incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервер memcached возвращал некорректный ответ,
-в логах могли появляться сообщения "negative size buf in writer".
-</para>
-<para lang="en">
-"negative size buf in writer" alerts might appear in logs
-if a memcached server returned a malformed response.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.19.0" date="2020-05-26">
-
-<change type="feature">
-<para lang="ru">
-проверка клиентских сертификатов с помощью OCSP.
-</para>
-<para lang="en">
-client certificate validation with OCSP.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при работе с gRPC-бэкендами
-могли возникать ошибки "upstream sent frame for closed stream".
-</para>
-<para lang="en">
-"upstream sent frame for closed stream" errors might occur
-when working with gRPC backends.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-OCSP stapling мог не работать,
-если не была указана директива resolver.
-</para>
-<para lang="en">
-OCSP stapling might not work
-if the "resolver" directive was not specified.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-соединения с некорректным HTTP/2 preface не логгировались.
-</para>
-<para lang="en">
-connections with incorrect HTTP/2 preface were not logged.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.10" date="2020-04-14">
-
-<change type="feature">
-<para lang="ru">
-директива auth_delay.
-</para>
-<para lang="en">
-the "auth_delay" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.9" date="2020-03-03">
-
-<change type="change">
-<para lang="ru">
-теперь nginx не разрешает
-несколько строк "Host" в заголовке запроса.
-</para>
-<para lang="en">
-now nginx does not allow
-several "Host" request header lines.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал дополнительные
-строки "Transfer-Encoding" в заголовке запроса.
-</para>
-<para lang="en">
-nginx ignored additional
-"Transfer-Encoding" request header lines.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании HTTP/2.
-</para>
-<para lang="en">
-socket leak when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался OCSP stapling.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if OCSP stapling was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении ошибок с кодом 494 с помощью директивы error_page
-nginx возвращал ответ с кодом 494 вместо 400.
-</para>
-<para lang="en">
-nginx used status code 494 instead of 400
-if errors with code 494 were redirected with the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании подзапросов в модуле njs и директивы aio.
-</para>
-<para lang="en">
-socket leak when using subrequests in the njs module and the "aio" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.8" date="2020-01-21">
-
-<change type="feature">
-<para lang="ru">
-директива grpc_pass поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "grpc_pass" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;
-ошибка появилась в 1.17.5.
-</para>
-<para lang="en">
-a timeout might occur while handling pipelined requests in an SSL connection;
-the bug had appeared in 1.17.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве debug_points при использовании HTTP/2.<br/>
-Спасибо Даниилу Бондареву.
-</para>
-<para lang="en">
-in the "debug_points" directive when using HTTP/2.<br/>
-Thanks to Daniil Bondarev.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.7" date="2019-12-24">
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации мог произойти segmentation fault,
-если в конфигурации использовалась
-директива rewrite с пустой строкой замены.
-</para>
-<para lang="en">
-a segmentation fault might occur on start or during reconfiguration
-if the "rewrite" directive with an empty replacement string
-was used in the configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если директива break использовалась совместно с директивой alias
-или директивой proxy_pass с URI.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "break" directive was used with the "alias" directive
-or with the "proxy_pass" directive with a URI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строка Location заголовка ответа могла содержать мусор,
-если URI запроса был изменён на URI, содержащий нулевой символ.
-</para>
-<para lang="en">
-the "Location" response header line might contain garbage
-if the request URI was rewritten to the one containing a null character.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при возврате перенаправлений с помощью директивы error_page
-запросы с телом обрабатывались некорректно;
-ошибка появилась в 0.7.12.
-</para>
-<para lang="en">
-requests with bodies were handled incorrectly
-when returning redirections with the "error_page" directive;
-the bug had appeared in 0.7.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании HTTP/2.
-</para>
-<para lang="en">
-socket leak when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;
-ошибка появилась в 1.17.5.
-</para>
-<para lang="en">
-a timeout might occur while handling pipelined requests in an SSL connection;
-the bug had appeared in 1.17.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_dav_module.
-</para>
-<para lang="en">
-in the ngx_http_dav_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.6" date="2019-11-19">
-
-<change type="feature">
-<para lang="ru">
-переменные $proxy_protocol_server_addr и $proxy_protocol_server_port.
-</para>
-<para lang="en">
-the $proxy_protocol_server_addr and $proxy_protocol_server_port variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива limit_conn_dry_run.
-</para>
-<para lang="en">
-the "limit_conn_dry_run" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $limit_req_status и $limit_conn_status.
-</para>
-<para lang="en">
-the $limit_req_status and $limit_conn_status variables.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.5" date="2019-10-22">
-
-<change type="feature">
-<para lang="ru">
-теперь nginx использует вызов ioctl(FIONREAD), если он доступен,
-чтобы избежать чтения из быстрого соединения в течение долгого времени.
-</para>
-<para lang="en">
-now nginx uses ioctl(FIONREAD), if available,
-to avoid reading from a fast connection for a long time.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-неполные закодированные символы в конце URI запроса игнорировались.
-</para>
-<para lang="en">
-incomplete escaped characters at the end of the request URI were ignored.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-"/." и "/.." в конце URI запроса не нормализовывались.
-</para>
-<para lang="en">
-"/." and "/.." at the end of the request URI were not normalized.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве merge_slashes.
-</para>
-<para lang="en">
-in the "merge_slashes" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве ignore_invalid_headers.<br/>
-Спасибо Alan Kemp.
-</para>
-<para lang="en">
-in the "ignore_invalid_headers" directive.<br/>
-Thanks to Alan Kemp.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с MinGW-w64 gcc 8.1 и новее.
-</para>
-<para lang="en">
-nginx could not be built with MinGW-w64 gcc 8.1 or newer.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.4" date="2019-09-24">
-
-<change type="change">
-<para lang="ru">
-улучшено детектирование некорректного поведения клиентов в HTTP/2.
-</para>
-<para lang="en">
-better detection of incorrect client behavior in HTTP/2.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в обработке непрочитанного тела запроса
-при возврате ошибок в HTTP/2.
-</para>
-<para lang="en">
-in handling of not fully read client request body
-when returning errors in HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива worker_shutdown_timeout могла не работать
-при использовании HTTP/2.
-</para>
-<para lang="en">
-the "worker_shutdown_timeout" directive might not work
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 и директивы proxy_request_buffering
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using HTTP/2 and the "proxy_request_buffering" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Windows при использовании SSL
-уровень записи в лог ошибки ECONNABORTED был "crit" вместо "error".
-</para>
-<para lang="en">
-the ECONNABORTED error log level was "crit" instead of "error"
-on Windows when using SSL.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал лишние данные при использовании chunked transfer encoding.
-</para>
-<para lang="en">
-nginx ignored extra data when using chunked transfer encoding.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовалась директива return и
-при чтении тела запроса возникала ошибка,
-nginx всегда возвращал ошибку 500.
-</para>
-<para lang="en">
-nginx always returned the 500 error
-if the "return" directive was used
-and an error occurred during reading client request body.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.
-</para>
-<para lang="en">
-in memory allocation error handling.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.3" date="2019-08-13">
-
-<change type="security">
-<para lang="ru">
-при использовании HTTP/2 клиент мог вызвать
-чрезмерное потребление памяти и ресурсов процессора
-(CVE-2019-9511, CVE-2019-9513, CVE-2019-9516).
-</para>
-<para lang="en">
-when using HTTP/2 a client might cause
-excessive memory consumption and CPU usage
-(CVE-2019-9511, CVE-2019-9513, CVE-2019-9516).
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании сжатия в логах могли появляться сообщения "zero size buf";
-ошибка появилась в 1.17.2.
-</para>
-<para lang="en">
-"zero size buf" alerts might appear in logs when using gzipping;
-the bug had appeared in 1.17.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы resolver в SMTP прокси-сервере
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "resolver" directive was used in SMTP proxy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.2" date="2019-07-23">
-
-<change type="change">
-<para lang="ru">
-минимальная поддерживаемая версия zlib&mdash;1.2.0.4.<br/>
-Спасибо Илье Леошкевичу.
-</para>
-<para lang="en">
-minimum supported zlib version is 1.2.0.4.<br/>
-Thanks to Ilya Leoshkevich.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-метод $r->internal_redirect() встроенного перла
-теперь ожидает закодированный URI.
-</para>
-<para lang="en">
-the $r->internal_redirect() embedded perl method
-now expects escaped URIs.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь с помощью метода $r->internal_redirect() встроенного перла
-можно перейти в именованный location.
-</para>
-<para lang="en">
-it is now possible to switch to a named location
-using the $r->internal_redirect() embedded perl method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок во встроенном перле.
-</para>
-<para lang="en">
-in error handling in embedded perl.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации мог произойти segmentation fault,
-если в конфигурации использовалось значение hash bucket size больше 64 килобайт.
-</para>
-<para lang="en">
-a segmentation fault might occur on start or during reconfiguration
-if hash bucket size larger than 64 kilobytes was used in the configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании методов обработки соединений select, poll и /dev/poll
-nginx мог нагружать процессор во время небуферизованного проксирования
-и при проксировании WebSocket-соединений.
-</para>
-<para lang="en">
-nginx might hog CPU during unbuffered proxying
-and when proxying WebSocket connections
-if the select, poll, or /dev/poll methods were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_xslt_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_xslt_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_ssi_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_ssi_filter_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.1" date="2019-06-25">
-
-<change type="feature">
-<para lang="ru">
-директива limit_req_dry_run.
-</para>
-<para lang="en">
-the "limit_req_dry_run" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при использовании директивы hash в блоке upstream
-пустой ключ хэширования теперь приводит к переключению
-на round-robin балансировку.<br/>
-Спасибо Niklas Keller.
-</para>
-<para lang="en">
-when using the "hash" directive inside the "upstream" block
-an empty hash key now triggers round-robin balancing.<br/>
-Thanks to Niklas Keller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалось кэширование и директива image_filter,
-а ошибки с кодом 415 перенаправлялись с помощью директивы error_page;
-ошибка появилась в 1.11.10.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if caching was used along with the "image_filter" directive,
-and errors with code 415 were redirected with the "error_page" directive;
-the bug had appeared in 1.11.10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался встроенный перл;
-ошибка появилась в 1.7.3.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if embedded perl was used;
-the bug had appeared in 1.7.3.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.17.0" date="2019-05-21">
-
-<change type="feature">
-<para lang="ru">
-директивы limit_rate и limit_rate_after поддерживают переменные.
-</para>
-<para lang="en">
-variables support in the "limit_rate" and "limit_rate_after" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_upload_rate и proxy_download_rate в модуле stream
-поддерживают переменные.
-</para>
-<para lang="en">
-variables support
-in the "proxy_upload_rate" and "proxy_download_rate" directives
-in the stream module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-минимальная поддерживаемая версия OpenSSL&mdash;0.9.8.
-</para>
-<para lang="en">
-minimum supported OpenSSL version is 0.9.8.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь postpone-фильтр собирается всегда.
-</para>
-<para lang="en">
-now the postpone filter is always built.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива include не работала в блоках if и limit_except.
-</para>
-<para lang="en">
-the "include" directive did not work inside the "if" and "limit_except" blocks.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке byte ranges.
-</para>
-<para lang="en">
-in byte ranges processing.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.12" date="2019-04-16">
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если в директивах ssl_certificate или ssl_certificate_key
-использовались переменные
-и был включён OCSP stapling.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if variables were used
-in the "ssl_certificate" or "ssl_certificate_key" directives
-and OCSP stapling was enabled.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.11" date="2019-04-09">
-
-<change type="bugfix">
-<para lang="ru">
-в директиве ssl_stapling_file на Windows.
-</para>
-<para lang="en">
-in the "ssl_stapling_file" directive on Windows.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.10" date="2019-03-26">
-
-<change type="change">
-<para lang="ru">
-теперь при использовании имени хоста в директиве listen
-nginx создаёт listen-сокеты для всех адресов,
-соответствующих этому имени
-(ранее использовался только первый адрес).
-</para>
-<para lang="en">
-when using a hostname in the "listen" directive
-nginx now creates listening sockets
-for all addresses the hostname resolves to
-(previously, only the first address was used).
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-диапазоны портов в директиве listen.
-</para>
-<para lang="en">
-port ranges in the "listen" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-возможность загрузки SSL-сертификатов и секретных ключей из переменных.
-</para>
-<para lang="en">
-loading of SSL certificates and secret keys from variables.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-переменная $ssl_server_name могла быть пустой
-при использовании OpenSSL 1.1.1.
-</para>
-<para lang="en">
-the $ssl_server_name variable might be empty
-when using OpenSSL 1.1.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с Visual Studio 2015 и новее;
-ошибка появилась в 1.15.9.
-</para>
-<para lang="en">
-nginx/Windows could not be built with Visual Studio 2015 or newer;
-the bug had appeared in 1.15.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.9" date="2019-02-26">
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_certificate и ssl_certificate_key
-поддерживают переменные.
-</para>
-<para lang="en">
-variables support
-in the "ssl_certificate" and "ssl_certificate_key" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-метод poll теперь доступен на Windows
-при использовании Windows Vista и новее.
-</para>
-<para lang="en">
-the "poll" method is now available on Windows
-when using Windows Vista or newer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании метода select на Windows
-происходила ошибка при установлении соединения с бэкендом,
-nginx ожидал истечения таймаута на установление соединения.
-</para>
-<para lang="en">
-if the "select" method was used on Windows
-and an error occurred while establishing a backend connection,
-nginx waited for the connection establishment timeout to expire.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_upload_rate и proxy_download_rate
-в модуле stream
-работали некорректно при проксировании UDP-пакетов.
-</para>
-<para lang="en">
-the "proxy_upload_rate" and "proxy_download_rate" directives
-in the stream module
-worked incorrectly when proxying UDP datagrams.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.8" date="2018-12-25">
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_bytes_sent.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the $upstream_bytes_sent variable.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новые директивы в скриптах подсветки синтаксиса для vim.<br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-new directives in vim syntax highlighting scripts.<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_background_update.
-</para>
-<para lang="en">
-in the "proxy_cache_background_update" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве geo при использовании unix domain listen-сокетов.
-</para>
-<para lang="en">
-in the "geo" directive when using unix domain listen sockets.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании директивы ssl_early_data с OpenSSL
-в логах могли появляться сообщения
-"ignoring stale global SSL error ... bad length".
-</para>
-<para lang="en">
-the "ignoring stale global SSL error ... bad length"
-alerts might appear in logs
-when using the "ssl_early_data" directive with OpenSSL.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в nginx/Windows.
-</para>
-<para lang="en">
-in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_autoindex_module на 32-битных платформах.
-</para>
-<para lang="en">
-in the ngx_http_autoindex_module on 32-bit platforms.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.7" date="2018-11-27">
-
-<change type="feature">
-<para lang="ru">
-директива proxy_requests в модуле stream.
-</para>
-<para lang="en">
-the "proxy_requests" directive in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр "delay" директивы "limit_req".<br/>
-Спасибо Владиславу Шабанову и Петру Щучкину.
-</para>
-<para lang="en">
-the "delay" parameter of the "limit_req" directive.<br/>
-Thanks to Vladislav Shabanov and Peter Shchuchkin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти в случае ошибок при переконфигурации.
-</para>
-<para lang="en">
-memory leak on errors during reconfiguration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в переменных $upstream_response_time, $upstream_connect_time и
-$upstream_header_time.
-</para>
-<para lang="en">
-in the $upstream_response_time, $upstream_connect_time, and
-$upstream_header_time variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_mp4_module на 32-битных платформах.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_mp4_module was used on 32-bit platforms.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.6" date="2018-11-06">
-
-<change type="security">
-<para lang="ru">
-при использовании HTTP/2 клиент мог вызвать
-чрезмерное потреблению памяти (CVE-2018-16843)
-и ресурсов процессора (CVE-2018-16844).
-</para>
-<para lang="en">
-when using HTTP/2 a client might cause
-excessive memory consumption (CVE-2018-16843)
-and CPU usage (CVE-2018-16844).
-</para>
-</change>
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного mp4-файла модулем ngx_http_mp4_module
-содержимое памяти рабочего процесса могло быть отправлено клиенту
-(CVE-2018-16845).
-</para>
-<para lang="en">
-processing of a specially crafted mp4 file with the ngx_http_mp4_module
-might result in worker process memory disclosure
-(CVE-2018-16845).
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_socket_keepalive, fastcgi_socket_keepalive,
-grpc_socket_keepalive, memcached_socket_keepalive,
-scgi_socket_keepalive и uwsgi_socket_keepalive.
-</para>
-<para lang="en">
-the "proxy_socket_keepalive", "fastcgi_socket_keepalive",
-"grpc_socket_keepalive", "memcached_socket_keepalive",
-"scgi_socket_keepalive", and "uwsgi_socket_keepalive" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с OpenSSL 1.1.0, а использовался с OpenSSL 1.1.1,
-протокол TLS 1.3 всегда был разрешён.
-</para>
-<para lang="en">
-if nginx was built with OpenSSL 1.1.0 and used with OpenSSL 1.1.1,
-the TLS 1.3 protocol was always enabled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при работе с gRPC-бэкендами могло расходоваться большое количество памяти.
-</para>
-<para lang="en">
-working with gRPC backends might result in excessive memory consumption.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.5" date="2018-10-02">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании OpenSSL 1.1.0h и новее
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.15.4.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using OpenSSL 1.1.0h or newer;
-the bug had appeared in 1.15.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-незначительных потенциальных ошибок.
-</para>
-<para lang="en">
-of minor potential bugs.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.4" date="2018-09-25">
-
-<change type="feature">
-<para lang="ru">
-теперь директиву ssl_early_data можно использовать с OpenSSL.
-</para>
-<para lang="en">
-now the "ssl_early_data" directive can be used with OpenSSL.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_uwsgi_module.<br/>
-Спасибо Chris Caputo.
-</para>
-<para lang="en">
-in the ngx_http_uwsgi_module.<br/>
-Thanks to Chris Caputo.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-соединения к некоторым gRPC-бэкендам могли не кэшироваться
-при использовании директивы keepalive.
-</para>
-<para lang="en">
-connections with some gRPC backends might not be cached
-when using the "keepalive" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы error_page для перенаправления ошибок,
-возникающих на ранних этапах обработки запроса,
-в частности ошибок с кодом 400,
-могла происходить утечка сокетов.
-</para>
-<para lang="en">
-a socket leak might occur
-when using the "error_page" directive
-to redirect early request processing errors,
-notably errors with code 400.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива return при возврате ошибок не изменяла код ответа,
-если запрос был перенаправлен с помощью директивы error_page.
-</para>
-<para lang="en">
-the "return" directive did not change the response code when returning errors
-if the request was redirected by the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-стандартные сообщения об ошибках и ответы модуля ngx_http_autoindex_module
-содержали атрибут bgcolor, что могло приводить к их некорректному отображению
-при использовании пользовательских настроек цветов в браузерах.<br/>
-Спасибо Nova DasSarma.
-</para>
-<para lang="en">
-standard error pages and responses of the ngx_http_autoindex_module module
-used the "bgcolor" attribute, and might be displayed incorrectly when using
-custom color settings in browsers.<br/>
-Thanks to Nova DasSarma.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-уровень логгирования ошибок SSL "no suitable key share" и
-"no suitable signature algorithm"
-понижен с уровня crit до info.
-</para>
-<para lang="en">
-the logging level of the "no suitable key share" and
-"no suitable signature algorithm" SSL errors
-has been lowered from "crit" to "info".
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.3" date="2018-08-28">
-
-<change type="feature">
-<para lang="ru">
-теперь TLSv1.3 можно использовать с BoringSSL.
-</para>
-<para lang="en">
-now TLSv1.3 can be used with BoringSSL.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_early_data,
-сейчас доступна при использовании BoringSSL.
-</para>
-<para lang="en">
-the "ssl_early_data" directive,
-currently available with BoringSSL.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы keepalive_timeout и keepalive_requests
-в блоке upstream.
-</para>
-<para lang="en">
-the "keepalive_timeout" and "keepalive_requests" directives
-in the "upstream" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module
-при копировании файла поверх существующего файла с помощью метода COPY
-не обнулял целевой файл.
-</para>
-<para lang="en">
-the ngx_http_dav_module
-did not truncate destination file when copying a file over an existing one
-with the COPY method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module
-при перемещении файла между файловыми системами с помощью метода MOVE
-устанавливал нулевые права доступа на результирующий файл
-и не сохранял время изменения файла.
-</para>
-<para lang="en">
-the ngx_http_dav_module
-used zero access rights on the destination file
-and did not preserve file modification time
-when moving a file between different file systems with the MOVE method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module
-при копировании файла с помощью метода COPY
-для результирующего файла использовал права доступа по умолчанию.
-</para>
-<para lang="en">
-the ngx_http_dav_module
-used default access rights
-when copying a file with the COPY method.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-некоторые клиенты могли не работать при использовании HTTP/2;
-ошибка появилась в 1.13.5.
-</para>
-<para lang="en">
-some clients might not work when using HTTP/2;
-the bug had appeared in 1.13.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с LibreSSL 2.8.0.
-</para>
-<para lang="en">
-nginx could not be built with LibreSSL 2.8.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.2" date="2018-07-24">
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_preread_protocol
-в модуле ngx_stream_ssl_preread_module.
-</para>
-<para lang="en">
-the $ssl_preread_protocol variable
-in the ngx_stream_ssl_preread_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании директивы reset_timedout_connection
-nginx сбрасывает соединения, закрываемые с кодом 444.
-</para>
-<para lang="en">
-now when using the "reset_timedout_connection" directive
-nginx will reset connections being closed with the 444 code.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-уровень логгирования ошибок SSL "http request", "https proxy request",
-"unsupported protocol" и "version too low"
-понижен с уровня crit до info.
-</para>
-<para lang="en">
-a logging level of the "http request", "https proxy request",
-"unsupported protocol", and "version too low" SSL errors
-has been lowered from "crit" to "info".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-запросы к DNS-серверу не отправлялись повторно,
-если при первой попытке отправки происходила ошибка.
-</para>
-<para lang="en">
-DNS requests were not resent
-if initial sending of a request failed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр reuseport директивы listen игнорировался,
-если количество рабочих процессов было задано после директивы listen.
-</para>
-<para lang="en">
-the "reuseport" parameter of the "listen" directive was ignored
-if the number of worker processes was specified after the "listen" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании OpenSSL 1.1.0 и новее
-директиву ssl_prefer_server_ciphers нельзя было выключить
-в виртуальном сервере, если она была включена в сервере по умолчанию.
-</para>
-<para lang="en">
-when using OpenSSL 1.1.0 or newer
-it was not possible to switch off "ssl_prefer_server_ciphers" in
-a virtual server if it was switched on in the default server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-повторное использование SSL-сессий к бэкендам
-не работало с протоколом TLS 1.3.
-</para>
-<para lang="en">
-SSL session reuse with upstream servers
-did not work with the TLS 1.3 protocol.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.1" date="2018-07-03">
-
-<change type="feature">
-<para lang="ru">
-директива random в блоке upstream.
-</para>
-<para lang="en">
-the "random" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшена производительность при использовании директив hash и ip_hash
-совместно с директивой zone.
-</para>
-<para lang="en">
-improved performance when using the "hash" and "ip_hash" directives
-with the "zone" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр reuseport директивы listen
-теперь использует SO_REUSEPORT_LB на FreeBSD 12.
-</para>
-<para lang="en">
-the "reuseport" parameter of the "listen" directive
-now uses SO_REUSEPORT_LB on FreeBSD 12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-HTTP/2 server push не работал, если SSL терминировался прокси-сервером
-перед nginx'ом.
-</para>
-<para lang="en">
-HTTP/2 server push did not work if SSL was terminated by a proxy server
-in front of nginx.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива tcp_nopush всегда использовалась для соединений к бэкендам.
-</para>
-<para lang="en">
-the "tcp_nopush" directive was always used on backend connections.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при отправке сохранённого на диск тела запроса на gRPC-бэкенд
-могли возникать ошибки.
-</para>
-<para lang="en">
-sending a disk-buffered request body to a gRPC backend
-might fail.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.15.0" date="2018-06-05">
-
-<change type="change">
-<para lang="ru">
-директива "ssl" теперь считается устаревшей;
-вместо неё следует использовать параметр ssl директивы listen.
-</para>
-<para lang="en">
-the "ssl" directive is deprecated;
-the "ssl" parameter of the "listen" directive should be used instead.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при использовании директивы listen с параметром ssl
-nginx определяет отсутствие SSL-сертификатов при тестировании конфигурации.
-</para>
-<para lang="en">
-now nginx detects missing SSL certificates during configuration testing
-when using the "ssl" parameter of the "listen" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь модуль stream умеет обрабатывать
-несколько входящих UDP-пакетов от клиента в рамках одной сессии.
-</para>
-<para lang="en">
-now the stream module can handle
-multiple incoming UDP datagrams from a client within a single session.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_valid
-можно было указать некорректный код ответа.
-</para>
-<para lang="en">
-it was possible to specify an incorrect response code
-in the "proxy_cache_valid" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался gcc 8.1.
-</para>
-<para lang="en">
-nginx could not be built by gcc 8.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-логгирование в syslog останавливалось при изменении локального IP-адреса.
-</para>
-<para lang="en">
-logging to syslog stopped on local IP address changes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался компилятором clang, если был установлен CUDA SDK;
-ошибка появилась в 1.13.8.
-</para>
-<para lang="en">
-nginx could not be built by clang with CUDA SDK installed;
-the bug had appeared in 1.13.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании unix domain listen-сокетов на FreeBSD
-в процессе обновления исполняемого файла
-в логе могли появляться сообщения "getsockopt(TCP_FASTOPEN) ... failed".
-</para>
-<para lang="en">
-"getsockopt(TCP_FASTOPEN) ... failed" messages might appear in logs
-during binary upgrade
-when using unix domain listen sockets on FreeBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Fedora 28 Linux.
-</para>
-<para lang="en">
-nginx could not be built on Fedora 28 Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы limit_req
-заданная скорость обработки запросов могла не соблюдаться.
-</para>
-<para lang="en">
-request processing rate might exceed configured rate
-when using the "limit_req" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке адресов клиентов при использовании unix domain listen-сокетов
-для работы с датаграммами на Linux.
-</para>
-<para lang="en">
-in handling of client addresses when using unix domain listen sockets
-to work with datagrams on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.
-</para>
-<para lang="en">
-in memory allocation error handling.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.12" date="2018-04-10">
-
-<change type="bugfix">
-<para lang="ru">
-при возврате большого ответа
-соединения с gRPC-бэкендами могли неожиданно закрываться.
-</para>
-<para lang="en">
-connections with gRPC backends might be closed unexpectedly
-when returning a large response.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.11" date="2018-04-03">
-
-<change type="feature">
-<para lang="ru">
-параметр proxy_protocol директивы listen
-теперь поддерживает протокол PROXY версии 2.
-</para>
-<para lang="en">
-the "proxy_protocol" parameter of the "listen" directive
-now supports the PROXY protocol version 2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с OpenSSL 1.1.1 статически на Linux.
-</para>
-<para lang="en">
-nginx could not be built with OpenSSL 1.1.1 statically on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в параметрах http_404, http_500 и им подобных
-директивы proxy_next_upstream.
-</para>
-<para lang="en">
-in the "http_404", "http_500", etc. parameters
-of the "proxy_next_upstream" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.10" date="2018-03-20">
-
-<change type="feature">
-<para lang="ru">
-теперь параметр set в SSI-директиве include
-позволяет сохранять в переменную любые ответы;
-максимальный размер ответа задаётся директивой subrequest_output_buffer_size.
-</para>
-<para lang="en">
-the "set" parameter of the "include" SSI directive now allows
-writing arbitrary responses to a variable;
-the "subrequest_output_buffer_size" directive defines maximum response size.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx использует вызов clock_gettime(CLOCK_MONOTONIC), если он доступен,
-что позволяет избежать некорректного срабатывания таймаутов
-при изменениях системного времени.
-</para>
-<para lang="en">
-now nginx uses clock_gettime(CLOCK_MONOTONIC) if available,
-to avoid timeouts being incorrectly triggered
-on system time changes.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр "escape=none" директивы log_format.<br/>
-Спасибо Johannes Baiter и Calin Don.
-</para>
-<para lang="en">
-the "escape=none" parameter of the "log_format" directive.<br/>
-Thanks to Johannes Baiter and Calin Don.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_preread_alpn_protocols
-в модуле ngx_stream_ssl_preread_module.
-</para>
-<para lang="en">
-the $ssl_preread_alpn_protocols variable
-in the ngx_stream_ssl_preread_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_grpc_module.
-</para>
-<para lang="en">
-the ngx_http_grpc_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти в директиве geo.
-</para>
-<para lang="en">
-in memory allocation error handling in the "geo" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменных в директиве auth_basic_user_file
-в лог мог выводиться символ '\0'.<br/>
-Спасибо Вадиму Филимонову.
-</para>
-<para lang="en">
-when using variables in the "auth_basic_user_file" directive
-a null character might appear in logs.<br/>
-Thanks to Vadim Filimonov.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.9" date="2018-02-20">
-
-<change type="feature">
-<para lang="ru">
-поддержка HTTP/2 server push;
-директивы http2_push и http2_push_preload.
-</para>
-<para lang="en">
-HTTP/2 server push support;
-the "http2_push" and "http2_push_preload" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэша
-в логах могли появляться сообщения "header already sent";
-ошибка появилась в 1.9.13.
-</para>
-<para lang="en">
-"header already sent" alerts might appear in logs
-when using cache;
-the bug had appeared in 1.9.13.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ssl_verify_client
-в рабочем процессе мог произойти segmentation fault,
-если в виртуальном сервере не был указан SSL-сертификат.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "ssl_verify_client" directive was used
-and no SSL certificate was specified in a virtual server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_dav_module.
-</para>
-<para lang="en">
-in the ngx_http_dav_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.8" date="2017-12-26">
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании параметра transparent директив proxy_bind,
-fastcgi_bind, memcached_bind, scgi_bind и uwsgi_bind
-nginx автоматически сохраняет capability CAP_NET_RAW в рабочих процессах.
-</para>
-<para lang="en">
-now nginx automatically preserves the CAP_NET_RAW capability in worker processes
-when using the "transparent" parameter of the "proxy_bind",
-"fastcgi_bind", "memcached_bind", "scgi_bind", and "uwsgi_bind" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшения в определении размера строки кэша процессора.<br/>
-Спасибо Debayan Ghosh.
-</para>
-<para lang="en">
-improved CPU cache line size detection.<br/>
-Thanks to Debayan Ghosh.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новые директивы в скриптах подсветки синтаксиса для vim.<br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-new directives in vim syntax highlighting scripts.<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-процедура обновления исполняемого файла не работала,
-если после завершения родительского процесса
-новым родительским процессом nginx'а становился процесс с PID, отличным от 1.
-</para>
-<para lang="en">
-binary upgrade refused to work
-if nginx was re-parented to a process with PID different from 1
-after its parent process has finished.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module неправильно обрабатывал запросы с телом.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module incorrectly handled requests with bodies.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_limit_rate при использовании с директивой keepalive.
-</para>
-<para lang="en">
-in the "proxy_limit_rate" directive when used with the "keepalive" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании "proxy_buffering off" часть ответа могла буферизироваться,
-если клиентское соединение использовало SSL.<br/>
-Спасибо Patryk Lesiewicz.
-</para>
-<para lang="en">
-some parts of a response might be buffered when using "proxy_buffering off"
-if the client connection used SSL.<br/>
-Thanks to Patryk Lesiewicz.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_background_update.
-</para>
-<para lang="en">
-in the "proxy_cache_background_update" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменную вида "${name}" с именем в фигурных скобках
-нельзя было использовать в начале параметра
-не заключив весь параметр в кавычки.
-</para>
-<para lang="en">
-it was not possible to start a parameter
-with a variable in the "${name}" form with the name in curly brackets
-without enclosing the parameter into single or double quotes.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.7" date="2017-11-21">
-
-<change type="bugfix">
-<para lang="ru">
-в переменной $upstream_status.
-</para>
-<para lang="en">
-in the $upstream_status variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если бэкенд возвращал ответ "101 Switching Protocols" на подзапрос.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if a backend returned a "101 Switching Protocols" response to a subrequest.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при переконфигурации изменялся размер зоны разделяемой памяти
-и переконфигурация завершалась неудачно,
-то в главном процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in a master process
-if a shared memory zone size was changed during a reconfiguration
-and the reconfiguration failed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_fastcgi_module.
-</para>
-<para lang="en">
-in the ngx_http_fastcgi_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал ошибку 500,
-если в директиве xslt_stylesheet
-были заданы параметры без использования переменных.
-</para>
-<para lang="en">
-nginx returned the 500 error
-if parameters without variables were specified
-in the "xslt_stylesheet" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании варианта библиотеки zlib от Intel
-в лог писались сообщения "gzip filter failed to use preallocated memory".
-</para>
-<para lang="en">
-"gzip filter failed to use preallocated memory" alerts appeared in logs
-when using a zlib library variant from Intel.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива worker_shutdown_timeout не работала
-при использовании почтового прокси-сервера
-и при проксировании WebSocket-соединений.
-</para>
-<para lang="en">
-the "worker_shutdown_timeout" directive did not work
-when using mail proxy and when proxying WebSocket connections.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.6" date="2017-10-10">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ssl_preread
-в модуле stream не работало переключение на следующий бэкенд.
-</para>
-<para lang="en">
-switching to the next upstream server in the stream module did not work
-when using the "ssl_preread" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал даты после 2038 года
-на 32-битных платформах с 64-битным time_t.
-</para>
-<para lang="en">
-nginx did not support dates after the year 2038
-on 32-bit platforms with 64-bit time_t.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке дат до 1970 года и после 10000 года.
-</para>
-<para lang="en">
-in handling of dates prior to the year 1970 and after the year 10000.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле stream таймауты ожидания UDP-пакетов от бэкендов
-не логгировались или логгировались на уровне info вместо error.
-</para>
-<para lang="en">
-in the stream module timeouts waiting for UDP datagrams from upstream servers
-were not logged or logged at the "info" level instead of "error".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 nginx мог вернуть ошибку 400,
-не указав в логе причину.
-</para>
-<para lang="en">
-when using HTTP/2 nginx might return the 400 response
-without logging the reason.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке повреждённых файлов кэша.
-</para>
-<para lang="en">
-in processing of corrupted cache files.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при кэшировании ошибок, перехваченных error_page,
-не учитывались заголовки управления кэшированием.
-</para>
-<para lang="en">
-cache control headers were ignored
-when caching errors intercepted by error_page.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 тело запроса могло быть повреждено.
-</para>
-<para lang="en">
-when using HTTP/2 client request body might be corrupted.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке адресов клиентов при использовании unix domain сокетов.
-</para>
-<para lang="en">
-in handling of client addresses when using unix domain sockets.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "hash ... consistent" в блоке upstream
-nginx нагружал процессор, если использовались большие веса
-и все или почти все бэкенды были недоступны.
-</para>
-<para lang="en">
-nginx hogged CPU
-when using the "hash ... consistent" directive in the upstream block
-if large weights were used and all or most of the servers were unavailable.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.5" date="2017-09-05">
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_client_escaped_cert.
-</para>
-<para lang="en">
-the $ssl_client_escaped_cert variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_session_ticket_key и параметр include директивы geo
-не работали на Windows.
-</para>
-<para lang="en">
-the "ssl_session_ticket_key" directive and
-the "include" parameter of the "geo" directive did not work on Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на 32-битных платформах
-при запросе более 4 гигабайт с помощью нескольких диапазонов
-возвращалась некорректная длина ответа.
-</para>
-<para lang="en">
-incorrect response length was returned
-on 32-bit platforms when requesting more than 4 gigabytes
-with multiple ranges.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "expires modified" и
-обработка строки If-Range заголовка запроса
-не учитывали время последнего изменения ответа,
-если использовалось проксирование без кэширования.
-</para>
-<para lang="en">
-the "expires modified" directive and
-processing of the "If-Range" request header line
-did not use the response last modification time
-if proxying without caching was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.4" date="2017-08-08">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_mirror_module.
-</para>
-<para lang="en">
-the ngx_http_mirror_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-клиентские соединения могли сбрасываться при тестировании конфигурации,
-если использовался параметр reuseport директивы listen на Linux.
-</para>
-<para lang="en">
-client connections might be dropped during configuration testing
-when using the "reuseport" parameter of the "listen" directive on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-тело запроса могло быть недоступно в подзапросах,
-если оно было сохранено в файл и использовалось проксирование.
-</para>
-<para lang="en">
-request body might not be available in subrequests
-if it was saved to a file and proxying was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-очистка кэша по max_size не работала на Windows.
-</para>
-<para lang="en">
-cleaning cache based on the "max_size" parameter did not work on Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-любое выделение разделяемой памяти на Windows требовало 4096 байт памяти.
-</para>
-<para lang="en">
-any shared memory allocation required 4096 bytes on Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы zone в блоке upstream на Windows
-рабочий процесс мог завершаться аварийно.
-</para>
-<para lang="en">
-nginx worker might be terminated abnormally
-when using the "zone" directive inside the "upstream" block on Windows.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.3" date="2017-07-11">
-
-<change type="security">
-<para lang="ru">
-специально созданный запрос мог вызвать целочисленное переполнение
-в range-фильтре и последующую некорректную обработку запрошенных диапазонов,
-что потенциально могло привести к утечке конфиденциальной информации
-(CVE-2017-7529).
-</para>
-<para lang="en">
-a specially crafted request might result in an integer overflow
-and incorrect processing of ranges in the range filter,
-potentially resulting in sensitive information leak
-(CVE-2017-7529).
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.2" date="2017-06-27">
-
-<change type="change">
-<para lang="ru">
-теперь при запросе диапазона, начинающегося с 0, из пустого файла
-nginx возвращает ответ 200 вместо 416.
-</para>
-<para lang="en">
-nginx now returns 200 instead of 416
-when a range starting with 0 is requested from an empty file.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива add_trailer.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "add_trailer" directive.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под Cygwin и NetBSD;
-ошибка появилась в 1.13.0.
-</para>
-<para lang="en">
-nginx could not be built on Cygwin and NetBSD;
-the bug had appeared in 1.13.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под MSYS2 / MinGW 64-bit.<br/>
-Спасибо Orgad Shaneh.
-</para>
-<para lang="en">
-nginx could not be built under MSYS2 / MinGW 64-bit.<br/>
-Thanks to Orgad Shaneh.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSI с большим количеством подзапросов
-и proxy_pass с переменными
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using SSI with many includes
-and proxy_pass with variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.1" date="2017-05-30">
-
-<change type="feature">
-<para lang="ru">
-теперь в качестве параметра директивы set_real_ip_from
-можно указывать имя хоста.
-</para>
-<para lang="en">
-now a hostname can be used
-as the "set_real_ip_from" directive parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшения в скриптах подсветки синтаксиса для vim.
-</para>
-<para lang="en">
-vim syntax highlighting scripts improvements.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_cpu_affinity теперь работает на DragonFly BSD.<br/>
-Спасибо Sepherosa Ziehau.
-</para>
-<para lang="en">
-the "worker_cpu_affinity" directive now works on DragonFly BSD.<br/>
-Thanks to Sepherosa Ziehau.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL renegotiation в соединениях к бэкендам
-не работал при использовании OpenSSL до 1.1.0.
-</para>
-<para lang="en">
-SSL renegotiation on backend connections
-did not work when using OpenSSL before 1.1.0.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-nginx не собирался с Oracle Developer Studio 12.5.
-</para>
-<para lang="en">
-nginx could not be built with Oracle Developer Studio 12.5.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-теперь cache manager пропускает заблокированные записи
-при очистке кэша по max_size.
-</para>
-<para lang="en">
-now cache manager ignores long locked cache entries
-when cleaning cache based on the "max_size" parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-клиентские SSL-соединения сразу закрывались, если использовался
-отложенный accept и параметр proxy_protocol директивы listen.
-</para>
-<para lang="en">
-client SSL connections were immediately closed if deferred accept
-and the "proxy_protocol" parameter of the "listen" directive were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_background_update.
-</para>
-<para lang="en">
-in the "proxy_cache_background_update" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-теперь директива tcp_nodelay
-устанавливает опцию TCP_NODELAY перед SSL handshake.
-</para>
-<para lang="en">
-now the "tcp_nodelay" directive
-sets the TCP_NODELAY option before an SSL handshake.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.13.0" date="2017-04-25">
-
-<change type="change">
-<para lang="ru">
-теперь SSL renegotiation допускается в соединениях к бэкендам.
-</para>
-<para lang="en">
-SSL renegotiation is now allowed on backend connections.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры rcvbuf и sndbuf директив listen
-в почтовом прокси-сервере и модуле stream.
-</para>
-<para lang="en">
-the "rcvbuf" and "sndbuf" parameters of the "listen" directives
-of the mail proxy and stream modules.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы return и error_page теперь могут использоваться для возврата
-перенаправлений с кодом 308.<br/>
-Спасибо Simon Leblanc.
-</para>
-<para lang="en">
-the "return" and "error_page" directives can now be used to return 308
-redirections.<br/>
-Thanks to Simon Leblanc.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр TLSv1.3 в директиве ssl_protocols.
-</para>
-<para lang="en">
-the "TLSv1.3" parameter of the "ssl_protocols" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при логгировании сигналов теперь указывается PID отправившего сигнал процесса.
-</para>
-<para lang="en">
-when logging signals nginx now logs PID of the process which sent the signal.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.
-</para>
-<para lang="en">
-in memory allocation error handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервер в модуле stream слушал на wildcard-адресе,
-исходящий адрес ответного UDP-пакета
-мог отличаться от адреса назначения исходного пакета.
-</para>
-<para lang="en">
-if a server in the stream module listened on a wildcard address,
-the source address of a response UDP datagram could differ
-from the original datagram destination address.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.13" date="2017-04-04">
-
-<change type="feature">
-<para lang="ru">
-параметр http_429 в директивах proxy_next_upstream, fastcgi_next_upstream,
-scgi_next_upstream и uwsgi_next_upstream.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "http_429" parameter of the "proxy_next_upstream", "fastcgi_next_upstream",
-"scgi_next_upstream", and "uwsgi_next_upstream" directives.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.
-</para>
-<para lang="en">
-in memory allocation error handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив sendfile и timer_resolution на Linux
-запросы могли зависать.
-</para>
-<para lang="en">
-requests might hang
-when using the "sendfile" and "timer_resolution" directives on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании с подзапросами директив sendfile и aio_write
-запросы могли зависать.
-</para>
-<para lang="en">
-requests might hang
-when using the "sendfile" and "aio_write" directives with subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-запросы могли зависать
-при использовании с подзапросами директив limit_rate, sendfile_max_chunk,
-limit_req или метода $r->sleep() встроенного перла.
-</para>
-<para lang="en">
-requests might hang
-when using the "limit_rate", "sendfile_max_chunk", "limit_req" directives,
-or the $r->sleep() embedded perl method with subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_slice_module.
-</para>
-<para lang="en">
-in the ngx_http_slice_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.12" date="2017-03-24">
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог нагружать процессор;
-ошибка появилась в 1.11.11.
-</para>
-<para lang="en">
-nginx might hog CPU;
-the bug had appeared in 1.11.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.11" date="2017-03-21">
-
-<change type="feature">
-<para lang="ru">
-директива worker_shutdown_timeout.
-</para>
-<para lang="en">
-the "worker_shutdown_timeout" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшения в скриптах подсветки синтаксиса для vim.<br/>
-Спасибо Wei-Ko Kao.
-</para>
-<para lang="en">
-vim syntax highlighting scripts improvements.<br/>
-Thanks to Wei-Ko Kao.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при попытке установить переменную $limit_rate в пустую строку
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the $limit_rate variable was set to an empty string.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_cache_background_update, fastcgi_cache_background_update,
-scgi_cache_background_update и uwsgi_cache_background_update
-могли работать некорректно, если использовалась директива if.
-</para>
-<para lang="en">
-the "proxy_cache_background_update", "fastcgi_cache_background_update",
-"scgi_cache_background_update", and "uwsgi_cache_background_update" directives
-might work incorrectly if the "if" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если количество large_client_header_buffers в виртуальном сервере
-отличалось от такового в сервере по умолчанию.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if number of large_client_header_buffers in a virtual server
-was different from the one in the default server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в почтовом прокси-сервере.
-</para>
-<para lang="en">
-in the mail proxy server.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.10" date="2017-02-14">
-
-<change type="change">
-<para lang="ru">
-формат заголовка кэша был изменен,
-ранее закэшированные ответы будут загружены заново.
-</para>
-<para lang="en">
-cache header format has been changed,
-previously cached responses will be invalidated.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка расширений stale-while-revalidate и stale-if-error
-в строке "Cache-Control" в заголовке ответа бэкенда.
-</para>
-<para lang="en">
-support of "stale-while-revalidate" and "stale-if-error" extensions
-in the "Cache-Control" backend response header line.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache_background_update, fastcgi_cache_background_update,
-scgi_cache_background_update и uwsgi_cache_background_update.
-</para>
-<para lang="en">
-the "proxy_cache_background_update", "fastcgi_cache_background_update",
-"scgi_cache_background_update", and "uwsgi_cache_background_update" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx может кэшировать ответы
-со строкой Vary заголовка длиной до 128 символов
-(вместо 42 символов в предыдущих версиях).
-</para>
-<para lang="en">
-nginx is now able to cache responses
-with the "Vary" header line up to 128 characters long
-(instead of 42 characters in previous versions).
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр build директивы server_tokens.<br/>
-Спасибо Tom Thorogood.
-</para>
-<para lang="en">
-the "build" parameter of the "server_tokens" directive.<br/>
-Thanks to Tom Thorogood.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при обработке запросов со строкой "Expect: 100-continue" в заголовке запроса
-в логах могли появляться сообщения "[crit] SSL_write() failed".
-</para>
-<para lang="en">
-"[crit] SSL_write() failed" messages might appear in logs
-when handling requests with the "Expect: 100-continue" request header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_slice_module не работал в именованных location'ах.
-</para>
-<para lang="en">
-the ngx_http_slice_module did not work in named locations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании AIO после перенаправления запроса с помощью X-Accel-Redirect
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using AIO after an "X-Accel-Redirect" redirection.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-уменьшено потребление памяти для долгоживущих запросов, использующих сжатие.
-</para>
-<para lang="en">
-reduced memory consumption for long-lived requests using gzipping.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.9" date="2017-01-24">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании модуля stream nginx мог нагружать процессор;
-ошибка появилась в 1.11.5.
-</para>
-<para lang="en">
-nginx might hog CPU when using the stream module;
-the bug had appeared in 1.11.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод аутентификации EXTERNAL в почтовом прокси-сервере
-можно было использовать, даже если он не был разрешён в конфигурации.
-</para>
-<para lang="en">
-EXTERNAL authentication mechanism in mail proxy
-was accepted even if it was not enabled in the configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ssl_verify_client модуля stream
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "ssl_verify_client" directive of the stream module was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_verify_client модуля stream могла не работать.
-</para>
-<para lang="en">
-the "ssl_verify_client" directive of the stream module might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при исчерпании рабочим процессом свободных соединений
-keepalive-соединения могли закрываться излишне агрессивно.<br/>
-Спасибо Joel Cunningham.
-</para>
-<para lang="en">
-closing keepalive connections due to no free worker connections
-might be too aggressive.<br/>
-Thanks to Joel Cunningham.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы sendfile на FreeBSD и macOS
-мог возвращаться некорректный ответ;
-ошибка появилась в 1.7.8.
-</para>
-<para lang="en">
-an incorrect response might be returned
-when using the "sendfile" directive on FreeBSD and macOS;
-the bug had appeared in 1.7.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы aio_write
-ответ мог сохраняться в кэш не полностью.
-</para>
-<para lang="en">
-a truncated response might be stored in cache
-when using the "aio_write" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы aio_write
-могла происходить утечка сокетов.
-</para>
-<para lang="en">
-a socket leak might occur
-when using the "aio_write" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.8" date="2016-12-27">
-
-<change type="feature">
-<para lang="ru">
-директива absolute_redirect.
-</para>
-<para lang="en">
-the "absolute_redirect" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр escape директивы log_format.
-</para>
-<para lang="en">
-the "escape" parameter of the "log_format" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-проверка клиентских SSL-сертификатов в модуле stream.
-</para>
-<para lang="en">
-client SSL certificates verification in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_session_ticket_key поддерживает
-шифрование TLS session tickets с помощью AES256
-при использовании с 80-байтными ключами.
-</para>
-<para lang="en">
-the "ssl_session_ticket_key" directive supports
-AES256 encryption of TLS session tickets
-when used with 80-byte keys.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка vim-commentary в скриптах для vim.<br/>
-Спасибо Armin Grodon.
-</para>
-<para lang="en">
-vim-commentary support in vim scripts.<br/>
-Thanks to Armin Grodon.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рекурсия при получении значений переменных не ограничивалась.
-</para>
-<para lang="en">
-recursion when evaluating variables was not limited.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_stream_ssl_preread_module.
-</para>
-<para lang="en">
-in the ngx_stream_ssl_preread_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервер, описанный в блоке upstream в модуле stream,
-был признан неработающим, то после истечения fail_timeout он
-признавался работающим только после завершения тестового соединения;
-теперь достаточно, чтобы соединение было успешно установлено.
-</para>
-<para lang="en">
-if a server in an upstream in the stream module failed,
-it was considered alive only when a test connection sent
-to it after fail_timeout was closed;
-now a successfully established connection is enough.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с 64-битным Visual Studio.
-</para>
-<para lang="en">
-nginx/Windows could not be built with 64-bit Visual Studio.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с OpenSSL 1.1.0.
-</para>
-<para lang="en">
-nginx/Windows could not be built with OpenSSL 1.1.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.7" date="2016-12-13">
-
-<change type="change">
-<para lang="ru">
-переменная $ssl_client_verify теперь
-в случае ошибки проверки клиентского сертификата
-содержит строку с описанием ошибки,
-например, "FAILED:certificate has expired".
-</para>
-<para lang="en">
-now in case of a client certificate verification error
-the $ssl_client_verify variable contains a string with the failure reason,
-for example, "FAILED:certificate has expired".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $ssl_ciphers, $ssl_curves,
-$ssl_client_v_start, $ssl_client_v_end и $ssl_client_v_remain.
-</para>
-<para lang="en">
-the $ssl_ciphers, $ssl_curves,
-$ssl_client_v_start, $ssl_client_v_end, and $ssl_client_v_remain variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр volatile директивы map.
-</para>
-<para lang="en">
-the "volatile" parameter of the "map" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при сборке динамических модулей
-не учитывались заданные для модуля зависимости.
-</para>
-<para lang="en">
-dependencies specified for a module
-were ignored while building dynamic modules.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 и директив limit_req или auth_request
-тело запроса могло быть повреждено;
-ошибка появилась в 1.11.0.
-</para>
-<para lang="en">
-when using HTTP/2 and the "limit_req" or "auth_request" directives
-client request body might be corrupted;
-the bug had appeared in 1.11.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.11.3.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process when using HTTP/2;
-the bug had appeared in 1.11.3.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.<br/>
-Спасибо Congcong Hu.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.<br/>
-Thanks to Congcong Hu.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_perl_module.
-</para>
-<para lang="en">
-in the ngx_http_perl_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.6" date="2016-11-15">
-
-<change type="change">
-<para lang="ru">
-формат переменных $ssl_client_s_dn и $ssl_client_i_dn
-изменён на соответствующий RFC 2253 (RFC 4514);
-значения в старом формате доступны через переменные
-$ssl_client_s_dn_legacy и $ssl_client_i_dn_legacy.
-</para>
-<para lang="en">
-format of the $ssl_client_s_dn and $ssl_client_i_dn variables
-has been changed to follow RFC 2253 (RFC 4514);
-values in the old format are available in
-the $ssl_client_s_dn_legacy and $ssl_client_i_dn_legacy variables.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при сохранении временных файлов в каталоге кэша
-они теперь располагаются не в отдельном подкаталоге для временных файлов,
-а в том же подкаталоге, что и соответствующие файлы в кэше.
-</para>
-<para lang="en">
-when storing temporary files in a cache directory
-they will be stored in the same subdirectories as corresponding cache files
-instead of a separate subdirectory for temporary files.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка метода аутентификации EXTERNAL
-в почтовом прокси-сервере.<br/>
-Спасибо Robert Norris.
-</para>
-<para lang="en">
-EXTERNAL authentication mechanism support
-in mail proxy.<br/>
-Thanks to Robert Norris.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка WebP в модуле ngx_http_image_filter_module.
-</para>
-<para lang="en">
-WebP support in the ngx_http_image_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_method поддерживает переменные.<br/>
-Спасибо Дмитрию Лазуркину.
-</para>
-<para lang="en">
-variables support in the "proxy_method" directive.<br/>
-Thanks to Dmitry Lazurkin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива http2_max_requests в модуле ngx_http_v2_module.
-</para>
-<para lang="en">
-the "http2_max_requests" directive in the ngx_http_v2_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache_max_range_offset, fastcgi_cache_max_range_offset,
-scgi_cache_max_range_offset и uwsgi_cache_max_range_offset.
-</para>
-<para lang="en">
-the "proxy_cache_max_range_offset", "fastcgi_cache_max_range_offset",
-"scgi_cache_max_range_offset", and "uwsgi_cache_max_range_offset" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-плавное завершение старых рабочих процессов могло занимать бесконечное время
-при использовании HTTP/2.
-</para>
-<para lang="en">
-graceful shutdown of old worker processes might require infinite time
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании WebSocket-соединений и включённом кэшировании
-в логах могли появляться сообщения "ignore long locked inactive cache entry".
-</para>
-<para lang="en">
-"ignore long locked inactive cache entry" alerts might appear in logs
-when proxying WebSocket connections with caching enabled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если во время SSL handshake с бэкендом происходил таймаут,
-nginx ничего не писал в лог
-и возвращал ответ с кодом 502 вместо 504.
-</para>
-<para lang="en">
-nginx did not write anything to log
-and returned a response with code 502 instead of 504
-when a timeout occurred during an SSL handshake to a backend.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.5" date="2016-10-11">
-
-<change type="change">
-<para lang="ru">
-параметр configure --with-ipv6 упразднён,
-поддержка IPv6 теперь собирается автоматически.
-</para>
-<para lang="en">
-the --with-ipv6 configure option was removed,
-now IPv6 support is configured automatically.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь, если в блоке upstream не оказалось доступных серверов,
-nginx не сбрасывает статистику ошибок всех серверов, как делал ранее,
-а ожидает истечения fail_timeout.
-</para>
-<para lang="en">
-now if there are no available servers in an upstream,
-nginx will not reset number of failures of all servers as it previously did,
-but will wait for fail_timeout to expire.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_ssl_preread_module.
-</para>
-<para lang="en">
-the ngx_stream_ssl_preread_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server в блоке upstream поддерживает параметр max_conns.
-</para>
-<para lang="en">
-the "server" directive in the "upstream" context supports
-the "max_conns" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр configure --with-compat.
-</para>
-<para lang="en">
-the --with-compat configure option.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры manager_files, manager_threshold и manager_sleep
-директив proxy_cache_path, fastcgi_cache_path, scgi_cache_path и
-uwsgi_cache_path.
-</para>
-<para lang="en">
-"manager_files", "manager_threshold", and "manager_sleep" parameters
-of the "proxy_cache_path", "fastcgi_cache_path", "scgi_cache_path", and
-"uwsgi_cache_path" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при сборке perl-модуля не использовались флаги,
-заданные с помощью параметра configure --with-ld-opt.
-</para>
-<para lang="en">
-flags passed by the --with-ld-opt configure option
-were not used while building perl module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве add_after_body при использовании совместно с директивой sub_filter.
-</para>
-<para lang="en">
-in the "add_after_body" directive when used with the "sub_filter" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в переменной $realip_remote_addr.
-</para>
-<para lang="en">
-in the $realip_remote_addr variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы dav_access, proxy_store_access, fastcgi_store_access,
-scgi_store_access и uwsgi_store_access
-игнорировали права, заданные для пользователя.
-</para>
-<para lang="en">
-the "dav_access", "proxy_store_access", "fastcgi_store_access",
-"scgi_store_access", and "uwsgi_store_access" directives
-ignored permissions specified for user.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-unix domain listen-сокеты могли не наследоваться
-при обновлении исполняемого файла на Linux.
-</para>
-<para lang="en">
-unix domain listen sockets might not be inherited
-during binary upgrade on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал ошибку 400 на запросы
-с символом "-" в HTTP-методе.
-</para>
-<para lang="en">
-nginx returned the 400 response on requests
-with the "-" character in the HTTP method.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.4" date="2016-09-13">
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_bytes_received.
-</para>
-<para lang="en">
-the $upstream_bytes_received variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $bytes_received, $session_time, $protocol, $status,
-$upstream_addr, $upstream_bytes_sent, $upstream_bytes_received,
-$upstream_connect_time, $upstream_first_byte_time
-и $upstream_session_time в модуле stream.
-</para>
-<para lang="en">
-the $bytes_received, $session_time, $protocol, $status,
-$upstream_addr, $upstream_bytes_sent, $upstream_bytes_received,
-$upstream_connect_time, $upstream_first_byte_time,
-and $upstream_session_time variables in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_log_module.
-</para>
-<para lang="en">
-the ngx_stream_log_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр proxy_protocol в директиве listen,
-переменные $proxy_protocol_addr и $proxy_protocol_port
-в модуле stream.
-</para>
-<para lang="en">
-the "proxy_protocol" parameter of the "listen" directive,
-the $proxy_protocol_addr and $proxy_protocol_port variables
-in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_realip_module.
-</para>
-<para lang="en">
-the ngx_stream_realip_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с модулем stream и модулем ngx_http_ssl_module,
-но без модуля ngx_stream_ssl_module;
-ошибка появилась в 1.11.3.
-</para>
-<para lang="en">
-nginx could not be built with the stream module and the ngx_http_ssl_module,
-but without ngx_stream_ssl_module;
-the bug had appeared in 1.11.3.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-опция сокета IP_BIND_ADDRESS_NO_PORT не использовалась;
-ошибка появилась в 1.11.2.
-</para>
-<para lang="en">
-the IP_BIND_ADDRESS_NO_PORT socket option was not used;
-the bug had appeared in 1.11.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в параметре ranges директивы geo.
-</para>
-<para lang="en">
-in the "ranges" parameter of the "geo" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив "aio threads" и sendfile
-мог возвращаться некорректный ответ; ошибка появилась в 1.9.13.
-</para>
-<para lang="en">
-an incorrect response might be returned
-when using the "aio threads" and "sendfile" directives;
-the bug had appeared in 1.9.13.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.3" date="2016-07-26">
-
-<change type="change">
-<para lang="ru">
-теперь accept_mutex по умолчанию выключен.
-</para>
-<para lang="en">
-now the "accept_mutex" directive is turned off by default.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx использует EPOLLEXCLUSIVE на Linux.
-</para>
-<para lang="en">
-now nginx uses EPOLLEXCLUSIVE on Linux.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_geo_module.
-</para>
-<para lang="en">
-the ngx_stream_geo_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_geoip_module.
-</para>
-<para lang="en">
-the ngx_stream_geoip_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_split_clients_module.
-</para>
-<para lang="en">
-the ngx_stream_split_clients_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_pass и proxy_ssl_name в модуле stream
-поддерживают переменные.
-</para>
-<para lang="en">
-variables support
-in the "proxy_pass" and "proxy_ssl_name" directives in the stream module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании HTTP/2.
-</para>
-<para lang="en">
-socket leak when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в configure.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in configure tests.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.2" date="2016-07-05">
-
-<change type="change">
-<para lang="ru">
-теперь nginx всегда использует внутренние реализации MD5 и SHA1;
-параметры configure --with-md5 и --with-sha1 упразднены.
-</para>
-<para lang="en">
-now nginx always uses internal MD5 and SHA1 implementations;
-the --with-md5 and --with-sha1 configure options were canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка переменных в модуле stream.
-</para>
-<para lang="en">
-variables support in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_map_module.
-</para>
-<para lang="en">
-the ngx_stream_map_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_stream_return_module.
-</para>
-<para lang="en">
-the ngx_stream_return_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в директивах proxy_bind, fastcgi_bind, memcached_bind, scgi_bind и uwsgi_bind
-теперь можно указывать порт.
-</para>
-<para lang="en">
-a port can be specified in the "proxy_bind", "fastcgi_bind",
-"memcached_bind", "scgi_bind", and "uwsgi_bind" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx использует опцию сокета IP_BIND_ADDRESS_NO_PORT, если она доступна.
-</para>
-<para lang="en">
-now nginx uses the IP_BIND_ADDRESS_NO_PORT socket option when available.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 и директивы proxy_request_buffering
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using HTTP/2 and the "proxy_request_buffering" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-к запросам, передаваемым на бэкенд,
-всегда добавлялась строка заголовка "Content-Length",
-даже если у запроса не было тела.
-</para>
-<para lang="en">
-the "Content-Length" request header line
-was always added to requests passed to backends,
-including requests without body,
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-в логах могли появляться сообщения "http request count is zero".
-</para>
-<para lang="en">
-"http request count is zero" alerts might appear in logs
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы sub_filter
-могло буферизироваться больше данных, чем это необходимо;
-проблема появилась в 1.9.4.
-</para>
-<para lang="en">
-unnecessary buffering might occur
-when using the "sub_filter" directive;
-the issue had appeared in 1.9.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.1" date="2016-05-31">
-
-<change type="security">
-<para lang="ru">
-при записи тела специально созданного запроса во временный файл
-в рабочем процессе мог происходить segmentation fault
-(CVE-2016-4450);
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-while writing a specially crafted request body to a temporary file
-(CVE-2016-4450);
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.11.0" date="2016-05-24">
-
-<change type="feature">
-<para lang="ru">
-параметр transparent директив proxy_bind, fastcgi_bind,
-memcached_bind, scgi_bind и uwsgi_bind.
-</para>
-<para lang="en">
-the "transparent" parameter of the "proxy_bind", "fastcgi_bind",
-"memcached_bind", "scgi_bind", and "uwsgi_bind" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $request_id.
-</para>
-<para lang="en">
-the $request_id variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает комбинации нескольких переменных
-в качестве результирующих значений.
-</para>
-<para lang="en">
-the "map" directive supports combinations of multiple variables
-as resulting values.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании метода epoll
-nginx проверяет, поддерживает ли ядро события EPOLLRDHUP,
-и соответственно оптимизирует обработку соединений.
-</para>
-<para lang="en">
-now nginx checks if EPOLLRDHUP events are supported by kernel,
-and optimizes connection handling accordingly
-if the "epoll" method is used.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_certificate и ssl_certificate_key
-теперь можно указывать несколько раз
-для загрузки сертификатов разных типов (например, RSA и ECDSA).
-</para>
-<para lang="en">
-the "ssl_certificate" and "ssl_certificate_key" directives
-can be specified multiple times
-to load certificates of different types (for example, RSA and ECDSA).
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при использовании OpenSSL 1.0.2 и новее
-с помощью директивы ssl_ecdh_curve теперь можно задать список кривых;
-по умолчанию используется встроенный в OpenSSL список кривых.
-</para>
-<para lang="en">
-the "ssl_ecdh_curve" directive now allows specifying a list of curves
-when using OpenSSL 1.0.2 or newer;
-by default a list built into OpenSSL is used.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-для использования DHE-шифров теперь надо явно задавать файл параметров
-с помощью директивы ssl_dhparam.
-</para>
-<para lang="en">
-to use DHE ciphers it is now required to specify parameters
-using the "ssl_dhparam" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $proxy_protocol_port.
-</para>
-<para lang="en">
-the $proxy_protocol_port variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $realip_remote_port в модуле ngx_http_realip_module.
-</para>
-<para lang="en">
-the $realip_remote_port variable in the ngx_http_realip_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_realip_module теперь позволяет устанавливать
-не только адрес, но и порт клиента.
-</para>
-<para lang="en">
-the ngx_http_realip_module is now able to set the client port
-in addition to the address.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при попытке запросить виртуальный сервер,
-отличающийся от согласованного в процессе SSL handshake,
-теперь возвращается ответ "421 Misdirected Request";
-это улучшает совместимость с некоторыми HTTP/2-клиентами
-в случае использования клиентских сертификатов.
-</para>
-<para lang="en">
-the "421 Misdirected Request" response now used
-when rejecting requests to a virtual server
-different from one negotiated during an SSL handshake;
-this improves interoperability with some HTTP/2 clients
-when using client certificates.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-HTTP/2-клиенты теперь могут сразу присылать тело запроса;
-директива http2_body_preread_size позволяет указать размер буфера, который
-будет использоваться до того, как nginx начнёт читать тело.
-</para>
-<para lang="en">
-HTTP/2 clients can now start sending request body immediately;
-the "http2_body_preread_size" directive controls size of the buffer used
-before nginx will start reading client request body.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы proxy_cache_bypass
-не обновлялись закэшированные ошибочные ответы.
-</para>
-<para lang="en">
-cached error responses were not updated
-when using the "proxy_cache_bypass" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.15" date="2016-04-19">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HHVM в качестве FastCGI-сервера
-могли возникать ошибки "recv() failed".
-</para>
-<para lang="en">
-"recv() failed" errors might occur
-when using HHVM as a FastCGI server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 и директив limit_req или auth_request
-при чтении тела запроса мог произойти таймаут
-или ошибка "client violated flow control";
-ошибка появилась в 1.9.14.
-</para>
-<para lang="en">
-when using HTTP/2 and the "limit_req" or "auth_request" directives
-a timeout or a "client violated flow control" error
-might occur while reading client request body;
-the bug had appeared in 1.9.14.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании HTTP/2 ответ мог не показываться некоторыми браузерами,
-если тело запроса было прочитано не целиком;
-ошибка появилась в 1.9.14.
-</para>
-<para lang="en">
-a response might not be shown by some browsers
-if HTTP/2 was used and client request body was not fully read;
-the bug had appeared in 1.9.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "aio threads" соединения могли зависать.<br/>
-Спасибо Mindaugas Rasiukevicius.
-</para>
-<para lang="en">
-connections might hang when using the "aio threads" directive.<br/>
-Thanks to Mindaugas Rasiukevicius.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.14" date="2016-04-05">
-
-<change type="feature">
-<para lang="ru">
-совместимость с OpenSSL 1.1.0.
-</para>
-<para lang="en">
-OpenSSL 1.1.0 compatibility.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_request_buffering, fastcgi_request_buffering,
-scgi_request_buffering и uwsgi_request_buffering
-теперь работают при использовании HTTP/2.
-</para>
-<para lang="en">
-the "proxy_request_buffering", "fastcgi_request_buffering",
-"scgi_request_buffering", and "uwsgi_request_buffering" directives
-now work with HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-в логах могли появляться сообщения "zero size buf in output".
-</para>
-<para lang="en">
-"zero size buf in output" alerts might appear in logs
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-директива client_max_body_size могла работать неверно.
-</para>
-<para lang="en">
-the "client_max_body_size" directive might work incorrectly
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-незначительных ошибок логгирования.
-</para>
-<para lang="en">
-of minor bugs in logging.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.13" date="2016-03-29">
-
-<change type="change">
-<para lang="ru">
-неидемпотентные запросы (POST, LOCK, PATCH)
-теперь по умолчанию не передаются на другой сервер,
-если запрос уже был отправлен на бэкенд;
-параметр non_idempotent директивы proxy_next_upstream
-явно разрешает повторять такие запросы.
-</para>
-<para lang="en">
-non-idempotent requests (POST, LOCK, PATCH)
-are no longer passed to the next server by default
-if a request has been sent to a backend;
-the "non_idempotent" parameter of the "proxy_next_upstream" directive
-explicitly allows retrying such requests.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module теперь можно собрать динамически.
-</para>
-<para lang="en">
-the ngx_http_perl_module can be built dynamically.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка UDP в модуле stream.
-</para>
-<para lang="en">
-UDP support in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива aio_write.
-</para>
-<para lang="en">
-the "aio_write" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь cache manager следит за количеством элементов в кэше
-и старается не допускать переполнений зоны разделяемой памяти.
-</para>
-<para lang="en">
-now cache manager monitors number of elements in caches
-and tries to avoid cache keys zone overflows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив sendfile и aio с подзапросами
-в логах могли появляться сообщения "task already active" и "second aio post".
-</para>
-<para lang="en">
-"task already active" and "second aio post" alerts might appear in logs
-when using the "sendfile" and "aio" directives with subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэширования
-в логах могли появляться сообщения "zero size buf in output",
-если клиент закрывал соединение преждевременно.
-</para>
-<para lang="en">
-"zero size buf in output" alerts might appear in logs
-if caching was used
-and a client closed a connection prematurely.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэширования
-соединения с клиентами могли закрываться без необходимости.<br/>
-Спасибо Justin Li.
-</para>
-<para lang="en">
-connections with clients might be closed needlessly
-if caching was used.<br/>
-Thanks to Justin Li.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог нагружать процессор
-при использовании директивы sendfile на Linux и Solaris,
-если отправляемый файл был изменён в процессе отправки.
-</para>
-<para lang="en">
-nginx might hog CPU
-if the "sendfile" directive was used on Linux or Solaris
-and a file being sent was changed during sending.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив sendfile и "aio threads"
-соединения могли зависать.
-</para>
-<para lang="en">
-connections might hang
-when using the "sendfile" and "aio threads" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах proxy_pass, fastcgi_pass, scgi_pass и uwsgi_pass
-при использовании переменных.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the "proxy_pass", "fastcgi_pass", "scgi_pass", and "uwsgi_pass" directives
-when using variables.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_sub_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_sub_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в закэшированном соединении к бэкенду происходила ошибка,
-запрос передавался на другой сервер
-без учёта директивы proxy_next_upstream.
-</para>
-<para lang="en">
-if an error occurred in a cached backend connection,
-the request was passed to the next server
-regardless of the proxy_next_upstream directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "CreateFile() failed" при создании временных файлов на Windows.
-</para>
-<para lang="en">
-"CreateFile() failed" errors when creating temporary files on Windows.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.12" date="2016-02-24">
-
-<change type="feature">
-<para lang="ru">
-кодирование Хаффмана заголовков ответов в HTTP/2.<br/>
-Спасибо Владу Краснову.
-</para>
-<para lang="en">
-Huffman encoding of response headers in HTTP/2.<br/>
-Thanks to Vlad Krasnov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_cpu_affinity теперь поддерживает более 64 процессоров.
-</para>
-<para lang="en">
-the "worker_cpu_affinity" directive now supports more than 64 CPUs.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость со сторонними модулями на C++;
-ошибка появилась в 1.9.11.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-compatibility with 3rd party C++ modules;
-the bug had appeared in 1.9.11.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался статически с OpenSSL на Linux;
-ошибка появилась в 1.9.11.
-</para>
-<para lang="en">
-nginx could not be built statically with OpenSSL on Linux;
-the bug had appeared in 1.9.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "add_header ... always" с пустым значением
-не удаляла из заголовков ошибочных ответов
-строки Last-Modified и ETag.
-</para>
-<para lang="en">
-the "add_header ... always" directive with an empty value
-did not delete "Last-Modified" and "ETag" header lines
-from error responses.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при использовании OpenSSL 1.0.2f в логах могли появляться
-сообщения "called a function you should not call" и
-"shutdown while in init".
-</para>
-<para lang="en">
-"called a function you should not call"
-and "shutdown while in init" messages might appear in logs
-when using OpenSSL 1.0.2f.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибочные заголовки могли логгироваться некорректно.
-</para>
-<para lang="en">
-invalid headers might be logged incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов при использовании HTTP/2.
-</para>
-<para lang="en">
-socket leak when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.11" date="2016-02-09">
-
-<change type="feature">
-<para lang="ru">
-теперь resolver поддерживает TCP.
-</para>
-<para lang="en">
-TCP support in resolver.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-динамические модули.
-</para>
-<para lang="en">
-dynamic modules.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-переменная $request_length не учитывала размер заголовков запроса.
-</para>
-<para lang="en">
-the $request_length variable did not include size of request headers
-when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.10" date="2016-01-26">
-
-<change type="security">
-<para lang="ru">
-при использовании директивы resolver
-во время обработки ответов DNS-сервера
-могло происходить разыменование некорректного адреса,
-что позволяло атакующему,
-имеющему возможность подделывать UDP-пакеты от DNS-сервера,
-вызвать segmentation fault в рабочем процессе (CVE-2016-0742).
-</para>
-<para lang="en">
-invalid pointer dereference might occur
-during DNS server response processing
-if the "resolver" directive was used,
-allowing an attacker who is able to forge UDP packets from the DNS server
-to cause segmentation fault in a worker process (CVE-2016-0742).
-</para>
-</change>
-
-<change type="security">
-<para lang="ru">
-при использовании директивы resolver
-во время обработки CNAME-записей
-могло произойти обращение к ранее освобождённой памяти,
-что позволяло атакующему,
-имеющему возможность инициировать преобразование произвольных имён в адреса,
-вызвать segmentation fault в рабочем процессе,
-а также потенциально могло иметь другие последствия (CVE-2016-0746).
-</para>
-<para lang="en">
-use-after-free condition might occur
-during CNAME response processing
-if the "resolver" directive was used,
-allowing an attacker who is able to trigger name resolution
-to cause segmentation fault in a worker process,
-or might have potential other impact (CVE-2016-0746).
-</para>
-</change>
-
-<change type="security">
-<para lang="ru">
-при использовании директивы resolver
-во время обработки CNAME-записей
-не во всех случаях проверялось ограничение
-на максимальное количество записей в цепочке,
-что позволяло атакующему,
-имеющему возможность инициировать преобразование произвольных имён в адреса,
-вызвать чрезмерное потребление ресурсов рабочими процессами (CVE-2016-0747).
-</para>
-<para lang="en">
-CNAME resolution was insufficiently limited
-if the "resolver" directive was used,
-allowing an attacker who is able to trigger arbitrary name resolution
-to cause excessive resource consumption in worker processes (CVE-2016-0747).
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр auto директивы worker_cpu_affinity.
-</para>
-<para lang="en">
-the "auto" parameter of the "worker_cpu_affinity" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр proxy_protocol директивы listen не работал
-с IPv6 listen-сокетами.
-</para>
-<para lang="en">
-the "proxy_protocol" parameter of the "listen" directive did not work
-with IPv6 listen sockets.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы keepalive
-соединения к бэкендам могли кэшироваться некорректно.
-</para>
-<para lang="en">
-connections to upstream servers might be cached incorrectly
-when using the "keepalive" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после перенаправления запроса с помощью X-Accel-Redirect
-при проксировании использовался HTTP-метод оригинального запроса.
-</para>
-<para lang="en">
-proxying used the HTTP method of the original request
-after an "X-Accel-Redirect" redirection.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.9" date="2015-12-09">
-
-<change type="bugfix">
-<para lang="ru">
-проксирование в unix domain сокеты не работало при использовании переменных;
-ошибка появилась в 1.9.8.
-</para>
-<para lang="en">
-proxying to unix domain sockets did not work when using variables;
-the bug had appeared in 1.9.8.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.8" date="2015-12-08">
-
-<change type="feature">
-<para lang="ru">
-поддержка pwritev().
-</para>
-<para lang="en">
-pwritev() support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива include в блоке upstream.
-</para>
-<para lang="en">
-the "include" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_slice_module.
-</para>
-<para lang="en">
-the ngx_http_slice_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании LibreSSL
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.9.6.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using LibreSSL;
-the bug had appeared in 1.9.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог не собираться на OS X.
-</para>
-<para lang="en">
-nginx could not be built on OS X in some cases.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.7" date="2015-11-17">
-
-<change type="feature">
-<para lang="ru">
-параметр nohostname логгирования в syslog.
-</para>
-<para lang="en">
-the "nohostname" parameter of logging to syslog.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_cache_convert_head.
-</para>
-<para lang="en">
-the "proxy_cache_convert_head" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $realip_remote_addr в модуле ngx_http_realip_module.
-</para>
-<para lang="en">
-the $realip_remote_addr variable in the ngx_http_realip_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива expires могла не срабатывать при использовании переменных.
-</para>
-<para lang="en">
-the "expires" directive might not work when using variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.9.6.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using HTTP/2;
-the bug had appeared in 1.9.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_v2_module,
-протокол HTTP/2 мог быть использован клиентом,
-даже если не был указан параметр http2 директивы listen.
-</para>
-<para lang="en">
-if nginx was built with the ngx_http_v2_module
-it was possible to use the HTTP/2 protocol
-even if the "http2" parameter of the "listen" directive was not specified.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_v2_module.
-</para>
-<para lang="en">
-in the ngx_http_v2_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.6" date="2015-10-27">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Piotr Sikora и Denis Andzakovic.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using HTTP/2.<br/>
-Thanks to Piotr Sikora and Denis Andzakovic.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP/2 переменная $server_protocol была пустой.
-</para>
-<para lang="en">
-the $server_protocol variable was empty when using HTTP/2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL-соединения к бэкендам в модуле stream
-могли неожиданно завершаться по таймауту.
-</para>
-<para lang="en">
-backend SSL connections in the stream module
-might be timed out unexpectedly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании различных настроек ssl_session_cache
-в разных виртуальных серверах
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if different ssl_session_cache settings were used
-in different virtual servers.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с MinGW gcc;
-ошибка появилась в 1.9.4.<br/>
-Спасибо Kouhei Sutou.
-</para>
-<para lang="en">
-nginx/Windows could not be built with MinGW gcc;
-the bug had appeared in 1.9.4.<br/>
-Thanks to Kouhei Sutou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы timer_resolution на Windows время не обновлялось.
-</para>
-<para lang="en">
-time was not updated when the timer_resolution directive was used on Windows.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Незначительные исправления и улучшения.<br/>
-Спасибо Markus Linnala, Kurtis Nusbaum и Piotr Sikora.
-</para>
-<para lang="en">
-Miscellaneous minor fixes and improvements.<br/>
-Thanks to Markus Linnala, Kurtis Nusbaum and Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.5" date="2015-09-22">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_v2_module (заменяет модуль ngx_http_spdy_module).<br/>
-Спасибо Dropbox и Automattic за спонсирование разработки.
-</para>
-<para lang="en">
-the ngx_http_v2_module (replaces ngx_http_spdy_module).<br/>
-Thanks to Dropbox and Automattic for sponsoring this work.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию директива output_buffers использует два буфера.
-</para>
-<para lang="en">
-now the "output_buffers" directive uses two buffers by default.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь nginx ограничивает максимальную вложенность подзапросов,
-а не количество одновременных подзапросов.
-</para>
-<para lang="en">
-now nginx limits subrequests recursion,
-not simultaneous subrequests.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при возврате ответов из кэша nginx проверяет ключ полностью.<br/>
-Спасибо Геннадию Махомеду и Сергею Брестеру.
-</para>
-<para lang="en">
-now nginx checks the whole cache key when returning a response from cache.<br/>
-Thanks to Gena Makhomed and Sergey Brester.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэша
-в логах могли появляться сообщения "header already sent";
-ошибка появилась в 1.7.5.
-</para>
-<para lang="en">
-"header already sent" alerts might appear in logs
-when using cache;
-the bug had appeared in 1.7.5.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании CephFS и директивы timer_resolution на Linux
-в логах могли появляться сообщения
-"writev() failed (4: Interrupted system call)".
-</para>
-<para lang="en">
-"writev() failed (4: Interrupted system call)"
-errors might appear in logs
-when using CephFS and the "timer_resolution" directive on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок конфигурации.<br/>
-Спасибо Markus Linnala.
-</para>
-<para lang="en">
-in invalid configurations handling.<br/>
-Thanks to Markus Linnala.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы sub_filter на уровне http
-в рабочем процессе происходил segmentation fault;
-ошибка появилась в 1.9.4.
-</para>
-<para lang="en">
-a segmentation fault occurred in a worker process
-if the "sub_filter" directive was used at http level;
-the bug had appeared in 1.9.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.4" date="2015-08-18">
-
-<change type="change">
-<para lang="ru">
-директивы proxy_downstream_buffer и proxy_upstream_buffer в модуле stream
-заменены директивой proxy_buffer_size.
-</para>
-<para lang="en">
-the "proxy_downstream_buffer" and "proxy_upstream_buffer" directives
-of the stream module are replaced with the "proxy_buffer_size" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива tcp_nodelay в модуле stream.
-</para>
-<para lang="en">
-the "tcp_nodelay" directive in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь можно указать несколько директив sub_filter одновременно.
-</para>
-<para lang="en">
-multiple "sub_filter" directives can be used simultaneously.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива sub_filter поддерживает переменные в строке поиска.
-</para>
-<para lang="en">
-variables support in the search string of the "sub_filter" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-тестирование конфигурации могло не работать под Linux OpenVZ.<br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-configuration testing might fail under Linux OpenVZ.<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после переконфигурации старые рабочие процессы могли сильно нагружать процессор
-при больших значениях worker_connections.
-</para>
-<para lang="en">
-old worker processes might hog CPU after reconfiguration
-with a large number of worker_connections.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при совместном использовании директив try_files и alias
-внутри location'а, заданного регулярным выражением,
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.7.1.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "try_files" and "alias" directives were used
-inside a location given by a regular expression;
-the bug had appeared in 1.7.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива try_files внутри вложенного location'а, заданного регулярным
-выражением, работала неправильно, если во внешнем location'е использовалась
-директива alias.
-</para>
-<para lang="en">
-the "try_files" directive inside a nested location
-given by a regular expression worked incorrectly
-if the "alias" directive was used in the outer location.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при построении хэш-таблиц.
-</para>
-<para lang="en">
-in hash table initialization error handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с Visual Studio 2015.
-</para>
-<para lang="en">
-nginx could not be built with Visual Studio 2015.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.3" date="2015-07-14">
-
-<change type="change">
-<para lang="ru">
-дублирующиеся блоки http, mail и stream теперь запрещены.
-</para>
-<para lang="en">
-duplicate "http", "mail", and "stream" blocks are now disallowed.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ограничение количества соединений в модуле stream.
-</para>
-<para lang="en">
-connection limiting in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ограничение скорости в модуле stream.
-</para>
-<para lang="en">
-data rate limiting in the stream module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива zone в блоке upstream не работала на Windows.
-</para>
-<para lang="en">
-the "zone" directive inside the "upstream" block did not work on Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с LibreSSL в модуле stream.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-compatibility with LibreSSL in the stream module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в параметре --builddir в configure.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the "--builddir" configure parameter.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_stapling_file не работала;
-ошибка появилась в 1.9.2.<br/>
-Спасибо Faidon Liambotis и Brandon Black.
-</para>
-<para lang="en">
-the "ssl_stapling_file" directive did not work;
-the bug had appeared in 1.9.2.<br/>
-Thanks to Faidon Liambotis and Brandon Black.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ssl_stapling
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 1.9.2.<br/>
-Спасибо Matthew Baldwin.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "ssl_stapling" directive was used;
-the bug had appeared in 1.9.2.<br/>
-Thanks to Matthew Baldwin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.2" date="2015-06-16">
-
-<change type="feature">
-<para lang="ru">
-параметр backlog директивы listen
-в почтовом прокси-сервере и модуле stream.
-</para>
-<para lang="en">
-the "backlog" parameter of the "listen" directives
-of the mail proxy and stream modules.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы allow и deny в модуле stream.
-</para>
-<para lang="en">
-the "allow" and "deny" directives in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_bind в модуле stream.
-</para>
-<para lang="en">
-the "proxy_bind" directive in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_protocol в модуле stream.
-</para>
-<para lang="en">
-the "proxy_protocol" directive in the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -T.
-</para>
-<para lang="en">
-the -T switch.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр REQUEST_SCHEME добавлен в стандартные конфигурационные файлы
-fastcgi.conf, fastcgi_params, scgi_params и uwsgi_params.
-</para>
-<para lang="en">
-the REQUEST_SCHEME parameter added to the fastcgi.conf, fastcgi_params,
-scgi_params, and uwsgi_params standard configuration files.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр reuseport директивы listen в модуле stream
-не работал.
-</para>
-<para lang="en">
-the "reuseport" parameter of the "listen" directive of the stream module
-did not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-OCSP stapling в некоторых случаях мог вернуть устаревший OCSP-ответ.
-</para>
-<para lang="en">
-OCSP stapling might return an expired OCSP response in some cases.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.1" date="2015-05-26">
-
-<change type="change">
-<para lang="ru">
-теперь протокол SSLv3 по умолчанию запрещён.
-</para>
-<para lang="en">
-now SSLv3 protocol is disabled by default.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-некоторые давно устаревшие директивы больше не поддерживаются.
-</para>
-<para lang="en">
-some long deprecated directives are not supported anymore.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр reuseport директивы listen.<br/>
-Спасибо Yingqi Lu из Intel и Sepherosa Ziehau.
-</para>
-<para lang="en">
-the "reuseport" parameter of the "listen" directive.<br/>
-Thanks to Yingqi Lu at Intel and Sepherosa Ziehau.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_connect_time.
-</para>
-<para lang="en">
-the $upstream_connect_time variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве hash на big-endian платформах.
-</para>
-<para lang="en">
-in the "hash" directive on big-endian platforms.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог не запускаться на некоторых старых версиях Linux;
-ошибка появилась в 1.7.11.
-</para>
-<para lang="en">
-nginx might fail to start on some old Linux variants;
-the bug had appeared in 1.7.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в парсинге IP-адресов.<br/>
-Спасибо Сергею Половко.
-</para>
-<para lang="en">
-in IP address parsing.<br/>
-Thanks to Sergey Polovko.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.9.0" date="2015-04-28">
-
-<change type="change">
-<para lang="ru">
-устаревшие методы обработки соединений aio и rtsig больше не поддерживаются.
-</para>
-<para lang="en">
-obsolete aio and rtsig event methods have been removed.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива zone в блоке upstream.
-</para>
-<para lang="en">
-the "zone" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль stream.
-</para>
-<para lang="en">
-the stream module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка byte ranges для ответов модуля ngx_http_memcached_module.<br/>
-Спасибо Martin Mlynář.
-</para>
-<para lang="en">
-byte ranges support in the ngx_http_memcached_module.<br/>
-Thanks to Martin Mlynář.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-разделяемую память теперь можно использовать на версиях Windows
-с рандомизацией адресного пространства.<br/>
-Спасибо Сергею Брестеру.
-</para>
-<para lang="en">
-shared memory can now be used on Windows versions
-with address space layout randomization.<br/>
-Thanks to Sergey Brester.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву error_log теперь можно использовать
-на уровнях mail и server в почтовом прокси-сервере.
-</para>
-<para lang="en">
-the "error_log" directive can now be used
-on mail and server levels in mail proxy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр proxy_protocol директивы listen не работал,
-если не был указан в первой директиве listen для данного listen-сокета.
-</para>
-<para lang="en">
-the "proxy_protocol" parameter of the "listen" directive did not work
-if not specified in the first "listen" directive for a listen socket.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.12" date="2015-04-07">
-
-<change type="feature">
-<para lang="ru">
-теперь директива tcp_nodelay работает для SSL-соединений с бэкендами.
-</para>
-<para lang="en">
-now the "tcp_nodelay" directive works with backend SSL connections.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь потоки могут использоваться для чтения заголовков файлов в кэше.
-</para>
-<para lang="en">
-now thread pools can be used to read cache file headers.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_request_buffering.
-</para>
-<para lang="en">
-in the "proxy_request_buffering" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании потоков на Linux
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when using thread pools on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при использовании директивы ssl_stapling.<br/>
-Спасибо Filipe da Silva.
-</para>
-<para lang="en">
-in error handling when using the "ssl_stapling" directive.<br/>
-Thanks to Filipe da Silva.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.11" date="2015-03-24">
-
-<change type="change">
-<para lang="ru">
-параметр sendfile директивы aio более не нужен;
-теперь nginx автоматически использует AIO для подгрузки данных для sendfile,
-если одновременно используются директивы aio и sendfile.
-</para>
-<para lang="en">
-the "sendfile" parameter of the "aio" directive is deprecated;
-now nginx automatically uses AIO to pre-load data for sendfile
-if both "aio" and "sendfile" directives are used.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-экспериментальная поддержка потоков.
-</para>
-<para lang="en">
-experimental thread pools support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_request_buffering, fastcgi_request_buffering,
-scgi_request_buffering и uwsgi_request_buffering.
-</para>
-<para lang="en">
-the "proxy_request_buffering", "fastcgi_request_buffering",
-"scgi_request_buffering", and "uwsgi_request_buffering" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-экспериментальное API для обработки тела запроса.
-</para>
-<para lang="en">
-request body filters experimental API.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-проверка клиентских SSL-сертификатов в почтовом прокси-сервере.<br/>
-Спасибо Sven Peter, Franck Levionnois и Filipe Da Silva.
-</para>
-<para lang="en">
-client SSL certificates support in mail proxy.<br/>
-Thanks to Sven Peter, Franck Levionnois, and Filipe Da Silva.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-уменьшение времени запуска
-при использовании директивы "hash ... consistent" в блоке upstream.<br/>
-Спасибо Wai Keen Woon.
-</para>
-<para lang="en">
-startup speedup
-when using the "hash ... consistent" directive in the upstream block.<br/>
-Thanks to Wai Keen Woon.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-отладочное логгирование в кольцевой буфер в памяти.
-</para>
-<para lang="en">
-debug logging into a cyclic memory buffer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке хэш-таблиц.<br/>
-Спасибо Chris West.
-</para>
-<para lang="en">
-in hash table handling.<br/>
-Thanks to Chris West.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_revalidate.
-</para>
-<para lang="en">
-in the "proxy_cache_revalidate" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL-соединения могли зависать, если использовался отложенный accept
-или параметр proxy_protocol директивы listen.<br/>
-Спасибо James Hamlin.
-</para>
-<para lang="en">
-SSL connections might hang if deferred accept
-or the "proxy_protocol" parameter of the "listen" directive were used.<br/>
-Thanks to James Hamlin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $upstream_response_time могла содержать неверное значение
-при использовании директивы image_filter.
-</para>
-<para lang="en">
-the $upstream_response_time variable might contain a wrong value
-if the "image_filter" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке целочисленных переполнений.<br/>
-Спасибо Régis Leroy.
-</para>
-<para lang="en">
-in integer overflow handling.<br/>
-Thanks to Régis Leroy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании LibreSSL было невозможно включить поддержку SSLv3.
-</para>
-<para lang="en">
-it was not possible to enable SSLv3 with LibreSSL.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании LibreSSL в логах появлялись сообщения
-"ignoring stale global SSL error ... called a function you should not call".
-</para>
-<para lang="en">
-the "ignoring stale global SSL error ... called a function you should not call"
-alerts appeared in logs when using LibreSSL.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сертификаты, указанные в директивах ssl_client_certificate и
-ssl_trusted_certificate, использовались
-для автоматического построения цепочек сертификатов.
-</para>
-<para lang="en">
-certificates specified by the "ssl_client_certificate" and
-"ssl_trusted_certificate" directives were inadvertently used
-to automatically construct certificate chains.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.10" date="2015-02-10">
-
-<change type="feature">
-<para lang="ru">
-параметр use_temp_path директив proxy_cache_path, fastcgi_cache_path,
-scgi_cache_path и uwsgi_cache_path.
-</para>
-<para lang="en">
-the "use_temp_path" parameter of the "proxy_cache_path", "fastcgi_cache_path",
-"scgi_cache_path", and "uwsgi_cache_path" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_header_time.
-</para>
-<para lang="en">
-the $upstream_header_time variable.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-теперь при переполнении диска nginx пытается писать error_log'и только
-раз в секунду.
-</para>
-<para lang="en">
-now on disk overflow nginx tries to write error logs once a second only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива try_files при тестировании каталогов
-не игнорировала обычные файлы.<br/>
-Спасибо Damien Tournoud.
-</para>
-<para lang="en">
-the "try_files" directive did not ignore normal files
-while testing directories.<br/>
-Thanks to Damien Tournoud.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы sendfile на OS X
-возникали ошибки "sendfile() failed";
-ошибка появилась в nginx 1.7.8.
-</para>
-<para lang="en">
-alerts "sendfile() failed"
-if the "sendfile" directive was used on OS X;
-the bug had appeared in 1.7.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в лог могли писаться сообщения "sem_post() failed".
-</para>
-<para lang="en">
-alerts "sem_post() failed" might appear in logs.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с musl libc.<br/>
-Спасибо James Taylor.
-</para>
-<para lang="en">
-nginx could not be built with musl libc.<br/>
-Thanks to James Taylor.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Tru64 UNIX.<br/>
-Спасибо Goetz T. Fischer.
-</para>
-<para lang="en">
-nginx could not be built on Tru64 UNIX.<br/>
-Thanks to Goetz T. Fischer.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.9" date="2014-12-23">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache, fastcgi_cache, scgi_cache и uwsgi_cache
-поддерживают переменные.
-</para>
-<para lang="en">
-variables support in the "proxy_cache", "fastcgi_cache", "scgi_cache",
-and "uwsgi_cache" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива expires поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "expires" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-возможность загрузки секретных ключей с аппаратных устройств
-с помощью OpenSSL engines.<br/>
-Спасибо Дмитрию Пичулину.
-</para>
-<para lang="en">
-loading of secret keys from hardware tokens
-with OpenSSL engines.<br/>
-Thanks to Dmitrii Pichulin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива autoindex_format.
-</para>
-<para lang="en">
-the "autoindex_format" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ревалидация элементов кэша теперь используется только для ответов
-с кодами 200 и 206.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-cache revalidation is now only used for responses
-with 200 and 206 status codes.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строка "TE" заголовка запроса клиента передавалась на бэкенд при проксировании.
-</para>
-<para lang="en">
-the "TE" client request header line was passed to backends while proxying.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_pass, fastcgi_pass, scgi_pass и uwsgi_pass
-могли неправильно работать внутри блоков if и limit_except.
-</para>
-<para lang="en">
-the "proxy_pass", "fastcgi_pass", "scgi_pass", and "uwsgi_pass" directives
-might not work correctly inside the "if" and "limit_except" blocks.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_store с параметром "on" игнорировалась,
-если на предыдущем уровне использовалась директива proxy_store
-с явно заданным путём к файлам.
-</para>
-<para lang="en">
-the "proxy_store" directive with the "on" parameter was ignored
-if the "proxy_store" directive with an explicitly specified file path
-was used on a previous level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с BoringSSL.<br/>
-Спасибо Lukas Tribus.
-</para>
-<para lang="en">
-nginx could not be built with BoringSSL.<br/>
-Thanks to Lukas Tribus.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.8" date="2014-12-02">
-
-<change type="change">
-<para lang="ru">
-теперь строки "If-Modified-Since", "If-Range" и им подобные
-в заголовке запроса клиента передаются бэкенду при включённом кэшировании,
-если nginx заранее знает, что не будет кэшировать ответ
-(например, при использовании proxy_cache_min_uses).
-</para>
-<para lang="en">
-now the "If-Modified-Since", "If-Range", etc.
-client request header lines are passed to a backend while caching
-if nginx knows in advance that the response will not be cached
-(e.g., when using proxy_cache_min_uses).
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь после истечения proxy_cache_lock_timeout
-nginx отправляет запрос на бэкенд без кэширования;
-новые директивы proxy_cache_lock_age, fastcgi_cache_lock_age,
-scgi_cache_lock_age и uwsgi_cache_lock_age позволяют указать,
-через какое время блокировка будет принудительно снята
-и будет сделана ещё одна попытка закэшировать ответ.
-</para>
-<para lang="en">
-now after proxy_cache_lock_timeout
-nginx sends a request to a backend with caching disabled;
-the new directives "proxy_cache_lock_age", "fastcgi_cache_lock_age",
-"scgi_cache_lock_age", and "uwsgi_cache_lock_age" specify a time
-after which the lock will be released
-and another attempt to cache a response will be made.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива log_format теперь может использоваться только на уровне http.
-</para>
-<para lang="en">
-the "log_format" directive can now be used only at http level.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_ssl_certificate, proxy_ssl_certificate_key,
-proxy_ssl_password_file, uwsgi_ssl_certificate,
-uwsgi_ssl_certificate_key и uwsgi_ssl_password_file.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "proxy_ssl_certificate", "proxy_ssl_certificate_key",
-"proxy_ssl_password_file", "uwsgi_ssl_certificate",
-"uwsgi_ssl_certificate_key", and "uwsgi_ssl_password_file" directives.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь с помощью X-Accel-Redirect
-можно перейти в именованный location.<br/>
-Спасибо Toshikuni Fukaya.
-</para>
-<para lang="en">
-it is now possible to switch to a named location
-using "X-Accel-Redirect".<br/>
-Thanks to Toshikuni Fukaya.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директива tcp_nodelay работает для SPDY-соединений.
-</para>
-<para lang="en">
-now the "tcp_nodelay" directive works with SPDY connections.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новые директивы в скриптах подсветки синтаксиса для vim.<br/>
-Спасибо Peter Wu.
-</para>
-<para lang="en">
-new directives in vim syntax highliting scripts.<br/>
-Thanks to Peter Wu.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал значение "s-maxage"
-в строке "Cache-Control" в заголовке ответа бэкенда.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-nginx ignored the "s-maxage" value
-in the "Cache-Control" backend response header line.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве ssl_password_file
-при использовании OpenSSL 0.9.8zc, 1.0.0o, 1.0.1j.
-</para>
-<para lang="en">
-in the "ssl_password_file" directive
-when using OpenSSL 0.9.8zc, 1.0.0o, 1.0.1j.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы post_action
-в лог писались сообщения "header already sent";
-ошибка появилась в nginx 1.5.4.
-</para>
-<para lang="en">
-alerts "header already sent" appeared in logs
-if the "post_action" directive was used;
-the bug had appeared in 1.5.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "postpone_output 0" с SSI-подзапросами
-в лог могли писаться сообщения "the http output chain is empty".
-</para>
-<para lang="en">
-alerts "the http output chain is empty" might appear in logs
-if the "postpone_output 0" directive was used with SSI includes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_lock при использовании SSI-подзапросов.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-in the "proxy_cache_lock" directive with SSI subrequests.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.7" date="2014-10-28">
-
-<change type="change">
-<para lang="ru">
-теперь nginx учитывает при кэшировании строку "Vary"
-в заголовке ответа бэкенда.
-</para>
-<para lang="en">
-now nginx takes into account the "Vary"
-header line in a backend response while caching.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_force_ranges, fastcgi_force_ranges,
-scgi_force_ranges и uwsgi_force_ranges.
-</para>
-<para lang="en">
-the "proxy_force_ranges", "fastcgi_force_ranges",
-"scgi_force_ranges", and "uwsgi_force_ranges" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_limit_rate, fastcgi_limit_rate,
-scgi_limit_rate и uwsgi_limit_rate.
-</para>
-<para lang="en">
-the "proxy_limit_rate", "fastcgi_limit_rate",
-"scgi_limit_rate", and "uwsgi_limit_rate" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр Vary директив proxy_ignore_headers, fastcgi_ignore_headers,
-scgi_ignore_headers и uwsgi_ignore_headers.
-</para>
-<para lang="en">
-the "Vary" parameter of the "proxy_ignore_headers", "fastcgi_ignore_headers",
-"scgi_ignore_headers", and "uwsgi_ignore_headers" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-последняя часть ответа, полученного от бэкенда
-при небуферизированном проксировании,
-могла не отправляться клиенту,
-если использовались директивы gzip или gunzip.
-</para>
-<para lang="en">
-the last part of a response received from a backend
-with unbufferred proxy
-might not be sent to a client
-if "gzip" or "gunzip" directives were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_cache_revalidate.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the "proxy_cache_revalidate" directive.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок.<br/>
-Спасибо Yichun Zhang и Даниилу Бондареву.
-</para>
-<para lang="en">
-in error handling.<br/>
-Thanks to Yichun Zhang and Daniil Bondarev.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах
-proxy_next_upstream_tries и proxy_next_upstream_timeout.<br/>
-Спасибо Feng Gu.
-</para>
-<para lang="en">
-in the "proxy_next_upstream_tries" and "proxy_next_upstream_timeout"
-directives.<br/>
-Thanks to Feng Gu.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с MinGW-w64 gcc.<br/>
-Спасибо Kouhei Sutou.
-</para>
-<para lang="en">
-nginx/Windows could not be built with MinGW-w64 gcc.<br/>
-Thanks to Kouhei Sutou.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.6" date="2014-09-30">
-
-<change type="change">
-<para lang="ru">
-устаревшая директива limit_zone больше не поддерживается.
-</para>
-<para lang="en">
-the deprecated "limit_zone" directive is not supported anymore.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в директивах limit_conn_zone и limit_req_zone теперь можно использовать
-комбинации нескольких переменных.
-</para>
-<para lang="en">
-the "limit_conn_zone" and "limit_req_zone" directives now can be used
-with combinations of multiple variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при повторной отправке FastCGI-запроса на бэкенд
-тело запроса могло передаваться неправильно.
-</para>
-<para lang="en">
-request body might be transmitted incorrectly
-when retrying a FastCGI request to the next upstream server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в логгировании в syslog.
-</para>
-<para lang="en">
-in logging to syslog.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.5" date="2014-09-16">
-
-<change type="security">
-<para lang="ru">
-при использовании общего для нескольких блоков server
-разделяемого кэша SSL-сессий или общего ключа для шифрования
-TLS session tickets было возможно повторно использовать
-SSL-сессию в контексте другого блока server (CVE-2014-3616).<br/>
-Спасибо Antoine Delignat-Lavaud.
-</para>
-<para lang="en">
-it was possible to reuse SSL sessions in unrelated contexts
-if a shared SSL session cache or the same TLS session ticket key
-was used for multiple "server" blocks (CVE-2014-3616).<br/>
-Thanks to Antoine Delignat-Lavaud.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директиву stub_status теперь можно указывать без параметров.
-</para>
-<para lang="en">
-now the "stub_status" directive does not require a parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр always директивы add_header.
-</para>
-<para lang="en">
-the "always" parameter of the "add_header" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы
-proxy_next_upstream_tries, proxy_next_upstream_timeout,
-fastcgi_next_upstream_tries, fastcgi_next_upstream_timeout,
-memcached_next_upstream_tries, memcached_next_upstream_timeout,
-scgi_next_upstream_tries, scgi_next_upstream_timeout,
-uwsgi_next_upstream_tries и uwsgi_next_upstream_timeout.
-</para>
-<para lang="en">
-the
-"proxy_next_upstream_tries", "proxy_next_upstream_timeout",
-"fastcgi_next_upstream_tries", "fastcgi_next_upstream_timeout",
-"memcached_next_upstream_tries", "memcached_next_upstream_timeout",
-"scgi_next_upstream_tries", "scgi_next_upstream_timeout",
-"uwsgi_next_upstream_tries", and "uwsgi_next_upstream_timeout"
-directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в параметре if директивы access_log.
-</para>
-<para lang="en">
-in the "if" parameter of the "access_log" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_perl_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_perl_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива listen почтового прокси-сервера
-не позволяла указать более двух параметров.
-</para>
-<para lang="en">
-the "listen" directive of the mail proxy module
-did not allow to specify more than two parameters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива sub_filter не работала
-с заменяемой строкой из одного символа.
-</para>
-<para lang="en">
-the "sub_filter" directive did not work
-with a string to replace consisting of a single character.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-запросы могли зависать, если использовался resolver
-и в процессе обращения к DNS-серверу происходил таймаут.
-</para>
-<para lang="en">
-requests might hang if resolver was used
-and a timeout occurred during a DNS request.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module при использовании совместно с AIO.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module when using with AIO.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если с помощью директивы set изменялись переменные
-"$http_...", "$sent_http_..." или "$upstream_http_...".
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "set" directive was used to change the "$http_...",
-"$sent_http_...", or "$upstream_http_..." variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.<br/>
-Спасибо Markus Linnala и Feng Gu.
-</para>
-<para lang="en">
-in memory allocation error handling.<br/>
-Thanks to Markus Linnala and Feng Gu.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.4" date="2014-08-05">
-
-<change type="security">
-<para lang="ru">
-pipelined-команды не отбрасывались
-после команды STARTTLS в SMTP прокси-сервере (CVE-2014-3556);
-ошибка появилась в 1.5.6.<br/>
-Спасибо Chris Boulton.
-</para>
-<para lang="en">
-pipelined commands were not discarded
-after STARTTLS command in SMTP proxy (CVE-2014-3556);
-the bug had appeared in 1.5.6.<br/>
-Thanks to Chris Boulton.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-экранирование символов в URI теперь использует
-шестнадцатеричные цифры в верхнем регистре.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-URI escaping now uses
-uppercase hexadecimal digits.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx можно собрать с BoringSSL и LibreSSL.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-now nginx can be build with BoringSSL and LibreSSL.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-запросы могли зависать, если использовался resolver
-и DNS-сервер возвращал некорректный ответ;
-ошибка появилась в 1.5.8.
-</para>
-<para lang="en">
-requests might hang if resolver was used
-and a DNS server returned a malformed response;
-the bug had appeared in 1.5.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $uri могла содержать мусор
-при возврате ошибок с кодом 400.<br/>
-Спасибо Сергею Боброву.
-</para>
-<para lang="en">
-the $uri variable might contain garbage
-when returning errors with code 400.<br/>
-Thanks to Sergey Bobrov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок в директиве proxy_store
-и в модуле ngx_http_dav_module.<br/>
-Спасибо Feng Gu.
-</para>
-<para lang="en">
-in error handling in the "proxy_store" directive
-and the ngx_http_dav_module.<br/>
-Thanks to Feng Gu.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при логгировании ошибок в syslog мог происходить segmentation fault;
-ошибка появилась в 1.7.1.
-</para>
-<para lang="en">
-a segmentation fault might occur if logging of errors to syslog was used;
-the bug had appeared in 1.7.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные $geoip_latitude, $geoip_longitude, $geoip_dma_code
-и $geoip_area_code могли не работать.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-the $geoip_latitude, $geoip_longitude, $geoip_dma_code,
-and $geoip_area_code variables might not work.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.<br/>
-Спасибо Tatsuhiko Kubo и Piotr Sikora.
-</para>
-<para lang="en">
-in memory allocation error handling.<br/>
-Thanks to Tatsuhiko Kubo and Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.3" date="2014-07-08">
-
-<change type="feature">
-<para lang="ru">
-weak entity tags теперь не удаляются при изменениях ответа,
-а strong entity tags преобразуются в weak.
-</para>
-<para lang="en">
-weak entity tags are now preserved on response modifications,
-and strong ones are changed to weak.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ревалидация элементов кэша теперь, если это возможно,
-использует заголовок If-None-Match.
-</para>
-<para lang="en">
-cache revalidation now uses If-None-Match header
-if possible.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_password_file.
-</para>
-<para lang="en">
-the "ssl_password_file" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при возврате ответа из кэша
-заголовок запроса If-None-Match игнорировался,
-если в ответе не было заголовка Last-Modified.
-</para>
-<para lang="en">
-the If-None-Match request header line was ignored
-if there was no Last-Modified header
-in a response returned from cache.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сообщения "peer closed connection in SSL handshake"
-при соединении с бэкендами логгировались на уровне info вместо error.
-</para>
-<para lang="en">
-"peer closed connection in SSL handshake" messages
-were logged at "info" level instead of "error" while connecting to backends.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_dav_module в nginx/Windows.
-</para>
-<para lang="en">
-in the ngx_http_dav_module module in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SPDY-соединения могли неожиданно закрываться,
-если использовалось кэширование.
-</para>
-<para lang="en">
-SPDY connections might be closed prematurely
-if caching was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.2" date="2014-06-17">
-
-<change type="feature">
-<para lang="ru">
-директива hash в блоке upstream.
-</para>
-<para lang="en">
-the "hash" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-дефрагментация свободных блоков разделяемой памяти.<br/>
-Спасибо Wandenberg Peixoto и Yichun Zhang.
-</para>
-<para lang="en">
-defragmentation of free shared memory blocks.<br/>
-Thanks to Wandenberg Peixoto and Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалось значение access_log по умолчанию;
-ошибка появилась в 1.7.0.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the default value of the "access_log" directive was used;
-the bug had appeared in 1.7.0.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-завершающий слэш ошибочно удалялся
-из последнего параметра директивы try_files.
-</para>
-<para lang="en">
-trailing slash was mistakenly removed
-from the last parameter of the "try_files" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог не собираться на OS X.
-</para>
-<para lang="en">
-nginx could not be built on OS X in some cases.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.1" date="2014-05-27">
-
-<change type="feature">
-<para lang="ru">
-переменные "$upstream_cookie_...".
-</para>
-<para lang="en">
-the "$upstream_cookie_..." variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_client_fingerprint.
-</para>
-<para lang="en">
-the $ssl_client_fingerprint variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы error_log и access_log теперь поддерживают логгирование в syslog.
-</para>
-<para lang="en">
-the "error_log" and "access_log" directives now support logging to syslog.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-почтовый прокси-сервер теперь логгирует порт клиента при соединении.
-</para>
-<para lang="en">
-the mail proxy now logs client port on connect.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при использовании директивы "ssl_stapling".<br/>
-Спасибо Filipe da Silva.
-</para>
-<para lang="en">
-memory leak if the "ssl_stapling" directive was used.<br/>
-Thanks to Filipe da Silva.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива alias внутри location'а, заданного регулярным выражением,
-работала неправильно, если использовались директивы if или limit_except.
-</para>
-<para lang="en">
-the "alias" directive used inside a location given by a regular expression
-worked incorrectly if the "if" or "limit_except" directives were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива charset не ставила кодировку для сжатых ответов бэкендов.
-</para>
-<para lang="en">
-the "charset" directive did not set a charset to encoded backend responses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_pass без URI могла использовать оригинальный запрос
-после установки переменной $args.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-a "proxy_pass" directive without URI part might use original request
-after the $args variable was set.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в работе параметра none директивы smtp_auth;
-ошибка появилась в 1.5.6.<br/>
-Спасибо Святославу Никольскому.
-</para>
-<para lang="en">
-in the "none" parameter in the "smtp_auth" directive;
-the bug had appeared in 1.5.6.<br/>
-Thanks to Svyatoslav Nikolsky.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при совместном использовании sub_filter и SSI
-ответы могли передаваться неверно.
-</para>
-<para lang="en">
-if sub_filter and SSI were used together,
-then responses might be transferred incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --with-file-aio на Linux/aarch64.
-</para>
-<para lang="en">
-nginx could not be built with the --with-file-aio option on Linux/aarch64.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.7.0" date="2014-04-24">
-
-<change type="feature">
-<para lang="ru">
-проверка SSL-сертификатов бэкендов.
-</para>
-<para lang="en">
-backend SSL certificate verification.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка SNI при работе с бэкендами по SSL.
-</para>
-<para lang="en">
-support for SNI while working with SSL backends.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_server_name.
-</para>
-<para lang="en">
-the $ssl_server_name variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр if директивы access_log.
-</para>
-<para lang="en">
-the "if" parameter of the "access_log" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.13" date="2014-04-08">
-
-<change type="change">
-<para lang="ru">
-улучшена обработка хэш-таблиц;
-в директивах variables_hash_max_size и types_hash_bucket_size
-значения по умолчанию изменены на 1024 и 64 соответственно.
-</para>
-<para lang="en">
-improved hash table handling;
-the default values of the "variables_hash_max_size" and
-"types_hash_bucket_size" were changed to 1024 and 64 respectively.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_mp4_module теперь понимает аргумент end.
-</para>
-<para lang="en">
-the ngx_http_mp4_module now supports the "end" argument.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка byte ranges модулем ngx_http_mp4_module и при сохранении
-ответов в кэш.
-</para>
-<para lang="en">
-byte ranges support in the ngx_http_mp4_module and while saving responses
-to cache.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx не пишет в лог сообщения "ngx_slab_alloc() failed: no memory"
-при использовании разделяемой памяти в ssl_session_cache
-и в модуле ngx_http_limit_req_module.
-</para>
-<para lang="en">
-alerts "ngx_slab_alloc() failed: no memory" no longer logged
-when using shared memory in the "ssl_session_cache" directive
-and in the ngx_http_limit_req_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива underscores_in_headers
-не разрешала подчёркивание в первом символе заголовка.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "underscores_in_headers" directive
-did not allow underscore as a first character of a header.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-cache manager мог нагружать процессор при выходе в nginx/Windows.
-</para>
-<para lang="en">
-cache manager might hog CPU on exit in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании ssl_session_cache с параметром shared
-рабочий процесс nginx/Windows завершался аварийно.
-</para>
-<para lang="en">
-nginx/Windows terminated abnormally
-if the "ssl_session_cache" directive was used with the "shared" parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.12" date="2014-03-18">
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного запроса модулем ngx_http_spdy_module
-могло происходить переполнение буфера в рабочем процессе,
-что потенциально могло приводить к выполнению произвольного кода
-(CVE-2014-0133).<br/>
-Спасибо Lucas Molas из Programa STIC, Fundación Dr. Manuel
-Sadosky, Buenos Aires, Argentina.
-</para>
-<para lang="en">
-a heap memory buffer overflow might occur in a worker process
-while handling a specially crafted request by ngx_http_spdy_module,
-potentially resulting in arbitrary code execution
-(CVE-2014-0133).<br/>
-Thanks to Lucas Molas, researcher at Programa STIC, Fundación Dr. Manuel
-Sadosky, Buenos Aires, Argentina.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр proxy_protocol в директивах listen и real_ip_header,
-переменная $proxy_protocol_addr.
-</para>
-<para lang="en">
-the "proxy_protocol" parameters of the "listen" and "real_ip_header" directives,
-the $proxy_protocol_addr variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве fastcgi_next_upstream.<br/>
-Спасибо Lucas Molas.
-</para>
-<para lang="en">
-in the "fastcgi_next_upstream" directive.<br/>
-Thanks to Lucas Molas.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.11" date="2014-03-04">
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного запроса модулем ngx_http_spdy_module
-на 32-битных платформах могла повреждаться память рабочего процесса,
-что потенциально могло приводить к выполнению произвольного кода
-(CVE-2014-0088);
-ошибка появилась в 1.5.10.<br/>
-Спасибо Lucas Molas из Programa STIC, Fundación Dr. Manuel
-Sadosky, Buenos Aires, Argentina.
-</para>
-<para lang="en">
-memory corruption might occur in a worker process on 32-bit platforms
-while handling a specially crafted request by ngx_http_spdy_module,
-potentially resulting in arbitrary code execution (CVE-2014-0088);
-the bug had appeared in 1.5.10.<br/>
-Thanks to Lucas Molas, researcher at Programa STIC, Fundación Dr. Manuel
-Sadosky, Buenos Aires, Argentina.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_session_reused.
-</para>
-<para lang="en">
-the $ssl_session_reused variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива client_max_body_size могла не работать
-при чтении тела запроса с использованием chunked transfer encoding;
-ошибка появилась в 1.3.9.<br/>
-Спасибо Lucas Molas.
-</para>
-<para lang="en">
-the "client_max_body_size" directive might not work
-when reading a request body using chunked transfer encoding;
-the bug had appeared in 1.3.9.<br/>
-Thanks to Lucas Molas.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании WebSocket-соединений
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-when proxying WebSocket connections.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_spdy_module на 32-битных платформах;
-ошибка появилась в 1.5.10.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_spdy_module was used on 32-bit platforms;
-the bug had appeared in 1.5.10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-значение переменной $upstream_status могло быть неверным,
-если использовались директивы proxy_cache_use_stale
-или proxy_cache_revalidate.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the $upstream_status variable might contain wrong data
-if the "proxy_cache_use_stale" or "proxy_cache_revalidate" directives
-were used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если ошибки с кодом 400 с помощью директивы error_page
-перенаправлялись в именованный location.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if errors with code 400 were redirected to a named location
-using the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с Visual Studio 2013.
-</para>
-<para lang="en">
-nginx/Windows could not be built with Visual Studio 2013.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.10" date="2014-02-04">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_spdy_module теперь использует протокол SPDY 3.1.<br/>
-Спасибо Automattic и MaxCDN за спонсирование разработки.
-</para>
-<para lang="en">
-the ngx_http_spdy_module now uses SPDY 3.1 protocol.<br/>
-Thanks to Automattic and MaxCDN for sponsoring this work.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_mp4_module теперь пропускает дорожки,
-имеющие меньшую длину, чем запрошенная перемотка.
-</para>
-<para lang="en">
-the ngx_http_mp4_module now skips tracks
-too short for a seek requested.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если переменная $ssl_session_id использовалась при логгировании;
-ошибка появилась в 1.5.9.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the $ssl_session_id variable was used in logs;
-the bug had appeared in 1.5.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные $date_local и $date_gmt использовали неверный формат
-вне модуля ngx_http_ssi_filter_module.
-</para>
-<para lang="en">
-the $date_local and $date_gmt variables used wrong format
-outside of the ngx_http_ssi_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-клиентские соединения могли сразу закрываться,
-если использовался отложенный accept;
-ошибка появилась в 1.3.15.
-</para>
-<para lang="en">
-client connections might be immediately closed
-if deferred accept was used;
-the bug had appeared in 1.3.15.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сообщения "getsockopt(TCP_FASTOPEN) ... failed" записывались в лог
-в процессе обновления исполняемого файла на Linux;
-ошибка появилась в 1.5.8.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-alerts "getsockopt(TCP_FASTOPEN) ... failed" appeared in logs
-during binary upgrade on Linux;
-the bug had appeared in 1.5.8.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.9" date="2014-01-22">
-
-<change type="change">
-<para lang="ru">
-теперь в заголовке X-Accel-Redirect nginx ожидает закодированный URI.
-</para>
-<para lang="en">
-now nginx expects escaped URIs in "X-Accel-Redirect" headers.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_buffer_size.
-</para>
-<para lang="en">
-the "ssl_buffer_size" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву limit_rate теперь можно использовать для
-ограничения скорости передачи ответов клиенту в SPDY-соединениях.
-</para>
-<para lang="en">
-the "limit_rate" directive can now be used to
-rate limit responses sent in SPDY connections.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива spdy_chunk_size.
-</para>
-<para lang="en">
-the "spdy_chunk_size" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_session_tickets.<br/>
-Спасибо Dirkjan Bussink.
-</para>
-<para lang="en">
-the "ssl_session_tickets" directive.<br/>
-Thanks to Dirkjan Bussink.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $ssl_session_id содержала всю сессию в сериализованном виде
-вместо её идентификатора.<br/>
-Спасибо Ivan Ristić.
-</para>
-<para lang="en">
-the $ssl_session_id variable contained full session serialized
-instead of just a session id.<br/>
-Thanks to Ivan Ristić.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx неправильно обрабатывал закодированный символ "?" в команде SSI include.
-</para>
-<para lang="en">
-nginx incorrectly handled escaped "?" character in the "include" SSI command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module не раскодировал целевой URI при
-обработке методов COPY и MOVE.
-</para>
-<para lang="en">
-the ngx_http_dav_module did not unescape destination URI
-of the COPY and MOVE methods.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-resolver не понимал доменные имена с точкой в конце.
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-resolver did not understand domain names with a trailing dot.
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании в логах могли появляться сообщения "zero size buf in output";
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-alerts "zero size buf in output" might appear in logs while proxying;
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_spdy_module.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_spdy_module was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании методов обработки соединений select, poll и /dev/poll
-проксируемые WebSocket-соединения могли зависать сразу после открытия.
-</para>
-<para lang="en">
-proxied WebSocket connections might hang right after handshake
-if the select, poll, or /dev/poll methods were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива xclient почтового прокси-сервера
-некорректно передавала IPv6-адреса.
-</para>
-<para lang="en">
-the "xclient" directive of the mail proxy module
-incorrectly handled IPv6 client addresses.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.8" date="2013-12-17">
-
-<change type="feature">
-<para lang="ru">
-теперь resolver поддерживает IPv6.
-</para>
-<para lang="en">
-IPv6 support in resolver.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива listen поддерживает параметр fastopen.<br/>
-Спасибо Mathew Rodley.
-</para>
-<para lang="en">
-the "listen" directive supports the "fastopen" parameter.<br/>
-Thanks to Mathew Rodley.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка SSL в модуле ngx_http_uwsgi_module.<br/>
-Спасибо Roberto De Ioris.
-</para>
-<para lang="en">
-SSL support in the ngx_http_uwsgi_module.<br/>
-Thanks to Roberto De Ioris.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-скрипты подсветки синтаксиса для vim добавлены в contrib.<br/>
-Спасибо Evan Miller.
-</para>
-<para lang="en">
-vim syntax highlighting scripts were added to contrib.<br/>
-Thanks to Evan Miller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при чтении тела запроса с использованием chunked transfer encoding
-по SSL-соединению мог произойти таймаут.
-</para>
-<para lang="en">
-a timeout might occur while reading client request body
-in an SSL connection using chunked transfer encoding.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива master_process работала неправильно в nginx/Windows.
-</para>
-<para lang="en">
-the "master_process" directive did not work correctly in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр setfib директивы listen мог не работать.
-</para>
-<para lang="en">
-the "setfib" parameter of the "listen" directive might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.7" date="2013-11-19">
-
-<change type="security">
-<para lang="ru">
-символ, следующий за незакодированным пробелом в строке запроса,
-обрабатывался неправильно (CVE-2013-4547);
-ошибка появилась в 0.8.41.<br/>
-Спасибо Ivan Fratric из Google Security Team.
-</para>
-<para lang="en">
-a character following an unescaped space in a request line
-was handled incorrectly (CVE-2013-4547);
-the bug had appeared in 0.8.41.<br/>
-Thanks to Ivan Fratric of the Google Security Team.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-уровень логгирования ошибок auth_basic об отсутствии пароля
-понижен с уровня error до info.
-</para>
-<para lang="en">
-a logging level of auth_basic errors about no user/password provided
-has been lowered from "error" to "info".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache_revalidate, fastcgi_cache_revalidate,
-scgi_cache_revalidate и uwsgi_cache_revalidate.
-</para>
-<para lang="en">
-the "proxy_cache_revalidate", "fastcgi_cache_revalidate",
-"scgi_cache_revalidate", and "uwsgi_cache_revalidate" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_session_ticket_key.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "ssl_session_ticket_key" directive.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "add_header Cache-Control ''"
-добавляла строку заголовка ответа "Cache-Control" с пустым значением.
-</para>
-<para lang="en">
-the directive "add_header Cache-Control ''"
-added a "Cache-Control" response header line with an empty value.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "satisfy any" могла вернуть ошибку 403 вместо 401
-при использовании директив auth_request и auth_basic.<br/>
-Спасибо Jan Marc Hoffmann.
-</para>
-<para lang="en">
-the "satisfy any" directive might return 403 error instead of 401
-if auth_request and auth_basic directives were used.<br/>
-Thanks to Jan Marc Hoffmann.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметры accept_filter и deferred директивы listen игнорировались
-для listen-сокетов, создаваемых в процессе обновления исполняемого файла.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "accept_filter" and "deferred" parameters of the "listen" directive
-were ignored for listen sockets created during binary upgrade.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-часть данных, полученных от бэкенда при небуферизированном проксировании,
-могла не отправляться клиенту сразу,
-если использовались директивы gzip или gunzip.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-some data received from a backend with unbufferred proxy
-might not be sent to a client immediately
-if "gzip" or "gunzip" directives were used.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок в модуле ngx_http_gunzip_filter_module.
-</para>
-<para lang="en">
-in error handling in ngx_http_gunzip_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы могли зависать,
-если использовался модуль ngx_http_spdy_module
-и директива auth_request.
-</para>
-<para lang="en">
-responses might hang
-if the ngx_http_spdy_module was used
-with the "auth_request" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти в nginx/Windows.
-</para>
-<para lang="en">
-memory leak in nginx/Windows.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.6" date="2013-10-01">
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_buffering.
-</para>
-<para lang="en">
-the "fastcgi_buffering" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_ssl_protocols и proxy_ssl_ciphers.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the "proxy_ssl_protocols" and "proxy_ssl_ciphers" directives.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-оптимизация SSL handshake при использовании длинных цепочек сертификатов.
-</para>
-<para lang="en">
-optimization of SSL handshakes when using long certificate chains.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-почтовый прокси-сервер поддерживает SMTP pipelining.
-</para>
-<para lang="en">
-the mail proxy supports SMTP pipelining.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_auth_basic_module
-при использовании метода шифрования паролей "$apr1$".<br/>
-Спасибо Markus Linnala.
-</para>
-<para lang="en">
-in the ngx_http_auth_basic_module
-when using "$apr1$" password encryption method.<br/>
-Thanks to Markus Linnala.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на MacOSX, Cygwin и nginx/Windows
-для обработки запроса мог использоваться неверный location,
-если для задания location'ов использовались символы разных регистров.
-</para>
-<para lang="en">
-in MacOSX, Cygwin, and nginx/Windows
-incorrect location might be used to process a request
-if locations were given using characters in different cases.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-автоматическое перенаправление с добавлением завершающего слэша
-для проксированных location'ов могло не работать.
-</para>
-<para lang="en">
-automatic redirect with appended trailing slash
-for proxied locations might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в почтовом прокси-сервере.
-</para>
-<para lang="en">
-in the mail proxy server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.5" date="2013-09-17">
-
-<change type="change">
-<para lang="ru">
-теперь nginx по умолчанию использует HTTP/1.0,
-если точно определить протокол не удалось.
-</para>
-<para lang="en">
-now nginx assumes HTTP/1.0 by default
-if it is not able to detect protocol reliably.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива disable_symlinks теперь использует O_PATH на Linux.
-</para>
-<para lang="en">
-the "disable_symlinks" directive now uses O_PATH on Linux.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-для определения того, что клиент закрыл соединение,
-при использовании метода epoll
-теперь используются события EPOLLRDHUP.
-</para>
-<para lang="en">
-now nginx uses EPOLLRDHUP events
-to detect premature connection close by clients
-if the "epoll" method is used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве valid_referers при использовании параметра server_names.
-</para>
-<para lang="en">
-in the "valid_referers" directive if the "server_names" parameter was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $request_time не работала в nginx/Windows.
-</para>
-<para lang="en">
-the $request_time variable did not work in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве image_filter.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-in the "image_filter" directive.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с OpenSSL 1.0.1f.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-OpenSSL 1.0.1f compatibility.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-
-</changes>
-
-
-<changes ver="1.5.4" date="2013-08-27">
-
-<change type="change">
-<para lang="ru">
-MIME-тип для расширения js изменён на "application/javascript";
-значение по умолчанию директивы charset_types изменено соответственно.
-</para>
-<para lang="en">
-the "js" extension MIME type has been changed to "application/javascript";
-default value of the "charset_types" directive was changed accordingly.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь директива image_filter с параметром size
-возвращает ответ с MIME-типом "application/json".
-</para>
-<para lang="en">
-now the "image_filter" directive with the "size" parameter
-returns responses with the "application/json" MIME type.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_auth_request_module.
-</para>
-<para lang="en">
-the ngx_http_auth_request_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации мог произойти segmentation fault,
-если использовалась директива try_files с пустым параметром.
-</para>
-<para lang="en">
-a segmentation fault might occur on start or during reconfiguration
-if the "try_files" directive was used with an empty parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при использовании в директивах root и auth_basic_user_file
-относительных путей, заданных с помощью переменных.
-</para>
-<para lang="en">
-memory leak if relative paths were specified using variables
-in the "root" or "auth_basic_user_file" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива valid_referers неправильно выполняла регулярные выражения,
-если заголовок Referer начинался с "https://".<br/>
-Спасибо Liangbin Li.
-</para>
-<para lang="en">
-the "valid_referers" directive incorrectly executed regular expressions
-if a "Referer" header started with "https://".<br/>
-Thanks to Liangbin Li.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы могли зависать, если использовались подзапросы и при обработке подзапроса
-происходила ошибка во время SSL handshake с бэкендом.<br/>
-Спасибо Aviram Cohen.
-</para>
-<para lang="en">
-responses might hang if subrequests were used
-and an SSL handshake error happened during subrequest processing.<br/>
-Thanks to Aviram Cohen.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_autoindex_module.
-</para>
-<para lang="en">
-in the ngx_http_autoindex_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.3" date="2013-07-30">
-
-<change>
-<para lang="ru">
-Изменение во внутреннем API:
-теперь при небуферизированной работе с бэкендами
-u->length по умолчанию устанавливается в -1.
-</para>
-<para lang="en">
-Change in internal API:
-now u->length defaults to -1
-if working with backends in unbuffered mode.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при получении неполного ответа от бэкенда
-nginx отправляет полученную часть ответа,
-после чего закрывает соединение с клиентом.
-</para>
-<para lang="en">
-now after receiving an incomplete response from a backend server
-nginx tries to send an available part of the response to a client,
-and then closes client connection.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_spdy_module
-и директива client_body_in_file_only.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_spdy_module was used
-with the "client_body_in_file_only" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр so_keepalive директивы listen
-мог работать некорректно на DragonFlyBSD.<br/>
-Спасибо Sepherosa Ziehau.
-</para>
-<para lang="en">
-the "so_keepalive" parameter of the "listen" directive
-might be handled incorrectly on DragonFlyBSD.<br/>
-Thanks to Sepherosa Ziehau.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_xslt_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_xslt_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_sub_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_sub_filter_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.2" date="2013-07-02">
-
-<change type="feature">
-<para lang="ru">
-теперь можно использовать несколько директив error_log.
-</para>
-<para lang="en">
-now several "error_log" directives can be used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод $r->header_in() встроенного перла не возвращал значения строк
-"Cookie" и "X-Forwarded-For" из заголовка запроса;
-ошибка появилась в 1.3.14.
-</para>
-<para lang="en">
-the $r->header_in() embedded perl method did not return value of the
-"Cookie" and "X-Forwarded-For" request header lines;
-the bug had appeared in 1.3.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_spdy_module.<br/>
-Спасибо Jim Radford.
-</para>
-<para lang="en">
-in the ngx_http_spdy_module.<br/>
-Thanks to Jim Radford.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Linux при использовании x32 ABI.<br/>
-Спасибо Сергею Иванцову.
-</para>
-<para lang="en">
-nginx could not be built on Linux with x32 ABI.<br/>
-Thanks to Serguei Ivantsov.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.1" date="2013-06-04">
-
-<change type="feature">
-<para lang="ru">
-директивы ssi_last_modified, sub_filter_last_modified и
-xslt_last_modified.<br/>
-Спасибо Алексею Колпакову.
-</para>
-<para lang="en">
-the "ssi_last_modified", "sub_filter_last_modified", and
-"xslt_last_modified" directives.<br/>
-Thanks to Alexey Kolpakov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр http_403 в директивах proxy_next_upstream, fastcgi_next_upstream,
-scgi_next_upstream и uwsgi_next_upstream.
-</para>
-<para lang="en">
-the "http_403" parameter of the "proxy_next_upstream", "fastcgi_next_upstream",
-"scgi_next_upstream", and "uwsgi_next_upstream" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы allow и deny теперь поддерживают unix domain сокеты.
-</para>
-<para lang="en">
-the "allow" and "deny" directives now support unix domain sockets.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с модулем ngx_mail_ssl_module,
-но без модуля ngx_http_ssl_module;
-ошибка появилась в 1.3.14.
-</para>
-<para lang="en">
-nginx could not be built with the ngx_mail_ssl_module,
-but without ngx_http_ssl_module;
-the bug had appeared in 1.3.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_set_body.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-in the "proxy_set_body" directive.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве lingering_time.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-in the "lingering_time" directive.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр fail_timeout директивы server
-в блоке upstream мог не работать,
-если использовался параметр max_fails;
-ошибка появилась в 1.3.0.
-</para>
-<para lang="en">
-the "fail_timeout" parameter of the "server" directive
-in the "upstream" context might not work
-if "max_fails" parameter was used;
-the bug had appeared in 1.3.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива ssl_stapling.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "ssl_stapling" directive was used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в почтовом прокси-сервере.<br/>
-Спасибо Filipe Da Silva.
-</para>
-<para lang="en">
-in the mail proxy server.<br/>
-Thanks to Filipe Da Silva.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows мог перестать принимать соединения,
-если использовалось несколько рабочих процессов.
-</para>
-<para lang="en">
-nginx/Windows might stop accepting connections
-if several worker processes were used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.5.0" date="2013-05-07">
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного запроса
-мог перезаписываться стек рабочего процесса,
-что могло приводить к выполнению произвольного кода (CVE-2013-2028);
-ошибка появилась в 1.3.9.<br/>
-Спасибо Greg MacManus, iSIGHT Partners Labs.
-</para>
-<para lang="en">
-a stack-based buffer overflow might occur in a worker process
-while handling a specially crafted request,
-potentially resulting in arbitrary code execution (CVE-2013-2028);
-the bug had appeared in 1.3.9.<br/>
-Thanks to Greg MacManus, iSIGHT Partners Labs.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.4.0" date="2013-04-24">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с модулем ngx_http_perl_module,
-если использовался параметр --with-openssl;
-ошибка появилась в 1.3.16.
-</para>
-<para lang="en">
-nginx could not be built with the ngx_http_perl_module
-if the --with-openssl option was used;
-the bug had appeared in 1.3.16.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в работе с телом запроса из модуля ngx_http_perl_module;
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-in a request body handling in the ngx_http_perl_module;
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.16" date="2013-04-16">
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовались подзапросы;
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if subrequests were used;
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива tcp_nodelay вызывала ошибку
-при проксировании WebSocket-соединений в unix domain сокет.
-</para>
-<para lang="en">
-the "tcp_nodelay" directive caused an error
-if a WebSocket connection was proxied into a unix domain socket.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $upstream_response_length возвращала значение "0",
-если не использовалась буферизация.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the $upstream_response_length variable has an incorrect value "0"
-if buffering was not used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в методах обработки соединений eventport и /dev/poll.
-</para>
-<para lang="en">
-in the eventport and /dev/poll methods.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.15" date="2013-03-26">
-
-<change type="change">
-<para lang="ru">
-открытие и закрытие соединения без отправки в нём каких-либо данных
-больше не записывается в access_log с кодом ошибки 400.
-</para>
-<para lang="en">
-opening and closing a connection without sending any data in it
-is no longer logged to access_log with error code 400.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_spdy_module.<br/>
-Спасибо Automattic за спонсирование разработки.
-</para>
-<para lang="en">
-the ngx_http_spdy_module.<br/>
-Thanks to Automattic for sponsoring this work.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы limit_req_status и limit_conn_status.<br/>
-Спасибо Nick Marden.
-</para>
-<para lang="en">
-the "limit_req_status" and "limit_conn_status" directives.<br/>
-Thanks to Nick Marden.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива image_filter_interlace.<br/>
-Спасибо Ивану Боброву.
-</para>
-<para lang="en">
-the "image_filter_interlace" directive.<br/>
-Thanks to Ian Babrou.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $connections_waiting в модуле ngx_http_stub_status_module.
-</para>
-<para lang="en">
-$connections_waiting variable in the ngx_http_stub_status_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь почтовый прокси-сервер поддерживает IPv6-бэкенды.
-</para>
-<para lang="en">
-the mail proxy module now supports IPv6 backends.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при повторной отправке запроса на бэкенд
-тело запроса могло передаваться неправильно;
-ошибка появилась в 1.3.9.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-request body might be transmitted incorrectly
-when retrying a request to the next upstream server;
-the bug had appeared in 1.3.9.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве client_body_in_file_only;
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-in the "client_body_in_file_only" directive;
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы могли зависать,
-если использовались подзапросы
-и при обработке подзапроса происходила DNS-ошибка.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-responses might hang
-if subrequests were used
-and a DNS error happened during subrequest processing.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в процедуре учёта использования бэкендов.
-</para>
-<para lang="en">
-in backend usage accounting.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.14" date="2013-03-05">
-
-<change type="feature">
-<para lang="ru">
-переменные $connections_active, $connections_reading и $connections_writing
-в модуле ngx_http_stub_status_module.
-</para>
-<para lang="en">
-$connections_active, $connections_reading, and $connections_writing variables
-in the ngx_http_stub_status_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка WebSocket-соединений
-в модулях ngx_http_uwsgi_module и ngx_http_scgi_module.
-</para>
-<para lang="en">
-support of WebSocket connections
-in the ngx_http_uwsgi_module and ngx_http_scgi_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке виртуальных серверов при использовании SNI.
-</para>
-<para lang="en">
-in virtual servers handling with SNI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "ssl_session_cache shared"
-новые сессии могли не сохраняться,
-если заканчивалось место в разделяемой памяти.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-new sessions were not always stored
-if the "ssl_session_cache shared" directive was used
-and there was no free space in shared memory.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-несколько заголовков X-Forwarded-For обрабатывались неправильно.<br/>
-Спасибо Neal Poole за спонсирование разработки.
-</para>
-<para lang="en">
-multiple X-Forwarded-For headers were handled incorrectly.<br/>
-Thanks to Neal Poole for sponsoring this work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.<br/>
-Спасибо Gernot Vormayr.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.<br/>
-Thanks to Gernot Vormayr.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.13" date="2013-02-19">
-
-<change type="change">
-<para lang="ru">
-теперь для сборки по умолчанию используется компилятор с именем "cc".
-</para>
-<para lang="en">
-a compiler with name "cc" is now used by default.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка проксирования WebSocket-соединений.<br/>
-Спасибо Apcera и CloudBees за спонсирование разработки.
-</para>
-<para lang="en">
-support for proxying of WebSocket connections.<br/>
-Thanks to Apcera and CloudBees for sponsoring this work.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива auth_basic_user_file поддерживает шифрование паролей
-методом "{SHA}".<br/>
-Спасибо Louis Opter.
-</para>
-<para lang="en">
-the "auth_basic_user_file" directive supports "{SHA}"
-password encryption method.<br/>
-Thanks to Louis Opter.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.12" date="2013-02-05">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_bind, fastcgi_bind, memcached_bind, scgi_bind и uwsgi_bind
-поддерживают переменные.
-</para>
-<para lang="en">
-variables support in the "proxy_bind", "fastcgi_bind", "memcached_bind",
-"scgi_bind", and "uwsgi_bind" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $pipe, $request_length, $time_iso8601 и $time_local
-теперь можно использовать не только в директиве log_format.<br/>
-Спасибо Kiril Kalchev.
-</para>
-<para lang="en">
-the $pipe, $request_length, $time_iso8601, and $time_local variables
-can now be used not only in the "log_format" directive.
-Thanks to Kiril Kalchev.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка IPv6 в модуле ngx_http_geoip_module.<br/>
-Спасибо Gregor Kališnik.
-</para>
-<para lang="en">
-IPv6 support in the ngx_http_geoip_module.<br/>
-Thanks to Gregor Kališnik.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_method работала неверно, если была указана на уровне http.
-</para>
-<para lang="en">
-in the "proxy_method" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался resolver и метод poll.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if resolver was used with the poll method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог нагружать процессор во время SSL handshake с бэкендом
-при использовании методов обработки соединений select, poll и /dev/poll.
-</para>
-<para lang="en">
-nginx might hog CPU during SSL handshake with a backend
-if the select, poll, or /dev/poll methods were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка "[crit] SSL_write() failed (SSL:)".
-</para>
-<para lang="en">
-the "[crit] SSL_write() failed (SSL:)" error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве client_body_in_file_only;
-ошибка появилась в 1.3.9.
-</para>
-<para lang="en">
-in the "client_body_in_file_only" directive;
-the bug had appeared in 1.3.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве fastcgi_keep_conn.
-</para>
-<para lang="en">
-in the "fastcgi_keep_conn" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.11" date="2013-01-10">
-
-<change type="bugfix">
-<para lang="ru">
-при записи в лог мог происходить segmentation fault;
-ошибка появилась в 1.3.10.
-</para>
-<para lang="en">
-a segmentation fault might occur if logging was used;
-the bug had appeared in 1.3.10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_pass не работала с IP-адресами
-без явного указания порта;
-ошибка появилась в 1.3.10.
-</para>
-<para lang="en">
-the "proxy_pass" directive did not work with IP addresses
-without port specified;
-the bug had appeared in 1.3.10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации происходил segmentation fault,
-если директива keepalive была указана несколько раз
-в одном блоке upstream.
-</para>
-<para lang="en">
-a segmentation fault occurred on start or during reconfiguration
-if the "keepalive" directive was specified more than once
-in a single upstream block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр default директивы geo не определял значение по умолчанию
-для IPv6-адресов.
-</para>
-<para lang="en">
-parameter "default" of the "geo" directive did not set default value
-for IPv6 addresses.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.10" date="2012-12-25">
-
-<change type="change">
-<para lang="ru">
-для указанных в конфигурационном файле доменных имён теперь
-используются не только IPv4, но и IPv6 адреса.
-</para>
-<para lang="en">
-domain names specified in configuration file
-are now resolved to IPv6 addresses as well as IPv4 ones.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при использовании директивы include с маской на Unix-системах
-включаемые файлы сортируются в алфавитном порядке.
-</para>
-<para lang="en">
-now if the "include" directive with mask is used on Unix systems,
-included files are sorted in alphabetical order.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива add_header добавляет строки в ответы с кодом 201.
-</para>
-<para lang="en">
-the "add_header" directive adds headers to 201 responses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива geo теперь поддерживает IPv6 адреса в формате CIDR.
-</para>
-<para lang="en">
-the "geo" directive now supports IPv6 addresses in CIDR notation.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры flush и gzip в директиве access_log.
-</para>
-<para lang="en">
-the "flush" and "gzip" parameters of the "access_log" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива auth_basic поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "auth_basic" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx в некоторых случаях не собирался с модулем ngx_http_perl_module.
-</para>
-<para lang="en">
-nginx could not be built with the ngx_http_perl_module in some cases.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_xslt_module.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_xslt_module was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог не собираться на MacOSX.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-nginx could not be built on MacOSX in some cases.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы limit_rate с большими значениями скорости
-на 32-битных системах ответ мог возвращаться не целиком.<br/>
-Спасибо Алексею Антропову.
-</para>
-<para lang="en">
-the "limit_rate" directive with high rates
-might result in truncated responses on 32-bit platforms.<br/>
-Thanks to Alexey Antropov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива if.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "if" directive was used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ "100 Continue" выдавался
-вместе с ответом "413 Request Entity Too Large".
-</para>
-<para lang="en">
-a "100 Continue" response was issued
-with "413 Request Entity Too Large" responses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы image_filter, image_filter_jpeg_quality и image_filter_sharpen
-могли наследоваться некорректно.<br/>
-Спасибо Ивану Боброву.
-</para>
-<para lang="en">
-the "image_filter", "image_filter_jpeg_quality"
-and "image_filter_sharpen" directives
-might be inherited incorrectly.<br/>
-Thanks to Ian Babrou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы auth_basic под Linux
-могли возникать ошибки "crypt_r() failed".
-</para>
-<para lang="en">
-"crypt_r() failed" errors might appear
-if the "auth_basic" directive was used on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке backup-серверов.<br/>
-Спасибо Thomas Chen.
-</para>
-<para lang="en">
-in backup servers handling.<br/>
-Thanks to Thomas Chen.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании HEAD-запросов мог возвращаться некорректный ответ,
-если использовалась директива gzip.
-</para>
-<para lang="en">
-proxied HEAD requests might return incorrect response
-if the "gzip" directive was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.9" date="2012-11-27">
-
-<change type="feature">
-<para lang="ru">
-поддержка chunked transfer encoding при получении тела запроса.
-</para>
-<para lang="en">
-support for chunked transfer encoding while reading client request body.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $request_time и $msec
-теперь можно использовать не только в директиве log_format.
-</para>
-<para lang="en">
-the $request_time and $msec variables
-can now be used not only in the "log_format" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-cache manager и cache loader могли не запускаться,
-если использовалось более 512 listen-сокетов.
-</para>
-<para lang="en">
-cache manager and cache loader processes might not be able to start
-if more than 512 listen sockets were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_dav_module.
-</para>
-<para lang="en">
-in the ngx_http_dav_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.8" date="2012-10-30">
-
-<change type="feature">
-<para lang="ru">
-параметр optional_no_ca директивы ssl_verify_client.<br/>
-Спасибо Михаилу Казанцеву и Eric O'Connor.
-</para>
-<para lang="en">
-the "optional_no_ca" parameter of the "ssl_verify_client" directive.<br/>
-Thanks to Mike Kazantsev and Eric O'Connor.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $bytes_sent, $connection и $connection_requests
-теперь можно использовать не только в директиве log_format.<br/>
-Спасибо Benjamin Grössing.
-</para>
-<para lang="en">
-the $bytes_sent, $connection, and $connection_requests variables
-can now be used not only in the "log_format" directive.<br/>
-Thanks to Benjamin Grössing.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр auto директивы worker_processes.
-</para>
-<para lang="en">
-the "auto" parameter of the "worker_processes" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сообщения "cache file ... has md5 collision".
-</para>
-<para lang="en">
-"cache file ... has md5 collision" alert.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_gunzip_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_gunzip_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве ssl_stapling.
-</para>
-<para lang="en">
-in the "ssl_stapling" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.7" date="2012-10-02">
-
-<change type="feature">
-<para lang="ru">
-поддержка OCSP stapling.<br/>
-Спасибо Comodo, DigiCert и GlobalSign за спонсирование разработки.
-</para>
-<para lang="en">
-OCSP stapling support.<br/>
-Thanks to Comodo, DigiCert and GlobalSign for sponsoring this work.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_trusted_certificate.
-</para>
-<para lang="en">
-the "ssl_trusted_certificate" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь resolver случайным образом меняет порядок
-возвращаемых закэшированных адресов.<br/>
-Спасибо Антону Жулину.
-</para>
-<para lang="en">
-resolver now randomly rotates addresses
-returned from cache.<br/>
-Thanks to Anton Jouline.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с OpenSSL 0.9.7.
-</para>
-<para lang="en">
-OpenSSL 0.9.7 compatibility.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.6" date="2012-09-12">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_gunzip_filter_module.
-</para>
-<para lang="en">
-the ngx_http_gunzip_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива memcached_gzip_flag.
-</para>
-<para lang="en">
-the "memcached_gzip_flag" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр always директивы gzip_static.
-</para>
-<para lang="en">
-the "always" parameter of the "gzip_static" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве "limit_req";
-ошибка появилась в 1.1.14.<br/>
-Спасибо Charles Chen.
-</para>
-<para lang="en">
-in the "limit_req" directive;
-the bug had appeared in 1.1.14.<br/>
-Thanks to Charles Chen.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался gcc 4.7 с оптимизацией -O2
-если использовался параметр --with-ipv6.
-</para>
-<para lang="en">
-nginx could not be built by gcc 4.7 with -O2 optimization
-if the --with-ipv6 option was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.5" date="2012-08-21">
-
-<change type="change">
-<para lang="ru">
-модуль ngx_http_mp4_module больше не отфильтровывает дорожки
-в форматах, отличных от H.264 и AAC.
-</para>
-<para lang="en">
-the ngx_http_mp4_module module no longer skips
-tracks in formats other than H.264 and AAC.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если в директиве map в качестве значений использовались переменные.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "map" directive was used with variables as values.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault
-при использовании директивы geo с параметром ranges,
-но без параметра default; ошибка появилась в 0.8.43.<br/>
-Спасибо Zhen Chen и Weibin Yao.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "geo" directive was used with the "ranges" parameter
-but without the "default" parameter; the bug had appeared in 0.8.43.<br/>
-Thanks to Zhen Chen and Weibin Yao.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке параметра командной строки -p.
-</para>
-<para lang="en">
-in the -p command-line parameter handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в почтовом прокси-сервере.
-</para>
-<para lang="en">
-in the mail proxy server.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-незначительных потенциальных ошибок.<br/>
-Спасибо Coverity.
-</para>
-<para lang="en">
-of minor potential bugs.<br/>
-Thanks to Coverity.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не собирался с Visual Studio 2005 Express.<br/>
-Спасибо HAYASHI Kentaro.
-</para>
-<para lang="en">
-nginx/Windows could not be built with Visual Studio 2005 Express.<br/>
-Thanks to HAYASHI Kentaro.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.4" date="2012-07-31">
-
-<change type="change">
-<para lang="ru">
-теперь на слушающих IPv6-сокетах параметр ipv6only
-включён по умолчанию.
-</para>
-<para lang="en">
-the "ipv6only" parameter is now turned on by default for
-listening IPv6 sockets.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка компилятора Clang.
-</para>
-<para lang="en">
-the Clang compiler support.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-могли создаваться лишние слушающие сокеты.<br/>
-Спасибо Роману Одайскому.
-</para>
-<para lang="en">
-extra listening sockets might be created.<br/>
-Thanks to Roman Odaisky.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows мог нагружать процессор, если при запуске рабочего процесса
-происходила ошибка.<br/>
-Спасибо Ricardo Villalobos Guevara.
-</para>
-<para lang="en">
-nginx/Windows might hog CPU if a worker process failed to start.<br/>
-Thanks to Ricardo Villalobos Guevara.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_pass_header, fastcgi_pass_header, scgi_pass_header,
-uwsgi_pass_header, proxy_hide_header, fastcgi_hide_header,
-scgi_hide_header и uwsgi_hide_header
-могли наследоваться некорректно.
-</para>
-<para lang="en">
-the "proxy_pass_header", "fastcgi_pass_header", "scgi_pass_header",
-"uwsgi_pass_header", "proxy_hide_header", "fastcgi_hide_header",
-"scgi_hide_header", and "uwsgi_hide_header" directives
-might be inherited incorrectly.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.3" date="2012-07-10">
-
-<change type="feature">
-<para lang="ru">
-поддержка entity tags и директива etag.
-</para>
-<para lang="en">
-entity tags support and the "etag" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы map с параметром hostnames
-не игнорировалась конечная точка в исходном значении.
-</para>
-<para lang="en">
-trailing dot in a source value was not ignored
-if the "map" directive was used with the "hostnames" parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-для обработки запроса мог использоваться неверный location,
-если переход в именованный location происходил
-после изменения URI с помощью директивы rewrite.
-</para>
-<para lang="en">
-incorrect location might be used to process a request
-if a URI was changed via a "rewrite" directive
-before an internal redirect to a named location.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.2" date="2012-06-26">
-
-<change type="change">
-<para lang="ru">
-параметр single директивы keepalive теперь игнорируется.
-</para>
-<para lang="en">
-the "single" parameter of the "keepalive" directive is now ignored.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-сжатие SSL теперь отключено
-в том числе при использовании OpenSSL старее 1.0.0.
-</para>
-<para lang="en">
-SSL compression is now disabled when using all versions of OpenSSL,
-including ones prior to 1.0.0.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву "ip_hash" теперь можно использовать для балансировки IPv6 клиентов.
-</para>
-<para lang="en">
-it is now possible to use the "ip_hash" directive to balance IPv6 clients.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменную $status теперь можно использовать не только в директиве log_format.
-</para>
-<para lang="en">
-the $status variable can now be used not only in the "log_format" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при завершении рабочего процесса мог произойти segmentation fault,
-если использовалась директива resolver.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process on shutdown
-if the "resolver" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался модуль ngx_http_mp4_module.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the ngx_http_mp4_module was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовались конфликтующие имена серверов с масками.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if conflicting wildcard server names were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на платформе ARM nginx мог аварийно завершаться по сигналу SIGBUS.
-</para>
-<para lang="en">
-nginx might be terminated abnormally on a SIGBUS signal on ARM platform.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-во время переконфигурации на HP-UX в лог
-записывался alert "sendmsg() failed (9: Bad file number)".
-</para>
-<para lang="en">
-an alert "sendmsg() failed (9: Bad file number)" on HP-UX
-while reconfiguration.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.1" date="2012-06-05">
-
-<change type="security">
-<para lang="ru">
-теперь nginx/Windows игнорирует точку в конце компонента URI
-и не разрешает URI, содержащие последовательность ":$".<br/>
-Спасибо Владимиру Кочеткову, Positive Research Center.
-</para>
-<para lang="en">
-now nginx/Windows ignores trailing dot in URI path component, and
-does not allow URIs with ":$" in it.<br/>
-Thanks to Vladimir Kochetkov, Positive Research Center.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_pass, fastcgi_pass, scgi_pass, uwsgi_pass и
-директива server в блоке upstream
-теперь поддерживают IPv6-адреса.
-</para>
-<para lang="en">
-the "proxy_pass", "fastcgi_pass", "scgi_pass", "uwsgi_pass" directives, and
-the "server" directive inside the "upstream" block,
-now support IPv6 addresses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в директиве resolver теперь можно указывать порт и
-задавать IPv6-адреса DNS-серверов.
-</para>
-<para lang="en">
-the "resolver" directive now supports IPv6 addresses and
-an optional port specification.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива least_conn в блоке upstream.
-</para>
-<para lang="en">
-the "least_conn" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при использовании директивы ip_hash
-теперь можно задавать веса серверов.
-</para>
-<para lang="en">
-it is now possible to specify a weight for servers
-while using the "ip_hash" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива image_filter;
-ошибка появилась в 1.3.0.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "image_filter" directive was used;
-the bug had appeared in 1.3.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с модулем ngx_cpp_test_module;
-ошибка появилась в 1.1.12.
-</para>
-<para lang="en">
-nginx could not be built with ngx_cpp_test_module;
-the bug had appeared in 1.1.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-доступ к переменным из SSI и встроенного перла мог не работать после
-переконфигурации.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-access to variables from SSI and embedded perl module might not work after
-reconfiguration.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_xslt_filter_module.<br/>
-Спасибо Kuramoto Eiji.
-</para>
-<para lang="en">
-in the ngx_http_xslt_filter_module.<br/>
-Thanks to Kuramoto Eiji.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при использовании переменной $geoip_org.<br/>
-Спасибо Денису Латыпову.
-</para>
-<para lang="en">
-memory leak if $geoip_org variable was used.<br/>
-Thanks to Denis F. Latypoff.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах proxy_cookie_domain и proxy_cookie_path.
-</para>
-<para lang="en">
-in the "proxy_cookie_domain" and "proxy_cookie_path" directives.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.3.0" date="2012-05-15">
-
-<change type="feature">
-<para lang="ru">
-директива debug_connection теперь поддерживает IPv6-адреса
-и параметр "unix:".
-</para>
-<para lang="en">
-the "debug_connection" directive now supports IPv6 addresses
-and the "unix:" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива set_real_ip_from и параметр proxy
-директивы geo теперь поддерживают IPv6-адреса.
-</para>
-<para lang="en">
-the "set_real_ip_from" directive and the "proxy" parameter
-of the "geo" directive now support IPv6 addresses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы real_ip_recursive, geoip_proxy и geoip_proxy_recursive.
-</para>
-<para lang="en">
-the "real_ip_recursive", "geoip_proxy", and "geoip_proxy_recursive" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр proxy_recursive директивы geo.
-</para>
-<para lang="en">
-the "proxy_recursive" parameter of the "geo" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива resolver.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "resolver" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовались директивы fastcgi_pass, scgi_pass или uwsgi_pass
-и бэкенд возвращал некорректный ответ.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "fastcgi_pass", "scgi_pass", or "uwsgi_pass" directives were used
-and backend returned incorrect response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива rewrite и в новых аргументах запроса в строке
-замены использовались переменные.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "rewrite" directive was used and new request arguments
-in a replacement used variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог нагружать процессор,
-если было достигнуто ограничение на количество открытых файлов.
-</para>
-<para lang="en">
-nginx might hog CPU
-if the open file resource limit was reached.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы proxy_next_upstream с параметром http_404
-nginx мог бесконечно перебирать бэкенды, если в блоке upstream был
-хотя бы один сервер с флагом backup.
-</para>
-<para lang="en">
-nginx might loop infinitely over backends
-if the "proxy_next_upstream" directive with the "http_404" parameter was used
-and there were backup servers specified in an upstream block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ip_hash
-установка параметра down директивы server
-могла приводить к ненужному перераспределению клиентов между бэкендами.
-</para>
-<para lang="en">
-adding the "down" parameter of the "server" directive
-might cause unneeded client redistribution among backend servers
-if the "ip_hash" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-socket leak.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_fastcgi_module.
-</para>
-<para lang="en">
-in the ngx_http_fastcgi_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.2.0" date="2012-04-23">
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива try_files;
-ошибка появилась в 1.1.19.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "try_files" directive was used;
-the bug had appeared in 1.1.19.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ мог быть передан не полностью,
-если использовалось больше IOV_MAX буферов.
-</para>
-<para lang="en">
-response might be truncated
-if there were more than IOV_MAX buffers used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в работе параметра crop директивы image_filter.<br/>
-Спасибо Maxim Bublis.
-</para>
-<para lang="en">
-in the "crop" parameter of the "image_filter" directive.<br/>
-Thanks to Maxim Bublis.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.19" date="2012-04-12">
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного mp4 файла модулем ngx_http_mp4_module
-могли перезаписываться области памяти рабочего процесса, что могло
-приводить к выполнению произвольного кода (CVE-2012-2089).<br/>
-Спасибо Matthew Daley.
-</para>
-<para lang="en">
-specially crafted mp4 file might allow to overwrite
-memory locations in a worker process
-if the ngx_http_mp4_module was used,
-potentially resulting in arbitrary code execution (CVE-2012-2089).<br/>
-Thanks to Matthew Daley.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows мог завершаться аварийно.<br/>
-Спасибо Vincent Lee.
-</para>
-<para lang="en">
-nginx/Windows might be terminated abnormally.<br/>
-Thanks to Vincent Lee.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx нагружал процессор, если все серверы в upstream'е были помечены
-флагом backup.
-</para>
-<para lang="en">
-nginx hogged CPU if all servers in an upstream were marked as "backup".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы allow и deny могли наследоваться некорректно,
-если в них использовались IPv6 адреса.
-</para>
-<para lang="en">
-the "allow" and "deny" directives might be inherited incorrectly
-if they were used with IPv6 addresses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы modern_browser и ancient_browser
-могли наследоваться некорректно.
-</para>
-<para lang="en">
-the "modern_browser" and "ancient_browser" directives
-might be inherited incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-таймауты могли работать некорректно на Solaris/SPARC.
-</para>
-<para lang="en">
-timeouts might be handled incorrectly on Solaris/SPARC.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.18" date="2012-03-28">
-
-<change type="change">
-<para lang="ru">
-теперь keepalive соединения не запрещены для Safari по умолчанию.
-</para>
-<para lang="en">
-keepalive connections are no longer disabled for Safari by default.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $connection_requests.
-</para>
-<para lang="en">
-the $connection_requests variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd и
-$tcpinfo_rcv_space.
-</para>
-<para lang="en">
-$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd and
-$tcpinfo_rcv_space variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_cpu_affinity теперь работает на FreeBSD.
-</para>
-<para lang="en">
-the "worker_cpu_affinity" directive now works on FreeBSD.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы xslt_param и xslt_string_param.<br/>
-Спасибо Samuel Behan.
-</para>
-<para lang="en">
-the "xslt_param" and "xslt_string_param" directives.<br/>
-Thanks to Samuel Behan.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в configure.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in configure tests.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_xslt_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_xslt_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Debian GNU/Hurd.
-</para>
-<para lang="en">
-nginx could not be built on Debian GNU/Hurd.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.17" date="2012-03-15">
-
-<change type="security">
-<para lang="ru">
-содержимое ранее освобождённой памяти могло быть отправлено клиенту,
-если бэкенд возвращал специально созданный ответ.<br/>
-Спасибо Matthew Daley.
-</para>
-<para lang="en">
-content of previously freed memory might be sent to a client
-if backend returned specially crafted response.<br/>
-Thanks to Matthew Daley.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании встроенного перла из SSI.<br/>
-Спасибо Matthew Daley.
-</para>
-<para lang="en">
-in the embedded perl module if used from SSI.<br/>
-Thanks to Matthew Daley.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_uwsgi_module.
-</para>
-<para lang="en">
-in the ngx_http_uwsgi_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.16" date="2012-02-29">
-
-<change type="change">
-<para lang="ru">
-ограничение на количество одновременных подзапросов поднято до 200.
-</para>
-<para lang="en">
-the simultaneous subrequest limit has been raised to 200.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр from в директиве disable_symlinks.
-</para>
-<para lang="en">
-the "from" parameter of the "disable_symlinks" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы return и error_page теперь могут использоваться для возврата
-перенаправлений с кодом 307.
-</para>
-<para lang="en">
-the "return" and "error_page" directives can now be used to return 307
-redirections.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива resolver
-и на глобальном уровне не была задана директива error_log.<br/>
-Спасибо Роману Арутюняну.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "resolver" directive was used
-and there was no "error_log" directive specified at global level.<br/>
-Thanks to Roman Arutyunyan.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовались директивы "proxy_http_version 1.1" или
-"fastcgi_keep_conn on".
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if the "proxy_http_version 1.1" or "fastcgi_keep_conn on" directives
-were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечек памяти.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-memory leaks.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве disable_symlinks.
-</para>
-<para lang="en">
-in the "disable_symlinks" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании ZFS размер кэша на диске мог считаться некорректно;
-ошибка появилась в 1.0.1.
-</para>
-<para lang="en">
-on ZFS filesystem disk cache size might be calculated incorrectly;
-the bug had appeared in 1.0.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался компилятором icc 12.1.
-</para>
-<para lang="en">
-nginx could not be built by the icc 12.1 compiler.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался gcc на Solaris;
-ошибка появилась в 1.1.15.
-</para>
-<para lang="en">
-nginx could not be built by gcc on Solaris;
-the bug had appeared in 1.1.15.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.15" date="2012-02-15">
-
-<change type="feature">
-<para lang="ru">
-директива disable_symlinks.
-</para>
-<para lang="en">
-the "disable_symlinks" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cookie_domain и proxy_cookie_path.
-</para>
-<para lang="en">
-the "proxy_cookie_domain" and "proxy_cookie_path" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог некорректно сообщать об ошибке "upstream prematurely closed
-connection" вместо "upstream sent too big header".<br/>
-Спасибо Feibo Li.
-</para>
-<para lang="en">
-nginx might log incorrect error "upstream prematurely closed connection"
-instead of correct "upstream sent too big header" one.<br/>
-Thanks to Feibo Li.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с модулем ngx_http_perl_module,
-если использовался параметр --with-openssl.
-</para>
-<para lang="en">
-nginx could not be built with the ngx_http_perl_module
-if the --with-openssl option was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-количество внутренних перенаправлений в именованные location'ы
-не ограничивалось.
-</para>
-<para lang="en">
-the number of internal redirects to named locations was not limited.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-вызов $r->flush() несколько раз подряд мог приводить к ошибкам
-в модуле ngx_http_gzip_filter_module.
-</para>
-<para lang="en">
-calling $r->flush() multiple times might cause errors
-in the ngx_http_gzip_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы proxy_store с SSI-подзапросами
-временные файлы могли не удаляться.
-</para>
-<para lang="en">
-temporary files might be not removed
-if the "proxy_store" directive was used with SSI includes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в некоторых случаях некэшируемые переменные (такие, как $args)
-возвращали старое пустое закэшированное значение.
-</para>
-<para lang="en">
-in some cases non-cacheable variables (such as the $args variable)
-returned old empty cached value.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если одновременно создавалось слишком много SSI-подзапросов;
-ошибка появилась в 0.7.25.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if too many SSI subrequests were issued simultaneously;
-the bug had appeared in 0.7.25.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.14" date="2012-01-30">
-
-<change type="feature">
-<para lang="ru">
-теперь можно указать несколько ограничений limit_req одновременно.
-</para>
-<para lang="en">
-multiple "limit_req" limits may be used simultaneously.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при соединении с бэкендом.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in error handling while connecting to a backend.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при использовании AIO на FreeBSD.
-</para>
-<para lang="en">
-in AIO error handling on FreeBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в инициализации библиотеки OpenSSL.
-</para>
-<para lang="en">
-in the OpenSSL library initialization.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_redirect могли наследоваться некорректно.
-</para>
-<para lang="en">
-the "proxy_redirect" directives might be inherited incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при переконфигурации, если использовалась директива pcre_jit.
-</para>
-<para lang="en">
-memory leak during reconfiguration if the "pcre_jit" directive was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.13" date="2012-01-16">
-
-<change type="feature">
-<para lang="ru">
-параметры TLSv1.1 и TLSv1.2 в директиве ssl_protocols.
-</para>
-<para lang="en">
-the "TLSv1.1" and "TLSv1.2" parameters of the "ssl_protocols" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметры директивы limit_req наследовались некорректно;
-ошибка появилась в 1.1.12.
-</para>
-<para lang="en">
-the "limit_req" directive parameters were not inherited correctly;
-the bug had appeared in 1.1.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_redirect некорректно обрабатывала заголовок Refresh
-при использовании регулярных выражений.
-</para>
-<para lang="en">
-the "proxy_redirect" directive incorrectly processed "Refresh" header
-if regular expression were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_cache_use_stale с параметром error не возвращала ответ из
-кэша, если все бэкенды были признаны неработающими.
-</para>
-<para lang="en">
-the "proxy_cache_use_stale" directive with "error" parameter did not return
-answer from cache if there were no live upstreams.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива worker_cpu_affinity могла не работать.
-</para>
-<para lang="en">
-the "worker_cpu_affinity" directive might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris;
-ошибка появилась в 1.1.12.
-</para>
-<para lang="en">
-nginx could not be built on Solaris;
-the bug had appeared in 1.1.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.12" date="2011-12-26">
-
-<change type="change">
-<para lang="ru">
-после перенаправления запроса с помощью директивы error_page
-директива proxy_pass без URI теперь использует изменённый URI.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-a "proxy_pass" directive without URI part now uses changed URI
-after redirection with the "error_page" directive.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy/fastcgi/scgi/uwsgi_cache_lock,
-proxy/fastcgi/scgi/uwsgi_cache_lock_timeout.
-</para>
-<para lang="en">
-the "proxy/fastcgi/scgi/uwsgi_cache_lock",
-"proxy/fastcgi/scgi/uwsgi_cache_lock_timeout" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива pcre_jit.
-</para>
-<para lang="en">
-the "pcre_jit" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-SSI команда if поддерживает выделения в регулярных выражениях.
-</para>
-<para lang="en">
-the "if" SSI command supports captures in regular expressions.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSI команда if не работала внутри команды block.
-</para>
-<para lang="en">
-the "if" SSI command did not work inside the "block" command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы limit_conn_log_level и limit_req_log_level могли не работать.
-</para>
-<para lang="en">
-the "limit_conn_log_level" and "limit_req_log_level" directives might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива limit_rate не позволяла передавать на полной скорости,
-даже если был указан очень большой лимит.
-</para>
-<para lang="en">
-the "limit_rate" directive did not allow to use full throughput,
-even if limit value was very high.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива sendfile_max_chunk не работала,
-если использовалась директива limit_rate.
-</para>
-<para lang="en">
-the "sendfile_max_chunk" directive did not work,
-if the "limit_rate" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве proxy_pass использовались переменные и не был указан URI,
-всегда использовался URI исходного запроса.
-</para>
-<para lang="en">
-a "proxy_pass" directive without URI part always used original request URI
-if variables were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после перенаправления запроса с помощью директивы try_files
-директива proxy_pass без URI могла использовать URI исходного запроса.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-a "proxy_pass" directive without URI part might use original request
-after redirection with the "try_files" directive.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_scgi_module.
-</para>
-<para lang="en">
-in the ngx_http_scgi_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris;
-ошибка появилась в 1.1.9.
-</para>
-<para lang="en">
-nginx could not be built on Solaris;
-the bug had appeared in 1.1.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.11" date="2011-12-12">
-
-<change type="feature">
-<para lang="ru">
-параметр so_keepalive в директиве listen.<br/>
-Спасибо Всеволоду Стахову.
-</para>
-<para lang="en">
-the "so_keepalive" parameter of the "listen" directive.<br/>
-Thanks to Vsevolod Stakhov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр if_not_empty в директивах fastcgi/scgi/uwsgi_param.
-</para>
-<para lang="en">
-the "if_not_empty" parameter of the "fastcgi/scgi/uwsgi_param" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $https.
-</para>
-<para lang="en">
-the $https variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_redirect поддерживает переменные в первом параметре.
-</para>
-<para lang="en">
-the "proxy_redirect" directive supports variables in the first parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_redirect поддерживает регулярные выражения.
-</para>
-<para lang="en">
-the "proxy_redirect" directive supports regular expressions.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $sent_http_cache_control могла содержать неверное значение при
-использовании директивы expires.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-the $sent_http_cache_control variable might contain a wrong value if the
-"expires" directive was used.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива read_ahead могла не работать при использовании совместно с
-try_files и open_file_cache.
-</para>
-<para lang="en">
-the "read_ahead" directive might not work combined with "try_files"
-and "open_file_cache".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в параметре inactive директивы proxy_cache_path
-было указано малое время,
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if small time was used in the "inactive" parameter of
-the "proxy_cache_path" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы из кэша могли зависать.
-</para>
-<para lang="en">
-responses from cache might hang.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.10" date="2011-11-30">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании AIO на Linux в рабочем процессе происходил segmentation fault;
-ошибка появилась в 1.1.9.
-</para>
-<para lang="en">
-a segmentation fault occurred in a worker process if AIO was used on Linux;
-the bug had appeared in 1.1.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.9" date="2011-11-28">
-
-<change type="change">
-<para lang="ru">
-теперь двойные кавычки экранируется при выводе SSI-командой echo.<br/>
-Спасибо Зауру Абасмирзоеву.
-</para>
-<para lang="en">
-now double quotes are encoded in an "echo" SSI-command output.<br/>
-Thanks to Zaur Abasmirzoev.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр valid в директиве resolver.  По умолчанию теперь
-используется TTL, возвращённый DNS-сервером.<br/>
-Спасибо Кириллу Коринскому.
-</para>
-<para lang="en">
-the "valid" parameter of the "resolver" directive.  By default TTL
-returned by a DNS server is used.<br/>
-Thanks to Kirill A. Korinskiy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог перестать отвечать, если рабочий процесс завершался аварийно.
-</para>
-<para lang="en">
-nginx might hang after a worker process abnormal termination.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалось SNI;
-ошибка появилась в 1.1.2.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if SNI was used;
-the bug had appeared in 1.1.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве keepalive_disable;
-ошибка появилась в 1.1.8.<br/>
-Спасибо Александру Усову.
-</para>
-<para lang="en">
-in the "keepalive_disable" directive;
-the bug had appeared in 1.1.8.<br/>
-Thanks to Alexander Usov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сигнал SIGWINCH переставал работать после первого обновления исполняемого
-файла;
-ошибка появилась в 1.1.1.
-</para>
-<para lang="en">
-SIGWINCH signal did not work after first binary upgrade;
-the bug had appeared in 1.1.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь ответы бэкендов, длина которых не соответствует заголовку
-Content-Length, не кэширутся.
-</para>
-<para lang="en">
-backend responses with length not matching "Content-Length" header line
-are no longer cached.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве scgi_param при использовании составных параметров.
-</para>
-<para lang="en">
-in the "scgi_param" directive, if complex parameters were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в методе epoll.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-in the "epoll" event method.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_flv_module.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-in the ngx_http_flv_module.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_mp4_module.
-</para>
-<para lang="en">
-in the ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx понимает IPv6-адреса в строке запроса и в заголовке Host.
-</para>
-<para lang="en">
-IPv6 addresses are now handled properly in a request line and in a "Host"
-request header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы add_header и expires не работали для ответов с кодом 206,
-если запрос проксировался.
-</para>
-<para lang="en">
-"add_header" and "expires" directives did not work if a request was proxied
-and response status code was 206.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на FreeBSD 10.
-</para>
-<para lang="en">
-nginx could not be built on FreeBSD 10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на AIX.
-</para>
-<para lang="en">
-nginx could not be built on AIX.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.8" date="2011-11-14">
-
-<change type="change">
-<para lang="ru">
-модуль ngx_http_limit_zone_module переименован в ngx_http_limit_conn_module.
-</para>
-<para lang="en">
-the ngx_http_limit_zone_module was renamed to the ngx_http_limit_conn_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива limit_zone заменена директивой limit_conn_zone с новым синтаксисом.
-</para>
-<para lang="en">
-the "limit_zone" directive was superseded by the "limit_conn_zone" directive
-with a new syntax.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка ограничения по нескольким limit_conn на одном уровне.
-</para>
-<para lang="en">
-support for multiple "limit_conn" limits on the same level.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива image_filter_sharpen.
-</para>
-<para lang="en">
-the "image_filter_sharpen" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если resolver получил большой DNS-ответ.<br/>
-Спасибо Ben Hawkes.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if resolver got a big DNS response.<br/>
-Thanks to Ben Hawkes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в вычислении ключа для кэширования,
-если использовалась внутренняя реализация MD5;
-ошибка появилась в 1.0.4.
-</para>
-<para lang="en">
-in cache key calculation
-if internal MD5 implementation was used;
-the bug had appeared in 1.0.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки "If-Modified-Since", "If-Range" и им подобные в заголовке запроса
-клиента могли передаваться бэкенду при кэшировании; или не передаваться при
-выключенном кэшировании, если кэширование было включено в другой части
-конфигурации.
-</para>
-<para lang="en">
-the "If-Modified-Since", "If-Range", etc. client request header lines
-might be passed to backend while caching; or not passed without caching
-if caching was enabled in another part of the configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_mp4_module выдавал неверную строку "Content-Length"
-в заголовке ответа, использовался аргумент start.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-the module ngx_http_mp4_module sent incorrect "Content-Length" response
-header line if the "start" argument was used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.7" date="2011-10-31">
-
-<change type="feature">
-<para lang="ru">
-поддержка нескольких DNS серверов в директиве "resolver".<br/>
-Спасибо Кириллу Коринскому.
-</para>
-<para lang="en">
-support of several DNS servers in the "resolver" directive.<br/>
-Thanks to Kirill A. Korinskiy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации происходил segmentation fault,
-если директива ssl использовалась на уровне http и не был указан
-ssl_certificate.
-</para>
-<para lang="en">
-a segmentation fault occurred on start or during reconfiguration
-if the "ssl" directive was used at http level and there was
-no "ssl_certificate" defined.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-уменьшено потребление памяти при проксировании больших файлов,
-если они буферизировались на диск.
-</para>
-<para lang="en">
-reduced memory consumption while proxying big files
-if they were buffered to disk.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовалась директива "proxy_http_version 1.1".
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if "proxy_http_version 1.1" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве "expires @time".
-</para>
-<para lang="en">
-in the "expires @time" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.6" date="2011-10-17">
-
-<change>
-<para lang="ru">
-Изменение во внутреннем API: теперь при внутреннем редиректе
-в именованный location контексты модулей очищаются.<br/>
-По запросу Yichun Zhang.
-</para>
-<para lang="en">
-Change in internal API: now module context data are cleared
-while internal redirect to named location.<br/>
-Requested by Yichun Zhang.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь если сервер, описанный в блоке upstream, был признан неработающим,
-то после истечения fail_timeout на него будет отправлен только один запрос;
-сервер будет считаться работающим, если успешно ответит на этот запрос.
-</para>
-<para lang="en">
-if a server in an upstream failed, only one request will be sent to it
-after fail_timeout; the server will be considered alive if it will
-successfully respond to the request.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь символы 0x7F-0xFF в access_log записываются в виде \xXX.
-</para>
-<para lang="en">
-now the 0x7F-0xFF characters are escaped as \xXX in an access_log.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы "proxy/fastcgi/scgi/uwsgi_ignore_headers" теперь поддерживают
-значения X-Accel-Limit-Rate, X-Accel-Buffering и X-Accel-Charset.
-</para>
-<para lang="en">
-"proxy/fastcgi/scgi/uwsgi_ignore_headers" directives support the following
-additional values: X-Accel-Limit-Rate, X-Accel-Buffering, X-Accel-Charset.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-уменьшение потребления памяти при использовании SSL.
-</para>
-<para lang="en">
-decrease of memory consumption if SSL is used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-некоторые UTF-8 символы обрабатывались неправильно.<br/>
-Спасибо Алексею Куцу.
-</para>
-<para lang="en">
-some UTF-8 characters were processed incorrectly.<br/>
-Thanks to Alexey Kuts.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы модуля ngx_http_rewrite_module, заданные на уровне server,
-применялись повторно, если для запроса не находилось ни одного location'а.
-</para>
-<para lang="en">
-the ngx_http_rewrite_module directives specified at "server" level were
-executed twice if no matching locations were defined.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании "aio sendfile" могла происходить утечка сокетов.
-</para>
-<para lang="en">
-a socket leak might occurred if "aio sendfile" was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании файлового AIO соединения с быстрыми клиентами
-могли быть закрыты по истечению send_timeout.
-</para>
-<para lang="en">
-connections with fast clients might be closed after send_timeout
-if file AIO was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_autoindex_module.
-</para>
-<para lang="en">
-in the ngx_http_autoindex_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_mp4_module не поддерживал перемотку на 32-битных платформах.
-</para>
-<para lang="en">
-the module ngx_http_mp4_module did not support seeking on 32-bit platforms.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.5" date="2011-10-05">
-
-<change type="feature">
-<para lang="ru">
-директивы uwsgi_buffering и scgi_buffering.<br/>
-Спасибо Peter Smit.
-</para>
-<para lang="en">
-the "uwsgi_buffering" and "scgi_buffering" directives.<br/>
-Thanks to Peter Smit.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании proxy_cache_bypass могли быть закэшированы
-некэшируемые ответы.<br/>
-Спасибо John Ferlito.
-</para>
-<para lang="en">
-non-cacheable responses might be cached if "proxy_cache_bypass" directive
-was used.<br/>
-Thanks to John Ferlito.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_proxy_module при работе с бэкендами по HTTP/1.1.
-</para>
-<para lang="en">
-in HTTP/1.1 support in the ngx_http_proxy_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-закэшированные ответы с пустым телом возвращались некорректно;
-ошибка появилась в 0.8.31.
-</para>
-<para lang="en">
-cached responses with an empty body were returned incorrectly;
-the bug had appeared in 0.8.31.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы с кодом 201 модуля ngx_http_dav_module были некорректны;
-ошибка появилась в 0.8.32.
-</para>
-<para lang="en">
-201 responses of the ngx_http_dav_module were incorrect;
-the bug had appeared in 0.8.32.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве return.
-</para>
-<para lang="en">
-in the "return" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "ssl_session_cache builtin" происходил
-segmentation fault;
-ошибка появилась в 1.1.1.
-</para>
-<para lang="en">
-the "ssl_session_cache builtin" directive caused segmentation fault;
-the bug had appeared in 1.1.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.4" date="2011-09-20">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_upstream_keepalive.
-</para>
-<para lang="en">
-the ngx_http_upstream_keepalive module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_http_version.
-</para>
-<para lang="en">
-the "proxy_http_version" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_keep_conn.
-</para>
-<para lang="en">
-the "fastcgi_keep_conn" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_aio_requests.
-</para>
-<para lang="en">
-the "worker_aio_requests" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с файловым AIO,
-он не мог запускаться на Linux без поддержки AIO.
-</para>
-<para lang="en">
-if nginx was built --with-file-aio it could not be run on Linux
-kernel which did not support AIO.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок при работе с Linux AIO.
-<br/>
-Спасибо Hagai Avrahami.
-</para>
-<para lang="en">
-in Linux AIO error processing.
-<br/>
-Thanks to Hagai Avrahami.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-уменьшено потребление памяти для долгоживущих запросов.
-</para>
-<para lang="en">
-reduced memory consumption for long-lived requests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_mp4_module не поддерживал 64-битный MP4-атом co64.
-</para>
-<para lang="en">
-the module ngx_http_mp4_module did not support 64-bit MP4 "co64" atom.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.3" date="2011-09-14">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_mp4_module.
-</para>
-<para lang="en">
-the module ngx_http_mp4_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в Linux AIO, используемым совместно с open_file_cache.
-</para>
-<para lang="en">
-in Linux AIO combined with open_file_cache.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-open_file_cache не обновлял информацию о файле,
-если файл был изменён не атомарно.
-</para>
-<para lang="en">
-open_file_cache did not update file info on retest
-if file was not atomically changed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на MacOSX 10.7.
-</para>
-<para lang="en">
-nginx could not be built on MacOSX 10.7.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.2" date="2011-09-05">
-
-<change type="change">
-<para lang="ru">
-теперь, если суммарный размер всех диапазонов больше размера исходного ответа,
-то nginx возвращает только исходный ответ, не обрабатывая диапазоны.
-</para>
-<para lang="en">
-now if total size of all ranges is greater than source response size,
-then nginx disables ranges and returns just the source response.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива max_ranges.
-</para>
-<para lang="en">
-the "max_ranges" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы ssl_verify_client, ssl_verify_depth и ssl_prefer_server_cipher
-могли работать некорректно, если использовался SNI.
-</para>
-<para lang="en">
-the "ssl_verify_client", "ssl_verify_depth", and "ssl_prefer_server_ciphers"
-directives might work incorrectly if SNI was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах proxy/fastcgi/scgi/ uwsgi_ignore_client_abort.
-</para>
-<para lang="en">
-in the "proxy/fastcgi/scgi/uwsgi_ignore_client_abort" directives.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.1" date="2011-08-22">
-
-<change type="change">
-<para lang="ru">
-теперь загрузчик кэша за каждую итерацию либо обрабатывает число файлов,
-указанное в параметре load_files, либо работает не дольше времени,
-указанного в параметре loader_threshold.
-</para>
-<para lang="en">
-now cache loader processes either as many files as specified by "loader_files"
-parameter or works no longer than time specified by the "loader_threshold"
-parameter during each iteration.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-SIGWINCH сигнал теперь работает только в режиме демона.
-</para>
-<para lang="en">
-now SIGWINCH signal works only in daemon mode.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь разделяемые зоны и кэши используют семафоры POSIX на Solaris.<br/>
-Спасибо Денису Иванову.
-</para>
-<para lang="en">
-now shared zones and caches use POSIX semaphores on Solaris.<br/>
-Thanks to Den Ivanov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь на NetBSD поддерживаются accept фильтры.
-</para>
-<para lang="en">
-accept filters are now supported on NetBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Linux 3.0.
-</para>
-<para lang="en">
-nginx could not be built on Linux 3.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в некоторых случаях nginx не использовал сжатие;
-ошибка появилась в 1.1.0.
-</para>
-<para lang="en">
-nginx did not use gzipping in some cases;
-the bug had appeared in 1.1.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-обработка тела запроса могла быть неверной, если клиент использовал pipelining.
-</para>
-<para lang="en">
-request body might be processed incorrectly if client used pipelining.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве request_body_in_single_buf.
-</para>
-<para lang="en">
-in the "request_body_in_single_buf" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах proxy_set_body и proxy_pass_request_body
-при использовании SSL-соединения с бэкендом.
-</para>
-<para lang="en">
-in "proxy_set_body" and "proxy_pass_request_body" directives
-if SSL connection to backend was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx нагружал процессор, если все серверы в upstream'е были помечены
-флагом down.
-</para>
-<para lang="en">
-nginx hogged CPU if all servers in an upstream were marked as "down".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при переконфигурации мог произойти segmentation fault,
-если в предыдущей конфигурации был определён, но не использовался
-ssl_session_cache.
-</para>
-<para lang="en">
-a segmentation fault might occur during reconfiguration
-if ssl_session_cache was defined but not used in previous configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании большого количества backup-серверов
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if many backup servers were used in an upstream.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив fastcgi/scgi/uwsgi_param
-со значениями, начинающимися со строки "HTTP_",
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.8.40.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-if "fastcgi/scgi/uwsgi_param" directives were used
-with values starting with "HTTP_";
-the bug had appeared in 0.8.40.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.1.0" date="2011-08-01">
-
-<change type="feature">
-<para lang="ru">
-уменьшение времени работы загрузчика кэша.
-</para>
-<para lang="en">
-cache loader run time decrease.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры loader_files, loader_sleep и loader_threshold
-директив proxy/fastcgi/scgi/uwsgi_cache_path.
-</para>
-<para lang="en">
-"loader_files", "loader_sleep", and "loader_threshold" options
-of the "proxy/fastcgi/scgi/uwsgi_cache_path" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-уменьшение времени загрузки конфигураций с большим количеством HTTPS серверов.
-</para>
-<para lang="en">
-loading time decrease of configuration with large number of HTTPS sites.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx поддерживает шифры с обменом ECDHE-ключами.<br/>
-Спасибо Adrian Kotelba.
-</para>
-<para lang="en">
-now nginx supports ECDHE key exchange ciphers.<br/>
-Thanks to Adrian Kotelba.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива lingering_close.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the "lingering_close" directive.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-закрытия соединения для pipelined-запросов.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in closing connection for pipelined requests.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не запрещал сжатие при получении значения "gzip;q=0"
-в строке "Accept-Encoding" в заголовке запроса клиента.
-</para>
-<para lang="en">
-nginx did not disable gzipping if client sent "gzip;q=0" in
-"Accept-Encoding" request header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-таймаута при небуферизированном проксировании.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in timeout in unbuffered proxied mode.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти при использовании переменных в директиве proxy_pass
-при работе с бэкендом по HTTPS.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-memory leaks when a "proxy_pass" directive contains variables and proxies
-to an HTTPS backend.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в проверке параметра директивы proxy_pass, заданного переменными.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-in parameter validation of a "proxy_pass" directive with variables.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL не работал на QNX.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-SSL did not work on QNX.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL модули не собирались gcc 4.6 без параметра --with-debug.
-</para>
-<para lang="en">
-SSL modules could not be built by gcc 4.6 without --with-debug option.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.5" date="2011-07-19">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию используются следующие шифры SSL: "HIGH:!aNULL:!MD5".<br/>
-Спасибо Rob Stradling.
-</para>
-<para lang="en">
-now default SSL ciphers are "HIGH:!aNULL:!MD5".<br/>
-Thanks to Rob Stradling.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы referer_hash_max_size и referer_hash_bucket_size.<br/>
-Спасибо Witold Filipczyk.
-</para>
-<para lang="en">
-the "referer_hash_max_size" and "referer_hash_bucket_size"
-directives.<br/>
-Thanks to Witold Filipczyk.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $uid_reset.
-</para>
-<para lang="en">
-$uid_reset variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэширования
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Lanshun Zhou.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-if a caching was used.<br/>
-Thanks to Lanshun Zhou.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэширования рабочие процессы
-могли зациклиться во время переконфигурации;
-ошибка появилась в 0.8.48.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-worker processes may got caught in an endless loop during reconfiguration,
-if a caching was used;
-the bug had appeared in 0.8.48.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сообщения "stalled cache updating".<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-"stalled cache updating" alert.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.4" date="2011-06-01">
-
-<change type="change">
-<para lang="ru">
-теперь в регулярных выражениях в директиве map можно задать
-чувствительность к регистру с помощью префиксов "~" и "~*".
-</para>
-<para lang="en">
-now regular expressions case sensitivity in the "map" directive
-is given by prefixes "~" or "~*".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь разделяемые зоны и кэши используют семафоры POSIX на Linux.<br/>
-Спасибо Денису Латыпову.
-</para>
-<para lang="en">
-now shared zones and caches use POSIX semaphores on Linux.<br/>
-Thanks to Denis F. Latypoff.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-сообщения "stalled cache updating".
-</para>
-<para lang="en">
-"stalled cache updating" alert.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http_auth_basic_module;
-ошибка появилась в 1.0.3.
-</para>
-<para lang="en">
-nginx could not be built --without-http_auth_basic_module;
-the bug had appeared in 1.0.3.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.3" date="2011-05-25">
-
-<change type="feature">
-<para lang="ru">
-директива auth_basic_user_file поддерживает шифрование пароля
-методами "$apr1", "{PLAIN}" и "{SSHA}".<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the "auth_basic_user_file" directive supports "$apr1", "{PLAIN}",
-and "{SSHA}" password encryption methods.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива geoip_org и переменная $geoip_org.<br/>
-Спасибо Александру Ускову, Arnaud Granal и Денису Латыпову.
-</para>
-<para lang="en">
-the "geoip_org" directive and $geoip_org variable.<br/>
-Thanks to Alexander Uskov, Arnaud Granal, and Denis F. Latypoff.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модули ngx_http_geo_module и ngx_http_geoip_module поддерживают
-адреса IPv4, отображённые на IPv6 адреса.
-</para>
-<para lang="en">
-ngx_http_geo_module and ngx_http_geoip_module support IPv4 addresses
-mapped to IPv6 addresses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проверке адреса IPv4, отображённого на адрес IPv6,
-в рабочем процессе происходил segmentation fault,
-если директивы access или deny были определены только для адресов IPv6;
-ошибка появилась в 0.8.22.
-</para>
-<para lang="en">
-a segmentation fault occurred in a worker process
-during testing IPv4 address mapped to IPv6 address,
-if access or deny rules were defined only for IPv6;
-the bug had appeared in 0.8.22.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-закэшированный ответ мог быть испорчен, если значения директив
-proxy/fastcgi/scgi/uwsgi_cache_bypass и proxy/fastcgi/scgi/ uwsgi_no_cache
-были разными;
-ошибка появилась в 0.8.46.
-</para>
-<para lang="en">
-a cached response may be broken if "proxy/fastcgi/scgi/ uwsgi_cache_bypass"
-and "proxy/fastcgi/scgi/uwsgi_no_cache" directive values were different;
-the bug had appeared in 0.8.46.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.2" date="2011-05-10">
-
-<change type="feature">
-<para lang="ru">
-теперь разделяемые зоны и кэши используют семафоры POSIX.
-</para>
-<para lang="en">
-now shared zones and caches use POSIX semaphores.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в работе параметра rotate директивы image_filter.<br/>
-Спасибо Adam Bocim.
-</para>
-<para lang="en">
-in the "rotate" parameter of the "image_filter" directive.<br/>
-Thanks to Adam Bocim.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris;
-ошибка появилась в 1.0.1.
-</para>
-<para lang="en">
-nginx could not be built on Solaris;
-the bug had appeared in 1.0.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.1" date="2011-05-03">
-
-<change type="change">
-<para lang="ru">
-теперь директива split_clients использует алгоритм MurmurHash2 из-за
-лучшего распределения.<br/>
-Спасибо Олегу Мамонтову.
-</para>
-<para lang="en">
-now the "split_clients" directive uses MurmurHash2 algorithm because
-of better distribution.<br/>
-Thanks to Oleg Mamontov.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь длинные строки, начинающиеся с нуля, не считаются ложными
-значениями.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now long strings starting with zero are not considered as false values.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию nginx использует значение 511 для listen backlog на Linux.
-</para>
-<para lang="en">
-now nginx uses a default listen backlog value 511 on Linux.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $upstream_... можно использовать в SSI и перловом модулях.
-</para>
-<para lang="en">
-the $upstream_... variables may be used in the SSI and perl modules.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx лучше ограничивает размер кэша на диске.<br/>
-Спасибо Олегу Мамонтову.
-</para>
-<para lang="en">
-now nginx limits better disk cache size.<br/>
-Thanks to Oleg Mamontov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при парсинге неправильного IPv4 адреса мог произойти segmentation fault;
-ошибка появилась в 0.8.22.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a segmentation fault might occur while parsing incorrect IPv4 address;
-the bug had appeared in 0.9.3.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался gcc 4.6 без параметра --with-debug.
-</para>
-<para lang="en">
-nginx could not be built by gcc 4.6 without --with-debug option.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris 9 и более ранних;
-ошибка появилась в 0.9.3.<br/>
-Спасибо Dagobert Michelsen.
-</para>
-<para lang="en">
-nginx could not be built on Solaris 9 and earlier;
-the bug had appeared in 0.9.3.<br/>
-Thanks to Dagobert Michelsen.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $request_time имела неверные значения, если использовались
-подзапросы;
-ошибка появилась в 0.8.47.<br/>
-Спасибо Игорю А. Валькову.
-</para>
-<para lang="en">
-$request_time variable had invalid values if subrequests were used;
-the bug had appeared in 0.8.47.<br/>
-Thanks to Igor A. Valcov.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="1.0.0" date="2011-04-12">
-
-<change type="bugfix">
-<para lang="ru">
-cache manager мог нагружать процессор после переконфигурации.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a cache manager might hog CPU after reload.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "image_filter crop" неправильно работала в сочетании с
-"image_filter rotate 180".
-</para>
-<para lang="en">
-an "image_filter crop" directive worked incorrectly coupled with
-an "image_filter rotate 180" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "satisfy any" запрещала выдачу пользовательской страницы
-для 401 кода.
-</para>
-<para lang="en">
-a "satisfy any" directive disabled custom 401 error page.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.7" date="2011-04-04">
-
-<change type="feature">
-<para lang="ru">
-теперь соединения в состоянии keepalive могут быть закрыты преждевременно,
-если у воркера нет свободных соединений.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now keepalive connections may be closed premature,
-if there are no free worker connections.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр rotate директивы image_filter.<br/>
-Спасибо Adam Bocim.
-</para>
-<para lang="en">
-the "rotate" parameter of the "image_filter" directive.<br/>
-Thanks to Adam Bocim.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ситуации, когда бэкенд в директивах fastcgi_pass, scgi_pass или uwsgi_pass
-задан выражением и ссылается на описанный upstream.
-</para>
-<para lang="en">
-a case when a backend in "fastcgi_pass", "scgi_pass", or "uwsgi_pass"
-directives is given by expression and refers to a defined upstream.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.6" date="2011-03-21">
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает регулярные выражения в качестве значения
-первого параметра.
-</para>
-<para lang="en">
-the "map" directive supports regular expressions as value of the first
-parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $time_iso8601 для access_log.<br/>
-Спасибо Michael Lustfield.
-</para>
-<para lang="en">
-$time_iso8601 access_log variable.<br/>
-Thanks to Michael Lustfield.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.5" date="2011-02-21">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию nginx использует значение -1 для listen backlog
-на Linux.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-now nginx uses a default listen backlog value -1 on Linux.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр utf8 в директивах geoip_country и geoip_city.<br/>
-Спасибо Денису Латыпову.
-</para>
-<para lang="en">
-the "utf8" parameter of "geoip_country" and "geoip_city" directives.<br/>
-Thanks to Denis F. Latypoff.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-исправление в умолчательной директиве proxy_redirect, если в директиве
-proxy_pass не был описан URI.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in a default "proxy_redirect" directive if "proxy_pass" directive has no
-URI part.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page не работала с нестандартными кодами ошибок;
-ошибка появилась в 0.8.53.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-an "error_page" directive did not work with nonstandard error codes;
-the bug had appeared in 0.8.53.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.4" date="2011-01-21">
-
-<change type="feature">
-<para lang="ru">
-директива server_name поддерживает переменную $hostname.
-</para>
-<para lang="en">
-the "server_name" directive supports the $hostname variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-494 код для ошибки "Request Header Too Large".
-</para>
-<para lang="en">
-494 code for "Request Header Too Large" error.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.3" date="2010-12-13">
-
-<change type="bugfix">
-<para lang="ru">
-если для пары IPv6-адрес:порт описан только один сервер, то выделения
-в регулярных выражениях в директиве server_name не работали.
-</para>
-<para lang="en">
-if there was a single server for given IPv6 address:port pair,
-then captures in regular expressions in a "server_name" directive did not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под Solaris;
-ошибка появилась в 0.9.0.
-</para>
-<para lang="en">
-nginx could not be built on Solaris;
-the bug had appeared in 0.9.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.2" date="2010-12-06">
-
-<change type="feature">
-<para lang="ru">
-поддержка строки "If-Unmodified-Since" в заголовке запроса клиента.
-</para>
-<para lang="en">
-the "If-Unmodified-Since" client request header line support.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-использование accept(), если accept4() не реализован;
-ошибка появилась в 0.9.0.
-</para>
-<para lang="en">
-fallback to accept() syscall if accept4() was not implemented;
-the issue had appeared in 0.9.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под Cygwin;
-ошибка появилась в 0.9.0.
-</para>
-<para lang="en">
-nginx could not be built on Cygwin;
-the bug had appeared in 0.9.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-уязвимости в OpenSSL CVE-2010-4180.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-for OpenSSL vulnerability CVE-2010-4180.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.1" date="2010-11-30">
-
-<change type="bugfix">
-<para lang="ru">
-директивы вида "return CODE message" не работали;
-ошибка появилась в 0.9.0.
-</para>
-<para lang="en">
-"return CODE message" directives did not work;
-the bug had appeared in 0.9.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.9.0" date="2010-11-29">
-
-<change type="feature">
-<para lang="ru">
-директива keepalive_disable.
-</para>
-<para lang="en">
-the "keepalive_disable" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает переменные в качестве значения определяемой
-переменной.
-</para>
-<para lang="en">
-the "map" directive supports variables as value of a defined variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает пустые строки в качестве значения первого параметра.
-</para>
-<para lang="en">
-the "map" directive supports empty strings as value of the first parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает выражения в первом параметре.
-</para>
-<para lang="en">
-the "map" directive supports expressions as the first parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-страница руководства nginx(8).<br/>
-Спасибо Сергею Осокину.
-</para>
-<para lang="en">
-nginx(8) manual page.<br/>
-Thanks to Sergey Osokin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка accept4() в Linux.<br/>
-Спасибо Simon Liu.
-</para>
-<para lang="en">
-Linux accept4() support.<br/>
-Thanks to Simon Liu.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-устранение предупреждения линкера о "sys_errlist" и "sys_nerr" под Linux;
-предупреждение появилось в 0.8.35.
-</para>
-<para lang="en">
-elimination of Linux linker warning about "sys_errlist" and "sys_nerr";
-the warning had appeared in 0.8.35.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы auth_basic
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Михаилу Лалетину.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-if the "auth_basic" directive was used.<br/>
-Thanks to Michail Laletin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с модулем ngx_http_eval_module;
-ошибка появилась в 0.8.42.
-</para>
-<para lang="en">
-compatibility with ngx_http_eval_module;
-the bug had appeared in 0.8.42.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.53" date="2010-10-18">
-
-<change type="feature">
-<para lang="ru">
-теперь директива error_page позволяет менять код статуса у редиректа.
-</para>
-<para lang="en">
-now the "error_page" directive allows to change a status code in a redirect.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива gzip_disable поддерживает специальную маску degradation.
-</para>
-<para lang="en">
-the "gzip_disable" directive supports special "degradation" mask.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании файлового AIO могла происходить утечка сокетов.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a socket leak might occurred if file AIO was used.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в первом сервере не была описана директива listen и нигде явно
-не описан сервер по умолчанию, то сервером по умолчанию становился
-следующий сервер с директивой listen;
-ошибка появилась в 0.8.21.
-</para>
-<para lang="en">
-if the first server had no "listen" directive and there was no explicit
-default server, then a next server with a "listen" directive became
-the default server;
-the bug had appeared in 0.8.21.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.52" date="2010-09-28">
-
-<change type="bugfix">
-<para lang="ru">
-nginx использовал режим SSL для listen сокета, если для него был
-установлен любой listen-параметр;
-ошибка появилась в 0.8.51.
-</para>
-<para lang="en">
-nginx used SSL mode for a listen socket if any listen option was set;
-the bug had appeared in 0.8.51.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.51" date="2010-09-27">
-
-<change type="change">
-<para lang="ru">
-директива secure_link_expires упразднена.
-</para>
-<para lang="en">
-the "secure_link_expires" directive has been canceled.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-уровень логгирования ошибок resolver'а понижен с уровня alert на error.
-</para>
-<para lang="en">
-a logging level of resolver errors has been lowered from "alert" to "error".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь параметр "ssl" listen-сокета можно устанавливать несколько раз.
-</para>
-<para lang="en">
-now a listen socket "ssl" parameter may be set several times.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.50" date="2010-09-02">
-
-<change type="feature">
-<para lang="ru">
-директивы secure_link, secure_link_md5 и secure_link_expires
-модуля ngx_http_secure_link_module.
-</para>
-<para lang="en">
-the "secure_link", "secure_link_md5", and "secure_link_expires" directives of
-the ngx_http_secure_link_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -q.<br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-the -q switch.<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании кэширования рабочие процессы и могли зациклиться
-во время переконфигурации;
-ошибка появилась в 0.8.48.
-</para>
-<para lang="en">
-worker processes may got caught in an endless loop during reconfiguration,
-if a caching was used;
-the bug had appeared in 0.8.48.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве gzip_disable.<br/>
-Спасибо Derrick Petzold.
-</para>
-<para lang="en">
-in the "gzip_disable" directive.<br/>
-Thanks to Derrick Petzold.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не мог посылать сигналы stop, quit, reopen, reload процессу,
-запущенному в другой сессии.
-</para>
-<para lang="en">
-nginx/Windows could not send stop, quit, reopen, and reload signals
-to a process run in other session.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.49" date="2010-08-09">
-
-<change type="feature">
-<para lang="ru">
-директива image_filter_jpeg_quality поддерживает переменные.
-</para>
-<para lang="en">
-the "image_filter_jpeg_quality" directive supports variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменной $geoip_region_name
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.8.48.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-if the $geoip_region_name variables was used;
-the bug had appeared in 0.8.48.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки, перехваченные error_page, кэшировались только до следующего запроса;
-ошибка появилась в 0.8.48.
-</para>
-<para lang="en">
-errors intercepted by error_page were cached only for next request;
-the bug had appeared in 0.8.48.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.48" date="2010-08-03">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию директива server_name имеет значение пустое имя "".<br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-now the "server_name" directive default value is an empty name "".<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию директива server_name_in_redirect имеет значение off.
-</para>
-<para lang="en">
-now the "server_name_in_redirect" directive default value is "off".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $geoip_dma_code, $geoip_area_code и $geoip_region_name.<br/>
-Спасибо Christine McGonagle.
-</para>
-<para lang="en">
-the $geoip_dma_code, $geoip_area_code, and $geoip_region_name variables.<br/>
-Thanks to Christine McGonagle.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_pass, fastcgi_pass, uwsgi_pass и scgi_pass не наследовались
-в блоки limit_except.
-</para>
-<para lang="en">
-the "proxy_pass", "fastcgi_pass", "uwsgi_pass", and "scgi_pass" directives
-were not inherited inside "limit_except" blocks.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_cache_min_uses, fastcgi_cache_min_uses
-uwsgi_cache_min_uses и scgi_cache_min_uses не работали;
-ошибка появилась в 0.8.46.
-</para>
-<para lang="en">
-the "proxy_cache_min_uses", "fastcgi_cache_min_uses"
-"uwsgi_cache_min_uses", and "scgi_cache_min_uses" directives did not work;
-the bug had appeared in 0.8.46.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива fastcgi_split_path_info неверно использовала выделения,
-если в выделения попадала только часть URI.<br/>
-Спасибо Юрию Тарадаю и Frank Enderle.
-</para>
-<para lang="en">
-the "fastcgi_split_path_info" directive used incorrectly captures,
-if only parts of an URI were captured.<br/>
-Thanks to Yuriy Taraday and Frank Enderle.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива rewrite не экранировала символ ";" при копировании из URI
-в аргументы.<br/>
-Спасибо Daisuke Murase.
-</para>
-<para lang="en">
-the "rewrite" directive did not escape a ";" character during copying
-from URI to query string.<br/>
-Thanks to Daisuke Murase.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_image_filter_module закрывал соединение,
-если изображение было больше размера image_filter_buffer.
-</para>
-<para lang="en">
-the ngx_http_image_filter_module closed a connection,
-if an image was larger than "image_filter_buffer" size.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.47" date="2010-07-28">
-
-<change type="bugfix">
-<para lang="ru">
-переменная $request_time имела неверные значения для подзапросов.
-</para>
-<para lang="en">
-$request_time variable had invalid values for subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки, перехваченные error_page, не кэшировались.
-</para>
-<para lang="en">
-errors intercepted by error_page could not be cached.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовался параметр max_size, то cache manager мог зациклиться;
-ошибка появилась в 0.8.46.
-</para>
-<para lang="en">
-a cache manager process may got caught in an endless loop,
-if max_size parameter was used;
-the bug had appeared in 0.8.46.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.46" date="2010-07-19">
-
-<change type="change">
-<para lang="ru">
-директивы proxy_no_cache, fastcgi_no_cache, uwsgi_no_cache
-и scgi_no_cache теперь влияют только на сохранение закэшированного ответа.
-</para>
-<para lang="en">
-now the "proxy_no_cache", "fastcgi_no_cache", "uwsgi_no_cache", and
-"scgi_no_cache" directives affect on a cached response saving only.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache_bypass, fastcgi_cache_bypass, uwsgi_cache_bypass
-и scgi_cache_bypass.
-</para>
-<para lang="en">
-the "proxy_cache_bypass", "fastcgi_cache_bypass", "uwsgi_cache_bypass",
-and "scgi_cache_bypass" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не освобождал память в keys_zone кэшей в случае ошибки работы с
-бэкендом: память освобождалась только по истечении времени неактивности
-или при недостатке памяти.
-</para>
-<para lang="en">
-nginx did not free memory in cache keys zones if there was an error
-during working with backend: the memory was freed only after inactivity
-time or on memory low condition.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.45" date="2010-07-13">
-
-<change type="feature">
-<para lang="ru">
-улучшения в модуле ngx_http_xslt_filter.<br/>
-Спасибо Laurence Rowe.
-</para>
-<para lang="en">
-ngx_http_xslt_filter improvements.<br/>
-Thanks to Laurence Rowe.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ SSI модуля мог передаваться не полностью после команды include
-с параметром wait="yes";
-ошибка появилась в 0.7.25.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-SSI response might be truncated after include with wait="yes";
-the bug had appeared in 0.7.25.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива listen не поддерживала параметр setfib=0.
-</para>
-<para lang="en">
-the "listen" directive did not support the "setfib=0" parameter.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.44" date="2010-07-05">
-
-<change type="change">
-<para lang="ru">
-теперь nginx по умолчанию не кэширует ответы бэкендов,
-в заголовке которых есть строка "Set-Cookie".
-</para>
-<para lang="en">
-now nginx does not cache by default backend responses,
-if they have a "Set-Cookie" header line.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива listen поддерживает параметр setfib.<br/>
-Спасибо Андрею Филонову.
-</para>
-<para lang="en">
-the "listen" directive supports the "setfib" parameter.<br/>
-Thanks to Andrew Filonov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива sub_filter могла изменять регистр букв при частичном совпадении.
-</para>
-<para lang="en">
-the "sub_filter" directive might change character case on partial match.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с HP/UX.
-</para>
-<para lang="en">
-compatibility with HP/UX.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с компилятором AIX xlC_r.
-</para>
-<para lang="en">
-compatibility with AIX xlC_r compiler.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx считал большие пакеты SSLv2 как обычные текстовые запросы.<br/>
-Спасибо Miroslaw Jaworski.
-</para>
-<para lang="en">
-nginx treated large SSLv2 packets as plain requests.<br/>
-Thanks to Miroslaw Jaworski.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.43" date="2010-06-30">
-
-<change type="feature">
-<para lang="ru">
-ускорение загрузки больших баз geo-диапазонов.
-</para>
-<para lang="en">
-large geo ranges base loading speed-up.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-перенаправление ошибки в "location /zero {return 204;}" без изменения
-кода ответа оставляло тело ошибки;
-ошибка появилась в 0.8.42.
-</para>
-<para lang="en">
-an error_page redirection to "location /zero {return 204;}" without
-changing status code kept the error body;
-the bug had appeared in 0.8.42.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог закрывать IPv6 listen сокет во время переконфигурации.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-nginx might close IPv6 listen socket during reconfiguration.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменную $uid_set можно использовать на любой стадии обработки запроса.
-</para>
-<para lang="en">
-the $uid_set variable may be used at any request processing stage.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.42" date="2010-06-21">
-
-<change type="change">
-<para lang="ru">
-теперь nginx проверяет location'ы, заданные регулярными выражениями,
-если запрос полностью совпал с location'ом, заданным строкой префикса.
-Предыдущее поведение появилось в 0.7.1.
-</para>
-<para lang="en">
-now nginx tests locations given by regular expressions,
-if request was matched exactly by a location given by a prefix string.
-The previous behavior has been introduced in 0.7.1.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_scgi_module.<br/>
-Спасибо Manlio Perillo.
-</para>
-<para lang="en">
-the ngx_http_scgi_module.<br/>
-Thanks to Manlio Perillo.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в директиве return можно добавлять текст ответа.
-</para>
-<para lang="en">
-a text answer may be added to a "return" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.41" date="2010-06-15">
-
-<change type="security">
-<para lang="ru">
-рабочий процесс nginx/Windows мог завершаться аварийно при запросе файла
-с неверной кодировкой UTF-8.
-</para>
-<para lang="en">
-nginx/Windows worker might be terminated abnormally if a requested file name
-has invalid UTF-8 encoding.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь nginx разрешает использовать пробелы в строке запроса.
-</para>
-<para lang="en">
-now nginx allows to use spaces in a request line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_redirect неправильно изменяла строку "Refresh" в заголовке
-ответа бэкенда.<br/>
-Спасибо Андрею Андрееву и Максиму Согину.
-</para>
-<para lang="en">
-the "proxy_redirect" directive changed incorrectly a backend "Refresh"
-response header line.<br/>
-Thanks to Andrey Andreew and Max Sogin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал путь без имени хоста в
-строке "Destination" в заголовке запроса.
-</para>
-<para lang="en">
-nginx did not support path without host name
-in "Destination" request header line.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.40" date="2010-06-07">
-
-<change type="security">
-<para lang="ru">
-теперь nginx/Windows игнорирует имя потока файла по умолчанию.<br/>
-Спасибо Jose Antonio Vazquez Gonzalez.
-</para>
-<para lang="en">
-now nginx/Windows ignores default file stream name.<br/>
-Thanks to Jose Antonio Vazquez Gonzalez.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_uwsgi_module.<br/>
-Спасибо Roberto De Ioris.
-</para>
-<para lang="en">
-the ngx_http_uwsgi_module.<br/>
-Thanks to Roberto De Ioris.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_param со значением, начинающимся со строки "HTTP_",
-изменяет строку заголовка в запросе клиента.
-</para>
-<para lang="en">
-a "fastcgi_param" directive with value starting with "HTTP_" overrides
-a client request header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки "If-Modified-Since", "If-Range" и им подобные в заголовке запроса
-клиента передавались FastCGI-серверу при кэшировании.
-</para>
-<para lang="en">
-the "If-Modified-Since", "If-Range", etc. client request header lines
-were passed to FastCGI-server while caching.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-listen unix domain сокет нельзя было изменить во время переконфигурации.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-listen unix domain socket could not be changed during reconfiguration.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.39" date="2010-05-31">
-
-<change type="bugfix">
-<para lang="ru">
-наследуемая директива alias неправильно работала во вложенном location'е.
-</para>
-<para lang="en">
-an inherited "alias" directive worked incorrectly in inclusive location.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в комбинации директив alias с переменными и try_files;
-</para>
-<para lang="en">
-in "alias" with variables and "try_files" directives combination.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-listen unix domain и IPv6 сокеты не наследовались во время обновления
-без перерыва.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-listen unix domain and IPv6 sockets did not inherit while online upgrade.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.38" date="2010-05-24">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_no_cache и fastcgi_no_cache.
-</para>
-<para lang="en">
-the "proxy_no_cache" and "fastcgi_no_cache" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании переменной $scheme в директиве rewrite
-автоматически делается редирект.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-now the "rewrite" directive does a redirect automatically
-if the $scheme variable is used.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь задержки в директиве limit_req соответствует описанному алгоритму.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now "limit_req" delay directive conforms to the described algorithm.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменную $uid_got нельзя было использовать в SSI и перловом модулях.
-</para>
-<para lang="en">
-the $uid_got variable might not be used in the SSI and perl modules.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.37" date="2010-05-17">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_split_clients_module.
-</para>
-<para lang="en">
-the ngx_http_split_clients_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает ключи больше 255 символов.
-</para>
-<para lang="en">
-the "map" directive supports keys more than 255 characters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал значения "private" и "no-store" в строке "Cache-Control"
-в заголовке ответа бэкенда.
-</para>
-<para lang="en">
-nginx ignored the "private" and "no-store" values
-in the "Cache-Control" backend response header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр stub в SSI-директиве include не использовался,
-если пустой ответ имел код 200.
-</para>
-<para lang="en">
-a "stub" parameter of an "include" SSI directive was not used,
-if empty response has 200 status code.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если проксированный или FastCGI запрос внутренне перенаправлялся
-в другой проксированный или FastCGI location,
-то в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.8.33.<br/>
-Спасибо Yichun Zhang.
-</para>
-<para lang="en">
-if a proxied or FastCGI request was internally redirected
-to another proxied or FastCGI location,
-then a segmentation fault might occur in a worker process;
-the bug had appeared in 0.8.33.<br/>
-Thanks to Yichun Zhang.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-соединения IMAP к серверу Zimbra могло зависнуть до таймаута.<br/>
-Спасибо Alan Batie.
-</para>
-<para lang="en">
-IMAP connections may hang until they timed out
-while talking to Zimbra server.<br/>
-Thanks to Alan Batie.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.36" date="2010-04-22">
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module неправильно обрабатывал методы DELETE, COPY и MOVE
-для симлинков.
-</para>
-<para lang="en">
-the ngx_http_dav_module handled incorrectly the DELETE, COPY, and MOVE methods
-for symlinks.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль SSI в подзапросах использовал закэшированные в основном запросе
-значения переменных $query_string, $arg_... и им подобных.
-</para>
-<para lang="en">
-values of the $query_string, $arg_..., etc. variables cached in main
-request were used by the SSI module in subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-значение переменной повторно экранировалось после каждого вывода
-SSI-команды echo;
-ошибка появилась в 0.6.14.
-</para>
-<para lang="en">
-a variable value was repeatedly encoded after each
-an "echo" SSI-command output;
-the bug had appeared in 0.6.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочий процесс зависал при запросе файла FIFO.<br/>
-Спасибо Vicente Aguilar и Максиму Дунину.
-</para>
-<para lang="en">
-a worker process hung if a FIFO file was requested.<br/>
-Thanks to Vicente Aguilar and Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с OpenSSL-1.0.0 на 64-битном Linux.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-OpenSSL-1.0.0 compatibility on 64-bit Linux.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http-cache;
-ошибка появилась в 0.8.35.
-</para>
-<para lang="en">
-nginx could not be built --without-http-cache;
-the bug had appeared in 0.8.35.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.35" date="2010-04-01">
-
-<change type="change">
-<para lang="ru">
-теперь charset-фильтр работает до SSI-фильтра.
-</para>
-<para lang="en">
-now the charset filter runs before the SSI filter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива chunked_transfer_encoding.
-</para>
-<para lang="en">
-the "chunked_transfer_encoding" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-символ "&amp;" при копировании в аргументы в правилах rewrite не экранировался.
-</para>
-<para lang="en">
-an "&amp;" character was not escaped when it was copied in arguments part
-in a rewrite rule.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог завершаться аварийно во время обработки сигнала или
-при использовании директивы timer_resolution на платформах,
-не поддерживающих методы kqueue или eventport.<br/>
-Спасибо George Xie и Максиму Дунину.
-</para>
-<para lang="en">
-nginx might be terminated abnormally
-while a signal processing or if the directive "timer_resolution" was used
-on platforms which do not support kqueue or eventport notification methods.<br/>
-Thanks to George Xie and Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если временные файлы и постоянное место хранения располагались на разных
-файловых системах, то у постоянных файлов время изменения было неверным.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-if temporary files and permanent storage area resided at different
-file systems, then permanent file modification times were incorrect.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_memcached_module мог выдавать ошибку "memcached sent invalid
-trailer".<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-ngx_http_memcached_module might issue the error message "memcached sent invalid
-trailer".<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не мог собрать библиотеку zlib-1.2.4 из исходных текстов.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-nginx could not built zlib-1.2.4 library using the library sources.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе происходил segmentation fault,
-если перед ответом FastCGI-сервера было много вывода в stderr;
-ошибка появилась в 0.8.34.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a segmentation fault occurred in a worker process,
-if there was large stderr output before FastCGI response;
-the bug had appeared in 0.8.34.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.34" date="2010-03-03">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал все шифры, используемые в клиентских сертификатах.<br/>
-Спасибо Иннокентию Еникееву.
-</para>
-<para lang="en">
-nginx did not support all ciphers and digests used in client certificates.<br/>
-Thanks to Innocenty Enikeew.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx неправильно кэшировал FastCGI-ответы, если перед ответом было
-много вывода в stderr.
-</para>
-<para lang="en">
-nginx cached incorrectly FastCGI responses if there was large stderr output
-before response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал HTTPS-рефереры.
-</para>
-<para lang="en">
-nginx did not support HTTPS referrers.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows мог не находить файлы, если путь в конфигурации был задан
-в другом регистре;
-ошибка появилась в 0.8.33.
-</para>
-<para lang="en">
-nginx/Windows might not find file if path in configuration was given
-in other character case;
-the bug had appeared in 0.8.33.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $date_local выдавала неверное время,
-если использовался формат "%s".<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the $date_local variable has an incorrect value,
-if the "%s" format was used.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если ssl_session_cache не был установлен или установлен в none,
-то при проверке клиентского сертификаты могла происходить
-ошибка "session id context uninitialized";
-ошибка появилась в 0.7.1.
-</para>
-<para lang="en">
-if ssl_session_cache was not set or was set to "none",
-then during client certificate verify
-the error "session id context uninitialized" might occur;
-the bug had appeared in 0.7.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-geo-диапазон возвращал значение по умолчанию, если диапазон включал
-в себя одну и более сетей размером /16 и не начинался на границе сети
-размером /16.
-</para>
-<para lang="en">
-a geo range returned default value if the range included two or more
-/16 networks and did not begin at /16 network boundary.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-блок, используемый в параметре stub в SSI-директиве include,
-выводился с MIME-типом "text/plain".
-</para>
-<para lang="en">
-a block used in a "stub" parameter of an "include" SSI directive
-was output with "text/plain" MIME type.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-$r->sleep() не работал;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-$r->sleep() did not work;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.33" date="2010-02-01">
-
-<change type="security">
-<para lang="ru">
-теперь nginx/Windows игнорирует пробелы в конце URI.<br/>
-Спасибо Dan Crowley, Core Security Technologies.
-</para>
-<para lang="en">
-now nginx/Windows ignores trailing spaces in URI.<br/>
-Thanks to Dan Crowley, Core Security Technologies.
-</para>
-</change>
-
-<change type="security">
-<para lang="ru">
-теперь nginx/Windows игнорирует короткие имена файлов.<br/>
-Спасибо Dan Crowley, Core Security Technologies.
-</para>
-<para lang="en">
-now nginx/Windows ignores short files names.<br/>
-Thanks to Dan Crowley, Core Security Technologies.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь keepalive соединения после запросов POST не запрещаются для
-MSIE 7.0+.<br/>
-Спасибо Adam Lounds.
-</para>
-<para lang="en">
-now keepalive connections after POST requests are not disabled for
-MSIE 7.0+.<br/>
-Thanks to Adam Lounds.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-теперь keepalive соединения запрещены для Safari.<br/>
-Спасибо Joshua Sierles.
-</para>
-<para lang="en">
-now keepalive connections are disabled for Safari.<br/>
-Thanks to Joshua Sierles.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если проксированный или FastCGI запрос внутренне перенаправлялся
-в другой проксированный или FastCGI location, то переменная
-$upstream_response_time могла иметь ненормально большое значение;
-ошибка появилась в 0.8.7.
-</para>
-<para lang="en">
-if a proxied or FastCGI request was internally redirected
-to another proxied or FastCGI location,
-then $upstream_response_time variable may have abnormally large value;
-the bug had appeared in 0.8.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault
-при отбрасывания тела запроса;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-while discarding a request body;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.32" date="2010-01-11">
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании кодировки UTF-8 в ngx_http_autoindex_module.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-UTF-8 encoding usage in the ngx_http_autoindex_module.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-именованные выделения в регулярных выражениях работали только для
-двух переменных.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-regular expression named captures worked for two names only.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь в строке заголовка запроса "Host" используется имя "localhost",
-если в директиве auth_http указан unix domain сокет.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now the "localhost" name is used in the "Host" request header line,
-if an unix domain socket is defined in the "auth_http" directive.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал передачу chunk'ами для 201-ых ответов.<br/>
-Спасибо Julian Reich.
-</para>
-<para lang="en">
-nginx did not support chunked transfer encoding for 201 responses.<br/>
-Thanks to Julian Reich.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если директива "expires modified" выставляла дату в прошлом, то в строке
-заголовка ответа "Cache-Control" выдавалось отрицательное число.<br/>
-Спасибо Алексею Капранову.
-</para>
-<para lang="en">
-if the "expires modified" set date in the past, then a negative number
-was set in the "Cache-Control" response header line.<br/>
-Thanks to Alex Kapranoff.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.31" date="2009-12-23">
-
-<change type="feature">
-<para lang="ru">
-теперь директива error_page может перенаправлять ответы со статусом 301 и 302.
-</para>
-<para lang="en">
-now the "error_page" directive may redirect the 301 and 302 responses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $geoip_city_continent_code, $geoip_latitude и $geoip_longitude.<br/>
-Спасибо Arvind Sundararajan.
-</para>
-<para lang="en">
-the $geoip_city_continent_code, $geoip_latitude, and $geoip_longitude
-variables.<br/>
-Thanks to Arvind Sundararajan.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_image_filter_module теперь всегда удаляет
-EXIF и другие данные, если они занимают больше 5% в JPEG-файле.
-</para>
-<para lang="en">
-now the ngx_http_image_filter_module deletes always EXIF and other
-application specific data if the data consume more than 5% of a JPEG file.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx закрывал соединение при запросе закэшированного
-ответа с пустым телом.<br/>
-Спасибо Piotr Sikora.
-</para>
-<para lang="en">
-nginx closed a connection if a cached response had an empty body.<br/>
-Thanks to Piotr Sikora.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог не собираться gcc 4.x при использовании оптимизации -O2 и выше.<br/>
-Спасибо Максиму Дунину и Денису Латыпову.
-</para>
-<para lang="en">
-nginx might not be built by gcc 4.x if the -O2 or higher optimization option
-was used.<br/>
-Thanks to Maxim Dounin and Denis F. Latypoff.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-регулярные выражения в location всегда тестировались с учётом регистра;
-ошибка появилась в 0.8.25.
-</para>
-<para lang="en">
-regular expressions in location were always tested in case-sensitive mode;
-the bug had appeared in 0.8.25.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx кэшировал 304 ответ, если в заголовке проксируемого запроса
-была строка "If-None-Match".<br/>
-Спасибо Tim Dettrick и David Kostal.
-</para>
-<para lang="en">
-nginx cached a 304 response if there was the "If-None-Match" header line
-in a proxied request.<br/>
-Thanks to Tim Dettrick and David Kostal.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows пытался дважды удалить временный файл
-при перезаписи уже существующего файла.
-</para>
-<para lang="en">
-nginx/Windows tried to delete a temporary file twice
-if the file should replace an already existent file.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.30" date="2009-12-15">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию размер буфера директивы large_client_header_buffers
-равен 8K.<br/>
-Спасибо Andrew Cholakian.
-</para>
-<para lang="en">
-now the default buffer size of the "large_client_header_buffers"
-directive is 8K.<br/>
-Thanks to Andrew Cholakian.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-файл conf/fastcgi.conf для простых конфигураций FastCGI.
-</para>
-<para lang="en">
-the conf/fastcgi.conf for simple FastCGI configurations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows пытался дважды переименовать временный файл
-при перезаписи уже существующего файла.
-</para>
-<para lang="en">
-nginx/Windows tried to rename a temporary file twice if the file
-should replace an already existent file.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки double free or corruption, возникающей, если имя хоста не было найдено;
-ошибка появилась в 0.8.22.<br/>
-Спасибо Константину Свисту.
-</para>
-<para lang="en">
-of "double free or corruption" error issued if host could not be resolved;
-the bug had appeared in 0.8.22.<br/>
-Thanks to Konstantin Svist.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании libatomic на некоторых платформах.<br/>
-Спасибо W-Mark Kubacki.
-</para>
-<para lang="en">
-in libatomic usage on some platforms.<br/>
-Thanks to W-Mark Kubacki.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.29" date="2009-11-30">
-
-<change type="change">
-<para lang="ru">
-теперь для проксируемых ответов HTTP/0.9 в лог пишется код ответа "009".
-</para>
-<para lang="en">
-now the "009" status code is written to an access log for proxied HTTP/0.9
-responses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы addition_types, charset_types, gzip_types, ssi_types,
-sub_filter_types и xslt_types поддерживают параметр "*".
-</para>
-<para lang="en">
-the "addition_types", "charset_types", "gzip_types", "ssi_types",
-"sub_filter_types", and "xslt_types" directives support an "*" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-использование встроенных атомарных операций GCC 4.1+.<br/>
-Спасибо W-Mark Kubacki.
-</para>
-<para lang="en">
-GCC 4.1+ built-in atomic operations usage.<br/>
-Thanks to W-Mark Kubacki.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр --with-libatomic[=DIR] в configure.<br/>
-Спасибо W-Mark Kubacki.
-</para>
-<para lang="en">
-the --with-libatomic[=DIR] option in the configure.<br/>
-Thanks to W-Mark Kubacki.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-listen unix domain сокет имели ограниченные права доступа.
-</para>
-<para lang="en">
-listen unix domain socket had limited access rights.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-закэшированные ответы ответов HTTP/0.9 неправильно обрабатывались.
-</para>
-<para lang="en">
-cached HTTP/0.9 responses were handled incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-именованные выделения в регулярных выражениях, заданные как "?P&lt;...&gt;",
-не работали в директиве server_name.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-regular expression named captures given by "?P&lt;...&gt;" did not work
-in a "server_name" directive.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.28" date="2009-11-23">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-pcre;
-ошибка появилась в 0.8.25.
-</para>
-<para lang="en">
-nginx could not be built with the --without-pcre parameter;
-the bug had appeared in 0.8.25.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.27" date="2009-11-17">
-
-<change type="bugfix">
-<para lang="ru">
-регулярные выражения не работали в nginx/Windows;
-ошибка появилась в 0.8.25.
-</para>
-<para lang="en">
-regular expressions did not work in nginx/Windows;
-the bug had appeared in 0.8.25.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.26" date="2009-11-16">
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании выделений в директиве rewrite;
-ошибка появилась в 0.8.25.
-</para>
-<para lang="en">
-in captures usage in "rewrite" directive;
-the bug had appeared in 0.8.25.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без параметра --with-debug;
-ошибка появилась в 0.8.25.
-</para>
-<para lang="en">
-nginx could not be built without the --with-debug option;
-the bug had appeared in 0.8.25.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.25" date="2009-11-16">
-
-<change type="change">
-<para lang="ru">
-теперь в лог ошибок не пишется сообщение, если переменная не найдена
-с помощью метода $r->variable().
-</para>
-<para lang="en">
-now no message is written in an error log if a variable is not found by
-$r->variable() method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_degradation_module.
-</para>
-<para lang="en">
-the ngx_http_degradation_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-именованные выделения в регулярных выражениях.
-</para>
-<para lang="en">
-regular expression named captures.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании переменных в директиве proxy_pass не требуется
-задавать URI.
-</para>
-<para lang="en">
-now URI part is not required a "proxy_pass" directive if variables are used.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директива msie_padding работает и для Chrome.
-</para>
-<para lang="en">
-now the "msie_padding" directive works for Chrome too.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе происходил segmentation fault при недостатке памяти;
-ошибка появилась в 0.8.18.
-</para>
-<para lang="en">
-a segmentation fault occurred in a worker process on low memory condition;
-the bug had appeared in 0.8.18.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx передавал сжатые ответы клиентам, не поддерживающим сжатие,
-при настройках gzip_static on и gzip_vary off;
-ошибка появилась в 0.8.16.
-</para>
-<para lang="en">
-nginx sent gzipped responses to clients those do not support gzip,
-if "gzip_static on" and "gzip_vary off";
-the bug had appeared in 0.8.16.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.24" date="2009-11-11">
-
-<change type="bugfix">
-<para lang="ru">
-nginx всегда добавлял строку "Content-Encoding: gzip" в заголовок
-304-ых ответов модуля ngx_http_gzip_static_module.
-</para>
-<para lang="en">
-nginx always added "Content-Encoding: gzip" response header line
-in 304 responses sent by ngx_http_gzip_static_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без параметра --with-debug;
-ошибка появилась в 0.8.23.
-</para>
-<para lang="en">
-nginx could not be built without the --with-debug option;
-the bug had appeared in 0.8.23.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр "unix:" в директиве set_real_ip_from неправильно наследовался
-с предыдущего уровня.
-</para>
-<para lang="en">
-the "unix:" parameter of the "set_real_ip_from" directive inherited
-incorrectly from previous level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в resolver'е при определении пустого имени.
-</para>
-<para lang="en">
-in resolving empty name.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.23" date="2009-11-11">
-
-<change type="security">
-<para lang="ru">
-теперь SSL/TLS renegotiation запрещён.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now SSL/TLS renegotiation is disabled.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-listen unix domain сокет не наследовался во время обновления без перерыва.
-</para>
-<para lang="en">
-listen unix domain socket did not inherit while online upgrade.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр "unix:" в директиве set_real_ip_from не работал без ещё
-одной директивы с любым IP-адресом.
-</para>
-<para lang="en">
-the "unix:" parameter of the "set_real_ip_from" directive did not without
-yet another directive with any IP address.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-segmentation fault и зацикливания в resolver'е.
-</para>
-<para lang="en">
-segmentation fault and infinite looping in resolver.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в resolver'е.<br/>
-Спасибо Артёму Бохану.
-</para>
-<para lang="en">
-in resolver.<br/>
-Thanks to Artem Bokhan.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.22" date="2009-11-03">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_bind, fastcgi_bind и memcached_bind.
-</para>
-<para lang="en">
-the "proxy_bind", "fastcgi_bind", and "memcached_bind" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы access и deny поддерживают IPv6.
-</para>
-<para lang="en">
-the "access" and the "deny" directives support IPv6.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива set_real_ip_from поддерживает IPv6 адреса в заголовках запроса.
-</para>
-<para lang="en">
-the "set_real_ip_from" directive supports IPv6 addresses in request headers.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр "unix:" в директиве set_real_ip_from.
-</para>
-<para lang="en">
-the "unix:" parameter of the "set_real_ip_from" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не удалял unix domain сокет после тестирования конфигурации.
-</para>
-<para lang="en">
-nginx did not delete unix domain socket after configuration testing.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx удалял unix domain сокет во время обновления без перерыва.
-</para>
-<para lang="en">
-nginx deleted unix domain socket while online upgrade.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-оператор "!-x" не работал.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the "!-x" operator did not work.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault
-при использовании limit_rate в HTTPS сервере.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-if limit_rate was used in HTTPS server.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при записи в лог переменной $limit_rate
-в рабочем процессе происходил segmentation fault.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process
-while $limit_rate logging.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если внутри блока server не было директивы listen;
-ошибка появилась в 0.8.21.
-</para>
-<para lang="en">
-a segmentation fault might occur in a worker process,
-if there was no "listen" directive in "server" block;
-the bug had appeared in 0.8.21.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.21" date="2009-10-26">
-
-<change type="feature">
-<para lang="ru">
-теперь ключ -V показывает статус поддержки TLS SNI.
-</para>
-<para lang="en">
-now the "-V" switch shows TLS SNI support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива listen модуля HTTP поддерживает unix domain сокеты.<br/>
-Спасибо Hongli Lai.
-</para>
-<para lang="en">
-the "listen" directive of the HTTP module supports unix domain sockets.<br/>
-Thanks to Hongli Lai.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр "default_server" в директиве listen.
-</para>
-<para lang="en">
-the "default_server" parameter of the "listen" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь параметр "default" не обязателен для установки параметров listen-сокета.
-</para>
-<para lang="en">
-now a "default" parameter is not required to set listen socket options.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал даты в 2038 году на 32-битных платформах;
-</para>
-<para lang="en">
-nginx did not support dates in 2038 year on 32-bit platforms;
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-socket leak;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.20" date="2009-10-14">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию используются следующие шифры SSL: "HIGH:!ADH:!MD5".
-</para>
-<para lang="en">
-now default SSL ciphers are "HIGH:!ADH:!MD5".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module не показывал последний слэш для линков
-на каталоги;
-ошибка появилась в 0.7.15.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not show the trailing slash in links to
-a directory;
-the bug had appeared in 0.7.15.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не закрывал лог, заданный параметром конфигурации --error-log-path;
-ошибка появилась в 0.7.53.
-</para>
-<para lang="en">
-nginx did not close a log file set by the --error-log-path configuration option;
-the bug had appeared in 0.7.53.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не считал запятую разделителем в строке "Cache-Control" в
-заголовке ответа бэкенда.
-</para>
-<para lang="en">
-nginx did not treat a comma as separator in the "Cache-Control" backend response
-header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows мог не создать временный файл, файл в кэше или файл
-с помощью директив proxy/fastcgi_store, если рабочий процесс не имел
-достаточно прав для работы с каталогами верхнего уровня.
-</para>
-<para lang="en">
-nginx/Windows might not create temporary file, a cache file, or
-"proxy/fastcgi_store"d file if a worker had no enough access rights
-for top level directories.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки "Set-Cookie" и "P3P" в заголовке ответа FastCGI-сервера не скрывались
-при кэшировании, если не использовались директивы fastcgi_hide_header
-с любыми параметрами.
-</para>
-<para lang="en">
-the "Set-Cookie" and "P3P" FastCGI response header lines were not hidden
-while caching if no "fastcgi_hide_header" directives were used with
-any parameters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx неверно считал размер кэша на диске.
-</para>
-<para lang="en">
-nginx counted incorrectly disk cache size.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.19" date="2009-10-06">
-
-<change type="change">
-<para lang="ru">
-теперь протокол SSLv2 по умолчанию запрещён.
-</para>
-<para lang="en">
-now SSLv2 protocol is disabled by default.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию используются следующие шифры SSL:
-"ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM".
-</para>
-<para lang="en">
-now default SSL ciphers are "ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива limit_req не работала;
-ошибка появилась в 0.8.18.
-</para>
-<para lang="en">
-a "limit_req" directive did not work;
-the bug had appeared in 0.8.18.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.18" date="2009-10-06">
-
-<change type="feature">
-<para lang="ru">
-директива read_ahead.
-</para>
-<para lang="en">
-the "read_ahead" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь можно использовать несколько директив perl_modules.
-</para>
-<para lang="en">
-now several "perl_modules" directives may be used.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы limit_req_log_level и limit_conn_log_level.
-</para>
-<para lang="en">
-the "limit_req_log_level" and "limit_conn_log_level" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь директива limit_req соответствует алгоритму leaky bucket.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now "limit_req" directive conforms to the leaky bucket algorithm.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на Linux/sparc.<br/>
-Спасибо Marcus Ramberg.
-</para>
-<para lang="en">
-nginx did not work on Linux/sparc.<br/>
-Thanks to Marcus Ramberg.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx слал символ '\0' в строке "Location" в заголовке в ответе на запрос
-MKCOL.<br/>
-Спасибо Xie Zhenye.
-</para>
-<para lang="en">
-nginx sent '\0' in a "Location" response header line on MKCOL request.<br/>
-Thanks to Xie Zhenye.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-вместо кода ответа 499 в лог записывался код 0;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-zero status code was logged instead of 499 status code;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-socket leak;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.17" date="2009-09-28">
-
-<change type="security">
-<para lang="ru">
-теперь символы "/../" запрещены в строке "Destination" в заголовке запроса.
-</para>
-<para lang="en">
-now "/../" are disabled in "Destination" request header line.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь значение переменной $host всегда в нижнем регистре.
-</para>
-<para lang="en">
-now $host variable value is always low case.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_session_id.
-</para>
-<para lang="en">
-the $ssl_session_id variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-socket leak;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.16" date="2009-09-22">
-
-<change type="feature">
-<para lang="ru">
-директива image_filter_transparency.
-</para>
-<para lang="en">
-the "image_filter_transparency" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "addition_types" была неверно названа "addtion_types".
-</para>
-<para lang="en">
-"addition_types" directive was incorrectly named "addtion_types".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-порчи кэша resolver'а.<br/>
-Спасибо Matthew Dempsky.
-</para>
-<para lang="en">
-resolver cache poisoning.<br/>
-Thanks to Matthew Dempsky.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти в resolver'е.<br/>
-Спасибо Matthew Dempsky.
-</para>
-<para lang="en">
-memory leak in resolver.<br/>
-Thanks to Matthew Dempsky.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-неверная строка запроса в переменной $request записывалась в access_log
-только при использовании error_log на уровне info или debug.
-</para>
-<para lang="en">
-invalid request line in $request variable was written in access_log
-only if error_log was set to "info" or "debug" level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в поддержке альфа-канала PNG в модуле ngx_http_image_filter_module.
-</para>
-<para lang="en">
-in PNG alpha-channel support in the ngx_http_image_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx всегда добавлял строку "Vary: Accept-Encoding" в заголовок ответа,
-если обе директивы gzip_static и gzip_vary были включены.
-</para>
-<para lang="en">
-nginx always added "Vary: Accept-Encoding" response header line,
-if both "gzip_static" and "gzip_vary" were on.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в поддержке кодировки UTF-8 директивой try_files в nginx/Windows.
-</para>
-<para lang="en">
-in UTF-8 encoding support by "try_files" directive in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании post_action;
-ошибка появилась в 0.8.11.<br/>
-Спасибо Игорю Артемьеву.
-</para>
-<para lang="en">
-in "post_action" directive usage;
-the bug had appeared in 0.8.11.<br/>
-Thanks to Igor Artemiev.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.15" date="2009-09-14">
-
-<change type="security">
-<para lang="ru">
-при обработке специально созданного запроса
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Chris Ries.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-while specially crafted request handling.<br/>
-Thanks to Chris Ries.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если были описаны имена .domain.tld, .sub.domain.tld и .domain-some.tld,
-то имя .sub.domain.tld попадало под маску .domain.tld.
-</para>
-<para lang="en">
-if names .domain.tld, .sub.domain.tld, and .domain-some.tld were defined,
-then the name .sub.domain.tld was matched by .domain.tld.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в поддержке прозрачности в модуле ngx_http_image_filter_module.
-</para>
-<para lang="en">
-in transparency support in the ngx_http_image_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в файловом AIO.
-</para>
-<para lang="en">
-in file AIO.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании X-Accel-Redirect;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-in X-Accel-Redirect usage;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании встроенного перла;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-in embedded perl module;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.14" date="2009-09-07">
-
-<change type="bugfix">
-<para lang="ru">
-устаревший закэшированный запрос мог залипнуть в состоянии "UPDATING".
-</para>
-<para lang="en">
-an expired cached response might stick in the "UPDATING" state.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании error_log на уровне info или debug
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Сергею Боченкову.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if error_log was set to info or debug level.<br/>
-Thanks to Sergey Bochenkov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании встроенного перла;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-in embedded perl module;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page не перенаправляла ошибку 413;
-ошибка появилась в 0.6.10.
-</para>
-<para lang="en">
-an "error_page" directive did not redirect a 413 error;
-the bug had appeared in 0.6.10.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.13" date="2009-08-31">
-
-<change type="bugfix">
-<para lang="ru">
-в директиве "aio sendfile";
-ошибка появилась в 0.8.12.
-</para>
-<para lang="en">
-in the "aio sendfile" directive;
-the bug had appeared in 0.8.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без параметра --with-file-aio на FreeBSD;
-ошибка появилась в 0.8.12.
-</para>
-<para lang="en">
-nginx could not be built without the --with-file-aio option on FreeBSD;
-the bug had appeared in 0.8.12.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.12" date="2009-08-31">
-
-<change type="feature">
-<para lang="ru">
-параметр sendfile в директиве aio во FreeBSD.
-</para>
-<para lang="en">
-the "sendfile" parameter in the "aio" directive on FreeBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании try_files;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-in try_files;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании memcached;
-ошибка появилась в 0.8.11.
-</para>
-<para lang="en">
-in memcached;
-the bug had appeared in 0.8.11.
-</para>
-</change>
-
-</changes>
-
-<changes ver="0.8.11" date="2009-08-28">
-
-<change type="change">
-<para lang="ru">
-теперь директива "gzip_disable msie6" не запрещает сжатие для
-<nobr>MSIE 6.0 SV1.</nobr>
-</para>
-<para lang="en">
-now directive "gzip_disable msie6" does not disable gzipping for
-<nobr>MSIE 6.0 SV1.</nobr>
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка файлового AIO во FreeBSD и Linux.
-</para>
-<para lang="en">
-file AIO support on FreeBSD and Linux.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива directio_alignment.
-</para>
-<para lang="en">
-the "directio_alignment" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.10" date="2009-08-24">
-
-<change type="bugfix">
-<para lang="ru">
-утечек памяти при использовании базы GeoIP City.
-</para>
-<para lang="en">
-memory leaks if GeoIP City database was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при копировании временных файлов в постоянное место хранения;
-ошибка появилась в 0.8.9.
-</para>
-<para lang="en">
-in copying temporary files to permanent storage area;
-the bug had appeared in 0.8.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.9" date="2009-08-17">
-
-<change type="feature">
-<para lang="ru">
-теперь стартовый загрузчик кэша работает в отдельном процесс;
-это должно улучшить обработку больших кэшей.
-</para>
-<para lang="en">
-now the start cache loader runs in a separate process;
-this should improve large caches handling.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь временные файлы и постоянное место хранения могут располагаться
-на разных файловых системах.
-</para>
-<para lang="en">
-now temporary files and permanent storage area may reside at
-different file systems.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.8" date="2009-08-10">
-
-<change type="bugfix">
-<para lang="ru">
-в обработке заголовков ответа, разделённых в FastCGI-записях.
-</para>
-<para lang="en">
-in handling FastCGI headers split in records.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если запрос обрабатывался в двух проксированных или FastCGI location'ах
-и в первом из них использовалось кэширование,
-то в рабочем процессе происходил segmentation fault;
-ошибка появилась в 0.8.7.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if a request was handled in two proxied or FastCGIed locations
-and a caching was enabled in the first location;
-the bug had appeared in 0.8.7.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.7" date="2009-07-27">
-
-<change type="change">
-<para lang="ru">
-минимальная поддерживаемая версия OpenSSL&mdash;0.9.7.
-</para>
-<para lang="en">
-minimum supported OpenSSL version is 0.9.7.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметр ask директивы ssl_verify_client изменён на параметр optional
-и теперь он проверяет клиентский сертификат, если он был предложен.<br/>
-Спасибо Brice Figureau.
-</para>
-<para lang="en">
-the "ask" parameter of the "ssl_verify_client" directive was changed
-to the "optional" parameter and now it checks a client certificate if it was
-offered.<br/>
-Thanks to Brice Figureau.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_client_verify.<br/>
-Спасибо Brice Figureau.
-</para>
-<para lang="en">
-the $ssl_client_verify variable.<br/>
-Thanks to Brice Figureau.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_crl.<br/>
-Спасибо Brice Figureau.
-</para>
-<para lang="en">
-the "ssl_crl" directive.<br/>
-Thanks to Brice Figureau.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр proxy директивы geo.
-</para>
-<para lang="en">
-the "proxy" parameter of the "geo" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива image_filter поддерживает переменные для задания размеров.
-</para>
-<para lang="en">
-the "image_filter" directive supports variables for setting size.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-использование переменной $ssl_client_cert портило память;
-ошибка появилась в 0.7.7.<br/>
-Спасибо Сергею Журавлёву.
-</para>
-<para lang="en">
-the $ssl_client_cert variable usage corrupted memory;
-the bug had appeared in 0.7.7.<br/>
-Thanks to Sergey Zhuravlev.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_pass_header и fastcgi_pass_header" не передавали клиенту
-строки "X-Accel-Redirect", "X-Accel-Limit-Rate", "X-Accel-Buffering" и
-"X-Accel-Charset" из заголовка ответа бэкенда.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-"proxy_pass_header" and "fastcgi_pass_header" directives did not pass to
-a client the "X-Accel-Redirect", "X-Accel-Limit-Rate", "X-Accel-Buffering",
-and "X-Accel-Charset" lines from backend response header.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке строк "Last-Modified" и "Accept-Ranges" в заголовке ответа бэкенда;
-ошибка появилась в 0.7.44.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in handling "Last-Modified" and "Accept-Ranges" backend response header lines;
-the bug had appeared in 0.7.44.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "[alert] zero size buf" при получении пустых ответы в подзапросах;
-ошибка появилась в 0.8.5.
-</para>
-<para lang="en">
-the "[alert] zero size buf" error if subrequest returns an empty response;
-the bug had appeared in 0.8.5.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.6" date="2009-07-20">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_geoip_module.
-</para>
-<para lang="en">
-the ngx_http_geoip_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-XSLT-фильтр мог выдавать ошибку "not well formed XML document" для
-правильного документа.<br/>
-Спасибо Kuramoto Eiji.
-</para>
-<para lang="en">
-XSLT filter may fail with message "not well formed XML document"
-for valid XML document.<br/>
-Thanks to Kuramoto Eiji.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в MacOSX, Cygwin и nginx/Windows при проверке location'ов, заданных
-регулярным выражением, теперь всегда делается сравнение без учёта
-регистра символов.
-</para>
-<para lang="en">
-now in MacOSX, Cygwin, and nginx/Windows locations given by a regular
-expression are always tested in case insensitive mode.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx/Windows игнорирует точки в конце URI.<br/>
-Спасибо Hugo Leisink.
-</para>
-<para lang="en">
-now nginx/Windows ignores trailing dots in URI.<br/>
-Thanks to Hugo Leisink.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-имя файла указанного в --conf-path игнорировалось при установке;
-ошибка появилась в 0.6.6.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-name of file specified in --conf-path was not honored during installation;
-the bug had appeared in 0.6.6.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.5" date="2009-07-13">
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx разрешает подчёркивания в методе запроса.
-</para>
-<para lang="en">
-now nginx allows underscores in a request method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTP Basic-аутентификации на Windows
-для неверных имени/пароля возвращалась 500-ая ошибка.
-</para>
-<para lang="en">
-a 500 error code was returned for invalid login/password while HTTP
-Basic authentication on Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы модуля ngx_http_perl_module не работали в подзапросах.
-</para>
-<para lang="en">
-ngx_http_perl_module responses did not work in subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_limit_req_module.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in ngx_http_limit_req_module.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.4" date="2009-06-22">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http-cache;
-ошибка появилась в 0.8.3.
-</para>
-<para lang="en">
-nginx could not be built --without-http-cache;
-the bug had appeared in 0.8.3.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.3" date="2009-06-19">
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_cache_status.
-</para>
-<para lang="en">
-the $upstream_cache_status variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на MacOSX 10.6.
-</para>
-<para lang="en">
-nginx could not be built on MacOSX 10.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http-cache;
-ошибка появилась в 0.8.2.
-</para>
-<para lang="en">
-nginx could not be built --without-http-cache;
-the bug had appeared in 0.8.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовался перехват 401 ошибки от бэкенда и бэкенд
-не возвращал строку "WWW-Authenticate" в заголовке ответа,
-то в рабочем процессе происходил segmentation fault.<br/>
-Спасибо Евгению Мычло.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if a backend 401 error was intercepted and the backend did not set
-the "WWW-Authenticate" response header line.<br/>
-Thanks to Eugene Mychlo.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.2" date="2009-06-15">
-
-<change type="bugfix">
-<para lang="ru">
-во взаимодействии open_file_cache и proxy/fastcgi кэша на старте.
-</para>
-<para lang="en">
-in open_file_cache and proxy/fastcgi cache interaction on start up.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-open_file_cache мог кэшировать открытые файлы очень долго;
-ошибка появилась в 0.7.4.
-</para>
-<para lang="en">
-open_file_cache might cache open file descriptors too long;
-the bug had appeared in 0.7.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.1" date="2009-06-08">
-
-<change type="feature">
-<para lang="ru">
-параметр updating в директивах proxy_cache_use_stale и fastcgi_cache_use_stale.
-</para>
-<para lang="en">
-the "updating" parameter in "proxy_cache_use_stale" and
-"fastcgi_cache_use_stale" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки "If-Modified-Since", "If-Range" и им подобные в заголовке запроса
-клиента передавались бэкенду при кэшировании, если не использовалась
-директива proxy_set_header с любыми параметрами.
-</para>
-<para lang="en">
-the "If-Modified-Since", "If-Range", etc. client request header lines
-were passed to backend while caching if no "proxy_set_header" directive
-was used with any parameters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки "Set-Cookie" и "P3P" в заголовке ответа бэкенда не скрывались
-при кэшировании, если не использовались директивы
-proxy_hide_header/fastcgi_hide_header с любыми параметрами.
-</para>
-<para lang="en">
-the "Set-Cookie" and "P3P" response header lines were not hidden while caching
-if no "proxy_hide_header/fastcgi_hide_header" directives were used with
-any parameters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_image_filter_module не понимал формат GIF87a.<br/>
-Спасибо Денису Ильиных.
-</para>
-<para lang="en">
-the ngx_http_image_filter_module did not support GIF87a format.<br/>
-Thanks to Denis Ilyinyh.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris 10 и более ранних;
-ошибка появилась в 0.7.56.
-</para>
-<para lang="en">
-nginx could not be built modules on Solaris 10 and early;
-the bug had appeared in 0.7.56.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.8.0" date="2009-06-02">
-
-<change type="feature">
-<para lang="ru">
-директива keepalive_requests.
-</para>
-<para lang="en">
-the "keepalive_requests" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива limit_rate_after.<br/>
-Спасибо Ivan Debnar.
-</para>
-<para lang="en">
-the "limit_rate_after" directive.<br/>
-Thanks to Ivan Debnar.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-XSLT-фильтр не работал в подзапросах.
-</para>
-<para lang="en">
-XLST filter did not work in subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-обработке относительных путей в nginx/Windows.
-</para>
-<para lang="en">
-in relative paths handling in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в proxy_store, fastcgi_store, proxy_cache и fastcgi_cache в nginx/Windows.
-</para>
-<para lang="en">
-in proxy_store, fastcgi_store, proxy_cache, and fastcgi_cache in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке ошибок выделения памяти.<br/>
-Спасибо Максиму Дунину и Кириллу Коринскому.
-</para>
-<para lang="en">
-in memory allocation error handling.<br/>
-Thanks to Maxim Dounin and Kirill A. Korinskiy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.59" date="2009-05-25">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_cache_methods и fastcgi_cache_methods.
-</para>
-<para lang="en">
-the "proxy_cache_methods" and "fastcgi_cache_methods" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов;
-ошибка появилась в 0.7.25.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-socket leak;
-the bug had appeared in 0.7.25.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменной $request_body
-в рабочем процессе происходил segmentation fault,
-если в запросе не было тела;
-ошибка появилась в 0.7.58.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-<nobr>if a request</nobr> had no body and the $request_body
-variable was used;<br/>
-the bug had appeared in 0.7.58.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSL-модули могли не собираться на Solaris и Linux;
-ошибка появилась в 0.7.56.
-</para>
-<para lang="en">
-the SSL modules might not built on Solaris and Linux;<br/>
-the bug had appeared in 0.7.56.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы модуля ngx_http_xslt_filter_module не обрабатывались
-SSI-, charset- и gzip-фильтрами.
-</para>
-<para lang="en">
-ngx_http_xslt_filter_module responses were not handled by SSI, charset,
-and gzip filters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива charset не ставила кодировку для ответов модуля
-ngx_http_gzip_static_module.
-</para>
-<para lang="en">
-a "charset" directive did not set a charset to ngx_http_gzip_static_module
-responses.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.58" date="2009-05-18">
-
-<change type="feature">
-<para lang="ru">
-директива listen почтового прокси-сервера поддерживает IPv6.
-</para>
-<para lang="en">
-a "listen" directive of the mail proxy module supports IPv6.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива image_filter_jpeg_quality.
-</para>
-<para lang="en">
-the "image_filter_jpeg_quality" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива client_body_in_single_buffer.
-</para>
-<para lang="en">
-the "client_body_in_single_buffer" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $request_body.
-</para>
-<para lang="en">
-the $request_body variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_autoindex_module в ссылках на имена файлов,
-содержащих символ ":".
-</para>
-<para lang="en">
-in ngx_http_autoindex_module in file name links
-having a ":" symbol in the name.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-процедура "make upgrade" не работала;
-ошибка появилась в 0.7.53.<br/>
-Спасибо Денису Латыпову.
-</para>
-<para lang="en">
-"make upgrade" procedure did not work;
-the bug had appeared in 0.7.53.<br/>
-Thanks to Denis F. Latypoff.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.57" date="2009-05-12">
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении ошибок модуля ngx_http_image_filter_module
-в именованный location в рабочем процессе происходил floating-point fault;
-ошибка появилась в 0.7.56.
-</para>
-<para lang="en">
-a floating-point fault occurred in worker process,
-if the ngx_http_image_filter_module errors were redirected to named location;
-the bug had appeared in 0.7.56.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.56" date="2009-05-11">
-
-<change type="feature">
-<para lang="ru">
-nginx/Windows поддерживает IPv6 в директиве listen модуля HTTP.
-</para>
-<para lang="en">
-nginx/Windows supports IPv6 in a "listen" directive of the HTTP module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_image_filter_module.
-</para>
-<para lang="en">
-in ngx_http_image_filter_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.55" date="2009-05-06">
-
-<change type="bugfix">
-<para lang="ru">
-параметры http_XXX в директивах proxy_cache_use_stale
-и fastcgi_cache_use_stale не работали.
-</para>
-<para lang="en">
-the http_XXX parameters in "proxy_cache_use_stale" and
-"fastcgi_cache_use_stale" directives did not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-fastcgi кэш не кэшировал ответы, состоящие только из заголовка.
-</para>
-<para lang="en">
-fastcgi cache did not cache header only responses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "select() failed (9: Bad file descriptor)" в nginx/Unix
-и "select() failed (10038: ...)" в nginx/Windows.
-</para>
-<para lang="en">
-of "select() failed (9: Bad file descriptor)" error in nginx/Unix
-and "select() failed (10038: ...)" error in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы debug_connection
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.7.54.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if an "debug_connection" directive was used;
-the bug had appeared in 0.7.54.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в сборке модуля ngx_http_image_filter_module.
-</para>
-<para lang="en">
-fix ngx_http_image_filter_module building errors.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-файлы больше 2G не передавались с использованием $r->sendfile.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the files bigger than 2G could not be transferred using $r->sendfile.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.54" date="2009-05-01">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_image_filter_module.
-</para>
-<para lang="en">
-the ngx_http_image_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_ignore_headers и fastcgi_ignore_headers.
-</para>
-<para lang="en">
-the "proxy_ignore_headers" and "fastcgi_ignore_headers" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменных "open_file_cache_errors on"
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.7.53.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if an "open_file_cache_errors off" directive was used;
-the bug had appeared in 0.7.53.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "port_in_redirect off" не работала;
-ошибка появилась в 0.7.39.
-</para>
-<para lang="en">
-the "port_in_redirect off" directive did not work;
-the bug had appeared in 0.7.39.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-улучшение обработки ошибок метода select.
-</para>
-<para lang="en">
-improve handling of "select" method errors.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "select() failed (10022: ...)" в nginx/Windows.
-</para>
-<para lang="en">
-of "select() failed (10022: ...)" error in nginx/Windows.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в текстовых сообщениях об ошибках в nginx/Windows;
-ошибка появилась в 0.7.53.
-</para>
-<para lang="en">
-in error text descriptions in nginx/Windows;
-the bug had appeared in 0.7.53.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.53" date="2009-04-27">
-
-<change type="change">
-<para lang="ru">
-теперь лог, указанный в --error-log-path, создаётся с самого начала работы.
-</para>
-<para lang="en">
-now a log set by --error-log-path is created from the very start-up.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь ошибки и предупреждения при старте записываются в error_log
-и выводятся на stderr.
-</para>
-<para lang="en">
-now the start up errors and warnings are outputted to an error_log and stderr.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-при сборке с пустым параметром --prefix= nginx использует как префикс каталог,
-в котором он был запущен.
-</para>
-<para lang="en">
-the empty --prefix= configure parameter forces nginx to use a directory
-where it was run as prefix.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -p.
-</para>
-<para lang="en">
-the -p switch.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -s на Unix-платформах.
-</para>
-<para lang="en">
-the -s switch on Unix platforms.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключи -? и -h.<br/>
-Спасибо Jerome Loyet.
-</para>
-<para lang="en">
-the -? and -h switches.<br/>
-Thanks to Jerome Loyet.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь ключи можно задавать в сжатой форме.
-</para>
-<para lang="en">
-now switches may be set in condensed form.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx/Windows не работал, если файл конфигурации был задан ключом -c.
-</para>
-<para lang="en">
-nginx/Windows did not work if configuration file was given by the -c switch.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив proxy_store, fastcgi_store,
-proxy_cache или fastcgi_cache временные файлы могли не удаляться.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-temporary files might be not removed if the "proxy_store", "fastcgi_store",
-"proxy_cache", or "fastcgi_cache" were used.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в заголовке Auth-Method запроса серверу аутентификации почтового
-прокси-сервера передавалось неверное значение;
-ошибка появилась в 0.7.34.<br/>
-Спасибо Simon Lecaille.
-</para>
-<para lang="en">
-an incorrect value was passed to mail proxy authentication server
-in "Auth-Method" header line;
-the bug had appeared<br/>
-in 0.7.34.<br/>
-Thanks to Simon Lecaille.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при логгировании на Linux не писались текстовые описания системных ошибок;
-ошибка появилась в 0.7.45.
-</para>
-<para lang="en">
-system error text descriptions were not logged on Linux;<br/>
-the bug had appeared in 0.7.45.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива fastcgi_cache_min_uses не работала.<br/>
-Спасибо Андрею Воробьёву.
-</para>
-<para lang="en">
-the "fastcgi_cache_min_uses" directive did not work.<br/>
-Thanks to Andrew Vorobyoff.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.52" date="2009-04-20">
-
-<change type="feature">
-<para lang="ru">
-первая бинарная версия под Windows.
-</para>
-<para lang="en">
-the first native Windows binary release.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-корректная обработка метода HEAD при кэшировании.
-</para>
-<para lang="en">
-in processing HEAD method while caching.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-корректная обработка строк "If-Modified-Since", "If-Range" и им подобных
-в заголовке запроса клиента при кэшировании.
-</para>
-<para lang="en">
-in processing the "If-Modified-Since", "If-Range", etc. client request
-header lines while caching.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь строки "Set-Cookie" и "P3P" скрываются в заголовке ответа
-для закэшированных ответов.
-</para>
-<para lang="en">
-now the "Set-Cookie" and "P3P" header lines are hidden in cacheable responses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_perl_module и perl
-поддерживал потоки, то при выходе основного процесса
-могла выдаваться ошибка "panic: MUTEX_LOCK".
-</para>
-<para lang="en">
-if nginx was built with the ngx_http_perl_module and with a perl which
-supports threads, then during a master process exit
-the message "panic: MUTEX_LOCK" might be issued.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http-cache;
-ошибка появилась в 0.7.48.
-</para>
-<para lang="en">
-nginx could not be built --without-http-cache;
-the bug had appeared in 0.7.48.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформах, отличных от i386, amd64, sparc и ppc;
-ошибка появилась в 0.7.42.
-</para>
-<para lang="en">
-nginx could not be built on platforms different from i386, amd64, sparc,
-and ppc;
-the bug had appeared in 0.7.42.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.51" date="2009-04-12">
-
-<change type="feature">
-<para lang="ru">
-директива try_files поддерживает код ответа в последнем параметре.
-</para>
-<para lang="en">
-the "try_files" directive supports a response code in the fallback parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь в директиве return можно использовать любой код ответа.
-</para>
-<para lang="en">
-now any response code can be used in the "return" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page делала внешний редирект без строки запроса;
-ошибка появилась в 0.7.44.
-</para>
-<para lang="en">
-the "error_page" directive made an external redirect without query string;
-the bug had appeared in 0.7.44.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервера слушали на нескольких явно описанных адресах,
-то виртуальные сервера могли не работать;
-ошибка появилась в 0.7.39.
-</para>
-<para lang="en">
-if servers listened on several defined explicitly addresses,
-then virtual servers might not work;
-the bug had appeared in 0.7.39.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.50" date="2009-04-06">
-
-<change type="bugfix">
-<para lang="ru">
-переменные $arg_... не работали;
-ошибка появилась в 0.7.49.
-</para>
-<para lang="en">
-the $arg_... variables did not work;
-the bug had appeared in 0.7.49.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.49" date="2009-04-06">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменных $arg_...
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.7.48.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if the $arg_... variables were used;
-the bug had appeared in 0.7.48.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.48" date="2009-04-06">
-
-<change type="feature">
-<para lang="ru">
-директива proxy_cache_key.
-</para>
-<para lang="en">
-the "proxy_cache_key" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx учитывает при кэшировании строки "X-Accel-Expires",
-"Expires" и "Cache-Control" в заголовке ответа бэкенда.
-</para>
-<para lang="en">
-now nginx takes into account the "X-Accel-Expires", "Expires", and
-"Cache-Control" header lines in a backend response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx кэширует только ответы на запросы GET.
-</para>
-<para lang="en">
-now nginx caches responses for the GET requests only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива fastcgi_cache_key не наследовалась.
-</para>
-<para lang="en">
-the "fastcgi_cache_key" directive was not inherited.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные $arg_... не работали с SSI-подзапросами.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the $arg_... variables did not work with SSI subrequests.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с библиотекой uclibc.<br/>
-Спасибо Timothy Redaelli.
-</para>
-<para lang="en">
-nginx could not be built with uclibc library.<br/>
-Thanks to Timothy Redaelli.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на OpenBSD;
-ошибка появилась <nobr>в 0.7.46.</nobr>
-</para>
-<para lang="en">
-nginx could not be built on OpenBSD;
-the bug had <nobr>appeared in 0.7.46.</nobr>
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.47" date="2009-04-01">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на FreeBSD 6 и более ранних версиях;
-ошибка появилась в 0.7.46.
-</para>
-<para lang="en">
-nginx could not be built on FreeBSD 6 and early versions;
-the bug had appeared in 0.7.46.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на MacOSX;
-ошибка появилась в 0.7.46.
-</para>
-<para lang="en">
-nginx could not be built on MacOSX;
-the bug had <nobr>appeared in 0.7.46.</nobr>
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовался параметр max_size, то cache manager мог удалить весь кэш;
-ошибка появилась в 0.7.46.
-</para>
-<para lang="en">
-if the "max_size" parameter was set, then the cache manager might purge
-a whole cache;
-the bug had appeared in 0.7.46.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если директивы proxy_cache/fastcgi_cache
-и proxy_cache_valid/ fastcgi_cache_valid не были заданы на одном уровне;
-ошибка появилась в 0.7.46.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if the "proxy_cache"/"fastcgi_cache" and
-the "proxy_cache_valid"/ "fastcgi_cache_valid" were set on different levels;
-the bug had appeared in 0.7.46.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault
-при перенаправлении запроса проксированному или FastCGI-серверу
-с помощью error_page или try_files;
-ошибка появилась в 0.7.44.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if a request was redirected to a proxied or FastCGI server via
-error_page or try_files;
-the bug had appeared in 0.7.44.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.46" date="2009-03-30">
-
-<change type="bugfix">
-<para lang="ru">
-архив предыдущего релиза был неверным.
-</para>
-<para lang="en">
-the previous release tarball was incorrect.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.45" date="2009-03-30">
-
-<change type="change">
-<para lang="ru">
-теперь директивы proxy_cache и proxy_cache_valid можно задавать
-на разных уровнях.
-</para>
-<para lang="en">
-now the "proxy_cache" and the "proxy_cache_valid" directives can be set on
-different levels.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметр clean_time в директиве proxy_cache_path удалён.
-</para>
-<para lang="en">
-the "clean_time" parameter of the "proxy_cache_path" directive is canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр max_size в директиве proxy_cache_path.
-</para>
-<para lang="en">
-the "max_size" parameter of the "proxy_cache_path" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-предварительная поддержка кэширования в модуле ngx_http_fastcgi_module.
-</para>
-<para lang="en">
-the ngx_http_fastcgi_module preliminary cache support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при ошибках выделения в разделяемой памяти в логе указываются
-названия директивы и зоны.
-</para>
-<para lang="en">
-now on shared memory allocation errors directive and zone names are logged.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "add_header last-modified ''" не удаляла в заголовке ответа
-строку "Last-Modified";
-ошибка появилась в 0.7.44.
-</para>
-<para lang="en">
-the directive "add_header last-modified ''" did not delete a "Last-Modified"
-response header line;
-the bug had appeared in 0.7.44.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве auth_basic_user_file не работал относительный путь,
-заданный строкой без переменных;
-ошибка появилась в 0.7.44.<br/>
-Спасибо Jerome Loyet.
-</para>
-<para lang="en">
-a relative path in the "auth_basic_user_file" directive given without variables
-did not work;
-the bug had appeared in 0.7.44.<br/>
-Thanks to Jerome Loyet.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве alias, заданной переменными
-без ссылок на выделения в регулярных выражениях;
-ошибка появилась в 0.7.42.
-</para>
-<para lang="en">
-in an "alias" directive given using variables
-without references to captures of regular expressions;
-the bug had appeared in 0.7.42.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.44" date="2009-03-23">
-
-<change type="feature">
-<para lang="ru">
-предварительная поддержка кэширования в модуле ngx_http_proxy_module.
-</para>
-<para lang="en">
-the ngx_http_proxy_module preliminary cache support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр --with-pcre в configure.
-</para>
-<para lang="en">
-the --with-pcre option in the configure.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директива try_files может быть использована на уровне server.
-</para>
-<para lang="en">
-the "try_files" directive is now allowed on the server block level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива try_files неправильно обрабатывала строку запроса в последнем
-параметре.
-</para>
-<para lang="en">
-the "try_files" directive handled incorrectly a query string
-in a fallback parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива try_files могла неверно тестировать каталоги.
-</para>
-<para lang="en">
-the "try_files" directive might test incorrectly directories.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если для пары адрес:порт описан только один сервер, то выделения
-в регулярных выражениях в директиве server_name не работали.
-</para>
-<para lang="en">
-if there was a single server for given address:port pair,
-then captures in regular expressions in a "server_name" directive did not work.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.43" date="2009-03-18">
-
-<change type="bugfix">
-<para lang="ru">
-запрос обрабатывался неверно, если директива root использовала переменные;
-ошибка появилась в 0.7.42.
-</para>
-<para lang="en">
-a request was handled incorrectly, if a "root" directive used variables;
-the bug had appeared in 0.7.42.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервер слушал на адресах типа "*", то значение переменной $server_addr
-было "0.0.0.0";
-ошибка появилась в 0.7.36.
-</para>
-<para lang="en">
-if a server listened on wildcard address, then the $server_addr variable
-value was "0.0.0.0";
-the bug had appeared in 0.7.36.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.42" date="2009-03-16">
-
-<change type="change">
-<para lang="ru">
-ошибка "Invalid argument", возвращаемая setsockopt(TCP_NODELAY) на Solaris,
-теперь игнорируется.
-</para>
-<para lang="en">
-now the "Invalid argument" error returned by setsockopt(TCP_NODELAY) on Solaris,
-is ignored.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при отсутствии файла, указанного в директиве auth_basic_user_file,
-теперь возвращается ошибка 403 вместо 500.
-</para>
-<para lang="en">
-now if a file specified in a "auth_basic_user_file" directive is absent,
-then the 403 error is returned instead of the 500 one.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива auth_basic_user_file поддерживает переменные.
-<br/>
-Спасибо Кириллу Коринскому.
-</para>
-<para lang="en">
-the "auth_basic_user_file" directive supports variables.<br/>
-Thanks to Kirill A. Korinskiy.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива listen поддерживает параметр ipv6only.<br/>
-Спасибо Zhang Hua.
-</para>
-<para lang="en">
-the "listen" directive supports the "ipv6only" parameter.
-<br/>
-Thanks to Zhang Hua.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве alias со ссылками на выделения в регулярных выражениях;
-ошибка появилась в 0.7.40.
-</para>
-<para lang="en">
-in an "alias" directive with references to captures of regular expressions;
-the bug had appeared in 0.7.40.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с Tru64 UNIX.<br/>
-Спасибо Dustin Marquess.
-</para>
-<para lang="en">
-compatibility with Tru64 UNIX.<br/>
-Thanks to Dustin Marquess.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без библиотеки PCRE;
-ошибка появилась в 0.7.41.
-</para>
-<para lang="en">
-nginx could not be built without PCRE library;
-the bug had appeared in 0.7.41.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.41" date="2009-03-11">
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если в server_name или location были выделения в регулярных выражениях;
-ошибка появилась в 0.7.40.<br/>
-Спасибо Владимиру Сопоту.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if a "server_name" or a "location" directives had captures
-in regular expressions;
-the issue had appeared in 0.7.40.<br/>
-Thanks to Vladimir Sopot.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.40" date="2009-03-09">
-
-<change type="feature">
-<para lang="ru">
-директива location поддерживает выделения в регулярных выражениях.
-</para>
-<para lang="en">
-the "location" directive supports captures in regular expressions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву alias с ссылками на выделения в регулярных выражениях
-можно использовать внутри location'а, заданного регулярным выражением
-с выделениями.
-</para>
-<para lang="en">
-an "alias" directive with capture references may be used inside
-a location given by a regular expression with captures.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server_name поддерживает выделения в регулярных выражениях.
-</para>
-<para lang="en">
-the "server_name" directive supports captures in regular expressions.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-модуль ngx_http_autoindex_module не показывал последний слэш для каталогов
-на файловой системе XFS;
-ошибка появилась в 0.7.15.<br/>
-Спасибо Дмитрию Кузьменко.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not show the trailing slash in directories
-on XFS filesystem;
-the issue had appeared in 0.7.15.<br/>
-Thanks to Dmitry Kuzmenko.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.39" date="2009-03-02">
-
-<change type="bugfix">
-<para lang="ru">
-при включённом сжатии большие ответы с использованием SSI могли зависать;
-ошибка появилась в 0.7.28.<br/>
-Спасибо Артёму Бохану.
-</para>
-<para lang="en">
-large response with SSI might hang, if gzipping was enabled;
-the bug had appeared in 0.7.28.<br/>
-Thanks to Artem Bokhan.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании коротких статических вариантов в директиве try_files
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process,
-if short static variants are used in a "try_files" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.38" date="2009-02-23">
-
-<change type="feature">
-<para lang="ru">
-логгирование ошибок аутентификации.
-</para>
-<para lang="en">
-authentication failures logging.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-имя/пароль, заданные в auth_basic_user_file, игнорировались после нечётного
-числа пустых строк.<br/>
-Спасибо Александру Загребину.
-</para>
-<para lang="en">
-name/password in auth_basic_user_file were ignored after odd number
-of empty lines.<br/>
-Thanks to Alexander Zagrebin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании длинного пути в unix domain сокете
-в главном процессе происходил segmentation fault;
-ошибка появилась в 0.7.36.
-</para>
-<para lang="en">
-a segmentation fault occurred in a master process,
-if long path was used in unix domain socket;
-the bug had appeared in 0.7.36.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.37" date="2009-02-21">
-
-<change type="bugfix">
-<para lang="ru">
-директивы, использующие upstream'ы, не работали;
-ошибка появилась в 0.7.36.
-</para>
-<para lang="en">
-directives using upstreams did not work;
-the bug had appeared in 0.7.36.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.36" date="2009-02-21">
-
-<change type="feature">
-<para lang="ru">
-предварительная поддержка IPv6;
-директива listen модуля HTTP поддерживает IPv6.
-</para>
-<para lang="en">
-a preliminary IPv6 support;
-the "listen" directive of the HTTP module supports IPv6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $ancient_browser не работала для браузеров, заданных
-директивами modern_browser.
-</para>
-<para lang="en">
-the $ancient_browser variable did not work for browsers
-preset by a "modern_browser" directives.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.35" date="2009-02-16">
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_engine не использовала SSL-акселератор
-для асимметричных шифров.<br/>
-Спасибо Marcin Gozdalik.
-</para>
-<para lang="en">
-a "ssl_engine" directive did not use a SSL-accelerator
-for asymmetric ciphers.<br/>
-Thanks to Marcin Gozdalik.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива try_files выставляла MIME-type, исходя из расширения
-первоначального запроса.
-</para>
-<para lang="en">
-a "try_files" directive set MIME type depending on an
-original request extension.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директивах server_name, valid_referers и map
-неправильно обрабатывались имена вида "*domain.tld",
-если использовались маски вида ".domain.tld" и ".subdomain.domain.tld";
-ошибка появилась в 0.7.9.
-</para>
-<para lang="en">
-"*domain.tld" names were handled incorrectly in
-"server_name", "valid_referers", and "map" directives,
-if ".domain.tld" and ".subdomain.domain.tld" wildcards were used;
-<nobr>the bug had</nobr> appeared in 0.7.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.34" date="2009-02-10">
-
-<change type="feature">
-<para lang="ru">
-параметр off в директиве if_modified_since.
-</para>
-<para lang="en">
-the "off" parameter of the "if_modified_since" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь после команды XCLIENT nginx посылает команду HELO/EHLO.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now nginx sends an HELO/EHLO command after a XCLIENT command.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка Microsoft-специфичного режима
-<nobr>"AUTH LOGIN with User Name"</nobr>
-в почтовом прокси-сервере.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-Microsoft specific "AUTH LOGIN with User Name" mode support
-in mail proxy server.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве rewrite, возвращающей редирект, старые аргументы присоединялись
-к новым через символ "?" вместо "&amp;";<br/>
-ошибка появилась в 0.1.18.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in a redirect rewrite directive original arguments were concatenated with
-new arguments by a "?" rather than an "&amp;";<br/>
-the bug had appeared in 0.1.18.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на AIX.
-</para>
-<para lang="en">
-nginx could not be built on AIX.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.33" date="2009-02-02">
-
-<change type="bugfix">
-<para lang="ru">
-если на запрос с телом возвращался редирект, то ответ мог быть двойным
-при использовании методов epoll или rtsig.<br/>
-Спасибо Eden Li.
-</para>
-<para lang="en">
-a double response might be returned if the epoll or rtsig methods are used
-and a redirect was returned to a request with body.<br/>
-Thanks to Eden Li.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-для некоторых типов редиректов в переменной $sent_http_location
-было пустое значение.
-</para>
-<para lang="en">
-the $sent_http_location variable was empty for some redirects types.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы resolver в SMTP прокси-сервере
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if "resolver" directive was used in SMTP proxy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.32" date="2009-01-26">
-
-<change type="feature">
-<para lang="ru">
-теперь в директиве try_files можно явно указать проверку каталога.
-</para>
-<para lang="en">
-now a directory existence testing can be set explicitly
-in the "try_files" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-fastcgi_store не всегда сохранял файлы.
-</para>
-<para lang="en">
-fastcgi_store stored files not always.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в гео-диапазонах.
-</para>
-<para lang="en">
-in geo ranges.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки выделения больших блоков в разделяемой памяти,
-если nginx был собран без отладки.<br/>
-Спасибо Андрею Квасову.
-</para>
-<para lang="en">
-in shared memory allocations if nginx was built without debugging.<br/>
-Thanks to Andrey Kvasov.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.31" date="2009-01-19">
-
-<change type="change">
-<para lang="ru">
-теперь директива try_files проверяет только файлы, игнорируя каталоги.
-</para>
-<para lang="en">
-now the "try_files" directive tests files only and ignores directories.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_split_path_info.
-</para>
-<para lang="en">
-the "fastcgi_split_path_info" directive.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправления в поддержке строки "Expect" в заголовке запроса.
-</para>
-<para lang="en">
-Bugfixes in an "Expect" request header line support.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправления в гео-диапазонах.
-</para>
-<para lang="en">
-Bugfixes in geo ranges.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при отсутствии ответа ngx_http_memcached_module возвращал
-в теле ответа строку "END" вместо 404-ой страницы по умолчанию;
-ошибка появилась в 0.7.18.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-in a miss case ngx_http_memcached_module returned the "END" line
-as response body instead of default 404 page body;
-the bug had appeared in 0.7.18.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании SMTP nginx выдавал сообщение
-<nobr>"250 2.0.0 OK"</nobr> вместо "235 2.0.0 OK";
-ошибка появилась в 0.7.22.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-while SMTP proxying nginx issued message
-"250 2.0.0 OK" instead of "235 2.0.0 OK";
-the bug had appeared in 0.7.22.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-
-<changes ver="0.7.30" date="2008-12-24">
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе происходил segmentation fault,
-если в директивах fastcgi_pass или proxy_pass
-использовались переменные и имя хоста должно было резолвиться;
-ошибка появилась в 0.7.29.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if variables were used in the "fastcgi_pass" or "proxy_pass" directives
-and host name must be resolved;
-the bug had appeared in 0.7.29.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.29" date="2008-12-24">
-
-<change type="bugfix">
-<para lang="ru">
-директивы fastcgi_pass и proxy_pass не поддерживали переменные
-при использовании unix domain сокетов.
-</para>
-<para lang="en">
-the "fastcgi_pass" and "proxy_pass" directives did not support
-variables if unix domain sockets were used.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправления в обработке подзапросов;
-ошибки появились в 0.7.25.
-</para>
-<para lang="en">
-Bugfixes in subrequest processing;
-the bugs had appeared in 0.7.25.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ "100 Continue" выдавался для запросов версии HTTP/1.0;<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a "100 Continue" response was issued for HTTP/1.0 requests;<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в выделении памяти в модуле ngx_http_gzip_filter_module под Cygwin.
-</para>
-<para lang="en">
-in memory allocation in the ngx_http_gzip_filter_module on Cygwin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.28" date="2008-12-22">
-
-<change type="change">
-<para lang="ru">
-в выделении памяти в модуле ngx_http_gzip_filter_module.
-</para>
-<para lang="en">
-in memory allocation in the ngx_http_gzip_filter_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-значения по умолчанию для директивы gzip_buffers изменены с 4 4k/8k
-на 32 4k или 16 8k.
-</para>
-<para lang="en">
-the default "gzip_buffers" directive values have been changed
-to 32 4k or 16 8k from 4 4k/8k.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.27" date="2008-12-15">
-
-<change type="feature">
-<para lang="ru">
-директива try_files.
-</para>
-<para lang="en">
-the "try_files" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_pass поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "fastcgi_pass" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директива geo может брать адрес из переменной.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-now the $geo variable may get an address from a variable.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь модификатор location'а можно указывать без пробела перед названием.
-</para>
-<para lang="en">
-now a location's modifier may be used without space before name.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_response_length.
-</para>
-<para lang="en">
-the $upstream_response_length variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь директива add_header не добавляет пустое значение.
-</para>
-<para lang="en">
-now a "add_header" directive does not add an empty value.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при запросе файла нулевой длины nginx закрывал соединение, ничего не передав;
-ошибка появилась в 0.7.25.
-</para>
-<para lang="en">
-if zero length static file was requested, then nginx just closed connection;
-the bug had appeared in 0.7.25.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод MOVE не мог перемещать файл в несуществующий каталог.
-</para>
-<para lang="en">
-a MOVE method could not move file in non-existent directory.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в сервере не был описан ни один именованный location,
-но такой location использовался в директиве error_page,
-то в рабочем процессе происходил segmentation fault.<br/>
-Спасибо Сергею Боченкову.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if no one named location was defined in server,
-but some one was used in an error_page directive.<br/>
-Thanks to Sergey Bochenkov.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.26" date="2008-12-08">
-
-<change type="bugfix">
-<para lang="ru">
-в обработке подзапросов;
-ошибка появилась в 0.7.25.
-</para>
-<para lang="en">
-in subrequest processing;
-the bug had appeared in 0.7.25.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.25" date="2008-12-08">
-
-<change type="change">
-<para lang="ru">
-в обработке подзапросов.
-</para>
-<para lang="en">
-in subrequest processing.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь разрешаются POST'ы без строки "Content-Length" в заголовке запроса.
-</para>
-<para lang="en">
-now POSTs without "Content-Length" header line are allowed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь директивы limit_req и limit_conn указывают причину запрета запроса.
-</para>
-<para lang="en">
-now the "limit_req" and "limit_conn" directives log a prohibition reason.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в параметре delete директивы geo.
-</para>
-<para lang="en">
-in the "delete" parameter of the "geo" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.24" date="2008-12-01">
-
-<change type="feature">
-<para lang="ru">
-директива if_modified_since.
-</para>
-<para lang="en">
-the "if_modified_since" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не обрабатывал ответ FastCGI-сервера,
-если перед ответом сервер передавал много сообщений в stderr.
-</para>
-<para lang="en">
-nginx did not process a FastCGI server response,
-if the server send too many messages to stderr before response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные "$cookie_..." не работали в SSI and в перловом модуле.
-</para>
-<para lang="en">
-the "$cookie_..." variables did not work in the SSI and the perl module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.23" date="2008-11-27">
-
-<change type="feature">
-<para lang="ru">
-параметры delete и ranges в директиве geo.
-</para>
-<para lang="en">
-the "delete" and "ranges" parameters in the "geo" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ускорение загрузки geo-базы с большим числом значений.
-</para>
-<para lang="en">
-speeding up loading of geo base with large number of values.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-уменьшение памяти, необходимой для загрузки geo-базы.
-</para>
-<para lang="en">
-decrease of memory required for geo base load.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.22" date="2008-11-20">
-
-<change type="feature">
-<para lang="ru">
-параметр none в директиве smtp_auth.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the "none" parameter in the "smtp_auth" directive.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные "$cookie_...".
-</para>
-<para lang="en">
-the "$cookie_..." variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива directio не работала с файловой системой XFS.
-</para>
-<para lang="en">
-the "directio" directive did not work in XFS filesystem.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-resolver не понимал большие DNS-ответы.<br/>
-Спасибо Zyb.
-</para>
-<para lang="en">
-the resolver did not understand big DNS responses.<br/>
-Thanks to Zyb.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.21" date="2008-11-11">
-
-<change>
-<para lang="ru">
-Изменения в модуле ngx_http_limit_req_module.
-</para>
-<para lang="en">
-Changes in the ngx_http_limit_req_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка EXSLT в модуле ngx_http_xslt_module.<br/>
-Спасибо Денису Латыпову.
-</para>
-<para lang="en">
-the EXSLT support in the ngx_http_xslt_module.<br/>
-Thanks to Denis F. Latypoff.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-совместимость с glibc 2.3.<br/>
-Спасибо Eric Benson и Максиму Дунину.
-</para>
-<para lang="en">
-compatibility with glibc 2.3.<br/>
-Thanks to Eric Benson and Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не запускался на MacOSX 10.4 и более ранних;
-ошибка появилась в 0.7.6.
-</para>
-<para lang="en">
-nginx could not run on MacOSX 10.4 and earlier;
-the bug had appeared in 0.7.6.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.20" date="2008-11-10">
-
-<change>
-<para lang="ru">
-Изменения в модуле ngx_http_gzip_filter_module.
-</para>
-<para lang="en">
-Changes in the ngx_http_gzip_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_limit_req_module.
-</para>
-<para lang="en">
-the ngx_http_limit_req_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на платформах sparc и ppc рабочие процессы могли выходить по сигналу SIGBUS;
-ошибка появилась в 0.7.3.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-worker processes might exit on a SIGBUS signal on sparc and ppc platforms;
-the bug had appeared in 0.7.3.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы вида "proxy_pass http://host/some:uri" не работали;
-ошибка появилась в 0.7.12.
-</para>
-<para lang="en">
-the "proxy_pass http://host/some:uri" directives did not work;
-the bug had appeared in 0.7.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTPS запросы могли завершаться с ошибкой "bad write retry".
-</para>
-<para lang="en">
-in HTTPS mode requests might fail with the "bad write retry" error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_secure_link_module не работал внутри location'ов
-с именами меньше 3 символов.
-</para>
-<para lang="en">
-the ngx_http_secure_link_module did not work inside locations,
-whose names are less than 3 characters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $server_addr могла не иметь значения.
-</para>
-<para lang="en">
-$server_addr variable might have no value.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.19" date="2008-10-13">
-
-<change type="bugfix">
-<para lang="ru">
-обновление номера версии.
-</para>
-<para lang="en">
-version number update.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.18" date="2008-10-13">
-
-<change type="change">
-<para lang="ru">
-директива underscores_in_headers;
-теперь nginx по умолчанию не разрешает подчёркивания в именах строк
-в заголовке запроса клиента.
-</para>
-<para lang="en">
-the "underscores_in_headers" directive;
-now nginx does not allows underscores in a client request header line names.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_secure_link_module.
-</para>
-<para lang="en">
-the ngx_http_secure_link_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива real_ip_header поддерживает любой заголовок.
-</para>
-<para lang="en">
-the "real_ip_header" directive supports any header.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива log_subrequest.
-</para>
-<para lang="en">
-the "log_subrequest" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $realpath_root.
-</para>
-<para lang="en">
-the $realpath_root variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры http_502 и http_504 в директиве proxy_next_upstream.
-</para>
-<para lang="en">
-the "http_502" and "http_504" parameters of the "proxy_next_upstream" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр http_503 в директивах proxy_next_upstream или fastcgi_next_upstream
-не работал.
-</para>
-<para lang="en">
-the "http_503" parameter of the "proxy_next_upstream" or
-"fastcgi_next_upstream" directives did not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx мог выдавать строку "Transfer-Encoding: chunked" для запросов  HEAD.
-</para>
-<para lang="en">
-nginx might send a "Transfer-Encoding: chunked" header line for HEAD requests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь accept-лимит зависит от числа worker_connections.
-</para>
-<para lang="en">
-now accept threshold depends on worker_connections.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.17" date="2008-09-15">
-
-<change type="feature">
-<para lang="ru">
-директива directio теперь работает на Linux.
-</para>
-<para lang="en">
-now the "directio" directive works on Linux.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $pid.
-</para>
-<para lang="en">
-the $pid variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-оптимизация directio, появившаяся в 0.7.15, не работала при использовании
-open_file_cache.
-</para>
-<para lang="en">
-the "directio" optimization that had appeared in 0.7.15 did not work with
-open_file_cache.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-access_log с переменными не работал на Linux;
-ошибка появилась в 0.7.7.
-</para>
-<para lang="en">
-the "access_log" with variables did not work on Linux;
-the bug had appeared in 0.7.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_charset_module не понимал название кодировки в кавычках,
-полученное от бэкенда.
-</para>
-<para lang="en">
-the ngx_http_charset_module did not understand quoted charset name
-received from backend.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.16" date="2008-09-08">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на 64-битных платформах;
-ошибка появилась в 0.7.15.
-</para>
-<para lang="en">
-nginx could not be built on 64-bit platforms;
-the bug had appeared in 0.7.15.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.15" date="2008-09-08">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_random_index_module.
-</para>
-<para lang="en">
-the ngx_http_random_index_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива directio оптимизирована для запросов файлов, начинающихся
-с произвольной позиции.
-</para>
-<para lang="en">
-the "directio" directive has been optimized for file requests starting
-from arbitrary position.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива directio при необходимости запрещает использование sendfile.
-</para>
-<para lang="en">
-the "directio" directive turns off sendfile if it is necessary.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx разрешает подчёркивания в именах строк в заголовке запроса клиента.
-</para>
-<para lang="en">
-now nginx allows underscores in a client request header line names.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.14" date="2008-09-01">
-
-<change type="change">
-<para lang="ru">
-теперь директивы ssl_certificate и ssl_certificate_key не имеют
-значений по умолчанию.
-</para>
-<para lang="en">
-now the ssl_certificate and ssl_certificate_key directives have no
-default values.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива listen поддерживает параметр ssl.
-</para>
-<para lang="en">
-the "listen" directive supports the "ssl" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при переконфигурации nginx учитывает изменение временной зоны
-на FreeBSD и Linux.
-</para>
-<para lang="en">
-now nginx takes into account a time zone change while reconfiguration
-on FreeBSD and Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметры директивы listen, такие как backlog, rcvbuf и прочие,
-не устанавливались, если сервером по умолчанию был не первый сервер.
-</para>
-<para lang="en">
-the "listen" directive parameters such as "backlog", "rcvbuf", etc.
-were not set, if a default server was not the first one.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании в качестве аргументов части URI, выделенного с помощью
-директивы rewrite, эти аргументы не экранировались.
-</para>
-<para lang="en">
-if URI part captured by a "rewrite" directive was used as a query string,
-then the query string was not escaped.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-улучшения тестирования правильности конфигурационного файла.
-</para>
-<para lang="en">
-configuration file validity test improvements.
-</para>
-</change>
-
-
-</changes>
-
-
-<changes ver="0.7.13" date="2008-08-26">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Linux и Solaris;
-ошибка появилась в 0.7.12.
-</para>
-<para lang="en">
-nginx could not be built on Linux and Solaris;
-the bug had appeared in 0.7.12.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.12" date="2008-08-26">
-
-<change type="feature">
-<para lang="ru">
-директива server_name поддерживает пустое имя "".
-</para>
-<para lang="en">
-the "server_name" directive supports empty name "".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива gzip_disable поддерживает специальную маску msie6.
-</para>
-<para lang="en">
-the "gzip_disable" directive supports special "msie6" mask.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании параметра max_fails=0 в upstream'е с несколькими
-серверами рабочий процесс выходил по сигналу SIGFPE.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-if the "max_fails=0" parameter was used in upstream with several servers,
-then a worker process exited on a SIGFPE signal.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении запроса с помощью директивы error_page
-терялось тело запроса.
-</para>
-<para lang="en">
-a request body was dropped while redirection via an "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении запроса с методом HEAD с помощью директивы error_page
-возвращался полный ответ.
-</para>
-<para lang="en">
-a full response was returned for request method HEAD
-while redirection via an "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод $r->header_in() не возвращал значения строк "Host", "User-Agent",
-и "Connection" из заголовка запроса;
-ошибка появилась в 0.7.0.
-</para>
-<para lang="en">
-the $r->header_in() method did not return value of the "Host",
-"User-Agent", and "Connection" request header lines;
-the bug had appeared in 0.7.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.11" date="2008-08-18">
-
-<change type="change">
-<para lang="ru">
-теперь ngx_http_charset_module по умолчанию не работает MIME-типом text/css.
-</para>
-<para lang="en">
-now ngx_http_charset_module does not work by default with text/css MIME type.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx возвращает код 405 для метода POST при запросе статического
-файла, только если файл существует.
-</para>
-<para lang="en">
-now nginx returns the 405 status code for POST method requesting a static file
-only if the file exists.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_ssl_session_reuse.
-</para>
-<para lang="en">
-the "proxy_ssl_session_reuse" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после перенаправления запроса с помощью "X-Accel-Redirect"
-директива proxy_pass без URI могла использовать оригинальный запрос.
-</para>
-<para lang="en">
-a "proxy_pass" directive without URI part might use original request
-after the "X-Accel-Redirect" redirection was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если у каталога были права доступа только на поиск файлов
-и первый индексный файл отсутствовал, то nginx возвращал ошибку 500.
-</para>
-<para lang="en">
-if a directory has search only rights and the first index file was absent,
-then nginx returned the 500 status code.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибок во вложенных location'ах;
-ошибки появились в 0.7.1.
-</para>
-<para lang="en">
-in inclusive locations;
-the bugs had appeared in 0.7.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.10" date="2008-08-13">
-
-<change type="bugfix">
-<para lang="ru">
-ошибок в директивах addition_types, charset_types,
-gzip_types, ssi_types, sub_filter_types и xslt_types;
-ошибки появились в 0.7.9.
-</para>
-<para lang="en">
-in the "addition_types", "charset_types",
-"gzip_types", "ssi_types", "sub_filter_types", and "xslt_types" directives;
-the bugs had appeared in 0.7.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рекурсивной error_page для 500 ошибки.
-</para>
-<para lang="en">
-of recursive error_page for 500 status code.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь модуль ngx_http_realip_module устанавливает адрес не для
-всего keepalive соединения, а для каждого запроса по этому соединению.
-</para>
-<para lang="en">
-now the ngx_http_realip_module sets address not for whole keepalive connection,
-but for each request passed via the connection.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.9" date="2008-08-12">
-
-<change type="change">
-<para lang="ru">
-теперь ngx_http_charset_module по умолчанию работает со следующими MIME-типами:
-text/html, text/css, text/xml, text/plain, text/vnd.wap.wml,
-application/x-javascript и application/rss+xml.
-</para>
-<para lang="en">
-now ngx_http_charset_module works by default with following MIME types:
-text/html, text/css, text/xml, text/plain, text/vnd.wap.wml,
-application/x-javascript, and application/rss+xml.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы charset_types и addition_types.
-</para>
-<para lang="en">
-the "charset_types" and "addition_types" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директивы gzip_types, ssi_types и sub_filter_types используют хэш.
-</para>
-<para lang="en">
-now the "gzip_types", "ssi_types", and "sub_filter_types" directives use hash.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_cpp_test_module.
-</para>
-<para lang="en">
-the ngx_cpp_test_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива expires поддерживает суточное время.
-</para>
-<para lang="en">
-the "expires" directive supports daily time.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшения и исправления в модуле ngx_http_xslt_module.<br/>
-Спасибо Денису Латыпову и Максиму Дунину.
-</para>
-<para lang="en">
-the ngx_http_xslt_module improvements and bug fixing.<br/>
-Thanks to Denis F. Latypoff and Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива log_not_found не работала при поиске индексных файлов.
-</para>
-<para lang="en">
-the "log_not_found" directive did not work for index files tests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-HTTPS-соединения могли зависнуть,
-если использовались методы kqueue, epoll, rtsig или eventport;
-ошибка появилась в 0.7.7.
-</para>
-<para lang="en">
-HTTPS connections might hang,
-if kqueue, epoll, rtsig, or eventport methods were used;
-the bug had appeared in 0.7.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директивах server_name, valid_referers и map
-использовалась маска вида "*.domain.tld" и при этом полное имя
-вида "domain.tld" не было описано, то это имя попадало под маску;
-ошибка появилась в 0.3.18.
-</para>
-<para lang="en">
-if the "server_name", "valid_referers", and "map" directives used
-an "*.domain.tld" wildcard and exact name "domain.tld" was not set,
-then the exact name was matched by the wildcard;
-the bug had appeared in 0.3.18.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.8" date="2008-08-04">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_xslt_module.
-</para>
-<para lang="en">
-the ngx_http_xslt_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные "$arg_...".
-</para>
-<para lang="en">
-the "$arg_..." variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка directio в Solaris.<br/>
-Спасибо Ivan Debnar.
-</para>
-<para lang="en">
-Solaris directio support.<br/>
-Thanks to Ivan Debnar.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь, если FastCGI-сервер присылает строку "Location" в заголовке ответа
-без строки статуса, то nginx использует код статуса 302.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now if FastCGI server sends a "Location" header line without status line,
-then nginx uses 302 status code.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.7" date="2008-07-30">
-
-<change type="change">
-<para lang="ru">
-теперь ошибка EAGAIN при вызове connect() не считается временной.
-</para>
-<para lang="en">
-now the EAGAIN error returned by connect() is not considered as temporary error.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-значением переменной $ssl_client_cert теперь является сертификат,
-перед каждой строкой которого, кроме первой, вставляется символ табуляции;
-неизменённый сертификат доступен через переменную $ssl_client_raw_cert.
-</para>
-<para lang="en">
-now the $ssl_client_cert variable value is a certificate with TAB character
-intended before each line except first one;
-an unchanged certificate is available in the $ssl_client_raw_cert variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр ask директивы ssl_verify_client.
-</para>
-<para lang="en">
-the "ask" parameter in the "ssl_verify_client" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-улучшения в обработке byte-range.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-byte-range processing improvements.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива directio.<br/>
-Спасибо Jiang Hong.
-</para>
-<para lang="en">
-the "directio" directive.<br/>
-Thanks to Jiang Hong.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка sendfile() в MacOSX 10.5.
-</para>
-<para lang="en">
-MacOSX 10.5 sendfile() support.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в MacOSX и Cygwin при проверке location'ов теперь делается сравнение
-без учёта регистра символов;
-однако, сравнение ограничено только однобайтными locale'ями.
-</para>
-<para lang="en">
-now in MacOSX and Cygwin locations are tested in case insensitive mode;
-however, the compare is provided by single-byte locales only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-соединения почтового прокси-сервера зависали в режиме SSL,
-если использовались методы select, poll или /dev/poll.
-</para>
-<para lang="en">
-mail proxy SSL connections hanged,
-if select, poll, or /dev/poll methods were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании кодировки UTF-8 в ngx_http_autoindex_module.
-</para>
-<para lang="en">
-UTF-8 encoding usage in the ngx_http_autoindex_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.6" date="2008-07-07">
-
-<change type="bugfix">
-<para lang="ru">
-теперь при использовании переменных в директиве access_log
-всегда проверяется существовании root'а для запроса.
-</para>
-<para lang="en">
-now if variables are used in the "access_log" directive
-a request root existence is always tested.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_flv_module не поддерживал несколько значений в
-аргументах запроса.
-</para>
-<para lang="en">
-the ngx_http_flv_module did not support several values in a query string.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.5" date="2008-07-01">
-
-<change>
-<para lang="ru">
-Исправления в поддержке переменных в директиве access_log;
-ошибки появились в 0.7.4.
-</para>
-<para lang="en">
-Bugfixes in variables support in the "access_log" directive;
-the bugs had appeared in 0.7.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http_gzip_module;
-ошибка появилась в 0.7.3.<br/>
-Спасибо Кириллу Коринскому.
-</para>
-<para lang="en">
-nginx could not be built --without-http_gzip_module;
-the bug had appeared in 0.7.3.<br/>
-Thanks to Kirill A. Korinskiy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при совместном использовании sub_filter и SSI
-ответы могли передаваться неверно.
-</para>
-<para lang="en">
-if sub_filter and SSI were used together, then responses might
-were transferred incorrectly.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.4" date="2008-06-30">
-
-<change type="feature">
-<para lang="ru">
-директива access_log поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "access_log" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива open_log_file_cache.
-</para>
-<para lang="en">
-the "open_log_file_cache" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -g.
-</para>
-<para lang="en">
-the -g switch.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка строки "Expect" в заголовке запроса.
-</para>
-<para lang="en">
-the "Expect" request header line support.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-большие включения в SSI могли передавались не полностью.
-</para>
-<para lang="en">
-large SSI inclusions might be truncated.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.3" date="2008-06-23">
-
-<change type="change">
-<para lang="ru">
-MIME-тип для расширения rss изменён на "application/rss+xml".
-</para>
-<para lang="en">
-the "rss" extension MIME type has been changed to "application/rss+xml".
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь директива "gzip_vary on" выдаёт строку
-<nobr>"Vary: Accept-Encoding"</nobr>
-в заголовке ответа и для несжатых ответов.
-</para>
-<para lang="en">
-now the "gzip_vary" directive turned on issues
-a <nobr>"Vary: Accept-Encoding"</nobr>
-header line for uncompressed responses too.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при использовании протокола "https://" в директиве rewrite
-автоматически делается редирект.
-</para>
-<para lang="en">
-now the "rewrite" directive does a redirect automatically
-if the "https://" protocol is used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_pass не работала с протоколом HTTPS;
-ошибка появилась в 0.6.9.
-</para>
-<para lang="en">
-the "proxy_pass" directive did not work with the HTTPS protocol;
-the bug had appeared in 0.6.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.2" date="2008-06-16">
-
-<change type="feature">
-<para lang="ru">
-теперь nginx поддерживает шифры с обменом EDH-ключами.
-</para>
-<para lang="en">
-now nginx supports EDH key exchange ciphers.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_dhparam.
-</para>
-<para lang="en">
-the "ssl_dhparam" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_client_cert.<br/>
-Спасибо Manlio Perillo.
-</para>
-<para lang="en">
-the $ssl_client_cert variable.<br/>
-Thanks to Manlio Perillo.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после изменения URI с помощью директивы rewrite nginx не искал новый location;
-ошибка появилась в 0.7.1.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-after changing URI via a "rewrite" directive nginx did not search
-a new location;
-the bug had appeared in 0.7.1.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без библиотеки PCRE;
-ошибка появилась в 0.7.1.
-</para>
-<para lang="en">
-nginx could not be built without PCRE library;
-the bug had appeared in 0.7.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при редиректе запроса к каталогу с добавлением слэша nginx
-не добавлял аргументы из оригинального запроса.
-</para>
-<para lang="en">
-when a request to a directory was redirected with the slash added,
-nginx dropped a query string from the original request.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.1" date="2008-05-26">
-
-<change type="change">
-<para lang="ru">
-теперь поиск location'а делается с помощью дерева.
-</para>
-<para lang="en">
-now locations are searched in a tree.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива optimize_server_names упразднена в связи с появлением
-директивы server_name_in_redirect.
-</para>
-<para lang="en">
-the "optimize_server_names" directive was canceled
-due to the "server_name_in_redirect" directive introduction.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-некоторые давно устаревшие директивы больше не поддерживаются.
-</para>
-<para lang="en">
-some long deprecated directives are not supported anymore.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметр "none" в директиве ssl_session_cache;
-теперь этот параметр используется по умолчанию.<br/>
-Спасибо Rob Mueller.
-</para>
-<para lang="en">
-the "none" parameter in the "ssl_session_cache" directive;
-now this is default parameter.<br/>
-Thanks to Rob Mueller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочие процессы могли не реагировать на сигналы переконфигурации
-и ротации логов.
-</para>
-<para lang="en">
-worker processes might not catch reconfiguration and log rotation signals.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на последних Fedora 9 Linux.<br/>
-Спасибо Roxis.
-</para>
-<para lang="en">
-nginx could not be built on latest Fedora 9 Linux.<br/>
-Thanks to Roxis.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.7.0" date="2008-05-19">
-
-<change type="change">
-<para lang="ru">
-теперь символы 0x00-0x1F, '"' и '\' в access_log записываются в виде \xXX.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now the 0x00-0x1F, '"' and '\' characters are escaped as \xXX in an
-access_log.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь nginx разрешает несколько строк "Host" в заголовке запроса.
-</para>
-<para lang="en">
-now nginx allows several "Host" request header line.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива expires поддерживает флаг modified.
-</para>
-<para lang="en">
-the "modified" flag in the "expires" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $uid_got и $uid_set можно использовать на любой стадии обработки
-запроса.
-</para>
-<para lang="en">
-the $uid_got and $uid_set variables may be used at any request processing stage.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $hostname.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-the $hostname variable.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка DESTDIR.<br/>
-Спасибо Todd A. Fisher и Andras Voroskoi.
-</para>
-<para lang="en">
-DESTDIR support.<br/>
-Thanks to Todd A. Fisher and Andras Voroskoi.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании keepalive на Linux
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process on Linux,
-if keepalive was enabled.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.31" date="2008-05-12">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не обрабатывал ответ FastCGI-сервера, если строка заголовка ответа была
-в конце записи FastCGI;
-ошибка появилась в 0.6.2.<br/>
-Спасибо Сергею Серову.
-</para>
-<para lang="en">
-nginx did not process FastCGI response
-if header was at the end of FastCGI record;
-the bug had appeared in 0.6.2.<br/>
-Thanks to Sergey Serov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при удалении файла и использовании директивы open_file_cache_errors off
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process if a file was deleted
-and the "open_file_cache_errors" directive was off.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.30" date="2008-04-29">
-
-<change type="change">
-<para lang="ru">
-теперь, если маске, заданной в директиве include, не соответствует
-ни один файл, то nginx не выдаёт ошибку.
-</para>
-<para lang="en">
-now if an "include" directive pattern does not match any file,
-then nginx does not issue an error.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь время в директивах можно задавать без пробела, например, "1h50m".
-</para>
-<para lang="en">
-now the time in directives may be specified without spaces,
-for example, "1h50m".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечек памяти, если директива ssl_verify_client имела значение on.<br/>
-Спасибо Chavelle Vincent.
-</para>
-<para lang="en">
-memory leaks if the "ssl_verify_client" directive was on.<br/>
-Thanks to Chavelle Vincent.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива sub_filter могла вставлять заменяемый текст в вывод.
-</para>
-<para lang="en">
-the "sub_filter" directive might set text to change into output.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page не воспринимала параметры в перенаправляемом URI.
-</para>
-<para lang="en">
-the "error_page" directive did not take into account arguments in
-redirected URI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь при сборке с Cygwin nginx всегда открывает файлы в бинарном режиме.
-</para>
-<para lang="en">
-now nginx always opens files in binary mode under Cygwin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под OpenBSD;
-ошибка появилась в 0.6.15.
-</para>
-<para lang="en">
-nginx could not be built on OpenBSD;
-the bug had appeared in 0.6.15.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.29" date="2008-03-18">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_google_perftools_module.
-</para>
-<para lang="en">
-the ngx_google_perftools_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_perl_module не собирался на 64-битных платформах;
-ошибка появилась в 0.6.27.
-</para>
-<para lang="en">
-the ngx_http_perl_module could not be built on 64-bit platforms;
-the bug had appeared in 0.6.27.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.28" date="2008-03-13">
-
-<change type="bugfix">
-<para lang="ru">
-метод rtsig не собирался;
-ошибка появилась в 0.6.27.
-</para>
-<para lang="en">
-the rtsig method could not be built;
-the bug had appeared in 0.6.27.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.27" date="2008-03-12">
-
-<change type="change">
-<para lang="ru">
-теперь на Linux 2.6.18+ по умолчанию не собирается метод rtsig.
-</para>
-<para lang="en">
-now by default the rtsig method is not built on <nobr>Linux 2.6.18+.</nobr>
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при перенаправлении запроса в именованный location с помощью
-директивы error_page метод запроса не изменяется.
-</para>
-<para lang="en">
-now a request method is not changed while redirection to a named location
-via an "error_page" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы resolver и resolver_timeout в SMTP прокси-сервере.
-</para>
-<para lang="en">
-the "resolver" and "resolver_timeout" directives in SMTP proxy.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива post_action поддерживает именованные location'ы.
-</para>
-<para lang="en">
-the "post_action" directive supports named locations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении запроса из location'а c обработчиком proxy, FastCGI
-или memcached в именованный location со статическим обработчиком
-в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if a request was redirected from proxy, FastCGI, or memcached location
-to static named locations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-браузеры не повторяли SSL handshake, если при первом handshake
-не оказалось правильного клиентского сертификата.
-<br/>
-Спасибо Александру Инюхину.
-</para>
-<para lang="en">
-browsers did not repeat SSL handshake if there is no valid client certificate
-in first handshake.
-<br/>
-Thanks to Alexander V. Inyukhin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении ошибок 495-497 с помощью директивы error_page
-без изменения кода ошибки nginx пытался выделить очень много памяти.
-</para>
-<para lang="en">
-if response code 495-497 was redirected via an "error_page" directive
-without code change, then nginx tried to allocate too many memory.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти в долгоживущих небуфферизированных соединениях.
-</para>
-<para lang="en">
-memory leak in long-lived non buffered connections.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки памяти в resolver'е.
-</para>
-<para lang="en">
-memory leak in resolver.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении запроса из location'а c обработчиком proxy
-в другой location с обработчиком proxy
-в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if a request was redirected from proxy, FastCGI, or memcached location
-to static named locations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в кэшировании переменных $proxy_host и $proxy_port.<br/>
-Спасибо Сергею Боченкову.
-</para>
-<para lang="en">
-in the $proxy_host and $proxy_port variables caching.<br/>
-Thanks to Sergey Bochenkov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива proxy_pass с переменными использовала порт, описанной в другой
-директиве proxy_pass без переменных, но с таким же именем хоста.<br/>
-Спасибо Сергею Боченкову.
-</para>
-<para lang="en">
-a "proxy_pass" directive with variables used incorrectly the same port
-as in another "proxy_pass" directive with the same host name
-and without variables.<br/>
-Thanks to Sergey Bochenkov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-во время переконфигурации на некоторых 64-битном платформах в лог
-записывался alert "sendmsg() failed (9: Bad file descriptor)".
-</para>
-<para lang="en">
-an alert "sendmsg() failed (9: Bad file descriptor)" on some 64-bit platforms
-while reconfiguration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при повторном использовании в SSI пустого block'а в качестве заглушки
-в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if empty stub block was used second time in SSI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при копировании части URI, содержащего экранированные символы,
-в аргументы.
-</para>
-<para lang="en">
-in copying URI part contained escaped symbols into arguments.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.26" date="2008-02-11">
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_store и fastcgi_store не проверяли длину ответа.
-</para>
-<para lang="en">
-the "proxy_store" and "fastcgi_store" directives did not check
-a response length.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании большого значения в директиве expires
-в рабочем процессе происходил segmentation fault.<br/>
-Спасибо Joaquin Cuenca Abela.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if big value was used in a "expires" directive.<br/>
-Thanks to Joaquin Cuenca Abela.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx неверно определял длину строки кэша на <nobr>Pentium 4.</nobr><br/>
-Спасибо Геннадию Махомеду.
-</para>
-<para lang="en">
-nginx incorrectly detected cache line size on Pentium 4.<br/>
-Thanks to Gena Makhomed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в проксированных подзапросах и подзапросах к FastCGI-серверу
-вместо метода GET использовался оригинальный метод клиента.
-</para>
-<para lang="en">
-in proxied or FastCGI subrequests a client original method was used
-instead of the GET method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов в режиме HTTPS при использовании отложенного accept'а.<br/>
-Спасибо Ben Maurer.
-</para>
-<para lang="en">
-socket leak in HTTPS mode if deferred accept was used.<br/>
-Thanks to Ben Maurer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx выдавал ошибочное сообщение "SSL_shutdown() failed (SSL: )";
-ошибка появилась в 0.6.23.
-</para>
-<para lang="en">
-nginx issued the bogus error message "SSL_shutdown() failed (SSL: )";
-the bug had appeared in 0.6.23.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTPS запросы могли завершаться с ошибкой "bad write retry";
-ошибка появилась в 0.6.23.
-</para>
-<para lang="en">
-in HTTPS mode requests might fail with the "bad write retry" error;
-the bug had appeared in 0.6.23.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.25" date="2008-01-08">
-
-<change type="change">
-<para lang="ru">
-вместо специального параметра "*" в директиве server_name теперь
-используется директива server_name_in_redirect.
-</para>
-<para lang="en">
-now the "server_name_in_redirect" directive is used instead of
-the "server_name" directive's special "*" parameter.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в качестве основного имени в директиве server_name теперь
-можно использовать имена с масками и регулярными выражениями.
-</para>
-<para lang="en">
-now wildcard and regex names can be used as main name in
-a "server_name" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива satisfy_any заменена директивой satisfy.
-</para>
-<para lang="en">
-the "satisfy_any" directive was replaced by the "satisfy" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-после переконфигурации старые рабочие процесс могли сильно нагружать процессор
-при запуске под Linux OpenVZ.
-</para>
-<para lang="en">
-old worker processes might hog CPU after reconfiguration if they was run
-under Linux OpenVZ.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива min_delete_depth.
-</para>
-<para lang="en">
-the "min_delete_depth" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-методы COPY и MOVE не работали с одиночными файлами.
-</para>
-<para lang="en">
-the COPY and MOVE methods did not work with single files.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_gzip_static_module не позволял работать модулю
-ngx_http_dav_module;
-ошибка появилась в 0.6.23.
-</para>
-<para lang="en">
-the ngx_http_gzip_static_module did not allow the ngx_http_dav_module to work;
-the bug had appeared in 0.6.23.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов в режиме HTTPS при использовании отложенного accept'а.<br/>
-Спасибо Ben Maurer.
-</para>
-<para lang="en">
-socket leak in HTTPS mode if deferred accept was used.<br/>
-Thanks to Ben Maurer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без библиотеки PCRE;
-ошибка появилась в 0.6.23.
-</para>
-<para lang="en">
-nginx could not be built without PCRE library;
-the bug had appeared in 0.6.23.
-</para>
-</change>
-
-</changes>
-
-<changes ver="0.6.24" date="2007-12-27">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTPS в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.6.23.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process if HTTPS was used;
-the bug had appeared in 0.6.23.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.23" date="2007-12-27">
-
-<change type="change">
-<para lang="ru">
-параметр "off" в директиве ssl_session_cache;
-теперь этот параметр используется по умолчанию.
-</para>
-<para lang="en">
-the "off" parameter in the "ssl_session_cache" directive;
-now this is default parameter.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива open_file_cache_retest переименована в open_file_cache_valid.
-</para>
-<para lang="en">
-the "open_file_cache_retest" directive was renamed
-to the "open_file_cache_valid".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива open_file_cache_min_uses.
-</para>
-<para lang="en">
-the "open_file_cache_min_uses" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_gzip_static_module.
-</para>
-<para lang="en">
-the ngx_http_gzip_static_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива gzip_disable.
-</para>
-<para lang="en">
-the "gzip_disable" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву memcached_pass можно использовать внутри блока if.
-</para>
-<para lang="en">
-the "memcached_pass" directive may be used inside the "if" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если внутри одного location'а использовались директивы "memcached_pass" и "if",
-то в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if the "memcached_pass" and "if" directives were used in the same location.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании директивы satisfy_any on" были заданы директивы
-не всех модулей доступа, то заданные директивы не проверялись.
-</para>
-<para lang="en">
-if a "satisfy_any on" directive was used and not all access and auth modules
-directives were set, then other given access and auth directives
-were not tested;
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметры, заданные регулярным выражением в директиве valid_referers,
-не наследовалась с предыдущего уровня.
-</para>
-<para lang="en">
-regex parameters in a "valid_referers" directive were not inherited
-from previous level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива post_action не работала, если запрос завершался с кодом 499.
-</para>
-<para lang="en">
-a "post_action" directive did run if a request was completed
-with 499 status code.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-оптимизация использования 16K буфера для SSL-соединения.<br/>
-Спасибо Ben Maurer.
-</para>
-<para lang="en">
-optimization of 16K buffer usage in a SSL connection.<br/>
-Thanks to Ben Maurer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-STARTTLS в режиме SMTP не работал.<br/>
-Спасибо Олегу Мотиенко.
-</para>
-<para lang="en">
-the STARTTLS in SMTP mode did not work.<br/>
-Thanks to Oleg Motienko.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании HTTPS запросы могли завершаться с ошибкой "bad write retry";
-ошибка появилась в 0.5.13.
-</para>
-<para lang="en">
-in HTTPS mode requests might fail with the "bad write retry" error;
-the bug had appeared in 0.5.13.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.22" date="2007-12-19">
-
-<change type="change">
-<para lang="ru">
-теперь все методы модуля ngx_http_perl_module
-возвращают значения, скопированные в память, выделенную perl'ом.
-</para>
-<para lang="en">
-now all ngx_http_perl_module methods return values copied to perl's
-allocated memory.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_perl_module,
-использовался perl до версии 5.8.6 и perl поддерживал потоки,
-то во время переконфигурации основной процесс аварийно выходил;
-ошибка появилась в 0.5.9.<br/>
-Спасибо Борису Жмурову.
-</para>
-<para lang="en">
-if nginx was built with ngx_http_perl_module,
-the perl before 5.8.6 was used, and perl supported threads,
-then during reconfiguration the master process aborted;
-the bug had appeared in 0.5.9.<br/>
-Thanks to Boris Zhmurov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в методы модуля ngx_http_perl_module
-могли передаваться неверные результаты выделения в регулярных выражениях.
-</para>
-<para lang="en">
-the ngx_http_perl_module methods may get invalid values of the regex captures.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если метод $r->has_request_body() вызывался для запроса,
-у которого небольшое тело запроса было уже полностью получено,
-то в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process,
-if the $r->has_request_body() method was called for a request
-whose small request body was already received.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-large_client_header_buffers не освобождались перед переходом в состояние
-keep-alive.<br/>
-Спасибо Олександру Штепе.
-</para>
-<para lang="en">
-large_client_header_buffers did not freed before going to keep-alive state.<br/>
-Thanks to Olexander Shtepa.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в переменной $upstream_addr не записывался последний адрес;
-ошибка появилась в 0.6.18.
-</para>
-<para lang="en">
-the last address was missed in the $upstream_addr variable;
-the bug had appeared in 0.6.18.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива fastcgi_catch_stderr не возвращала ошибку;
-теперь она возвращает ошибку 502, которую можно направить на следующий сервер
-с помощью "fastcgi_next_upstream invalid_header".
-</para>
-<para lang="en">
-the "fastcgi_catch_stderr" directive did return error code;
-now it returns 502 code, that can be rerouted to a next server using
-the "fastcgi_next_upstream invalid_header" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы fastcgi_catch_stderr
-в основном процессе происходил segmentation fault;
-ошибка появилась в 0.6.10.<br/>
-Спасибо Manlio Perillo.
-</para>
-<para lang="en">
-a segmentation fault occurred in master process
-if the "fastcgi_catch_stderr" directive was used;
-the bug had appeared in 0.6.10.<br/>
-Thanks to Manlio Perillo.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.21" date="2007-12-03">
-
-<change type="change">
-<para lang="ru">
-если в значениях переменных директивы proxy_pass используются
-только IP-адреса, то указывать resolver не нужно.
-</para>
-<para lang="en">
-if variable values used in a "proxy_pass" directive contain IP-addresses only,
-then a "resolver" directive is not mandatory.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы proxy_pass c URI-частью
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.6.19.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if a "proxy_pass" directive with URI-part was used;
-the bug had appeared in 0.6.19.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если resolver использовался на платформах, не поддерживающих метод kqueue,
-то nginx выдавал alert "name is out of response".<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-if resolver was used on platform that does not support kqueue,
-then nginx issued an alert "name is out of response".<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-При использовании переменной $server_protocol в FastCGI-параметрах
-и запросе, длина которого была близка к значению директивы
-client_header_buffer_size,
-nginx выдавал alert "fastcgi: the request record is too big".
-</para>
-<para lang="en">
-if the $server_protocol was used in FastCGI parameters
-and a request line length was near to the "client_header_buffer_size"
-directive value,
-then nginx issued an alert "fastcgi: the request record is too big".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при обычном запросе версии HTTP/0.9 к HTTPS серверу nginx возвращал
-обычный ответ.
-</para>
-<para lang="en">
-if a plain text HTTP/0.9 version request was made to HTTPS server,
-then nginx returned usual response.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.20" date="2007-11-28">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы proxy_pass c URI-частью
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.6.19.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if a "proxy_pass" directive with URI-part was used;
-the bug had appeared in 0.6.19.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.19" date="2007-11-27">
-
-<change type="bugfix">
-<para lang="ru">
-версия 0.6.18 не собиралась.
-</para>
-<para lang="en">
-the 0.6.18 version could not be built.
-</para>
-</change>
-
-</changes>
-
-<changes ver="0.6.18" date="2007-11-27">
-
-<change type="change">
-<para lang="ru">
-теперь модуль ngx_http_userid_module в поле куки с номером процесса
-добавляет микросекунды на время старта.
-</para>
-<para lang="en">
-now the ngx_http_userid_module adds start time microseconds
-to the cookie field contains a pid value.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в error_log теперь записывается полная строка запроса вместо только URI.
-</para>
-<para lang="en">
-now the full request line instead of URI only is written to error_log.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_pass поддерживает переменные.
-</para>
-<para lang="en">
-variables support in the "proxy_pass" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы resolver и resolver_timeout.
-</para>
-<para lang="en">
-the "resolver" and "resolver_timeout" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь директива "add_header last-modified ''" удаляет в заголовке ответа
-строку "Last-Modified".
-</para>
-<para lang="en">
-now the directive "add_header last-modified ''" deletes a "Last-Modified"
-response header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива limit_rate не позволяла передавать на полной скорости,
-даже если был указан очень большой лимит.
-</para>
-<para lang="en">
-the "limit_rate" directive did not allow to use full throughput,
-even if limit value was very high.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.17" date="2007-11-15">
-
-<change type="feature">
-<para lang="ru">
-поддержка строки "If-Range" в заголовке запроса.<br/>
-Спасибо Александру Инюхину.
-</para>
-<para lang="en">
-the "If-Range" request header line support.<br/>
-Thanks to Alexander V. Inyukhin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы msie_refresh повторно экранировались
-уже экранированные символы;
-ошибка появилась в 0.6.4.
-</para>
-<para lang="en">
-URL double escaping in a redirect of the "msie_refresh" directive;
-the bug had appeared in 0.6.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива autoindex не работала при использовании "alias /".
-</para>
-<para lang="en">
-the "autoindex" directive did not work with the "alias /" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании подзапросов
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process if subrequests were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSL и gzip большие ответы могли передаваться не полностью.
-</para>
-<para lang="en">
-the big responses may be transferred truncated if SSL and gzip were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если ответ проксированного сервера был версии HTTP/0.9,
-то переменная $status была равна 0.
-</para>
-<para lang="en">
-the $status variable was equal to 0 if a proxied server returned response
-in HTTP/0.9 version.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.16" date="2007-10-29">
-
-<change type="change">
-<para lang="ru">
-теперь на Linux используется uname(2) вместо procfs.<br/>
-Спасибо Илье Новикову.
-</para>
-<para lang="en">
-now the uname(2) is used on Linux instead of procfs.<br/>
-Thanks to Ilya Novikov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве error_page использовался символ "?", то он экранировался
-при проксировании запроса;
-ошибка появилась в 0.6.11.
-</para>
-<para lang="en">
-if the "?" character was in a "error_page" directive, then it was escaped
-in a proxied request;
-the bug had appeared in 0.6.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с mget.
-</para>
-<para lang="en">
-compatibility with mget.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.15" date="2007-10-22">
-
-<change type="feature">
-<para lang="ru">
-совместимость с Cygwin.<br/>
-Спасибо Владимиру Кутакову.
-</para>
-<para lang="en">
-Cygwin compatibility.<br/>
-Thanks to Vladimir Kutakov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива merge_slashes.
-</para>
-<para lang="en">
-the "merge_slashes" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива gzip_vary.
-</para>
-<para lang="en">
-the "gzip_vary" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server_tokens.
-</para>
-<para lang="en">
-the "server_tokens" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не раскодировал URI в команде SSI include.
-</para>
-<para lang="en">
-nginx did not unescape URI in the "include" SSI command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменной в директивах charset или source_charset
-на старте или во время переконфигурации происходил segmentation fault,
-</para>
-<para lang="en">
-the segmentation fault was occurred on start or while reconfiguration
-if variable was used in the "charset" or "source_charset" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал ошибку 400 на запросы вида
-<nobr>"GET http://www.domain.com HTTP/1.0"</nobr>.<br/>
-Спасибо James Oakley.
-</para>
-<para lang="en">
-nginx returned the 400 response on requests like
-<nobr>"GET http://www.domain.com HTTP/1.0"</nobr>.<br/>
-Thanks to James Oakley.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после перенаправления запроса с телом запроса с помощью директивы
-error_page nginx пытался снова прочитать тело запроса;
-ошибка появилась в 0.6.7.
-</para>
-<para lang="en">
-if request with request body was redirected using the "error_page" directive,
-then nginx tried to read the request body again;
-the bug had appeared in 0.6.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе происходил segmentation fault, если у сервера,
-обрабатывающему запрос, не был явно определён server_name;
-ошибка появилась в 0.6.7.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process
-if no server_name was explicitly defined for server processing request;
-the bug had appeared in 0.6.7.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.14" date="2007-10-15">
-
-<change type="change">
-<para lang="ru">
-теперь по умолчанию команда SSI echo использует кодирование entity.
-</para>
-<para lang="en">
-now by default the "echo" SSI command uses entity encoding.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр encoding в команде SSI echo.
-</para>
-<para lang="en">
-the "encoding" parameter in the "echo" SSI command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директиву access_log можно использовать внутри блока limit_except.
-</para>
-<para lang="en">
-the "access_log" directive may be used inside the "limit_except" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если все сервера апстрима оказывались недоступными,
-то до восстановления работоспособности
-у всех серверов вес становился равным одному;
-ошибка появилась в 0.6.6.
-</para>
-<para lang="en">
-if all upstream servers were failed, then all servers had got weight
-the was equal one until servers became alive;
-the bug had appeared in 0.6.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменных $date_local и $date_gmt вне модуля
-ngx_http_ssi_filter_module в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process
-if $date_local and $date_gmt were used outside the ngx_http_ssi_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании включённом отладочном логе
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if debug log was enabled.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_memcached_module не устанавливал $upstream_response_time.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-ngx_http_memcached_module did not set $upstream_response_time.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочий процесс мог зациклиться при использовании memcached.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop, if the memcached was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx распознавал параметры "close" и "keep-alive" в строке "Connection"
-в заголовке запроса только, если они были в нижнем регистре;
-ошибка появилась в 0.6.11.
-</para>
-<para lang="en">
-nginx supported low case only "close" and "keep-alive" values
-in the "Connection" request header line;
-the bug had appeared in 0.6.11.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-sub_filter не работал с пустой строкой замены.
-</para>
-<para lang="en">
-sub_filter did not work with empty substitution.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в парсинге sub_filter.
-</para>
-<para lang="en">
-in sub_filter parsing.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.13" date="2007-09-24">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не закрывал файл каталога для запроса HEAD,
-если использовался autoindex<br/>
-Спасибо Arkadiusz Patyk.
-</para>
-<para lang="en">
-nginx did not close directory file on HEAD request if autoindex was used.<br/>
-Thanks to Arkadiusz Patyk.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.12" date="2007-09-21">
-
-<change type="change">
-<para lang="ru">
-почтовый прокси-сервер разделён на три модуля: pop3, imap и smtp.
-</para>
-<para lang="en">
-mail proxy was split on three modules: pop3, imap and smtp.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры конфигурации --without-mail_pop3_module,
---without-mail_imap_module и --without-mail_smtp_module.
-</para>
-<para lang="en">
-the --without-mail_pop3_module, --without-mail_imap_module,
-and --without-mail_smtp_module configuration parameters.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы smtp_greeting_delay и smtp_client_buffer модуля ngx_mail_smtp_module.
-</para>
-<para lang="en">
-the "smtp_greeting_delay" and "smtp_client_buffer" directives
-of the ngx_mail_smtp_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-wildcard в конце имени сервера не работали;
-ошибка появилась в 0.6.9.
-</para>
-<para lang="en">
-the trailing wildcards did not work;
-the bug had appeared in 0.6.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании разделяемой библиотеки PCRE,
-расположенной в нестандартном месте, nginx не запускался на Solaris.
-</para>
-<para lang="en">
-nginx could not start on Solaris if the shared PCRE library located
-in non-standard place was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_hide_header и fastcgi_hide_header не скрывали
-строки заголовка ответа с именем больше 32 символов.<br/>
-Спасибо Manlio Perillo.
-</para>
-<para lang="en">
-the "proxy_hide_header" and "fastcgi_hide_header" directives did not
-hide response header lines whose name was longer than 32 characters.<br/>
-Thanks to Manlio Perillo.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.11" date="2007-09-11">
-
-<change type="bugfix">
-<para lang="ru">
-счётчик активных соединений всегда рос при использовании почтового
-прокси-сервера.
-</para>
-<para lang="en">
-active connection counter always increased if mail proxy was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если бэкенд возвращал только заголовок ответа при небуферизированном
-проксировании, то nginx закрывал соединение с бэкендом по таймауту.
-</para>
-<para lang="en">
-if backend returned response header only using non-buffered proxy,
-then nginx closed backend connection on timeout.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не поддерживал несколько строк "Connection" в заголовке запроса.
-</para>
-<para lang="en">
-nginx did not support several "Connection" request header lines.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в сервере апстрима был задан max_fails, то после первой же неудачной
-попытки вес сервера навсегда становился равным одному;
-ошибка появилась в 0.6.6.
-</para>
-<para lang="en">
-if the "max_fails" was set for upstream server, then after first
-failure server weight was always one;
-the bug had appeared in 0.6.6.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.10" date="2007-09-03">
-
-<change type="feature">
-<para lang="ru">
-директивы open_file_cache, open_file_cache_retest и open_file_cache_errors.
-</para>
-<para lang="en">
-the "open_file_cache", "open_file_cache_retest", and "open_file_cache_errors"
-directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-утечки сокетов;
-ошибка появилась в 0.6.7.
-</para>
-<para lang="en">
-socket leak;
-the bug had appeared in 0.6.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-В строку заголовка ответа "Content-Type", указанную в методе
-$r->send_http_header(), не добавлялась кодировка, указанная в директиве charset.
-</para>
-<para lang="en">
-a charset set by the "charset" directive was not appended
-to the "Content-Type" header set by $r->send_http_header().
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании метода /dev/poll
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if /dev/poll method was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.9" date="2007-08-28">
-
-<change type="bugfix">
-<para lang="ru">
-рабочий процесс мог зациклиться при использовании протокола HTTPS;
-ошибка появилась в 0.6.7.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop,
-if the HTTPS protocol was used;
-the bug had appeared in 0.6.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если сервер слушал на двух адресах или портах, то nginx не запускался
-при использовании wildcard в конце имени сервера.
-</para>
-<para lang="en">
-if server listened on two addresses or ports and trailing wildcard was used,
-then nginx did not run.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ip_hash могла неверно помечать сервера как нерабочие.
-</para>
-<para lang="en">
-the "ip_hash" directive might incorrectly mark servers as down.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на amd64;
-ошибка появилась в 0.6.8.
-</para>
-<para lang="en">
-nginx could not be built on amd64;
-the bug had appeared in 0.6.8.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.8" date="2007-08-20">
-
-<change type="change">
-<para lang="ru">
-теперь nginx пытается установить директивы worker_priority,
-worker_rlimit_nofile, worker_rlimit_core, worker_rlimit_sigpending
-без привилегий root'а.
-</para>
-<para lang="en">
-now nginx tries to set the "worker_priority", "worker_rlimit_nofile",
-"worker_rlimit_core", and "worker_rlimit_sigpending" without super-user
-privileges.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь nginx экранирует символы пробела и "%" при передаче запроса
-серверу аутентификации почтового прокси-сервера.
-</para>
-<para lang="en">
-now nginx escapes space and "%" in request to a mail proxy authentication
-server.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь nginx экранирует символ "%" в переменной $memcached_key.
-</para>
-<para lang="en">
-now nginx escapes "%" in $memcached_key variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при указании относительного пути к конфигурационному файлу в качестве
-параметра ключа -c nginx определял путь относительно конфигурационного префикса;
-ошибка появилась в 0.6.6.
-</para>
-<para lang="en">
-nginx used path relative to configuration prefix for non-absolute
-configuration file path specified in the "-c" key;
-the bug had appeared in 0.6.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на FreeBSD/sparc64.
-</para>
-<para lang="en">
-nginx did not work on FreeBSD/sparc64.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.7" date="2007-08-15">
-
-<change type="change">
-<para lang="ru">
-теперь пути, указанные в директивах include, auth_basic_user_file,
-perl_modules, ssl_certificate, ssl_certificate_key и
-ssl_client_certificate, определяются относительно каталога конфигурационного
-файла nginx.conf, а не относительно префикса.
-</para>
-<para lang="en">
-now the paths specified in the "include", "auth_basic_user_file",
-"perl_modules", "ssl_certificate", "ssl_certificate_key", and
-"ssl_client_certificate" directives are relative to directory of
-nginx configuration file nginx.conf, but not to nginx prefix directory.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметр --sysconfdir=PATH в configure упразднён.
-</para>
-<para lang="en">
-the --sysconfdir=PATH option in configure was canceled.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-для обновления на лету версий 0.1.x создан специальный сценарий
-<nobr>make upgrade1.</nobr>
-</para>
-<para lang="en">
-the special make target "upgrade1" was defined for online upgrade of
-0.1.x versions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы server_name и valid_referers поддерживают регулярные выражения.
-</para>
-<para lang="en">
-the "server_name" and "valid_referers" directives support regular expressions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server в блоке upstream поддерживает параметр backup.
-</para>
-<para lang="en">
-the "server" directive in the "upstream" context supports
-the "backup" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает метод $r->discard_request_body.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->discard_request_body.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива "add_header Last-Modified ..." меняет строку "Last-Modified"
-в заголовке ответа.
-</para>
-<para lang="en">
-the "add_header Last-Modified ..." directive changes the "Last-Modified"
-response header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если на запрос с телом возвращался ответ с кодом HTTP отличным от 200,
-и после этого запроса соединение переходило в состояние keep-alive,
-то на следующий запрос nginx возвращал 400.
-</para>
-<para lang="en">
-if a response different than 200 was returned to a request with body
-and connection went to the keep-alive state after the request, then
-nginx returned 400 for the next request.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве auth_http был задан неправильный адрес, то
-в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process
-if invalid address was set in the "auth_http" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь по умолчанию nginx использует значение 511 для listen backlog
-на всех платформах, кроме FreeBSD.<br/>
-Спасибо Jiang Hong.
-</para>
-<para lang="en">
-now nginx uses default listen backlog value 511 on all platforms
-except FreeBSD.<br/>
-Thanks to Jiang Hong.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочий процесс мог зациклиться, если server в блоке upstream был помечен
-как down;
-ошибка появилась в 0.6.6.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop, if a "server" inside
-"upstream" block was marked as "down";
-the bug had appeared in 0.6.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-sendfilev() в Solaris теперь не используется при передаче тела запроса
-FastCGI-серверу через unix domain сокет.
-</para>
-<para lang="en">
-now Solaris sendfilev() is not used to transfer the client request body
-to FastCGI-server via the unix domain socket.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.6" date="2007-07-30">
-
-<change type="feature">
-<para lang="ru">
-параметр --sysconfdir=PATH в configure.
-</para>
-<para lang="en">
-the --sysconfdir=PATH option in configure.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-именованные location'ы.
-</para>
-<para lang="en">
-named locations.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменную $args можно устанавливать с помощью set.
-</para>
-<para lang="en">
-the $args variable can be set with the "set" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $is_args.
-</para>
-<para lang="en">
-the $is_args variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-равномерное распределение запросов к апстримам с большими весами.
-</para>
-<para lang="en">
-fair big weight upstream balancer.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если клиент в почтовом прокси-сервере закрывал соединение,
-то nginx мог не закрывать соединение с бэкендом.
-</para>
-<para lang="en">
-if a client has closed connection to mail proxy
- then nginx might not close connection to backend.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании одного хоста в качестве бэкендов для протоколов HTTP и HTTPS
-без явного указания портов, nginx использовал только один порт&mdash;80 или 443.
-</para>
-<para lang="en">
-if the same host without specified port was used as backend for HTTP and HTTPS,
-then nginx used only one port&mdash;80 or 443.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris/amd64 Sun Studio 11 и более ранними версиями;
-ошибка появилась в 0.6.4.
-</para>
-<para lang="en">
-fix building on Solaris/amd64 by Sun Studio 11 and early versions;
-the bug had appeared in 0.6.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.5" date="2007-07-23">
-
-<change type="feature">
-<para lang="ru">
-переменная $nginx_version.<br/>
-Спасибо Николаю Гречуху.
-</para>
-<para lang="en">
-$nginx_version variable.<br/>
-Thanks to Nick S. Grechukh.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-почтовый прокси-сервер поддерживает AUTHENTICATE в режиме IMAP.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the mail proxy supports AUTHENTICATE in IMAP mode.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-почтовый прокси-сервер поддерживает STARTTLS в режиме SMTP.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-the mail proxy supports STARTTLS in SMTP mode.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx экранирует пробел в переменной $memcached_key.
-</para>
-<para lang="en">
-now nginx escapes space in $memcached_key variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx неправильно собирался Sun Studio на Solaris/amd64.<br/>
-Спасибо Jiang Hong.
-</para>
-<para lang="en">
-nginx was incorrectly built by Sun Studio on Solaris/amd64.<br/>
-Thanks to Jiang Hong.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-незначительных потенциальных ошибок.<br/>
-Спасибо Coverity's Scan.
-</para>
-<para lang="en">
-of minor potential bugs.<br/>
-Thanks to Coverity's Scan.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.4" date="2007-07-17">
-
-<change type="security">
-<para lang="ru">
-при использовании директивы msie_refresh был возможен XSS.<br/>
-Спасибо Максиму Богуку.
-</para>
-<para lang="en">
-the "msie_refresh" directive allowed XSS.<br/>
-Thanks to Maxim Boguk.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы proxy_store и fastcgi_store изменены.
-</para>
-<para lang="en">
-the "proxy_store" and "fastcgi_store" directives were changed.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_store_access и fastcgi_store_access.
-</para>
-<para lang="en">
-the "proxy_store_access" and "fastcgi_store_access" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на Solaris/sparc64, если был собран Sun Studio.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-nginx did not work on Solaris/sparc64 if it was built by Sun Studio.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки в Sun Studio 12.<br/>
-Спасибо Jiang Hong.
-</para>
-<para lang="en">
-for Sun Studio 12.<br/>
-Thanks to Jiang Hong.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.3" date="2007-07-12">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_store и fastcgi_store.
-</para>
-<para lang="en">
-the "proxy_store" and "fastcgi_store" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы auth_http_header
-в рабочем процессе мог произойти segmentation fault.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if the "auth_http_header" directive was used.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовался метод аутентификации CRAM-MD5, но он не был разрешён,
-то в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process
-if the CRAM-MD5 authentication method was used, but it was not enabled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании протокола HTTPS в директиве proxy_pass
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process when
-the HTTPS protocol was used in the "proxy_pass" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в рабочем процессе мог произойти segmentation fault,
-если использовался метод eventport.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if the eventport method was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_ignore_client_abort и fastcgi_ignore_client_abort не работали;
-ошибка появилась в 0.5.13.
-</para>
-<para lang="en">
-the "proxy_ignore_client_abort" and "fastcgi_ignore_client_abort" directives
-did not work;
-the bug had appeared in 0.5.13.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.2" date="2007-07-09">
-
-<change type="bugfix">
-<para lang="ru">
-если заголовок ответа был разделён в FastCGI-записях, то nginx передавал
-клиенту мусор в таких заголовках.
-</para>
-<para lang="en">
-if the FastCGI header was split in records,
-then nginx passed garbage in the header to a client.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.1" date="2007-06-17">
-
-<change type="bugfix">
-<para lang="ru">
-в парсинге SSI.
-</para>
-<para lang="en">
-in SSI parsing.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании удалённого подзапроса в SSI последующий
-подзапрос локального файла мог отдаваться клиенту в неверном порядке.
-</para>
-<para lang="en">
-if remote SSI subrequest was used, then posterior local file subrequest
-might transferred to client in wrong order.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-большие включения в SSI, сохранённые во временные файлы,
-передавались не полностью.
-</para>
-<para lang="en">
-large SSI inclusions buffered in temporary files were truncated.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-значение perl'овой переменной $$ модуля ngx_http_perl_module было равно
-номеру главного процесса.
-</para>
-<para lang="en">
-the perl $$ variable value in ngx_http_perl_module was equal to the master
-process identification number.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.6.0" date="2007-06-14">
-
-<change type="feature">
-<para lang="ru">
-директивы "server_name", "map", and "valid_referers" поддерживают
-маски вида "www.example.*".
-</para>
-<para lang="en">
-the "server_name", "map", and "valid_referers" directives support
-the "www.example.*" wildcards.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.25" date="2007-06-11">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-http_rewrite_module;
-ошибка появилась в 0.5.24.
-</para>
-<para lang="en">
-nginx could not be built with the --without-http_rewrite_module parameter;
-the bug had appeared in 0.5.24.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.24" date="2007-06-06">
-
-<change type="security">
-<para lang="ru">
-директива ssl_verify_client не работала, если запрос выполнялся
-по протоколу HTTP/0.9.
-</para>
-<para lang="en">
-the "ssl_verify_client" directive did not work if request was made
-using HTTP/0.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании сжатия часть ответа могла передаваться несжатой;
-ошибка появилась в 0.5.23.
-</para>
-<para lang="en">
-a part of response body might be passed uncompressed if gzip was used;
-the bug had appeared in 0.5.23.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.23" date="2007-06-04">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssl_module поддерживает расширение TLS Server Name Indication.
-</para>
-<para lang="en">
-the ngx_http_ssl_module supports Server Name Indication TLS extension.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_catch_stderr.<br/>
-Спасибо Николаю Гречуху, проект OWOX.
-</para>
-<para lang="en">
-the "fastcgi_catch_stderr" directive.<br/>
-Thanks to Nick S. Grechukh, OWOX project.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Линуксе в основном процессе происходил segmentation fault,
-если два виртуальных сервера должны bind()ится к пересекающимся портам.
-</para>
-<para lang="en">
-a segmentation fault occurred in master process if
-two virtual servers should bind() to the overlapping ports.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_perl_module и perl
-поддерживал потоки, то во время второй переконфигурации
-выдавались ошибки "panic: MUTEX_LOCK" и "perl_parse() failed".
-</para>
-<para lang="en">
-if nginx was built with ngx_http_perl_module and perl supported threads,
-then during second reconfiguration the error messages
-"panic: MUTEX_LOCK" and "perl_parse() failed" were issued.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании протокола HTTPS в директиве proxy_pass.
-</para>
-<para lang="en">
-in the HTTPS protocol in the "proxy_pass" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.22" date="2007-05-29">
-
-<change type="bugfix">
-<para lang="ru">
-большое тело запроса могло не передаваться бэкенду;
-ошибка появилась в 0.5.21.
-</para>
-<para lang="en">
-a big request body might not be passed to backend;
-the bug had appeared in 0.5.21.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.21" date="2007-05-28">
-
-<change type="bugfix">
-<para lang="ru">
-если внутри сервера описано больше примерно десяти location'ов,
-то location'ы, заданные с помощью регулярного выражения,
-могли выполняться не в том, порядке, в каком они описаны.
-</para>
-<para lang="en">
-if server has more than about ten locations, then regex locations
-might be chosen not in that order as they were specified.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на 64-битной платформе рабочий процесс мог зациклиться, если 33-тий
-по счёту или последующий бэкенд упал.<br/>
-Спасибо Антону Поварову.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop on 64-bit platform,
-if the 33-rd or next in succession backend has failed.<br/>
-Thanks to Anton Povarov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании библиотеки PCRE на Solaris/sparc64
-мог произойти bus error.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-a bus error might occur on Solaris/sparc64 if the PCRE library was used.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании протокола HTTPS в директиве proxy_pass.
-</para>
-<para lang="en">
-in the HTTPS protocol in the "proxy_pass" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.20" date="2007-05-07">
-
-<change type="feature">
-<para lang="ru">
-директива sendfile_max_chunk.
-</para>
-<para lang="en">
-the "sendfile_max_chunk" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные "$http_...", "$sent_http_..." и "$upstream_http_..."
-можно менять директивой set.
-</para>
-<para lang="en">
-the "$http_...", "$sent_http_...", and "$upstream_http_..." variables
-may be changed using the "set" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSI-команды 'if expr="$var = /"'
-в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if the SSI command 'if expr="$var = /"' was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-завершающая строка multipart range ответа передавалась неверно.<br/>
-Спасибо Evan Miller.
-</para>
-<para lang="en">
-trailing boundary of multipart range response was transferred incorrectly.<br/>
-Thanks to Evan Miller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на Solaris/sparc64, если был собран Sun Studio.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-nginx did not work on Solaris/sparc64 if it was built by Sun Studio.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_perl_module не собирался make в Solaris.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-the ngx_http_perl_module could not be built by Solaris make.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.19" date="2007-04-24">
-
-<change type="change">
-<para lang="ru">
-значение переменной $request_time теперь записывается с точностью
-до миллисекунд.
-</para>
-<para lang="en">
-now the $request_time variable has millisecond precision.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-метод $r->rflush в модуле ngx_http_perl_module переименован в $r->flush.
-</para>
-<para lang="en">
-the method $r->rflush of ngx_http_perl_module was renamed to the $r->flush.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $upstream_addr.
-</para>
-<para lang="en">
-the $upstream_addr variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_headers_hash_max_size и proxy_headers_hash_bucket_size.<br/>
-Спасибо Володымыру Костырко.
-</para>
-<para lang="en">
-the "proxy_headers_hash_max_size" and "proxy_headers_hash_bucket_size"
-directives.<br/>
-Thanks to Volodymyr Kostyrko.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании sendfile и limit_rate на 64-битных платформах
-нельзя было передавать файлы больше 2G.
-</para>
-<para lang="en">
-the files more than 2G could not be transferred using sendfile and limit_rate
-on 64-bit platforms.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании sendfile на 64-битном Linux нельзя было передавать файлы
-больше 2G.
-</para>
-<para lang="en">
-the files more than 2G could not be transferred using sendfile on 64-bit Linux.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.18" date="2007-04-19">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_sub_filter_module.
-</para>
-<para lang="en">
-the ngx_http_sub_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные "$upstream_http_...".
-</para>
-<para lang="en">
-the "$upstream_http_..." variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь переменные $upstream_status и $upstream_response_time
-содержат данные о всех обращениях к апстримам, сделанным до X-Accel-Redirect.
-</para>
-<para lang="en">
-now the $upstream_status and $upstream_response_time variables
-keep data about all upstreams before X-Accel-Redirect.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_perl_module и perl
-не поддерживал multiplicity, то после первой переконфигурации
-и после получения любого сигнала
-в основном процессе происходил segmentation fault;
-ошибка появилась в 0.5.9.
-</para>
-<para lang="en">
-a segmentation fault occurred in master process
-after first reconfiguration and receiving any signal
-if nginx was built with ngx_http_perl_module and perl
-did not support multiplicity;
-the bug had appeared in 0.5.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если perl не поддерживал multiplicity, то после переконфигурации
-перловый код не работал;
-ошибка появилась в 0.3.38.
-</para>
-<para lang="en">
-if perl did not support multiplicity, then after reconfiguration
-perl code did not work;
-the bug had appeared in 0.3.38.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.17" date="2007-04-02">
-
-<change type="change">
-<para lang="ru">
-теперь nginx для метода TRACE всегда возвращает код 405.
-</para>
-<para lang="en">
-now nginx always returns the 405 status for the TRACE method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь nginx поддерживает директиву include внутри блока types.
-</para>
-<para lang="en">
-now nginx supports the "include" directive inside the "types" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-использование переменной $document_root в директиве root и alias
-запрещено: оно вызывало рекурсивное переполнение стека.
-</para>
-<para lang="en">
-the $document_root variable usage in the "root" and "alias" directives
-is disabled: this caused recursive stack overflow.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании протокола HTTPS в директиве proxy_pass.
-</para>
-<para lang="en">
-in the HTTPS protocol in the "proxy_pass" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в некоторых случаях некэшируемые переменные (такие, как $uri)
-возвращали старое закэшированное значение.
-</para>
-<para lang="en">
-in some cases non-cacheable variables (such as $uri variable)
-returned old cached value.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.16" date="2007-03-26">
-
-<change type="bugfix">
-<para lang="ru">
-в качестве ключа для хэша в директиве ip_hash не использовалась сеть
-класса С.<br/>
-Спасибо Павлу Ярковому.
-</para>
-<para lang="en">
-the C-class network was not used as hash key in the "ip_hash" directive.<br/>
-Thanks to Pavel Yarkovoy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в строке "Content-Type" в заголовке ответа бэкенда был указан charset
-и строка завершалась символом ";",
-то в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if a charset was set in the "Content-Type" header line and the line
-has trailing ";";
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "[alert] zero size buf" при работе с FastCGI-сервером, если
-тело запроса, записанное во временный файл, было кратно 32K.
-</para>
-<para lang="en">
-the "[alert] zero size buf" error when FastCGI server was used and
-a request body written in a temporary file was multiple of 32K.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Solaris без параметра --with-debug;
-ошибка появилась в 0.5.15.
-</para>
-<para lang="en">
-nginx could not be built on Solaris without the --with-debug option;
-the bug had appeared in 0.5.15.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.15" date="2007-03-19">
-
-<change type="feature">
-<para lang="ru">
-почтовый прокси-сервер поддерживает аутентифицированное SMTP-проксирование и
-директивы smtp_auth, smtp_capabilities и xclient.<br/>
-Спасибо Антону Южанинову и Максиму Дунину.
-</para>
-<para lang="en">
-the mail proxy supports authenticated SMTP proxying and
-the "smtp_auth", "smtp_capabilities", and "xclient" directives.<br/>
-Thanks to Anton Yuzhaninov and Maxim Dounin.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь keep-alive соединения закрываются сразу же по получении сигнала
-переконфигурации.
-</para>
-<para lang="en">
-now the keep-alive connections are closed just after receiving
-the reconfiguration signal.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы imap и auth переименованы соответственно в mail и pop3_auth.
-</para>
-<para lang="en">
-the "imap" and "auth" directives were renamed
-to the "mail" and "pop3_auth" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если использовался метод аутентификации CRAM-MD5 и не был разрешён метод APOP,
-то в рабочем процессе происходил segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault occurred in worker process
-if the CRAM-MD5 authentication method was used
-and the APOP method was disabled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы starttls only в протоколе POP3 nginx
-разрешал аутентификацию без перехода в режим SSL.
-</para>
-<para lang="en">
-if the "starttls only" directive was used in POP3 protocol,
-then nginx allowed authentication without switching to the SSL mode.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочие процессы не выходили после переконфигурации и не переоткрывали логи,
-если использовался метод eventport.
-</para>
-<para lang="en">
-worker processes did not exit after reconfiguration and
-did not rotate logs if the eventport method was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы ip_hash рабочий процесс мог зациклиться.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop,
-if the "ip_hash" directive was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь nginx не пишет в лог некоторые alert'ы,
-если используются методы eventport или /dev/poll.
-</para>
-<para lang="en">
-now nginx does not log some alerts if eventport or /dev/poll methods are used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.14" date="2007-02-23">
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал лишние закрывающие скобки "}" в конце
-конфигурационного файла.
-</para>
-<para lang="en">
-nginx ignored superfluous closing "}" in the end of configuration file.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.13" date="2007-02-19">
-
-<change type="feature">
-<para lang="ru">
-методы COPY и MOVE.
-</para>
-<para lang="en">
-the COPY and MOVE methods.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_realip_module устанавливал мусор для запросов,
-переданных по keep-alive соединению.
-</para>
-<para lang="en">
-the ngx_http_realip_module set garbage for requests passed via
-keep-alive connection.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на 64-битном big-endian Linux.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-nginx did not work on big-endian 64-bit Linux.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при получении слишком длинной команды IMAP/POP3-прокси теперь сразу
-закрывает соединение, а не по таймауту.
-</para>
-<para lang="en">
-now when IMAP/POP3 proxy receives too long command it closes the connection
-right away, but not after timeout.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании метода epoll клиент закрывал преждевременно
-соединение со своей стороны, то nginx закрывал это соединение только
-по истечении таймаута на передачу.
-</para>
-<para lang="en">
-if the "epoll" method was used and a client closed a connection prematurely,
-then nginx closed the connection after a send timeout only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформах, отличных от i386, amd64, sparc и ppc;
-ошибка появилась в 0.5.8.
-</para>
-<para lang="en">
-nginx could not be built on platforms different from i386, amd64, sparc,
-and ppc;
-the bug had appeared in 0.5.8.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.12" date="2007-02-12">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформах, отличных от i386, amd64, sparc и ppc;
-ошибка появилась в 0.5.8.
-</para>
-<para lang="en">
-nginx could not be built on platforms different from i386, amd64, sparc,
-and ppc;
-the bug had appeared in 0.5.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании временных файлов в время работы с FastCGI-сервером
-в рабочем процессе мог произойти segmentation fault;
-ошибка появилась в 0.5.8.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if the temporary files were used while working with FastCGI server;
-the bug had appeared in 0.5.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если переменная $fastcgi_script_name записывалась в лог,
-то в рабочем процессе мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if the $fastcgi_script_name variable was logged.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_perl_module не собирался на Solaris.
-</para>
-<para lang="en">
-ngx_http_perl_module could not be built on Solaris.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.11" date="2007-02-05">
-
-<change type="feature">
-<para lang="ru">
-теперь configure определяет библиотеку PCRE в MacPorts.<br/>
-Спасибо Chris McGrath.
-</para>
-<para lang="en">
-now configure detects system PCRE library in MacPorts.<br/>
-Thanks to Chris McGrath.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ был неверным, если запрашивалось несколько диапазонов;
-ошибка появилась в 0.5.6.
-</para>
-<para lang="en">
-the response was incorrect if several ranges were requested;
-the bug had appeared in 0.5.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива create_full_put_path не могла создавать промежуточные каталоги,
-если не была установлена директива dav_access.<br/>
-Спасибо Evan Miller.
-</para>
-<para lang="en">
-the "create_full_put_path" directive could not create the intermediate
-directories if no "dav_access" directive was set.<br/>
-Thanks to Evan Miller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-вместо кодов ошибок "400" и "408" в access_log мог записываться код "0".
-</para>
-<para lang="en">
-the "0" response code might be logged in the access_log instead of
-the "400" and "408" error codes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при сборке с оптимизацией -O2 в рабочем процессе мог произойти
-segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if nginx was built with -O2 optimization.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.10" date="2007-01-26">
-
-<change type="bugfix">
-<para lang="ru">
-во время обновления исполняемого файла новый процесс не наследовал
-слушающие сокеты;
-ошибка появилась в 0.5.9.
-</para>
-<para lang="en">
-while online executable file upgrade the new master process did not
-inherit the listening sockets;
-the bug had appeared in 0.5.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при сборке с оптимизацией -O2 в рабочем процессе мог произойти
-segmentation fault;
-ошибка появилась в 0.5.1.
-</para>
-<para lang="en">
-a segmentation fault might occur in worker process
-if nginx was built with -O2 optimization;
-the bug had appeared in 0.5.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.9" date="2007-01-25">
-
-<change type="change">
-<para lang="ru">
-модуль ngx_http_memcached_module теперь в качестве ключа использует
-значение переменной $memcached_key.
-</para>
-<para lang="en">
-now the ngx_http_memcached_module uses the $memcached_key variable value
-as a key.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $memcached_key.
-</para>
-<para lang="en">
-the $memcached_key variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр clean в директиве client_body_in_file_only.
-</para>
-<para lang="en">
-the "clean" parameter in the "client_body_in_file_only" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива env.
-</para>
-<para lang="en">
-the "env" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива sendfile работает внутри блока if.
-</para>
-<para lang="en">
-the "sendfile" directive is available inside the "if" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь при ошибке записи в access_log nginx записывает сообщение в error_log,
-но не чаще одного раза в минуту.
-</para>
-<para lang="en">
-now on failure of the writing to access nginx logs a message to error_log,
-but not more often than once a minute.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива "access_log off" не всегда запрещала запись в лог.
-</para>
-<para lang="en">
-the "access_log off" directive did not always turn off the logging.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.8" date="2007-01-19">
-
-<change type="bugfix">
-<para lang="ru">
-если использовалась директива <nobr>"client_body_in_file_only on"</nobr>
-и тело запроса было небольшое, то мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur if
-<nobr>"client_body_in_file_only on"</nobr> was used
-and a request body was small.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-происходил segmentation fault, если использовались директивы
-<nobr>"client_body_in_file_only on"</nobr>
-и <nobr>"proxy_pass_request_body off"</nobr>
-или <nobr>"fastcgi_pass_request_body off"</nobr>,
-и делался переход к следующему бэкенду.
-</para>
-<para lang="en">
-a segmentation fault occurred if <nobr>"client_body_in_file_only on"</nobr>
-and <nobr>"proxy_pass_request_body off"</nobr>
-or <nobr>"fastcgi_pass_request_body off"</nobr>
-directives were used, and nginx switched to a next upstream.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании директивы "proxy_buffering off" соединение с клиентом
-было неактивно, то оно закрывалось по таймауту, заданному директивой
-send_timeout;
-ошибка появилась в 0.4.7.
-</para>
-<para lang="en">
-if the "proxy_buffering off" directive was used and a client connection
-was non-active, then the connection was closed after send timeout;
-the bug had appeared in 0.4.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании метода epoll клиент закрывал преждевременно
-соединение со своей стороны, то nginx закрывал это соединение только
-по истечении таймаута на передачу.
-</para>
-<para lang="en">
-if the "epoll" method was used and a client closed a connection prematurely,
-then nginx closed the connection after a send timeout only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "[alert] zero size buf" при работе с FastCGI-сервером.
-</para>
-<para lang="en">
-the "[alert] zero size buf" error when FastCGI server was used.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправление ошибок в директиве limit_zone.
-</para>
-<para lang="en">
-Bugfixes in the "limit_zone" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.7" date="2007-01-15">
-
-<change type="feature">
-<para lang="ru">
-оптимизация использования памяти в ssl_session_cache.
-</para>
-<para lang="en">
-the ssl_session_cache storage optimization.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправление ошибок в директивах ssl_session_cache и limit_zone.
-</para>
-<para lang="en">
-Bugfixes in the "ssl_session_cache" and "limit_zone" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на старте или во время переконфигурации происходил segmentation fault,
-если директивы ssl_session_cache или limit_zone использовались
-на 64-битных платформах.
-</para>
-<para lang="en">
-the segmentation fault was occurred on start or while reconfiguration
-if the "ssl_session_cache" or "limit_zone" directives were used
-on 64-bit platforms.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директив add_before_body или add_after_body происходил
-segmentation fault, если в заголовке ответа нет строки "Content-Type".
-</para>
-<para lang="en">
-a segmentation fault occurred if the "add_before_body" or "add_after_body"
-directives were used and there was no "Content-Type" header line in response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-библиотека OpenSSL всегда собиралась с поддержкой потоков.<br/>
-Спасибо Дену Иванову.
-</para>
-<para lang="en">
-the OpenSSL library was always built with the threads support.<br/>
-Thanks to Den Ivanov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость библиотеки PCRE-6.5+ и компилятора icc.
-</para>
-<para lang="en">
-the PCRE-6.5+ library and the icc compiler compatibility.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.6" date="2007-01-09">
-
-<change type="change">
-<para lang="ru">
-теперь модуль ngx_http_index_module игнорирует все методы,
-кроме GET, HEAD и POST.
-</para>
-<para lang="en">
-now the ngx_http_index_module ignores all methods except the GET, HEAD, and
-POST methods.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_limit_zone_module.
-</para>
-<para lang="en">
-the ngx_http_limit_zone_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $binary_remote_addr.
-</para>
-<para lang="en">
-the $binary_remote_addr variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_session_cache модулей ngx_http_ssl_module и ngx_imap_ssl_module.
-</para>
-<para lang="en">
-the "ssl_session_cache" directives
-of the ngx_http_ssl_module and ngx_imap_ssl_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-метод DELETE поддерживает рекурсивное удаление.
-</para>
-<para lang="en">
-the DELETE method supports recursive removal.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании $r->sendfile() byte-ranges передавались неверно.
-</para>
-<para lang="en">
-the byte-ranges were transferred incorrectly if the $r->sendfile() was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.5" date="2006-12-24">
-
-<change type="change">
-<para lang="ru">
-ключ -v больше не выводит информацию о компиляторе.
-</para>
-<para lang="en">
-the -v switch does not show compiler information any more.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -V.
-</para>
-<para lang="en">
-the -V switch.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_rlimit_core поддерживает указание размера в K, M и G.
-</para>
-<para lang="en">
-the "worker_rlimit_core" directive supports size in K, M, and G.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль nginx.pm теперь может устанавливаться непривилегированным пользователем.
-</para>
-<para lang="en">
-the nginx.pm module now could be installed by an unprivileged user.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании методов $r->request_body или $r->request_body_file мог
-произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur if the $r->request_body or
-$r->request_body_file methods were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибок, специфичных для платформы ppc.
-</para>
-<para lang="en">
-the ppc platform specific bugs.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.4" date="2006-12-15">
-
-<change type="feature">
-<para lang="ru">
-директиву perl можно использовать внутри блока limit_except.
-</para>
-<para lang="en">
-the "perl" directive may be used inside the "limit_except" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_dav_module требовал строку "Date" в заголовке запроса
-для метода DELETE.
-</para>
-<para lang="en">
-the ngx_http_dav_module required the "Date" request header line
-for the DELETE method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании одного параметра в директиве dav_access nginx мог
-сообщить об ошибке в конфигурации.
-</para>
-<para lang="en">
-if one only parameter was used in the "dav_access" directive, then
-nginx might report about configuration error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменной $host мог произойти segmentation fault;
-ошибка появилась в 0.4.14.
-</para>
-<para lang="en">
-a segmentation fault might occur if the $host variable was used;
-the bug had appeared in 0.4.14.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.3" date="2006-12-13">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает методы $r->status, $r->log_error
-и $r->sleep.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->status, $r->log_error,
-and $r->sleep methods.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-метод $r->variable поддерживает переменные, неописанные в конфигурации nginx'а.
-</para>
-<para lang="en">
-the $r->variable method supports variables that do not exist in nginx
-configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод $r->has_request_body не работал.
-</para>
-<para lang="en">
-the $r->has_request_body method did not work.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.2" date="2006-12-11">
-
-<change type="bugfix">
-<para lang="ru">
-если в директивах proxy_pass использовалось имя, указанное в upstream,
-то nginx пытался найти IP-адрес этого имени;
-ошибка появилась в 0.5.1.
-</para>
-<para lang="en">
-if the "proxy_pass" directive used the name of the "upstream" block,
-then nginx tried to resolve the name;
-the bug had appeared in 0.5.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.1" date="2006-12-11">
-
-<change type="bugfix">
-<para lang="ru">
-директива post_action могла не работать после неудачного завершения запроса.
-</para>
-<para lang="en">
-the "post_action" directive might not run after a unsuccessful completion
-of a request.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки в Eudora для Mac;
-ошибка появилась в 0.4.11.<br/>
-Спасибо Bron Gondwana.
-</para>
-<para lang="en">
-for Eudora for Mac;
-the bug had appeared in 0.4.11.<br/>
-Thanks to Bron Gondwana.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при указании в директиве fastcgi_pass имени описанного upstream'а выдавалось
-сообщение "no port in upstream";
-ошибка появилась в 0.5.0.
-</para>
-<para lang="en">
-if the "upstream" name was used in the "fastcgi_pass", then the message
-"no port in upstream" was issued;
-the bug had appeared in 0.5.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директивах proxy_pass и fastcgi_pass использовались одинаковых имена
-серверов, но с разными портами, то эти директивы использовали первый
-описанный порт;
-ошибка появилась в 0.5.0.
-</para>
-<para lang="en">
-if the "proxy_pass" and "fastcgi_pass" directives used the same servers but
-different ports, then these directives uses the first described port;
-the bug had appeared in 0.5.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директивах proxy_pass и fastcgi_pass использовались unix domain сокеты,
-то эти директивы использовали первый описанный сокет;
-ошибка появилась в 0.5.0.
-</para>
-<para lang="en">
-if the "proxy_pass" and "fastcgi_pass" directives used the unix domain sockets,
-then these directives used first described socket;
-the bug had appeared in 0.5.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_auth_basic_module игнорировал пользователя, если он был указан
-в последней строке файла паролей и после пароля не было перевода строки,
-возврата каретки или символа ":".
-</para>
-<para lang="en">
-ngx_http_auth_basic_module ignored the user if it was in the last line in
-the password file and there was no the carriage return, the line feed,
-or the ":" symbol after the password.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $upstream_response_time могла быть равна "0.000", хотя время
-обработки было больше 1 миллисекунды.
-</para>
-<para lang="en">
-the $upstream_response_time variable might be equal to "0.000", although
-response time was more than 1 millisecond.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.5.0" date="2006-12-04">
-
-<change type="change">
-<para lang="ru">
-параметры в виде "%name" в директиве log_format больше не поддерживаются.
-</para>
-<para lang="en">
-the parameters in the "%name" form in the "log_format" directive
-are not supported anymore.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы proxy_upstream_max_fails, proxy_upstream_fail_timeout,
-fastcgi_upstream_max_fails, и fastcgi_upstream_fail_timeout,
-memcached_upstream_max_fails и memcached_upstream_fail_timeout
-больше не поддерживаются.
-</para>
-<para lang="en">
-the "proxy_upstream_max_fails", "proxy_upstream_fail_timeout",
-"fastcgi_upstream_max_fails", "fastcgi_upstream_fail_timeout",
-"memcached_upstream_max_fails", and "memcached_upstream_fail_timeout"
-directives are not supported anymore.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server в блоке upstream поддерживает параметры
-max_fails, fail_timeout и down.
-</para>
-<para lang="en">
-the "server" directive in the "upstream" context supports
-the "max_fails", "fail_timeout", and "down" parameters.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ip_hash в блоке upstream.
-</para>
-<para lang="en">
-the "ip_hash" directive inside the "upstream" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-статус WAIT в строке "Auth-Status" в заголовке ответа сервера аутентификации
-IMAP/POP3 прокси.
-</para>
-<para lang="en">
-the WAIT status in the "Auth-Status" header line of the IMAP/POP3 proxy
-authentication server response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на 64-битных платформах;
-ошибка появилась в 0.4.14.
-</para>
-<para lang="en">
-nginx could not be built on 64-bit platforms;
-the bug had appeared in 0.4.14.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.14" date="2006-11-27">
-
-<change type="feature">
-<para lang="ru">
-директива proxy_pass_error_message в IMAP/POP3 прокси.
-</para>
-<para lang="en">
-the "proxy_pass_error_message" directive in IMAP/POP3 proxy.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь configure определяет библиотеку PCRE на FreeBSD, Linux и NetBSD.
-</para>
-<para lang="en">
-now configure detects system PCRE library on FreeBSD, Linux, and NetBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_perl_module не работал с перлом, собранным с поддержкой потоков;
-ошибка появилась в 0.3.38.
-</para>
-<para lang="en">
-ngx_http_perl_module did not work with perl built with the threads support;
-the bug had appeared in 0.3.38.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_perl_module не работал корректно, если перл вызывался рекурсивно.
-</para>
-<para lang="en">
-ngx_http_perl_module did not work if perl was called recursively.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx игнорировал имя сервера в строке запроса.
-</para>
-<para lang="en">
-nginx ignored a host name in a request line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если FastCGI сервер передавал много в stderr,
-то рабочий процесс мог зациклиться.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop,
-if a FastCGI server sent too many data to the stderr.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при изменении системного времени переменная $upstream_response_time
-могла быть отрицательной.
-</para>
-<para lang="en">
-the $upstream_response_time variable may be negative if the system time
-was changed backward.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании POP3 серверу аутентификации IMAP/POP3 прокси
-не передавался параметр Auth-Login-Attempt.
-</para>
-<para lang="en">
-the "Auth-Login-Attempt" parameter was not sent to
-IMAP/POP3 proxy authentication server when POP3 was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при ошибке соединения с сервером аутентификации IMAP/POP3 прокси
-мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur if connect to IMAP/POP3 proxy
-authentication server failed.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.13" date="2006-11-15">
-
-<change type="feature">
-<para lang="ru">
-директиву proxy_pass можно использовать внутри блока limit_except.
-</para>
-<para lang="en">
-the "proxy_pass" directive may be used inside the "limit_except" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива limit_except поддерживает все WebDAV методы.
-</para>
-<para lang="en">
-the "limit_except" directive supports all WebDAV methods.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы add_before_body без директивы add_after_body
-ответ передавался не полностью.
-</para>
-<para lang="en">
-if the "add_before_body" directive was used without
-the "add_after_body" directive, then a response did not transferred complete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-большое тело запроса не принималось, если использовались метод epoll
-и deferred accept().
-</para>
-<para lang="en">
-a large request body did not receive if the epoll method
-and the deferred accept() were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-для ответов модуля ngx_http_autoindex_module не выставлялась кодировка;
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-a charset could not be set for ngx_http_autoindex_module responses;
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "[alert] zero size buf" при работе с FastCGI-сервером;
-</para>
-<para lang="en">
-the "[alert] zero size buf" error when FastCGI server was used;
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр конфигурации --group= игнорировался.<br/>
-Спасибо Thomas Moschny.
-</para>
-<para lang="en">
-the --group= configuration parameter was ignored.<br/>
-Thanks to Thomas Moschny.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-50-й подзапрос в SSI ответе не работал;
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-the 50th subrequest in SSI response did not work;
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.12" date="2006-10-31">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает метод $r->variable.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->variable method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включении в ответ большого статического файла с помощью SSI
-ответ мог передаваться не полностью.
-</para>
-<para lang="en">
-if a big static file was included using SSI in a response,
-then the response may be transferred incomplete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не убирал "#fragment" в URI.
-</para>
-<para lang="en">
-nginx did not omit the "#fragment" part in URI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.11" date="2006-10-25">
-
-<change type="feature">
-<para lang="ru">
-POP3 прокси поддерживает AUTH LOGIN PLAIN и CRAM-MD5.
-</para>
-<para lang="en">
-the POP3 proxy supports the AUTH LOGIN PLAIN and CRAM-MD5.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает метод $r->allow_ranges.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->allow_ranges method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включённой поддержке команды APOP в POP3 прокси могли
-не работать команды USER/PASS;
-ошибка появилась в 0.4.10.
-</para>
-<para lang="en">
-if the APOP was enabled in the POP3 proxy, then the USER/PASS commands
-might not work;
-the bug had appeared in 0.4.10.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.10" date="2006-10-23">
-
-<change type="feature">
-<para lang="ru">
-POP3 прокси поддерживает APOP.
-</para>
-<para lang="en">
-the POP3 proxy supports the APOP command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании методов select, poll и /dev/poll во время ожидания
-ответа от сервера аутентификации IMAP/POP3 прокси нагружал процессор.
-</para>
-<para lang="en">
-if the select, poll or /dev/poll methods were used, then while
-waiting authentication server response the IMAP/POP3 proxy hogged CPU.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменной $server_addr в директиве map мог
-произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault might occur if the $server_addr variable was used
-in the "map" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_flv_module не поддерживал byte ranges для полных ответов;
-ошибка появилась в 0.4.7.
-</para>
-<para lang="en">
-the ngx_http_flv_module did not support the byte ranges for full responses;
-the bug had appeared in 0.4.7.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Debian amd64;
-ошибка появилась в 0.4.9.
-</para>
-<para lang="en">
-nginx could not be built on Debian amd64;
-the bug had appeared in 0.4.9.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.9" date="2006-10-13">
-
-<change type="feature">
-<para lang="ru">
-параметр set в команде SSI include.
-</para>
-<para lang="en">
-the "set" parameter in the "include" SSI command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module теперь проверяет версию модуля nginx.pm.
-</para>
-<para lang="en">
-the ngx_http_perl_module now tests the nginx.pm module version.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.8" date="2006-10-11">
-
-<change type="bugfix">
-<para lang="ru">
-если до команды SSI include с параметром wait выполнялась ещё
-одна команда SSI include, то параметр wait мог не работать.
-</para>
-<para lang="en">
-if an "include" SSI command were before another "include" SSI command
-with a "wait" parameter, then the "wait" parameter might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_flv_module добавлял FLV-заголовок для полных ответов.<br/>
-Спасибо Алексею Ковырину.
-</para>
-<para lang="en">
-the ngx_http_flv_module added the FLV header to the full responses.<br/>
-Thanks to Alexey Kovyrin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.7" date="2006-10-10">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_flv_module.
-</para>
-<para lang="en">
-the ngx_http_flv_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $request_body_file.
-</para>
-<para lang="en">
-the $request_body_file variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы charset и source_charset поддерживают переменные.
-</para>
-<para lang="en">
-the "charset" and "source_charset" directives support the variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если до команды SSI include с параметром wait выполнялась ещё
-одна команда SSI include, то параметр wait мог не работать.
-</para>
-<para lang="en">
-if an "include" SSI command were before another "include" SSI command
-with a "wait" parameter, then the "wait" parameter might not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании директивы "proxy_buffering off" или при работе
-с memcached соединения могли не закрываться по таймауту.
-</para>
-<para lang="en">
-if the "proxy_buffering off" directive was used or while working with
-memcached the connections might not be closed on timeout.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не запускался на 64-битных платформах, отличных от amd64, sparc64 и ppc64.
-</para>
-<para lang="en">
-nginx did not run on 64-bit platforms except amd64, sparc64, and ppc64.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.6" date="2006-10-06">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не запускался на 64-битных платформах, отличных от amd64, sparc64 и ppc64.
-</para>
-<para lang="en">
-nginx did not run on 64-bit platforms except amd64, sparc64, and ppc64.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при запросе версии HTTP/1.1 nginx передавал ответ chunk'ами,
-если длина ответа в методе $r->headers_out("Content-Length", ...)
-была задана текстовой строкой.
-</para>
-<para lang="en">
-nginx sent the chunked response for HTTP/1.1 request,<br/>
-if its length was set by text string in
-the $r->headers_out("Content-Length", ...) method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после перенаправления ошибки с помощью директивы error_page любая директива
-модуля ngx_http_rewrite_module возвращала эту ошибку;
-ошибка появилась в 0.4.4.
-</para>
-<para lang="en">
-after redirecting error by an "error_page" directive
-any ngx_http_rewrite_module directive returned this error code;
-the bug had appeared in 0.4.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.5" date="2006-10-02">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Linux и Solaris;
-ошибка появилась в 0.4.4.
-</para>
-<para lang="en">
-nginx could not be built on Linux and Solaris;
-the bug had appeared in 0.4.4.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.4" date="2006-10-02">
-
-<change type="feature">
-<para lang="ru">
-переменная $scheme.
-</para>
-<para lang="en">
-the $scheme variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива expires поддерживает параметр max.
-</para>
-<para lang="en">
-the "expires" directive supports the "max" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива include поддерживает маску "*".<br/>
-Спасибо Jonathan Dance.
-</para>
-<para lang="en">
-the "include" directive supports the "*" mask.<br/>
-Thanks to Jonathan Dance.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива return всегда изменяла код ответа, перенаправленного
-директивой error_page.
-</para>
-<para lang="en">
-the "return" directive always overrode the "error_page" response code
-redirected by the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-происходил segmentation fault, если в методе PUT передавалось
-тело нулевой длины.
-</para>
-<para lang="en">
-a segmentation fault occurred if zero-length body was in PUT method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании переменных в директиве proxy_redirect редирект
-изменялся неверно.
-</para>
-<para lang="en">
-the redirect was changed incorrectly if the variables were used
-in the "proxy_redirect" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.3" date="2006-09-26">
-
-<change type="change">
-<para lang="ru">
-ошибку 499 теперь нельзя перенаправить с помощью директивы error_page.
-</para>
-<para lang="en">
-now the 499 error could not be redirected using an "error_page" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка Solaris 10 event ports.
-</para>
-<para lang="en">
-the Solaris 10 event ports support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_browser_module.
-</para>
-<para lang="en">
-the ngx_http_browser_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении ошибки 400 проксированному серверу
-помощью директивы error_page мог произойти segmentation fault.
-</para>
-<para lang="en">
-a segmentation fault may occur while redirecting the 400 error
-to the proxied server using a "proxy_pass" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-происходил segmentation fault, если в директиве proxy_pass использовался
-unix domain сокет;
-ошибка появилась в 0.3.47.
-</para>
-<para lang="en">
-a segmentation fault occurred if an unix domain socket was used in
-a "proxy_pass" directive;
-the bug had appeared in 0.3.47.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-SSI не работал с ответами memcached и небуферизированными проксированными
-ответами.
-</para>
-<para lang="en">
-SSI did work with memcached and nonbuffered responses.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки PAUSE hardware capability в Sun Studio.
-</para>
-<para lang="en">
-of the Sun Studio PAUSE hardware capability bug.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.2" date="2006-09-14">
-
-<change type="bugfix">
-<para lang="ru">
-убрана поддержка флага O_NOATIME на Linux;
-ошибка появилась в 0.4.1.
-</para>
-<para lang="en">
-the O_NOATIME flag support on Linux was canceled;
-the bug had appeared in 0.4.1.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.1" date="2006-09-14">
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с DragonFlyBSD.<br/>
-Спасибо Павлу Назарову.
-</para>
-<para lang="en">
-the DragonFlyBSD compatibility.<br/>
-Thanks to Pavel Nazarov.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки в sendfile() в 64-битном Linux при передаче файлов больше 2G.
-</para>
-<para lang="en">
-of bug in 64-bit Linux sendfile(), when file is more than 2G.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-теперь на Linux nginx для статических запросов использует флаг O_NOATIME.<br/>
-Спасибо Yusuf Goolamabbas.
-</para>
-<para lang="en">
-now on Linux nginx uses O_NOATIME flag for static requests.<br/>
-Thanks to Yusuf Goolamabbas.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.4.0" date="2006-08-30">
-
-<change>
-<para lang="ru">
-Изменение во внутреннем API: инициализация модулей HTTP перенесена из фазы
-init module в фазу HTTP postconfiguration.
-</para>
-<para lang="en">
-Change in internal API: the HTTP modules initialization was moved
-from the init module phase to the HTTP postconfiguration phase.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь тело запроса в модуле ngx_http_perl_module не считывается
-заранее: нужно явно инициировать чтение с помощью метода $r->has_request_body.
-</para>
-<para lang="en">
-now the request body is not read beforehand for the ngx_http_perl_module:
-it's required to start the reading using the $r->has_request_body method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает код возврата DECLINED.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the DECLINED return code.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_dav_module поддерживает входящую строку заголовка "Date"
-для метода PUT.
-</para>
-<para lang="en">
-the ngx_http_dav_module supports the incoming "Date" header line
-for the PUT method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssi работает внутри блока if.
-</para>
-<para lang="en">
-the "ssi" directive is available inside the "if" block.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-происходил segmentation fault, если в директиве index использовалась
-переменные и при этом первое имя индексного файла было без переменных;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-a segmentation fault occurred if there was an "index" directive with
-variables and the first index name was without variables;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.61" date="2006-08-28">
-
-<change type="change">
-<para lang="ru">
-директива tcp_nodelay теперь по умолчанию включена.
-</para>
-<para lang="en">
-now the "tcp_nodelay" directive is turned on by default.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива msie_refresh.
-</para>
-<para lang="en">
-the "msie_refresh" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива recursive_error_pages.
-</para>
-<para lang="en">
-the "recursive_error_pages" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива rewrite возвращала неправильный редирект, если редирект
-включал в себя выделенные закодированные символы из оригинального URI.
-</para>
-<para lang="en">
-the "rewrite" directive returned incorrect redirect, if the redirect
-had the captured escaped symbols from original URI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.60" date="2006-08-18">
-
-<change type="bugfix">
-<para lang="ru">
-во время перенаправления ошибки рабочий процесс мог зациклиться;
-ошибка появилась в 0.3.59.
-</para>
-<para lang="en">
-a worker process may got caught in an endless loop
-while an error redirection;
-the bug had appeared in 0.3.59.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.59" date="2006-08-16">
-
-<change type="feature">
-<para lang="ru">
-теперь можно делать несколько перенаправлений через директиву error_page.
-</para>
-<para lang="en">
-now is possible to do several redirection using the "error_page" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива dav_access не поддерживала три параметра.
-</para>
-<para lang="en">
-the "dav_access" directive did not support three parameters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page не изменяла строку "Content-Type"
-после перенаправления с помощью "X-Accel-Redirect";
-ошибка появилась в 0.3.58.
-</para>
-<para lang="en">
-the "error_page" directive did not changes the "Content-Type" header line
-after the "X-Accel-Redirect" was used;
-the bug had appeared in 0.3.58.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.58" date="2006-08-14">
-
-<change type="feature">
-<para lang="ru">
-директива error_page поддерживает переменные.
-</para>
-<para lang="en">
-the "error_page" directive supports the variables.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь на Linux используется интерфейс procfs вместо sysctl.
-</para>
-<para lang="en">
-now the procfs interface instead of sysctl is used on Linux.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь при использовании "X-Accel-Redirect" строка "Content-Type" наследуется
-из первоначального ответа.
-</para>
-<para lang="en">
-now the "Content-Type" header line is inherited from first response
-when the "X-Accel-Redirect" was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива error_page не перенаправляла ошибку 413.
-</para>
-<para lang="en">
-the "error_page" directive did not redirect the 413 error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-завершающий "?" не удалял старые аргументы, если в переписанном URI
-не было новых аргументов.
-</para>
-<para lang="en">
-the trailing "?" did not remove old arguments if no new arguments
-were added to a rewritten URI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не запускался на 64-битной FreeBSD 7.0-CURRENT.
-</para>
-<para lang="en">
-nginx could not run on 64-bit FreeBSD 7.0-CURRENT.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.57" date="2006-08-09">
-
-<change type="feature">
-<para lang="ru">
-переменная $ssl_client_serial.
-</para>
-<para lang="en">
-the $ssl_client_serial variable.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в операторе "!-e" в директиве if.<br/>
-Спасибо Андриану Буданцову.
-</para>
-<para lang="en">
-in the "!-e" operator of the "if" directive.<br/>
-Thanks to Andrian Budanstov.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проверке клиентского сертификата nginx не передавал клиенту
-информацию о требуемых сертификатах.
-</para>
-<para lang="en">
-while a client certificate verification nginx did not send to a client
-the required certificates information.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $document_root не поддерживала переменные в директиве root.
-</para>
-<para lang="en">
-the $document_root variable did not support the variables in the "root"
-directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.56" date="2006-08-04">
-
-<change type="feature">
-<para lang="ru">
-директива dav_access.
-</para>
-<para lang="en">
-the "dav_access" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива if поддерживает операторы "-d", "!-d", "-e", "!-e", "-x" и "!-x".
-</para>
-<para lang="en">
-the "if" directive supports the "-d", "!-d", "-e", "!-e", "-x", and "!-x"
-operators.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при записи в access_log некоторых передаваемых клиенту строк заголовков
-происходил segmentation fault, если запрос возвращал редирект.
-</para>
-<para lang="en">
-a segmentation fault occurred if a request returned a redirect and
-some sent to client header lines were logged in the access log.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.55" date="2006-07-28">
-
-<change type="feature">
-<para lang="ru">
-параметр stub в команде SSI include.
-</para>
-<para lang="en">
-the "stub" parameter in the "include" SSI command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-команда SSI block.
-</para>
-<para lang="en">
-the "block" SSI command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-скрипт unicode2nginx добавлен в contrib.
-</para>
-<para lang="en">
-the unicode2nginx script was added to contrib.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если root был задан только переменной, то корень задавался
-относительно префикса сервера.
-</para>
-<para lang="en">
-if a "root" was specified by variable only, then the root was relative
-to a server prefix.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в запросе был "//" или "/.", и после этого закодированные
-символы в виде "%XX", то проксируемый запрос передавался незакодированным.
-</para>
-<para lang="en">
-if the request contained "//" or "/./" and escaped symbols after them,
-then the proxied request was sent unescaped.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод $r->header_in("Cookie") модуля ngx_http_perl_module теперь возвращает
-все строки "Cookie" в заголовке запроса.
-</para>
-<para lang="en">
-the $r->header_in("Cookie") of the ngx_http_perl_module now returns
-all "Cookie" header lines.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-происходил segmentation fault, если использовался
-<nobr>"client_body_in_file_only on"</nobr>
-и делался переход к следующему бэкенду.
-</para>
-<para lang="en">
-a segmentation fault occurred if <nobr>"client_body_in_file_only on"</nobr>
-was used and nginx switched to a next upstream.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых условиях во время переконфигурации коды символов
-внутри директивы charset_map могли считаться неверными;
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-on some condition while reconfiguration character codes
-inside the "charset_map" may be treated invalid;
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.54" date="2006-07-11">
-
-<change type="feature">
-<para lang="ru">
-nginx теперь записывает в лог информацию о подзапросах.
-</para>
-<para lang="en">
-nginx now logs the subrequest information to the error log.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_next_upstream, fastcgi_next_upstream и memcached_next_upstream
-поддерживают параметр off.
-</para>
-<para lang="en">
-the "proxy_next_upstream", "fastcgi_next_upstream",
-and "memcached_next_upstream" directives support the "off" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива debug_connection поддерживает запись адресов в формате CIDR.
-</para>
-<para lang="en">
-the "debug_connection" directive supports the CIDR address form.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перекодировании ответа проксированного сервера или сервера FastCGI
-в UTF-8 или наоборот ответ мог передаваться не полностью.
-</para>
-<para lang="en">
-if a response of proxied server or FastCGI server was converted from UTF-8
-or back, then it may be transferred incomplete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $upstream_response_time содержала время только первого
-обращения к бэкенду.
-</para>
-<para lang="en">
-the $upstream_response_time variable had the time of the first
-request to a backend only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформе amd64;
-ошибка появилась в 0.3.53.
-</para>
-<para lang="en">
-nginx could not be built on amd64 platform;
-the bug had appeared in 0.3.53.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.53" date="2006-07-07">
-
-<change type="change">
-<para lang="ru">
-директива add_header добавляет строки в ответы с кодом 204, 301 и 302.
-</para>
-<para lang="en">
-the "add_header" directive adds the string to 204, 301, and 302 responses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server в блоке upstream поддерживает параметр weight.
-</para>
-<para lang="en">
-the "server" directive in the "upstream" context supports
-the "weight" parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server_name поддерживает маску "*".
-</para>
-<para lang="en">
-the "server_name" directive supports the "*" wildcard.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-nginx поддерживает тело запроса больше 2G.
-</para>
-<para lang="en">
-nginx supports the request body size more than 2G.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если при использовании "satisfy_any on" клиент успешно проходил аутентификацию,
-в лог всё равно записалоcь сообщение "access forbidden by rule".
-</para>
-<para lang="en">
-if a client was successfully authorized using "satisfy_any on", then anyway
-the message "access forbidden by rule" was written in the log.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-метод PUT мог ошибочно не создать файл и вернуть код 409.
-</para>
-<para lang="en">
-the "PUT" method may erroneously not create a file and return the 409 code.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если во время аутентификации IMAP/POP3 бэкенд возвращал ошибку, nginx
-продолжал проксирование.
-</para>
-<para lang="en">
-if the IMAP/POP3 backend returned an error, then nginx continued proxying
-anyway.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.52" date="2006-07-03">
-
-<change type="change">
-<para lang="ru">
-восстановлено поведение модуля ngx_http_index_module для запросов "POST /":
-как в версии до 0.3.40, модуль теперь не выдаёт ошибку 405.
-</para>
-<para lang="en">
-the ngx_http_index_module behavior for the "POST /" requests is reverted
-to the 0.3.40 version state: the module now does not return the 405 error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании ограничения скорости рабочий процесс мог зациклиться;
-ошибка появилась в 0.3.37.
-</para>
-<para lang="en">
-the worker process may got caught in an endless loop if the limit rate was used;
-the bug had appeared in 0.3.37.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_charset_module записывал в лог ошибку "unknown charset",
-даже если перекодировка не требовалась;
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-ngx_http_charset_module logged "unknown charset" alert, even if the recoding
-was not needed;
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в результате запроса PUT возвращался код 409, то временный файл
-не удалялся.
-</para>
-<para lang="en">
-if a code response of the PUT request was 409, then a temporary file
-was not removed.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.51" date="2006-06-30">
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых условиях в SSI мог пропадать символы "&lt;";
-ошибка появилась в 0.3.50.
-</para>
-<para lang="en">
-the "&lt;" symbols might disappeared some conditions in the SSI;
-the bug had appeared in 0.3.50.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.50" date="2006-06-28">
-
-<change type="change">
-<para lang="ru">
-директивы proxy_redirect_errors и fastcgi_redirect_errors
-переименованы соответственно в proxy_intercept_errors и
-fastcgi_intercept_errors.
-</para>
-<para lang="en">
-the "proxy_redirect_errors" and "fastcgi_redirect_errors" directives
-was renamed to the "proxy_intercept_errors" and
-"fastcgi_intercept_errors" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_charset_module поддерживает перекодирование из
-однобайтных кодировок в UTF-8 и обратно.
-</para>
-<para lang="en">
-the ngx_http_charset_module supports the recoding from the single byte
-encodings to the UTF-8 encoding and back.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в режиме прокси и FastCGI поддерживается строка заголовка "X-Accel-Charset"
-в ответе бэкенда.
-</para>
-<para lang="en">
-the "X-Accel-Charset" response header line is supported in proxy
-and FastCGI mode.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-символ "\" в парах "\"" и "\'" в SSI командах убирался, только если
-также использовался символ "$".
-</para>
-<para lang="en">
-the "\" escape symbol in the "\"" and "\'" pairs in the SSI command
-was removed only if the command also has the "$" symbol.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых условиях в SSI после вставки могла быть добавлена
-строка "&lt;!--".
-</para>
-<para lang="en">
-the "&lt;!--" string might be added on some conditions
-in the SSI after inclusion.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в заголовке ответа была строка <nobr>"Content-Length: 0",</nobr>
-то при использовании небуферизированного проксировании не закрывалось соединение
-с клиентом.
-</para>
-<para lang="en">
-if the "Content-Length: 0" header line was in response, then
-in nonbuffered proxying mode the client connection was not closed.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.49" date="2006-05-31">
-
-<change type="bugfix">
-<para lang="ru">
-в директиве set.
-</para>
-<para lang="en">
-in the "set" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включении в ssi двух и более подзапросов, обрабатываемых через FastCGI,
-вместо вывода второго и остальных подзапросов в ответ включался вывод
-первого подзапроса.
-</para>
-<para lang="en">
-if two or more FastCGI subrequests was in SSI, then first subrequest output
-was included instead of second and following subrequests.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.48" date="2006-05-29">
-
-<change type="change">
-<para lang="ru">
-теперь модуль ngx_http_charset_module работает для подзапросов,
-в ответах которых нет строки заголовка "Content-Type".
-</para>
-<para lang="en">
-now the ngx_http_charset_module works for subrequests,
-if the response has no "Content-Type" header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве proxy_pass не было URI,
-то директива "proxy_redirect  default" добавляла в переписанный
-редирект в начало лишний слэш.
-</para>
-<para lang="en">
-if the "proxy_pass" directive has no URI part,
-then the "proxy_redirect  default" directive add the unnecessary slash
-in start of the rewritten redirect.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-внутренний редирект всегда превращал любой HTTP-метод в GET,
-теперь это делается только для редиректов, выполняемых с помощью
-X-Accel-Redirect, и у которых метод не равен HEAD;
-ошибка появилась в 0.3.42.
-</para>
-<para lang="en">
-the internal redirect always transform client's HTTP method to GET,
-now the transformation is made for the "X-Accel-Redirect" redirects only
-and if the method is not HEAD;
-the bug had appeared in 0.3.42.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_perl_module не собирался, если перл был с поддержкой потоков;
-ошибка появилась в 0.3.46.
-</para>
-<para lang="en">
-the ngx_http_perl_module could not be built, if the perl was built
-with the threads support;
-the bug had appeared in 0.3.46.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.47" date="2006-05-23">
-
-<change type="feature">
-<para lang="ru">
-директива upstream.
-</para>
-<para lang="en">
-the "upstream" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-символ "\" в парах "\"" и "\'" в SSI командах теперь всегда убирается.
-</para>
-<para lang="en">
-now the "\" escape symbol in the "\"" and "\'" pairs in the SSI command
-is always removed.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.46" date="2006-05-11">
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_hide_header, proxy_pass_header, fastcgi_hide_header
-и fastcgi_pass_header.
-</para>
-<para lang="en">
-the "proxy_hide_header", "proxy_pass_header", "fastcgi_hide_header",
-and "fastcgi_pass_header" directives.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы proxy_pass_x_powered_by, fastcgi_x_powered_by и proxy_pass_server
-упразднены.
-</para>
-<para lang="en">
-the "proxy_pass_x_powered_by", "fastcgi_x_powered_by", and "proxy_pass_server"
-directives were canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в режиме прокси поддерживается строка заголовка "X-Accel-Buffering"
-в ответе бэкенда.
-</para>
-<para lang="en">
-the "X-Accel-Buffering" response header line is supported in proxy mode.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибок и утечек памяти при переконфигурации в модуле ngx_http_perl_module.
-</para>
-<para lang="en">
-the reconfiguration bug and memory leaks in the ngx_http_perl_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.45" date="2006-05-06">
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_verify_client, ssl_verify_depth и ssl_client_certificate.
-</para>
-<para lang="en">
-the "ssl_verify_client", "ssl_verify_depth", and "ssl_client_certificate"
-directives.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь переменная $request_method возвращает метод только основного запроса.
-</para>
-<para lang="en">
-the $request_method variable now returns the main request method.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в таблице перекодировки koi-win изменены коды символа &amp;deg;.
-</para>
-<para lang="en">
-the &amp;deg; symbol codes were changed in koi-win conversion table.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в таблицу перекодировки koi-win добавлены символы евро и номера.
-</para>
-<para lang="en">
-the euro and N symbols were added to koi-win conversion table.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если nginx распределял запросы на несколько машин, то при падении
-одной из них запросы, предназначенные для этой машины, перенаправлялись только
-на одну машину вместо того, чтобы равномерно распределяться между остальными.
-</para>
-<para lang="en">
-if nginx distributed the requests among several backends and some backend
-failed, then requests intended for this backend was directed to one live
-backend only instead of being distributed among the rest.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.44" date="2006-05-04">
-
-<change type="feature">
-<para lang="ru">
-параметр wait в команде SSI include.
-</para>
-<para lang="en">
-the "wait" parameter in the "include" SSI command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в таблицу перекодировки koi-win добавлены украинские и белорусские символы.
-</para>
-<para lang="en">
-the Ukrainian and Byelorussian characters were added to koi-win conversion
-table.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в SSI.
-</para>
-<para lang="en">
-in the SSI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.43" date="2006-04-26">
-
-<change type="bugfix">
-<para lang="ru">
-в SSI.
-</para>
-<para lang="en">
-in the SSI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.42" date="2006-04-26">
-
-<change type="feature">
-<para lang="ru">
-параметр bind в директиве listen в IMAP/POP3 прокси.
-</para>
-<para lang="en">
-the "bind" option of the "listen" directive in IMAP/POP3 proxy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании в директиве rewrite одного и того же
-выделения более одного раза.
-</para>
-<para lang="en">
-if the same capture in the "rewrite" directive was used more then once.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в лог не записывались переменные
-$sent_http_content_type, $sent_http_content_length, $sent_http_last_modified,
-$sent_http_connection, $sent_http_keep_alive и $sent_http_transfer_encoding.
-</para>
-<para lang="en">
-the $sent_http_content_type, $sent_http_content_length,
-$sent_http_last_modified, $sent_http_connection, $sent_http_keep_alive,
-and $sent_http_transfer_encoding variables were not written to access log.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменная $sent_http_cache_control возвращала содержимое только одной
-строки "Cache-Control" в заголовке ответа.
-</para>
-<para lang="en">
-the $sent_http_cache_control returned value of the single "Cache-Control"
-response header line.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.41" date="2006-04-21">
-
-<change type="feature">
-<para lang="ru">
-ключ -v.
-</para>
-<para lang="en">
-the -v switch.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включении в SSI удалённых подзапросов
-мог произойти segmentation fault.
-</para>
-<para lang="en">
-the segmentation fault may occurred if the SSI page has remote subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в обработке FastCGI.
-</para>
-<para lang="en">
-in FastCGI handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если путь к перловым модулям не был указан с помощью
---with-perl_modules_path=PATH или директивы perl_modules,
-то на старте происходил segmentation fault.
-</para>
-<para lang="en">
-if the perl modules path was not set using
---with-perl_modules_path=PATH or the "perl_modules", then
-the segmentation fault was occurred.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.40" date="2006-04-19">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_dav_module поддерживает метод MKCOL.
-</para>
-<para lang="en">
-the ngx_http_dav_module supports the MKCOL method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива create_full_put_path.
-</para>
-<para lang="en">
-the "create_full_put_path" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $limit_rate.
-</para>
-<para lang="en">
-the "$limit_rate" variable.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.39" date="2006-04-17">
-
-<change type="feature">
-<para lang="ru">
-директива uninitialized_variable_warn; уровень логгирования сообщения
-о неинициализированной переменной понижен с уровня alert на warn.
-</para>
-<para lang="en">
-the "uninitialized_variable_warn" directive; the logging level of the
-"uninitialized variable" message was lowered from "alert" to "warn".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива override_charset.
-</para>
-<para lang="en">
-the "override_charset" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при использовании неизвестной переменной в SSI-командах echo и if expr='$name'
-теперь не записывается в лог сообщение о неизвестной переменной.
-</para>
-<para lang="en">
-now if the unknown variable is used in the "echo" and "if expr='$name'"
-SSI-commands, then the "unknown variable" message is not logged.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-счётчик активных соединений рос при превышении лимита соединений,
-заданного директивой worker_connections;
-ошибка появилась в 0.2.0.
-</para>
-<para lang="en">
-the active connection counter increased on the exceeding of the connection
-limit specified by the "worker_connections" directive;
-the bug had appeared in 0.2.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых условия ограничение скорости соединения могло не работать;
-ошибка появилась в 0.3.38.
-</para>
-<para lang="en">
-the limit rate might not work on some condition;
-the bug had appeared in 0.3.38.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.38" date="2006-04-14">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_dav_module.
-</para>
-<para lang="en">
-the ngx_http_dav_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-оптимизация модуля ngx_http_perl_module.<br/>
-Спасибо Сергею Скворцову.
-</para>
-<para lang="en">
-the ngx_http_perl_module optimizations.<br/>
-Thanks to Sergey Skvortsov.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает метод $r->request_body_file.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->request_body_file method.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива client_body_in_file_only.
-</para>
-<para lang="en">
-the "client_body_in_file_only" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-теперь при переполнении диска nginx пытается писать access_log'и только
-раз в секунду.<br/>
-Спасибо Антону Южанинову и Максиму Дунину.
-</para>
-<para lang="en">
-now on disk overflow nginx tries to write access logs once a second only.<br/>
-Thanks to Anton Yuzhaninov and Maxim Dounin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-теперь директива limit_rate точнее ограничивает скорость при значениях
-больше <nobr>100 Kbyte/s.</nobr><br/>
-Спасибо ForJest.
-</para>
-<para lang="en">
-now the "limit_rate" directive more precisely limits rate if rate is more
-than <nobr>100 Kbyte/s.</nobr><br/>
-Thanks to ForJest.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-IMAP/POP3 прокси теперь передаёт серверу авторизации символы "\r" и "\n"
-в логине и пароле в закодированном виде.<br/>
-Спасибо Максиму Дунину.
-</para>
-<para lang="en">
-now the IMAP/POP3 proxy escapes the "\r" and "\n" symbols in login and
-password to pass authorization server.<br/>
-Thanks to Maxim Dounin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.37" date="2006-04-07">
-
-<change type="feature">
-<para lang="ru">
-директива limit_except.
-</para>
-<para lang="en">
-the "limit_except" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива if поддерживает операторы "!~", "!~*", "-f" и "!-f".
-</para>
-<para lang="en">
-the "if" directive supports the "!~", "!~*", "-f", and "!-f" operators.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает метод $r->request_body.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->request_body method.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в модуле ngx_http_addition_filter_module.
-</para>
-<para lang="en">
-in the ngx_http_addition_filter_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.36" date="2006-04-05">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_addition_filter_module.
-</para>
-<para lang="en">
-the ngx_http_addition_filter_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_pass и fastcgi_pass можно использовать внутри блока if.
-</para>
-<para lang="en">
-the "proxy_pass" and "fastcgi_pass" directives may be used inside
-the "if" block.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_ignore_client_abort и fastcgi_ignore_client_abort.
-</para>
-<para lang="en">
-the "proxy_ignore_client_abort" and "fastcgi_ignore_client_abort" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $request_completion.
-</para>
-<para lang="en">
-the "$request_completion" variable.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает методы $r->request_method и
-$r->remote_addr.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->request_method and $r->remote_addr.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает команду elif.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the "elif" command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строка "\/" в начале выражения команды if модуля ngx_http_ssi_module
-воспринималась неверно.
-</para>
-<para lang="en">
-the "\/" string in the expression of the "if" command of the
-ngx_http_ssi_module was treated incorrectly.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании регулярных выражениях в команде if модуля ngx_http_ssi_module.
-</para>
-<para lang="en">
-in the regular expressions in the "if" command of the ngx_http_ssi_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при задании относительного пути в директивах
-client_body_temp_path, proxy_temp_path, fastcgi_temp_path и perl_modules
-использовался каталог относительно текущего каталога, а не относительно
-префикса сервера.
-</para>
-<para lang="en">
-if the relative path was specified in the "client_body_temp_path",
-"proxy_temp_path", "fastcgi_temp_path", and "perl_modules" directives,
-then the directory was used relatively to a current path but not
-to a server prefix.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.35" date="2006-03-22">
-
-<change type="bugfix">
-<para lang="ru">
-accept-фильтр и TCP_DEFER_ACCEPT устанавливались только для первой
-директивы listen;
-ошибка появилась в 0.3.31.
-</para>
-<para lang="en">
-the accept-filter and the TCP_DEFER_ACCEPT option were set for first "listen"
-directive only;
-the bug had appeared in 0.3.31.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве proxy_pass без URI при использовании в подзапросе.
-</para>
-<para lang="en">
-in the "proxy_pass" directive without the URI part in a subrequest.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.34" date="2006-03-21">
-
-<change type="feature">
-<para lang="ru">
-директива add_header поддерживает переменные.
-</para>
-<para lang="en">
-the "add_header" directive supports the variables.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.33" date="2006-03-15">
-
-<change type="feature">
-<para lang="ru">
-параметр http_503 в директивах proxy_next_upstream или fastcgi_next_upstream.
-</para>
-<para lang="en">
-the "http_503" parameter of the "proxy_next_upstream" or
-"fastcgi_next_upstream" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_perl_module не работал со встроенным в конфигурационный файл кодом,
-если он не начинался сразу же с "sub".
-</para>
-<para lang="en">
-ngx_http_perl_module did not work with inlined in the configuration code,
-if it was not started with the "sub" word.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве post_action.
-</para>
-<para lang="en">
-in the "post_action" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.32" date="2006-03-11">
-
-<change type="bugfix">
-<para lang="ru">
-удаление отладочного логгирования на старте и при переконфигурации;
-ошибка появилась в 0.3.31.
-</para>
-<para lang="en">
-the debug logging on startup and reconfiguration time was removed;
-the bug had appeared in 0.3.31.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.31" date="2006-03-10">
-
-<change type="change">
-<para lang="ru">
-теперь nginx передаёт неверные ответы проксированного бэкенда.
-</para>
-<para lang="en">
-now nginx passes the malformed proxied backend responses.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы listen поддерживают адрес в виде "*:порт".
-</para>
-<para lang="en">
-the "listen" directives support the address in the "*:port" form.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка EVFILER_TIMER в MacOSX 10.4.
-</para>
-<para lang="en">
-the EVFILER_TIMER support in MacOSX 10.4.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки обработки миллисекундных таймаутов kqueue в 64-битном ядре
-MacOSX.<br/>
-Спасибо Андрею Нигматулину.
-</para>
-<para lang="en">
-for MacOSX 64-bit kernel kqueue millisecond timeout bug.<br/>
-Thanks to Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если внутри одного сервера описаны несколько директив listen, слушающих на
-разных адресах, то имена серверов вида "*.domain.tld" работали только
-для первого адреса;
-ошибка появилась в 0.3.18.
-</para>
-<para lang="en">
-if there were several "listen" directives listening one various addresses
-inside one server, then server names like "*.domain.tld" worked for first
-address only;
-the bug had appeared in 0.3.18.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании протокола HTTPS в директиве proxy_pass не передавались
-запросы с телом, записанным во временный файл.
-</para>
-<para lang="en">
-if the HTTPS protocol was used in the "proxy_pass" directive and
-the request body was in temporary file then the request was not transferred.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с perl 5.8.8.
-</para>
-<para lang="en">
-perl 5.8.8 compatibility.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.30" date="2006-02-22">
-
-<change type="change">
-<para lang="ru">
-уровень записи в лог ошибки ECONNABORTED изменён на error с уровня crit.
-</para>
-<para lang="en">
-the ECONNABORTED error log level was changed to "error" from "crit".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_perl_module не собирался без модуля ngx_http_ssi_filter_module.
-</para>
-<para lang="en">
-the ngx_http_perl_module could not be build without
-the ngx_http_ssi_filter_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на i386 платформе, если использовался PIC;
-ошибка появилась в 0.3.27.
-</para>
-<para lang="en">
-nginx could not be built on i386 platform, if the PIC was used;
-the bug had appeared in 0.3.27.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.29" date="2006-02-20">
-
-<change type="feature">
-<para lang="ru">
-теперь nginx использует меньше памяти, если PHP в режиме FastCGI передаёт
-большое количество предупреждений перед ответом.
-</para>
-<para lang="en">
-now nginx uses less memory, if PHP in FastCGI mode sends many warnings
-before the response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в ответах 204 для запросов версии HTTP/1.1 выдавалась строка заголовка
-"Transfer-Encoding: chunked".
-</para>
-<para lang="en">
-the "Transfer-Encoding: chunked" header line was issued in the 204 responses
-for the HTTP/1.1 requests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал 502 код ответа, если FastCGI сервер передавал полные строки
-заголовка ответа в отдельных FastCGI записях.
-</para>
-<para lang="en">
-nginx returned the 502 response, if the complete response header lines
-were transferred in a separate FastCGI records.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве post_action был указан проксируемый URI, то он выполнялся
-только после успешного завершения запроса.
-</para>
-<para lang="en">
-if the proxied URI was specified in the "post_action" directive, then it ran
-only after a successful completion of a request.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.28" date="2006-02-16">
-
-<change type="feature">
-<para lang="ru">
-директива restrict_host_names упразднена.
-</para>
-<para lang="en">
-the "restrict_host_names" directive was canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр конфигурации --with-cpu-opt=ppc64.
-</para>
-<para lang="en">
-the --with-cpu-opt=ppc64 configuration parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых условиях проксированное соединение с клиентом завершалось
-преждевременно.<br/>
-Спасибо Владимиру Шутову.
-</para>
-<para lang="en">
-on some condition the proxied connection with a client was terminated
-prematurely.<br/>
-Thanks to Vladimir Shutoff.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строка заголовка "X-Accel-Limit-Rate" не учитывалась для запросов,
-перенаправленных с помощью строки "X-Accel-Redirect".
-</para>
-<para lang="en">
-the "X-Accel-Limit-Rate" header line was not taken into account
-if the request was redirected using the "X-Accel-Redirect" header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива post_action работала только после успешного завершения запроса.
-</para>
-<para lang="en">
-the "post_action" directive ran only after a successful completion of a request.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-тело проксированного ответа, создаваемого директивой post_action,
-передавалось клиенту.
-</para>
-<para lang="en">
-the proxied response body generated by the "post_action" directive
-was transferred to a client.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.27" date="2006-02-08">
-
-<change type="change">
-<para lang="ru">
-директивы variables_hash_max_size и variables_hash_bucket_size.
-</para>
-<para lang="en">
-the "variables_hash_max_size" and "variables_hash_bucket_size" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменная $body_bytes_sent доступна не только в директиве log_format.
-</para>
-<para lang="en">
-the $body_bytes_sent variable can be used not only in the "log_format"
-directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные $ssl_protocol и $ssl_cipher.
-</para>
-<para lang="en">
-the $ssl_protocol and $ssl_cipher variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-определение размера строки кэша распространённых процессоров при старте.
-</para>
-<para lang="en">
-the cache line size detection for widespread CPUs at start time.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива accept_mutex теперь поддерживается посредством fcntl(2)
-на платформах, отличных от i386, amd64, sparc64 и ppc.
-</para>
-<para lang="en">
-now the "accept_mutex" directive is supported using fcntl(2)
-on platforms different from i386, amd64, sparc64, and ppc.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива lock_file и параметр автоконфигурации --with-lock-path=PATH.
-</para>
-<para lang="en">
-the "lock_file" directive and the --with-lock-path=PATH autoconfiguration
-directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании протокола HTTPS в директиве proxy_pass не передавались
-запросы с телом.
-</para>
-<para lang="en">
-if the HTTPS protocol was used in the "proxy_pass" directive then
-the requests with the body was not transferred.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.26" date="2006-02-03">
-
-<change type="change">
-<para lang="ru">
-директива optimize_host_names переименована в optimize_server_names.
-</para>
-<para lang="en">
-the "optimize_host_names" directive was renamed to the "optimize_server_names".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании подзапроса в SSI бэкенду передавался URI основного запроса,
-если в директиве proxy_pass отсутствовал URI.
-</para>
-<para lang="en">
-if in the "proxy_pass" directive was no the URI part, then the main request
-URI was transferred to a backend while proxying the SSI subrequest.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.25" date="2006-02-01">
-
-<change type="bugfix">
-<para lang="ru">
-при неверной конфигурации на старте или во время переконфигурации происходил
-segmentation fault;
-ошибка появилась в 0.3.24.
-</para>
-<para lang="en">
-the segmentation fault was occurred on start or while reconfiguration
-if there was invalid configuration;
-the bug had appeared in 0.3.24.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.24" date="2006-02-01">
-
-<change type="workaround">
-<para lang="ru">
-обход ошибки в kqueue во FreeBSD.
-</para>
-<para lang="en">
-for bug in FreeBSD kqueue.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответ, создаваемый директивой post_action, теперь не передаётся клиенту.
-</para>
-<para lang="en">
-now a response generated by the "post_action" directive is not transferred
-to a client.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании большого количества лог-файлов происходила утечка памяти.
-</para>
-<para lang="en">
-the memory leaks were occurring if many log files were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-внутри одного location работала только первая директива proxy_redirect.
-</para>
-<para lang="en">
-the first "proxy_redirect" directive was working inside one location.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на 64-битных платформах при старте мог произойти segmentation fault,
-если использовалось большое количество имён в директивах server_name;
-ошибка появилась в 0.3.18.
-</para>
-<para lang="en">
-on 64-bit platforms segmentation fault may occurred on start
-if the many names were used in the "server_name" directives;
-the bug had appeared in 0.3.18.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.23" date="2006-01-24">
-
-<change type="feature">
-<para lang="ru">
-директива optimize_host_names.
-</para>
-<para lang="en">
-the "optimize_host_names" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании переменных в директивах path и alias.
-</para>
-<para lang="en">
-in using of the variables in the "path" and "alias" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_perl_module неправильно собирался на Linux и Solaris.
-</para>
-<para lang="en">
-the ngx_http_perl_module was incorrectly built on Linux and Solaris.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.22" date="2006-01-17">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module поддерживает методы $r->args и $r->unescape.
-</para>
-<para lang="en">
-the ngx_http_perl_module supports the $r->args and $r->unescape methods.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-метод $r->query_string в модуле ngx_http_perl_module упразднён.
-</para>
-<para lang="en">
-the method $r->query_string of ngx_http_perl_module was canceled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве valid_referers указаны только none или blocked, то
-происходил segmentation fault;
-ошибка появилась в 0.3.18.
-</para>
-<para lang="en">
-segmentation fault was occurred if the "none" or "blocked" values was
-specified in the "valid_referers" directive;
-the bug had appeared in 0.3.18.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.21" date="2006-01-16">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_perl_module.
-</para>
-<para lang="en">
-the ngx_http_perl_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива valid_referers разрешает использовать рефереры совсем без URI.
-</para>
-<para lang="en">
-the "valid_referers" directive allows the referrers without URI part.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.20" date="2006-01-11">
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в обработке SSI.
-</para>
-<para lang="en">
-in SSI handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_memcached_module не поддерживал ключи в виде /uri?args.
-</para>
-<para lang="en">
-the ngx_http_memcached_module did not support the keys in the "/usr?args" form.
-</para>
-</change>
-
-</changes>
-
-<changes ver="0.3.19" date="2005-12-28">
-
-<change type="feature">
-<para lang="ru">
-директивы path и alias поддерживают переменные.
-</para>
-<para lang="en">
-the "path" and "alias" directives support the variables.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь директива valid_referers опять учитывает URI.
-</para>
-<para lang="en">
-now the "valid_referers" directive again checks the URI part.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в обработке SSI.
-</para>
-<para lang="en">
-in SSI handling.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.18" date="2005-12-26">
-
-<change type="feature">
-<para lang="ru">
-директива server_names поддерживает имена вида ".domain.tld".
-</para>
-<para lang="en">
-the "server_names" directive supports the ".domain.tld" names.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server_names использует хэш для имён вида "*.domain.tld"
-и более эффективный хэш для обычных имён.
-</para>
-<para lang="en">
-the "server_names" directive uses the hash for the "*.domain.tld" names
-and more effective hash for usual names.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы server_names_hash_max_size и server_names_hash_bucket_size.
-</para>
-<para lang="en">
-the "server_names_hash_max_size" and "server_names_hash_bucket_size" directives.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы server_names_hash и server_names_hash_threshold упразднены.
-</para>
-<para lang="en">
-the "server_names_hash" and "server_names_hash_threshold" directives
-were canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива valid_referers использует хэш для имён сайтов.
-</para>
-<para lang="en">
-the "valid_referers" directive uses the hash site names.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-теперь директива valid_referers проверяет только имена сайтов без учёта URI.
-</para>
-<para lang="en">
-now the "valid_referers" directive checks the site names only without
-the URI part.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-некоторые имена вида ".domain.tld" неверно обрабатывались модулем
-ngx_http_map_module.
-</para>
-<para lang="en">
-some ".domain.tld" names incorrectly processed by the ngx_http_map_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если конфигурационного файла не было, то происходил segmentation fault;
-ошибка появилась в 0.3.12.
-</para>
-<para lang="en">
-segmentation fault was occurred if configuration file did not exist;
-the bug had appeared in 0.3.12.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на 64-битных платформах при старте мог произойти segmentation fault;
-ошибка появилась в 0.3.16.
-</para>
-<para lang="en">
-on 64-bit platforms segmentation fault may occurred on start;
-the bug had appeared in 0.3.16.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.17" date="2005-12-18">
-
-<change type="change">
-<para lang="ru">
-на Linux configure теперь проверяет наличие epoll и sendfile64() в ядре.
-</para>
-<para lang="en">
-now on Linux configure checks the presence of epoll and sendfile64() in kernel.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива map поддерживает доменные имена в формате ".domain.tld".
-</para>
-<para lang="en">
-the "map" directive supports domain names in the ".domain.tld" form.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-во время SSL handshake не иcпользовались таймауты;
-ошибка появилась в 0.2.4.
-</para>
-<para lang="en">
-the timeouts were not used in SSL handshake;
-the bug had appeared in 0.2.4.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в использовании протокола HTTPS в директиве proxy_pass.
-</para>
-<para lang="en">
-in the HTTPS protocol in the "proxy_pass" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании протокола HTTPS в директиве proxy_pass по умолчанию
-использовался порт 80.
-</para>
-<para lang="en">
-when the HTTPS protocol was used in the "proxy_pass" directive the port 80
-was used by default.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.16" date="2005-12-16">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_map_module.
-</para>
-<para lang="en">
-the ngx_http_map_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы types_hash_max_size и types_hash_bucket_size.
-</para>
-<para lang="en">
-the "types_hash_max_size" and "types_hash_bucket_size" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssi_value_length.
-</para>
-<para lang="en">
-the "ssi_value_length" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_rlimit_core.
-</para>
-<para lang="en">
-the "worker_rlimit_core" directive.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-при сборке компиляторами icc 8.1 и 9.0 с оптимизацией для
-<nobr>Pentium 4</nobr> номер соединения в логах всегда был равен 1.
-</para>
-<para lang="en">
-the connection number in logs was always 1 if nginx was built by the
-icc 8.1 or 9.0 compilers with optimization for <nobr>Pentium 4.</nobr>
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-команда config timefmt в SSI задавала неверный формат времени.
-</para>
-<para lang="en">
-the "config timefmt" SSI command set incorrect time format.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не закрывал соединения с IMAP/POP3 бэкендом при использовании SSL
-соединений;
-ошибка появилась в 0.3.13.<br/>
-Спасибо Rob Mueller.
-</para>
-<para lang="en">
-nginx did not close connection to IMAP/POP3 backend for the SSL
-connections;
-the bug had appeared in 0.3.13.<br/>
-Thanks to Rob Mueller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-segmentation fault мог произойти во время SSL shutdown;
-ошибка появилась в 0.3.13.
-</para>
-<para lang="en">
-segmentation fault may occurred in at SSL shutdown;
-the bug had appeared in 0.3.13.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.15" date="2005-12-07">
-
-<change type="feature">
-<para lang="ru">
-новой код 444 в директиве return для закрытия соединения.
-</para>
-<para lang="en">
-the new 444 code of the "return" directive to close connection.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива so_keepalive в IMAP/POP3 прокси.
-</para>
-<para lang="en">
-the "so_keepalive" directive in IMAP/POP3 proxy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx теперь вызывает abort() при обнаружении незакрытых соединений
-только при плавном выходе и включённой директиве debug_points.
-</para>
-<para lang="en">
-if there are unclosed connection nginx now calls abort() only on graceful
-quit and active "debug_points" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.14" date="2005-12-05">
-
-<change type="bugfix">
-<para lang="ru">
-в ответе 304 передавалось тело ответа;
-ошибка появилась в 0.3.13.
-</para>
-<para lang="en">
-in the 304 response the body was transferred;
-the bug had appeared in 0.3.13.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.13" date="2005-12-05">
-
-<change type="feature">
-<para lang="ru">
-IMAP/POP3 прокси поддерживает STARTTLS и STLS.
-</para>
-<para lang="en">
-the IMAP/POP3 proxy supports STARTTLS and STLS.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-IMAP/POP3 прокси не работала с методами select, poll и /dev/poll.
-</para>
-<para lang="en">
-the IMAP/POP3 proxy did not work with the select, poll, and /dev/poll methods.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в обработке SSI.
-</para>
-<para lang="en">
-in SSI handling.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-sendfilev() в Solaris теперь не используется при передаче тела запроса
-FastCGI-серверу через unix domain сокет.
-</para>
-<para lang="en">
-now Solaris sendfilev() is not used to transfer the client request body
-to FastCGI-server via the unix domain socket.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива auth_basic не запрещала аутентификацию;
-ошибка появилась в 0.3.11.
-</para>
-<para lang="en">
-the "auth_basic" directive did not disable the authorization;
-the bug had appeared in 0.3.11.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.12" date="2005-11-26">
-
-<change type="security">
-<para lang="ru">
-если nginx был собран с модулем ngx_http_realip_module, то при использовании
-директивы "satisfy_any on" директивы доступа и аутентификации не работали.
-Модуль ngx_http_realip_module не собирался и не собирается по умолчанию.
-</para>
-<para lang="en">
-if nginx was built with the ngx_http_realip_module and the "satisfy_any on"
-directive was used, then access and authorization directives did not work.
-The ngx_http_realip_module was not built and is not built by default.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-имя переменной "$time_gmt" изменено на "$time_local".
-</para>
-<para lang="en">
-the "$time_gmt" variable name was changed to "$time_local".
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы proxy_header_buffer_size и fastcgi_header_buffer_size
-переименованы соответственно в proxy_buffer_size и fastcgi_buffer_size.
-</para>
-<para lang="en">
-the "proxy_header_buffer_size" and "fastcgi_header_buffer_size" directives
-was renamed to the "proxy_buffer_size" and "fastcgi_buffer_size" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_memcached_module.
-</para>
-<para lang="en">
-the ngx_http_memcached_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_buffering.
-</para>
-<para lang="en">
-the "proxy_buffering" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-изменение в работе с accept mutex при использовании метода rtsig;
-ошибка появилась в 0.3.0.
-</para>
-<para lang="en">
-the changes in accept mutex  handling when the "rtsig" method was used;
-the bug had appeared in 0.3.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если клиент передал строку "Transfer-Encoding: chunked" в заголовке
-запроса, то nginx теперь выдаёт ошибку 411.
-</para>
-<para lang="en">
-if the client sent the "Transfer-Encoding: chunked" header line, then
-nginx returns the 411 error.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при наследовании директивы auth_basic с уровня http в строке
-"WWW-Authenticate" заголовка ответа выводился realm без текста "Basic realm".
-</para>
-<para lang="en">
-if the "auth_basic" directive was inherited from the http level,
-then the realm in the "WWW-Authenticate" header line was without
-the "Basic realm" text.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве access_log был явно указан формат combined, то в лог
-записывались пустые строки;
-ошибка появилась в 0.3.8.
-</para>
-<para lang="en">
-if the "combined" format was explicitly specified in the "access_log" directive,
-then the empty lines was written to the log;
-the bug had appeared in 0.3.8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на платформе sparc под любыми OS, кроме Solaris.
-</para>
-<para lang="en">
-nginx did not run on the sparc platform under any OS except Solaris.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве if теперь не нужно разделять пробелом строку в кавычках и
-закрывающую скобку.
-</para>
-<para lang="en">
-now it is not necessary to place space between the quoted string and closing
-bracket in the "if" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.11" date="2005-11-15">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не передавал при проксировании тело запроса и строки заголовка клиента;
-ошибка появилась в 0.3.10.
-</para>
-<para lang="en">
-nginx did not pass the client request headers and body while proxying;
-the bug had appeared in 0.3.10.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.10" date="2005-11-15">
-
-<change type="change">
-<para lang="ru">
-директива valid_referers и переменная $invalid_referer перенесены
-из модуля ngx_http_rewrite_module в новый модуль ngx_http_referer_module.
-</para>
-<para lang="en">
-the "valid_referers" directive and the "$invalid_referer" variable
-were moved to the new ngx_http_referer_module from the ngx_http_rewrite_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-имя переменной "$apache_bytes_sent" изменено на "$body_bytes_sent".
-</para>
-<para lang="en">
-the "$apache_bytes_sent" variable name was changed to "$body_bytes_sent".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные "$sent_http_...".
-</para>
-<para lang="en">
-the "$sent_http_..." variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива if поддерживает операции "=" и "!=".
-</para>
-<para lang="en">
-the "if" directive supports the "=" and "!=" operations.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_pass поддерживает протокол HTTPS.
-</para>
-<para lang="en">
-the "proxy_pass" directive supports the HTTPS protocol.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_set_body.
-</para>
-<para lang="en">
-the "proxy_set_body" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива post_action.
-</para>
-<para lang="en">
-the "post_action" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_empty_gif_module.
-</para>
-<para lang="en">
-the ngx_http_empty_gif_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива worker_cpu_affinity для Linux.
-</para>
-<para lang="en">
-the "worker_cpu_affinity" directive for Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива rewrite не раскодировала символы в редиректах в URI,
-теперь символы раскодируются, кроме символов %00-%25 и %7F-%FF.
-</para>
-<para lang="en">
-the "rewrite" directive did not unescape URI part in redirect,
-now it is unescaped except the %00-%25 and %7F-%FF characters.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался компилятором icc 9.0.
-</para>
-<para lang="en">
-nginx could not be built by the icc 9.0 compiler.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если для статического файла нулевого размера был разрешён SSI,
-то ответ передавался неверно при кодировании chunk'ами.
-</para>
-<para lang="en">
-if the SSI was enabled for zero size static file, then the chunked
-response was encoded incorrectly.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.9" date="2005-11-10">
-
-<change type="bugfix">
-<para lang="ru">
-nginx считал небезопасными URI, в которых между двумя слэшами
-находилось два любых символа;
-ошибка появилась в 0.3.8.
-</para>
-<para lang="en">
-nginx considered URI as unsafe if two any symbols was between two slashes;
-the bug had appeared in 0.3.8.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.8" date="2005-11-09">
-
-<change type="security">
-<para lang="ru">
-nginx теперь проверят URI, полученные от бэкенда в строке "X-Accel-Redirect"
-в заголовке ответа, или в SSI файле на наличие путей "/../" и нулей.
-</para>
-<para lang="en">
-nginx now checks URI got from a backend in "X-Accel-Redirect" header line
-or in SSI file for the "/../" paths and zeroes.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-nginx теперь не воспринимает пустое имя как правильное
-в строке "Authorization" в заголовке запроса.
-</para>
-<para lang="en">
-nginx now does not treat the empty user name in the "Authorization" header
-line as valid one.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssl_session_timeout модулей
-ngx_http_ssl_module и ngx_imap_ssl_module.
-</para>
-<para lang="en">
-the "ssl_session_timeout" directives
-of the ngx_http_ssl_module and ngx_imap_ssl_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива auth_http_header модуля ngx_imap_auth_http_module.
-</para>
-<para lang="en">
-the "auth_http_header" directive of the ngx_imap_auth_http_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива add_header.
-</para>
-<para lang="en">
-the "add_header" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_realip_module.
-</para>
-<para lang="en">
-the ngx_http_realip_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новые переменные для использования в директиве log_format:
-$bytes_sent, $apache_bytes_sent, $status, $time_gmt,
-$uri, $request_time, $request_length,
-$upstream_status, $upstream_response_time,
-$gzip_ratio,
-$uid_got, $uid_set,
-$connection, $pipe и $msec.
-Параметры в виде "%name" скоро будут упразднены.
-</para>
-<para lang="en">
-the new variables to use in the "log_format" directive:
-$bytes_sent, $apache_bytes_sent, $status, $time_gmt,
-$uri, $request_time, $request_length,
-$upstream_status, $upstream_response_time,
-$gzip_ratio,
-$uid_got, $uid_set,
-$connection, $pipe, and $msec.
-The parameters in the "%name" form will be canceled soon.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в директиве "if" ложными значениями переменных теперь являются
-пустая строка "" и строки, начинающиеся на "0".
-</para>
-<para lang="en">
-now the false variable values in the "if" directive are the empty string ""
-and string starting with "0".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при работает с проксированными или FastCGI-серверами nginx мог оставлять
-открытыми соединения и временные файлы с запросами клиентов.
-</para>
-<para lang="en">
-while using proxied or FastCGI-server nginx may leave connections
-and temporary files with client requests in open state.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-рабочие процессы не сбрасывали буферизированные логи при плавном выходе.
-</para>
-<para lang="en">
-the worker processes did not flush the buffered logs on graceful exit.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если URI запроса изменялось с помощью rewrite, а затем запрос проксировался
-в location, заданном регулярным выражением, то бэкенду передавался
-неверный запрос;
-ошибка появилась в 0.2.6.
-</para>
-<para lang="en">
-if the request URI was changes by the "rewrite" directive and the request
-was proxied in location given by regular expression, then the incorrect
-request was transferred to backend;
-the bug had appeared in 0.2.6.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива expires не удаляла уже установленную строку заголовка "Expires".
-</para>
-<para lang="en">
-the "expires" directive did not remove the previous "Expires" header.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании метода rtsig и нескольких рабочих процессах nginx
-мог перестать принимать запросы.
-</para>
-<para lang="en">
-nginx may stop to accept requests if the "rtsig" method and several worker
-processes were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в SSI командах неверно обрабатывались строки "\"" и "\'".
-</para>
-<para lang="en">
-the "\"" and "\'" escape symbols were incorrectly handled in SSI commands.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если ответ заканчивался сразу же после SSI команды, то при использовании
-сжатия ответ передавался не до конца или не передавался вообще.
-</para>
-<para lang="en">
-if the response was ended just after the SSI command and gzipping was used,
-then the response did not transferred complete or did not transferred at all.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.7" date="2005-10-27">
-
-<change type="feature">
-<para lang="ru">
-директива access_log поддерживает параметр buffer=.
-</para>
-<para lang="en">
-the "access_log" supports the "buffer=" parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформах, отличных от i386, amd64, sparc и ppc;
-ошибка появилась в 0.3.2.
-</para>
-<para lang="en">
-nginx could not be built on platforms different from i386, amd64, sparc,
-and ppc;
-the bug had appeared in 0.3.2.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.6" date="2005-10-24">
-
-<change type="change">
-<para lang="ru">
-IMAP/POP3 прокси теперь не передаёт серверу авторизации пустой логин.
-</para>
-<para lang="en">
-now the IMAP/POP3 proxy do not send the empty login to authorization server.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива log_format поддерживает переменные в виде $name.
-</para>
-<para lang="en">
-the "log_format" supports the variables in the $name form.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если хотя бы в одном сервере не было описано ни одной директивы listen, то
-nginx не слушал на 80 порту;
-ошибка появилась в 0.3.3.
-</para>
-<para lang="en">
-if at least in one server was no the "listen" directive, then nginx did not
-listen on the 80 port;
-the bug had appeared in 0.3.3.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве proxy_pass отсутствовал URI, то всегда использовался порт 80.
-</para>
-<para lang="en">
-if the URI part is omitted in "proxy_pass" directive, the 80 port was
-always used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.5" date="2005-10-21">
-
-<change type="bugfix">
-<para lang="ru">
-если логин IMAP/POP3 менялся сервером авторизации, то мог произойти
-segmentation fault;
-ошибка появилась в 0.2.2.
-</para>
-<para lang="en">
-the segmentation fault may occurred if the IMAP/POP3 login was changed
-by authorization server;
-the bug had appeared in 0.2.2.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-accept mutex не работал, все соединения обрабатывались одним рабочим процессом;
-ошибка появилась в 0.3.3.
-</para>
-<para lang="en">
-the accept mutex did not work and all connections were handled by one process;
-the bug had appeared in 0.3.3.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании метода rtsig и директивы timer_resolution
-не работали таймауты.
-</para>
-<para lang="en">
-the timeout did not work if the "rtsig" method and the "timer_resolution"
-directive were used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.4" date="2005-10-19">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на Linux 2.4+ и MacOS X;
-ошибка появилась в 0.3.3.
-</para>
-<para lang="en">
-nginx could not be built on Linux 2.4+ and MacOS X;
-the bug had appeared in 0.3.3.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.3" date="2005-10-19">
-
-<change type="change">
-<para lang="ru">
-параметры "bl" и "af" директивы listen переименованы в "backlog"
-и "accept_filter".
-</para>
-<para lang="en">
-the "bl" and "af" parameters of the "listen" directive was renamed to
-the "backlog" and "accept_filter".
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры "rcvbuf" и "sndbuf" в директиве listen.
-</para>
-<para lang="en">
-the "rcvbuf" and "sndbuf" parameters of the "listen" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметр лога $msec теперь не требует дополнительного системного
-вызова gettimeofday().
-</para>
-<para lang="en">
-the "$msec" log parameter does not require now the additional
-the gettimeofday() system call.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-ключ -t теперь проверяет директивы listen.
-</para>
-<para lang="en">
-the -t switch now tests the "listen" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в директиве listen был указан неверный адрес, то nginx после
-сигнала -HUP оставлял открытый сокет в состоянии CLOSED.
-</para>
-<para lang="en">
-if the invalid address was specified in the "listen" directive, then
-after the -HUP signal nginx left an open socket in the CLOSED state.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-для индексных файлов, содержащих в имени переменную, мог неверно выставляться
-тип mime по умолчанию;
-ошибка появилась в 0.3.0.
-</para>
-<para lang="en">
-the mime type may be incorrectly set to default value for index file with
-variable in the name;
-the bug had appeared in 0.3.0.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива timer_resolution.
-</para>
-<para lang="en">
-the "timer_resolution" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр лога $upstream_response_time в миллисекундах.
-</para>
-<para lang="en">
-the millisecond "$upstream_response_time" log parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-временный файл с телом запроса клиента теперь удаляется сразу после того,
-как клиенту передан заголовок ответа.
-</para>
-<para lang="en">
-a temporary file with client request body now is removed just after
-the response header was transferred to a client.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с OpenSSL 0.9.6.
-</para>
-<para lang="en">
-OpenSSL 0.9.6 compatibility.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-пути к файлам с SSL сертификатом и ключом не могли быть относительными.
-</para>
-<para lang="en">
-the SSL certificate and key file paths could not be relative.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_prefer_server_ciphers не работала для модуля ngx_imap_ssl_module.
-</para>
-<para lang="en">
-the "ssl_prefer_server_ciphers" directive did not work in
-the ngx_imap_ssl_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива ssl_protocols позволяла задать только один протокол.
-</para>
-<para lang="en">
-the "ssl_protocols" directive allowed to specify the single protocol only.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.2" date="2005-10-12">
-
-<change type="feature">
-<para lang="ru">
-поддержка Sun Studio 10 C compiler.
-</para>
-<para lang="en">
-the Sun Studio 10 C compiler support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_upstream_max_fails, proxy_upstream_fail_timeout,
-fastcgi_upstream_max_fails и fastcgi_upstream_fail_timeout.
-</para>
-<para lang="en">
-the "proxy_upstream_max_fails", "proxy_upstream_fail_timeout",
-"fastcgi_upstream_max_fails", and "fastcgi_upstream_fail_timeout"
-directives.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.1" date="2005-10-10">
-
-<change type="bugfix">
-<para lang="ru">
-во время переполнения очереди сигналов при использовании метода rtsig
-происходил segmentation fault;
-ошибка появилась в 0.2.0.
-</para>
-<para lang="en">
-the segmentation fault occurred when the signal queue overflowed
-if the "rtsig" method was used;
-the bug had appeared in 0.2.0.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-корректная обработка пар "\\", "\"", "\'" и "\$" в SSI.
-</para>
-<para lang="en">
-correct handling of the "\\", "\"", "\'", and "\$" pairs in SSI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.3.0" date="2005-10-07">
-
-<change type="change">
-<para lang="ru">
-убрано десятидневное ограничение времени работы рабочего процесса.
-Ограничение было введено из-за переполнения миллисекундных таймеров.
-</para>
-<para lang="en">
-the 10-days live time limit of worker process was eliminated.
-The limit was introduced because of millisecond timers overflow.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.6" date="2005-10-05">
-
-<change type="change">
-<para lang="ru">
-с 60 до 10 секунд уменьшено время повторного обращения к бэкенду
-при использовании распределения нагрузки.
-</para>
-<para lang="en">
-while using load-balancing the time before the failed backend retry
-was decreased from 60 to 10 seconds.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива proxy_pass_unparsed_uri упразднена, оригинальный запрос теперь
-передаётся, если в директиве proxy_pass отсутствует URI.
-</para>
-<para lang="en">
-the "proxy_pass_unparsed_uri" was canceled, the original URI now passed,
-if the URI part is omitted in "proxy_pass" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива error_page поддерживает редиректы и позволяет более гибко
-менять код ошибки.
-</para>
-<para lang="en">
-the "error_page" directive supports redirects and allows more flexible
-to change an error code.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в проксированных подзапросах теперь игнорируется переданный charset.
-</para>
-<para lang="en">
-the charset in the "Content-Type" header line now is ignored
-in proxied subrequests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если после изменения URI в блоке if для запроса не находилась
-новая конфигурация, то правила модуля ngx_http_rewrite_module выполнялись
-снова.
-</para>
-<para lang="en">
-if the URI was changed in the "if" block and request did not found
-new configuration, then the ngx_http_rewrite_module rules ran again.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если директива set устанавливала переменную модуля ngx_http_geo_module
-в какой-либо части конфигурации, то эта переменная не была доступна в
-других частях конфигурации и выдавалась ошибка "using uninitialized variable";
-ошибка появилась в 0.2.2.
-</para>
-<para lang="en">
-if the "set" directive set the ngx_http_geo_module variable in some
-configuration part, the this variable was not available in other
-configuration parts and the "using uninitialized variable" error was occurred;
-the bug had appeared in 0.2.2.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.5" date="2005-10-04">
-
-<change type="change">
-<para lang="ru">
-дублирующее значение переменной модуля ngx_http_geo_module теперь
-выдаёт предупреждение и изменяет старое значение.
-</para>
-<para lang="en">
-the duplicate value of the ngx_http_geo_module variable now causes
-the warning and changes old value.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает команду set.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the "set" command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает параметр file в команде include.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the "file" parameter in the "include" command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает подстановку значений переменных
-в выражениях команды if.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the variable value substitutions in
-expressions of the "if" command.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.4" date="2005-10-03">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает выражения
-"$var=text", "$var!=text", "$var=/text/" и "$var!=/text/"
-в команде if.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports
-"$var=text", "$var!=text", "$var=/text/", and "$var!=/text/" expressions
-in the "if" command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при проксировании location без слэша в конце;
-ошибка появилась в 0.1.44.
-</para>
-<para lang="en">
-in proxying location without trailing slash;
-the bug had appeared in 0.1.44.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании метода rtsig мог произойти segmentation fault;
-ошибка появилась в 0.2.0.
-</para>
-<para lang="en">
-the segmentation fault may occurred if the "rtsig" method was used;
-the bug had appeared in 0.2.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.3" date="2005-09-30">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался без параметра --with-debug;
-ошибка появилась в 0.2.2.
-</para>
-<para lang="en">
-nginx could not be built without the --with-debug option;
-the bug had appeared in 0.2.2.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.2" date="2005-09-30">
-
-<change type="feature">
-<para lang="ru">
-команда config errmsg в модуле ngx_http_ssi_module.
-</para>
-<para lang="en">
-the "config errmsg" command of the ngx_http_ssi_module.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-переменные модуля ngx_http_geo_module можно переопределять директивой set.
-</para>
-<para lang="en">
-the ngx_http_geo_module variables can be overridden by the "set" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_protocols и ssl_prefer_server_ciphers модулей
-ngx_http_ssl_module и ngx_imap_ssl_module.
-</para>
-<para lang="en">
-the "ssl_protocols" and "ssl_prefer_server_ciphers" directives
-of the ngx_http_ssl_module and ngx_imap_ssl_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка в модуле ngx_http_autoindex_module при показе длинных имён файлов;
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not show correctly the long file names;
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module теперь не показывает файлы,
-начинающиеся на точку.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module now do not show the files starting by dot.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если SSL handshake завершался с ошибкой, то это могло привести также
-к закрытию другого соединения.<br/>
-Спасибо Rob Mueller.
-</para>
-<para lang="en">
-if the SSL handshake failed then another connection may be closed too.<br/>
-Thanks to Rob Mueller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-экспортные версии MSIE 5.x не могли соединиться по HTTPS.
-</para>
-<para lang="en">
-the export versions of MSIE 5.x could not connect via HTTPS.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.1" date="2005-09-23">
-
-<change type="bugfix">
-<para lang="ru">
-если все бэкенды, используемые для балансировки нагрузки, оказывались
-в нерабочем состоянии после одной ошибки, то nginx мог зациклится;
-ошибка появилась в 0.2.0.
-</para>
-<para lang="en">
-if all backend using in load-balancing failed after one error, then
-nginx may got caught in an endless loop;
-the bug had appeared in 0.2.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.2.0" date="2005-09-23">
-
-<change>
-<para lang="ru">
-Изменились имена pid-файлов, используемые во время обновления исполняемого
-файла. Ручное переименование теперь не нужно.
-Старый основной процесс добавляет к своему pid-файл суффикс ".oldbin"
-и запускает новый исполняемый файл.
-Новый основной процесс создаёт обычный pid-файл без суффикса ".newbin".
-Если новый основной процесс выходит, то старый процесс переименовывает свой
-pid-файл c суффиксом ".oldbin" в pid-файл без суффикса.
-При обновлении с версии 0.1.х до 0.2.0 нужно учитывать, что оба
-процесса&mdash;старый 0.1.x и новый 0.2.0&mdash;используют pid-файл
-без суффиксов.
-</para>
-<para lang="en">
-The pid-file names used during online upgrade was changed and now is not
-required a manual rename operation.
-The old master process adds the ".oldbin" suffix to its pid-file and
-executes a new binary file.
-The new master process creates usual pid-file without the ".newbin" suffix.
-If the master process exits, then old master process renames back
-its pid-file with the ".oldbin" suffix to the pid-file without suffix.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива worker_connections, новое название директивы connections;
-директива теперь задаёт максимальное число соединений,
-а не максимально возможный номер дескриптора для сокета.
-</para>
-<para lang="en">
-the "worker_connections" directive, new name of the "connections" directive;
-now the directive specifies maximum number of connections,
-but not maximum socket descriptor number.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-SSL поддерживает кэширование сессий в пределах одного рабочего процесса.
-</para>
-<para lang="en">
-SSL supports the session cache inside one worker process.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива satisfy_any.
-</para>
-<para lang="en">
-the "satisfy_any" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-модули ngx_http_access_module и ngx_http_auth_basic_module не работают
-для подзапросов.
-</para>
-<para lang="en">
-the ngx_http_access_module and ngx_http_auth_basic_module do not run
-for subrequests.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы worker_rlimit_nofile и worker_rlimit_sigpending.
-</para>
-<para lang="en">
-the "worker_rlimit_nofile" and "worker_rlimit_sigpending" directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если все бэкенды, используемые для балансировки нагрузки, оказывались
-в нерабочем состоянии после одной ошибки, то nginx не обращался к ним
-в течение 60 секунд.
-</para>
-<para lang="en">
-if all backend using in load-balancing failed after one error, then
-nginx did not try do connect to them during 60 seconds.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в парсинге аргументов IMAP/POP3 команд.<br/>
-Спасибо Rob Mueller.
-</para>
-<para lang="en">
-in IMAP/POP3 command argument parsing.<br/>
-Thanks to Rob Mueller.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании SSL в IMAP/POP3 прокси.
-</para>
-<para lang="en">
-errors while using SSL in IMAP/POP3 proxy.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании SSI и сжатия.
-</para>
-<para lang="en">
-errors while using SSI and gzipping.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в ответах 304 не добавлялись строки заголовка ответа "Expires" и
-"Cache-Control".<br/>
-Спасибо Александру Кукушкину.
-</para>
-<para lang="en">
-the "Expires" and "Cache-Control" header lines were omitted
-from the 304 responses.<br/>
-Thanks to Alexandr Kukushkin.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.45" date="2005-09-08">
-
-<change type="change">
-<para lang="ru">
-директива ssl_engine упразднена в модуле ngx_http_ssl_module и
-перенесена на глобальный уровень.
-</para>
-<para lang="en">
-the "ssl_engine" directive was canceled in the ngx_http_ssl_module
-and now is introduced at global level.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ответы с подзапросами, включённые с помощью SSI, не передавались
-через SSL соединение.
-</para>
-<para lang="en">
-the responses with SSI subrequests did not transferred via SSL connection.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Разные исправления в IMAP/POP3 прокси.
-</para>
-<para lang="en">
-Various bug fixes in the IMAP/POP3 proxy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.44" date="2005-09-06">
-
-<change type="feature">
-<para lang="ru">
-IMAP/POP3 прокси поддерживает SSL.
-</para>
-<para lang="en">
-the IMAP/POP3 proxy supports SSL.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_timeout модуля ngx_imap_proxy_module.
-</para>
-<para lang="en">
-the "proxy_timeout" directive of the ngx_imap_proxy_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива userid_mark.
-</para>
-<para lang="en">
-the "userid_mark" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-значение переменной $remote_user определяется независимо от того,
-используется ли авторизация или нет.
-</para>
-<para lang="en">
-the $remote_user variable value is determined independently of
-authorization use.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.43" date="2005-08-30">
-
-<change type="feature">
-<para lang="ru">
-listen(2) backlog в директиве listen можно менять по сигналу -HUP.
-</para>
-<para lang="en">
-the listen(2) backlog in the "listen" directive
-can be changed using the -HUP signal.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-скрипт geo2nginx.pl добавлен в contrib.
-</para>
-<para lang="en">
-the geo2nginx.pl script was added to contrib.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-параметры FastCGI с пустым значениями теперь передаются серверу.
-</para>
-<para lang="en">
-the FastCGI parameters with the empty values now are passed to a server.
-</para>
-</change>
-
-<!--
-
-<change type="bugfix">
-<para lang="ru">
-при ошибках в работе с проксированным сервером или FastCGI сервером
-мог произойти segmentation fault;
-в режиме прокси ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-the segmentation fault may occurred if there were errors while
-working with proxied or FastCGI server;
-in the proxied mode the bug had appeared in 0.1.29.
-</para>
-</change>
-
--->
-
-<change type="bugfix">
-<para lang="ru">
-если в ответе проксированного сервера или FastCGI сервера была строка
-"Cache-Control", то при использовании директивы expires происходил
-segmentation fault или рабочий процесс мог зациклится;
-в режиме прокси ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-the segmentation fault occurred or the worker process may got caught
-in an endless loop if the proxied or FastCGI server sent the "Cache-Control"
-header line and the "expires" directive was used;
-in the proxied mode the bug had appeared in 0.1.29.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.42" date="2005-08-23">
-
-<change type="bugfix">
-<para lang="ru">
-если URI запроса получался нулевой длины после обработки модулем
-ngx_http_rewrite_module, то в модуле ngx_http_proxy_module происходил
-segmentation fault или bus error.
-</para>
-<para lang="en">
-if the request URI had a zero length after the processing in
-the ngx_http_proxy_module, then the segmentation fault or bus error occurred
-in the ngx_http_proxy_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива limit_rate не работала внутри блока if;
-ошибка появилась в 0.1.38.
-</para>
-<para lang="en">
-the "limit_rate" directive did not work inside the "if" block;
-the bug had appeared in 0.1.38.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.41" date="2005-07-25">
-
-<change type="bugfix">
-<para lang="ru">
-если переменная использовалась в файле конфигурации,
-то она не могла использоваться в SSI.
-</para>
-<para lang="en">
-if the variable was used in the configuration file,
-then it can not be used in SSI.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.40" date="2005-07-22">
-
-<change type="bugfix">
-<para lang="ru">
-если клиент слал очень длинную строку заголовка, то в логе не помещалась
-информация, связанная с этим запросом.
-</para>
-<para lang="en">
-if a client sent too long header line, then the request information
-did not logged in the error log.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании "X-Accel-Redirect" не передавалась строка "Set-Cookie";
-ошибка появилась в 0.1.39.
-</para>
-<para lang="en">
-the "Set-Cookie" header line was not transferred when the "X-Accel-Redirect"
-was used;
-the bug had appeared in 0.1.39.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании "X-Accel-Redirect" не передавалась строка
-"Content-Disposition".
-</para>
-<para lang="en">
-the "Content-Disposition" header line was not transferred when
-the "X-Accel-Redirect" was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-по сигналу SIGQUIT основной процесс не закрывал сокеты, на которых он слушал.
-</para>
-<para lang="en">
-the master process did not close the listen socket on the SIGQUIT signal.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после обновления исполняемого файла на лету на Linux и Solaris
-название процесса в команде ps становилось короче.
-</para>
-<para lang="en">
-after on-line upgrade on Linux and Solaris the process name
-became shorter in the "ps" command.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.39" date="2005-07-14">
-
-<change>
-<para lang="ru">
-Изменения в модуле ngx_http_charset_module:
-директива default_charset упразднена;
-директива charset задаёт кодировку ответа;
-директива source_charset задаёт только исходную кодировку.
-</para>
-<para lang="en">
-The changes in the ngx_http_charset_module:
-the "default_charset" directive was canceled;
-the "charset" directive sets the response charset;
-the "source_charset" directive sets the source charset only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении ошибки 401, полученной от бэкенда, не передавалась
-строка заголовка "WWW-Authenticate".
-</para>
-<para lang="en">
-the backend "WWW-Authenticate" header line did not transferred while
-the 401 response code redirecting.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модули ngx_http_proxy_module и ngx_http_fastcgi_module могли закрыть
-соединение до того, как что-нибудь было передано клиенту;
-ошибка появилась в 0.1.38.
-</para>
-<para lang="en">
-the ngx_http_proxy_module and ngx_http_fastcgi_module may close
-a connection before anything was transferred to a client;
-the bug had appeared in 0.1.38.
-</para>
-</change>
-
-<change type="workaround">
-<para lang="ru">
-обработка ошибки инициализации в crypt_r() в Linux glibc.
-</para>
-<para lang="en">
-the Linux glibc crypt_r() initialization bug.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_ssi_module не поддерживал относительные URI в
-команде include virtual.
-</para>
-<para lang="en">
-the ngx_http_ssi_module did not support the relative URI in
-the "include virtual" command.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в строке заголовка ответа бэкенда была строка "Location",
-которую nginx не должен был изменять, то в ответе передавалось тело 500 ошибки;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-if the backend response had the "Location" header line and nginx
-should not rewrite this line, then the 500 code response body was transferred;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-некоторые директивы модулей ngx_http_proxy_module и ngx_http_fastcgi_module
-не наследовались с уровня server на уровень location;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-some directives of the ngx_http_proxy_module and ngx_http_fastcgi_module
-were not inherited from the server to the location level;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_ssl_module не поддерживал цепочки сертификатов.
-</para>
-<para lang="en">
-the ngx_http_ssl_module did not support the certificate chain.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка в модуле ngx_http_autoindex_module при показе длинных имён файлов;
-ошибка появилась в 0.1.38.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not show correctly the long file names;
-the bug had appeared in 0.1.38.
-</para>
-</change>
-
-<change>
-<para lang="ru">
-Исправления в IMAP/POP3 прокси при взаимодействии с бэкендом на стадии login.
-</para>
-<para lang="en">
-Bugfixes in IMAP/POP3 proxy in interaction with a backend at the login state.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.38" date="2005-07-08">
-
-<change type="feature">
-<para lang="ru">
-директива limit_rate поддерживается в режиме прокси и FastCGI.
-</para>
-<para lang="en">
-the "limit_rate" directive is supported in proxy and FastCGI mode.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в режиме прокси и FastCGI поддерживается строка заголовка "X-Accel-Limit-Rate"
-в ответе бэкенда.
-</para>
-<para lang="en">
-the "X-Accel-Limit-Rate" response header line is supported in proxy
-and FastCGI mode.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива break.
-</para>
-<para lang="en">
-the "break" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива log_not_found.
-</para>
-<para lang="en">
-the "log_not_found" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при перенаправлении запроса с помощью строки заголовка "X-Accel-Redirect"
-не изменялся код ответа.
-</para>
-<para lang="en">
-the response status code was not changed when request was redirected
-by the ""X-Accel-Redirect" header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные, установленные директивой set не могли использоваться в SSI.
-</para>
-<para lang="en">
-the variables set by the "set" directive could not be used in SSI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включении в SSI более одного удалённого подзапроса
-мог произойти segmentation fault.
-</para>
-<para lang="en">
-the segmentation fault may occurred if the SSI page has more than one
-remote subrequest.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если статусная строка в ответе бэкенда передавалась в двух пакетах, то
-nginx считал ответ неверным;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-nginx treated the backend response as invalid if the status line in the
-header was transferred in two packets;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssi_types.
-</para>
-<para lang="en">
-the "ssi_types" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива autoindex_exact_size.
-</para>
-<para lang="en">
-the "autoindex_exact_size" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module не поддерживал длинные имена файлов в UTF-8.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not support the long file names in UTF-8.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-IMAP/POP3 прокси.
-</para>
-<para lang="en">
-the IMAP/POP3 proxy.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.37" date="2005-06-23">
-
-<change type="change">
-<para lang="ru">
-в конце файла nginx.pid теперь добавляется "\n".
-</para>
-<para lang="en">
-now the "\n" is added to the end of the "nginx.pid" file.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при включении большого количества вставок или нескольких больших вставок
-с помощью SSI ответ мог передаваться не полностью.
-</para>
-<para lang="en">
-the responses may be transferred not completely,
-if many parts or the big parts were included by SSI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если все бэкенды возвращали ответ 404, то при использовании параметра http_404
-в директивах proxy_next_upstream или fastcgi_next_upstream, nginx
-начинал запрашивать все бэкенды снова.
-</para>
-<para lang="en">
-if all backends had returned the 404 response and the "http_404" parameter of
-the "proxy_next_upstream" or "fastcgi_next_upstream" directives was used,
-then nginx started to request all backends again.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.36" date="2005-06-15">
-
-<change type="change">
-<para lang="ru">
-если в заголовке запроса есть дублирующиеся строки "Host", "Connection",
-"Content-Length" и "Authorization", то nginx теперь выдаёт ошибку 400.
-</para>
-<para lang="en">
-if the request header has duplicate the "Host", "Connection", "Content-Length",
-or "Authorization" lines, then nginx now returns the 400 error.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива post_accept_timeout упразднена.
-</para>
-<para lang="en">
-the "post_accept_timeout" directive was canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметры default, af=, bl=, deferred и bind в директиве listen.
-</para>
-<para lang="en">
-the "default", "af=", "bl=", "deferred", and "bind" parameters
-of the "listen" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка accept фильтров во FreeBSD.
-</para>
-<para lang="en">
-the FreeBSD accept filters support.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка TCP_DEFER_ACCEPT в Linux.
-</para>
-<para lang="en">
-the Linux TCP_DEFER_ACCEPT support.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module не поддерживал имена файлов в UTF-8.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module did not support the file names in UTF-8.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-после добавления новый лог-файл ротация этого лога по сигналу -USR1
-выполнялась, только если переконфигурировать nginx два раза по сигналу -HUP.
-</para>
-<para lang="en">
-the new log file can be rotated by the -USR1 signal only if
-the reconfiguration by the -HUP signal was made twice.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.35" date="2005-06-07">
-
-<change type="feature">
-<para lang="ru">
-директива working_directory.
-</para>
-<para lang="en">
-the "working_directory" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива port_in_redirect.
-</para>
-<para lang="en">
-the "port_in_redirect" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если заголовок ответа бэкенда не помещался в один пакет, то
-происходил segmentation fault;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-the segmentation fault was occurred if the backend response header was in
-several packets;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если было сконфигурировано более 10 серверов или в сервере не описана
-директива "listen",
-то при запуске мог произойти segmentation fault.
-</para>
-<para lang="en">
-if more than 10 servers were configured or some server did not use the
-"listen" directive, then the segmentation fault was occurred on the start.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если ответ не помещался во временный файл,
-то мог произойти segmentation fault.
-</para>
-<para lang="en">
-the segmentation fault might occur if the response was bigger than
-the temporary file.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx возвращал ошибку 400 на запросы вида
-<nobr>"GET http://www.domain.com/uri HTTP/1.0"</nobr>;
-ошибка появилась в 0.1.28.
-</para>
-<para lang="en">
-nginx returned the 400 response on requests like
-<nobr>"GET http://www.domain.com/uri HTTP/1.0"</nobr>;
-the bug had appeared in 0.1.28.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.34" date="2005-05-26">
-
-<change type="bugfix">
-<para lang="ru">
-при включении больших ответов с помощью SSI рабочий процесс мог зациклиться.
-</para>
-<para lang="en">
-the worker process may got caught in an endless loop if the big response
-part were include by SSI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-переменные, устанавливаемые директивой "set", не были доступны в SSI.
-</para>
-<para lang="en">
-the variables set by the "set" directive were not available in SSI.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива autoindex_localtime.
-</para>
-<para lang="en">
-the "autoindex_localtime" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-пустое значение в директиве proxy_set_header запрещает передачу заголовка.
-</para>
-<para lang="en">
-the empty value of the "proxy_set_header" directive forbids the client
-request header line passing.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.33" date="2005-05-23">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался с параметром --without-pcre;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-nginx could not be built with the --without-pcre parameter;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-3, 5, 7 и 8 директив proxy_set_header на одном уровне вызывали
-bus fault при запуске.
-</para>
-<para lang="en">
-3, 4, 7, and 8 the "proxy_set_header" directives in one level cause
-the bus fault on start up.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в редиректах внутри HTTPS сервера был указан протокол HTTP.
-</para>
-<para lang="en">
-the HTTP protocol was specified in the HTTPS redirects.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если директива rewrite использовала выделения внутри директивы if, то
-возвращалась ошибка 500.
-</para>
-<para lang="en">
-if the "rewrite" directive used the captures inside the "if" directive, then
-the 500 error code was returned.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.32" date="2005-05-19">
-
-<change type="bugfix">
-<para lang="ru">
-в редиректах, выдаваемых с помощью директивы rewrite, не передавались аргументы;
-ошибка появилась в 0.1.29.
-</para>
-<para lang="en">
-the arguments were omitted in the redirects, issued by the "rewrite" directive;
-the bug had appeared in 0.1.29.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива if поддерживает выделения в регулярных выражениях.
-</para>
-<para lang="en">
-the "if" directive supports the captures in regular expressions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива set поддерживает переменные и выделения из регулярных выражений.
-</para>
-<para lang="en">
-the "set" directive supports the variables and the captures of regular
-expressions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в режиме прокси и FastCGI поддерживается строка заголовка "X-Accel-Redirect"
-в ответе бэкенда.
-</para>
-<para lang="en">
-the "X-Accel-Redirect" response header line is supported in proxy and FastCGI
-mode.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.31" date="2005-05-16">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSL ответ мог передаваться не до конца.
-</para>
-<para lang="en">
-the response encrypted by SSL may not transferred complete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при обработке SSI в ответе, полученного от FastCGI-сервера.
-</para>
-<para lang="en">
-errors while processing FastCGI response by SSI.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки при использовании SSI и сжатия.
-</para>
-<para lang="en">
-errors while using SSI and gzipping.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-редирект с кодом 301 передавался без тела ответа;
-ошибка появилась в 0.1.30.
-</para>
-<para lang="en">
-the redirect with the 301 code was transferred without response body;
-the bug had appeared in 0.1.30.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.30" date="2005-05-14">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSI рабочий процесс мог зациклиться.
-</para>
-<para lang="en">
-the worker process may got caught in an endless loop if the SSI was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSL ответ мог передаваться не до конца.
-</para>
-<para lang="en">
-the response encrypted by SSL may not transferred complete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если длина части ответа, полученного за один раз от проксируемого или
-FastCGI сервера была равна 500 байт, то nginx возвращал код ответа 500;
-в режиме прокси ошибка появилась только в 0.1.29.
-</para>
-<para lang="en">
-if the length of the response part received at once from proxied
-or FastCGI server was equal to 500, then nginx returns the 500 response code;
-in proxy mode the bug had appeared in 0.1.29 only.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не считал неверными директивы с 8-ю или 9-ю параметрами.
-</para>
-<para lang="en">
-nginx did not consider the directives with 8 or 9 parameters as invalid.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива return может возвращать код ответа 204.
-</para>
-<para lang="en">
-the "return" directive can return the 204 response code.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ignore_invalid_headers.
-</para>
-<para lang="en">
-the "ignore_invalid_headers" directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.29" date="2005-05-12">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает команду include virtual.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports "include virtual" command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает условную команду вида
-'if expr="$NAME"' и команды else и endif.
-Допускается только один уровень вложенности.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the condition command like
-'if expr="$NAME"' and "else" and "endif" commands.
-Only one nested level is supported.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_module поддерживает две переменные DATE_LOCAL и DATE_GMT
-и команду config timefmt.
-</para>
-<para lang="en">
-the ngx_http_ssi_module supports the DATE_LOCAL and DATE_GMT variables
-and "config timefmt" command.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива ssi_ignore_recycled_buffers.
-</para>
-<para lang="en">
-the "ssi_ignore_recycled_buffers" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если переменная QUERY_STRING не была определена, то в команде echo
-не ставилось значение по умолчанию.
-</para>
-<para lang="en">
-the "echo" command did not show the default value for the empty QUERY_STRING
-variable.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-модуль ngx_http_proxy_module полностью переписан.
-</para>
-<para lang="en">
-the ngx_http_proxy_module was rewritten.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_redirect, proxy_pass_request_headers,
-proxy_pass_request_body и proxy_method.
-</para>
-<para lang="en">
-the "proxy_redirect", "proxy_pass_request_headers",
-"proxy_pass_request_body", and "proxy_method" directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_set_header.
-Директива proxy_x_var упразднена и должна быть заменена директивой
-proxy_set_header.
-</para>
-<para lang="en">
-the "proxy_set_header" directive.
-The "proxy_x_var" was canceled and must be replaced with the proxy_set_header
-directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива proxy_preserve_host упразднена и должна быть заменена директивами
-"proxy_set_header Host $host" и "proxy_redirect off"
-или директивой <nobr>"proxy_set_header Host $host:$proxy_port"</nobr>
-и соответствующими ей директивами proxy_redirect.
-</para>
-<para lang="en">
-the "proxy_preserve_host" is canceled and must be replaced with
-the "proxy_set_header Host $host" and the "proxy_redirect off" directives,
-the <nobr>"proxy_set_header Host $host:$proxy_port" directive</nobr>
-and the appropriate proxy_redirect directives.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива proxy_set_x_real_ip упразднена и должна быть заменена директивой
-"proxy_set_header X-Real-IP $remote_addr".
-</para>
-<para lang="en">
-the "proxy_set_x_real_ip" is canceled and must be replaced with
-the "proxy_set_header X-Real-IP $remote_addr" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива proxy_add_x_forwarded_for упразднена и должна быть заменена
-директивой
-<nobr>"proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for".</nobr>
-</para>
-<para lang="en">
-the "proxy_add_x_forwarded_for" is canceled and must be replaced with
-<nobr>the "proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for"</nobr>
-directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директива proxy_set_x_url упразднена и должна быть заменена директивой
-<nobr>"proxy_set_header X-URL http://$host:$server_port$request_uri".</nobr>
-</para>
-<para lang="en">
-the "proxy_set_x_url" is canceled and must be replaced with
-the "proxy_set_header X-URL http://$host:$server_port$request_uri"
-directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_param.
-</para>
-<para lang="en">
-the "fastcgi_param" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-директивы fastcgi_root, fastcgi_set_var и fastcgi_params упразднены
-и должны быть замены директивами fastcgi_param.
-</para>
-<para lang="en">
-the "fastcgi_root", "fastcgi_set_var" and "fastcgi_params" directive
-are canceled and must be replaced with the fastcgi_param directives.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива index может использовать переменные.
-</para>
-<para lang="en">
-the "index" directive can use the variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива index может быть указана на уровне http и server.
-</para>
-<para lang="en">
-the "index" directive can be used at http and server levels.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-только последний параметр в директиве index может быть абсолютным.
-</para>
-<para lang="en">
-the last index only in the "index" directive can be absolute.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-в директиве rewrite могут использоваться переменные.
-</para>
-<para lang="en">
-the "rewrite" directive can use the variables.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива internal.
-</para>
-<para lang="en">
-the "internal" directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-переменные CONTENT_LENGTH, CONTENT_TYPE, REMOTE_PORT, SERVER_ADDR,
-SERVER_PORT, SERVER_PROTOCOL, DOCUMENT_ROOT, SERVER_NAME,
-REQUEST_METHOD, REQUEST_URI и REMOTE_USER.
-</para>
-<para lang="en">
-the CONTENT_LENGTH, CONTENT_TYPE, REMOTE_PORT, SERVER_ADDR,
-SERVER_PORT, SERVER_PROTOCOL, DOCUMENT_ROOT, SERVER_NAME,
-REQUEST_METHOD, REQUEST_URI, and REMOTE_USER variables.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-nginx теперь передаёт неверные строки в заголовках запроса клиента и
-ответа бэкенда.
-</para>
-<para lang="en">
-nginx now passes the invalid lines in a client request headers
-or a backend response header.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если бэкенд долго не передавал ответ и send_timeout был меньше, чем
-proxy_read_timeout, то клиенту возвращался ответ 408.
-</para>
-<para lang="en">
-if the backend did not transfer response for a long time and
-the "send_timeout" was less than "proxy_read_timeout", then nginx
-returned the 408 response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если бэкенд передавал неверную строку в заголовке ответа, то происходил
-segmentation fault;
-ошибка появилась в 0.1.26.
-</para>
-<para lang="en">
-the segmentation fault was occurred if the backend sent an invalid line
-in response header;
-the bug had appeared in 0.1.26.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании отказоустойчивой конфигурации в FastCGI мог
-происходить segmentation fault.
-</para>
-<para lang="en">
-the segmentation fault may occurred in FastCGI fault tolerance configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива expires не удаляла уже установленные строки заголовка
-"Expires" и "Cache-Control".
-</para>
-<para lang="en">
-the "expires" directive did not remove the previous "Expires" and
-"Cache-Control" headers.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не учитывал завершающую точку в строке заголовка запроса "Host".
-</para>
-<para lang="en">
-nginx did not take into account trailing dot in "Host" header line.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_auth_module не работал на Linux.
-</para>
-<para lang="en">
-the ngx_http_auth_module did not work under Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива rewrite неверно работала, если в запросе присутствовали аргументы.
-</para>
-<para lang="en">
-the rewrite directive worked incorrectly, if the arguments were in a request.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на MacOS X.
-</para>
-<para lang="en">
-nginx could not be built on MacOS X.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.28" date="2005-04-08">
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании больших файлов nginx сильно нагружал процессор.
-</para>
-<para lang="en">
-nginx hogs CPU while proxying the huge files.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался gcc 4.0 на Linux.
-</para>
-<para lang="en">
-nginx could not be built by gcc 4.0 on Linux.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.27" date="2005-03-28">
-
-<change type="feature">
-<para lang="ru">
-параметр blocked в директиве valid_referers.
-</para>
-<para lang="en">
-the "blocked" parameter of the "valid_referers" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-ошибки обработки заголовка запроса теперь записываются на уровне
-info, в лог также записывается имя сервера и строки заголовка
-запроса "Host" и "Referer".
-</para>
-<para lang="en">
-the errors while handling the request header now logged at "info" level.
-The server name and the "Host" and "Referer" header lines also logged.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при записи ошибок в лог записывается также строка заголовка запроса "Host".
-</para>
-<para lang="en">
-the "Host" header line is also logged in error log.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_pass_unparsed_uri.
-Специальная обработка символов "://" в URI, введённая в версии 0.1.11,
-теперь упразднена.
-</para>
-<para lang="en">
-the proxy_pass_unparsed_uri directive.
-The special handling of the "://" symbols in URI, appeared in 0.1.11 version,
-now is canceled.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на FreeBSD и Linux, если был указан параметр конфигурации
---without-ngx_http_auth_basic_module.
-</para>
-<para lang="en">
-nginx could not be built on FreeBSD and Linux, if the
---without-ngx_http_auth_basic_module configuration parameter was used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.26" date="2005-03-22">
-
-<change type="change">
-<para lang="ru">
-неверные строки заголовка, переданные клиентом, теперь игнорируется и
-записываются в error_log на уровне info.
-</para>
-<para lang="en">
-the invalid client header lines are now ignored and logged at the info level.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-при записи ошибок в лог записывается также имя сервера, при обращении
-к которому произошла ошибка.
-</para>
-<para lang="en">
-the server name is also logged in error log.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_auth_basic_module и директивы auth_basic и
-auth_basic_user_file.
-</para>
-<para lang="en">
-the ngx_http_auth_basic_module module and the auth_basic and
-auth_basic_user_file directives.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.25" date="2005-03-19">
-
-<change type="bugfix">
-<para lang="ru">
-nginx не работал на Linux parisc.
-</para>
-<para lang="en">
-nginx did run on Linux parisc.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-nginx теперь не запускается под FreeBSD, если значение
-sysctl kern.ipc.somaxconn слишком большое.
-</para>
-<para lang="en">
-nginx now does not start under FreeBSD if the sysctl kern.ipc.somaxconn
-value is too big.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если модуль ngx_http_index_module делал внутреннее перенаправление запроса
-в модули ngx_http_proxy_module или ngx_http_fastcgi_module, то файл индекса
-не закрывался после обслуживания запроса.
-</para>
-<para lang="en">
-if a request was internally redirected by the ngx_http_index_module
-module to the ngx_http_proxy_module or ngx_http_fastcgi_module modules,
-then the index file was not closed after request completion.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_pass может использоваться в location, заданных регулярным
-выражением.
-</para>
-<para lang="en">
-the "proxy_pass" can be used in location with regular expression.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_rewrite_filter_module поддерживает условия вида
-"if ($HTTP_USER_AGENT ~ MSIE)".
-</para>
-<para lang="en">
-the ngx_http_rewrite_filter_module module supports the condition like
-"if ($HTTP_USER_AGENT ~ MSIE)".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx очень медленно запускался при большом количестве адресов и
-использовании текстовых значений в директиве geo.
-</para>
-<para lang="en">
-nginx started too slow if the large number of addresses and text values
-were used in the "geo" directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-имя переменной в директиве geo нужно указывать, как $name.
-Прежний вариант без "$" пока работает, но вскоре будет убран.
-</para>
-<para lang="en">
-a variable name must be declared as "$name" in the "geo" directive.
-The previous variant without "$" is still supported, but will be removed soon.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр лога "%{VARIABLE}v".
-</para>
-<para lang="en">
-the "%{VARIABLE}v" logging parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива "set $name value".
-</para>
-<para lang="en">
-the "set $name value" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-совместимость с gcc 4.0.
-</para>
-<para lang="en">
-gcc 4.0 compatibility.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр автоконфигурации --with-openssl-opt=OPTIONS.
-</para>
-<para lang="en">
-the --with-openssl-opt=OPTIONS autoconfiguration directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.24" date="2005-03-04">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_filter_module поддерживает переменные
-QUERY_STRING и DOCUMENT_URI.
-</para>
-<para lang="en">
-the ngx_http_ssi_filter_module supports the QUERY_STRING and DOCUMENT_URI
-variables.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module мог выдавать ответ 404
-на существующий каталог, если этот каталог был указан как alias.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module may some times return the 404 response
-for existent directory, if this directory was used in "alias" directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_ssi_filter_module неправильно работал при больших
-ответах.
-</para>
-<para lang="en">
-the ngx_http_ssi_filter_module ran incorrectly for large responses.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-отсутствие строки заголовка "Referer" всегда считалось правильным referrer'ом.
-</para>
-<para lang="en">
-the lack of the "Referer" header line was always accounted as valid referrer.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.23" date="2005-03-01">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_ssi_filter_module и
-директивы ssi, ssi_silent_errors и ssi_min_file_chunk.
-Поддерживаются команды 'echo var="HTTP_..." default=""' и
-'echo var="REMOTE_ADDR"'.
-</para>
-<para lang="en">
-the ngx_http_ssi_filter_module and
-the ssi, ssi_silent_errors, and ssi_min_file_chunk directives.
-The 'echo var="HTTP_..." default=""' and 'echo var="REMOTE_ADDR"' commands
-are supported.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-параметр лога %request_time.
-</para>
-<para lang="en">
-the %request_time log parameter.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-если запрос пришёл без строки заголовка "Host", то директива
-proxy_preserve_host устанавливает в качестве этого заголовка первое имя
-сервера из директивы server_name.
-</para>
-<para lang="en">
-if the request has no the "Host" header line, then the "proxy_preserve_host"
-directive set this header line to the first server name of the "server_name"
-directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался на платформах, отличных от i386, amd64, sparc и ppc;
-ошибка появилась в 0.1.22.
-</para>
-<para lang="en">
-nginx could not be built on platforms different from i386, amd64, sparc,
-and ppc;
-the bug had appeared in 0.1.22.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_autoindex_module теперь показывает информацию не о
-символическом линке, а о файле или каталоге, на который он указывает.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module now shows the information not about the symlink,
-but about file or directory it points to.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если клиенту ничего не передавалось, то параметр %apache_length
-записывал в лог отрицательную длину заголовка ответа.
-</para>
-<para lang="en">
-the %apache_length parameter logged the negative length
-of the response header if the no response was transferred to a client.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.22" date="2005-02-22">
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_stub_status_module показывал неверную статистику
-для обработанных соединений, если использовалось проксирование
-или FastCGI-сервер.
-</para>
-<para lang="en">
-the ngx_http_stub_status_module showed incorrect handled connections
-statistics if the proxying or FastCGI server were used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Linux и Solaris установочные пути были неверно заключены в кавычки;
-ошибка появилась в 0.1.21.
-</para>
-<para lang="en">
-the installation paths were incorrectly quoted on Linux and Solaris;
-the bug had appeared in 0.1.21.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.21" date="2005-02-22">
-
-<change type="bugfix">
-<para lang="ru">
-модуль ngx_http_stub_status_module показывал неверную статистику
-при использовании метода rtsig или при использовании нескольких
-рабочих процессов на SMP машине.
-</para>
-<para lang="en">
-the ngx_http_stub_status_module showed incorrect statistics
-if "rtsig" method was used or if several worker process ran on SMP.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался компилятором icc под Линуксом или
-если библиотека zlib-1.2.x собиралась из исходных текстов.
-</para>
-<para lang="en">
-nginx could not be built by the icc compiler on Linux or
-if the zlib-1.2.x library was building from sources.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под NetBSD 2.0.
-</para>
-<para lang="en">
-nginx could not be built on NetBSD 2.0.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.20" date="2005-02-17">
-
-<change type="feature">
-<para lang="ru">
-новые параметры script_filename и remote_port в директиве fastcgi_params.
-</para>
-<para lang="en">
-the new "script_filename" and "remote_port" parameters
-of the fastcgi_params directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-неправильно обрабатывался поток stderr от FastCGI-сервера.
-</para>
-<para lang="en">
-the FastCGI stderr stream was handled incorrectly.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.19" date="2005-02-16">
-
-<change type="bugfix">
-<para lang="ru">
-если в запросе есть нуль, то для локальных запросов теперь возвращается
-ошибка 404.
-</para>
-<para lang="en">
-now, if request contains the zero, then the 404 error is returned
-for the local requests.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под NetBSD 2.0.
-</para>
-<para lang="en">
-nginx could not be built on NetBSD 2.0.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-во время чтения тела запроса клиента в SSL соединении мог произойти таймаут.
-</para>
-<para lang="en">
-the timeout may occur while reading of the client request body
-via SSL connections.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.18" date="2005-02-09">
-
-<change type="workaround">
-<para lang="ru">
-для совместимости с Solaris 10 в директивах devpoll_events и devpoll_changes
-значения по умолчанию уменьшены с 512 до 32.
-</para>
-<para lang="en">
-the default values of the devpoll_events and the devpoll_changes directives
-changed from 512 to 32 to be compatible with Solaris 10.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директивы proxy_set_x_var и fastcgi_set_var не наследовались.
-</para>
-<para lang="en">
-the proxy_set_x_var and fastcgi_set_var directives were not inherited.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в директиве rewrite, возвращающей редирект, аргументы присоединялись
-к URI через символ "&amp;" вместо "?".
-</para>
-<para lang="en">
-in a redirect rewrite directive arguments were concatenated with URI
-by an "&amp;" rather than a "?".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-строки для модуля ngx_http_geo_module без символа ";" во включённом файле
-игнорировались.
-</para>
-<para lang="en">
-the lines without trailing ";" in the file being included
-by the ngx_http_geo_module were silently ignored.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_stub_status_module.
-</para>
-<para lang="en">
-the ngx_http_stub_status_module.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-неизвестный формат лог-файла в директиве access_log вызывал segmentation fault.
-</para>
-<para lang="en">
-the unknown log format in the access_log directive caused
-the segmentation fault.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новый параметр document_root в директиве fastcgi_params.
-</para>
-<para lang="en">
-the new "document_root" parameter of the fastcgi_params directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива fastcgi_redirect_errors.
-</para>
-<para lang="en">
-the fastcgi_redirect_errors directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-новый модификатор break в директиве rewrite позволяет прекратить
-цикл rewrite/location и устанавливает текущую конфигурацию для запроса.
-</para>
-<para lang="en">
-the new "break" modifier of the "rewrite" directive allows to stop
-the rewrite/location cycle and sets the current configuration to the request.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.17" date="2005-02-03">
-
-<change type="change">
-<para lang="ru">
-модуль ngx_http_rewrite_module полностью переписан.
-Теперь можно делать редиректы, возвращать коды ошибок
-и проверять переменные и рефереры.
-Эти директивы можно использовать внутри location.
-Директива redirect упразднена.
-</para>
-<para lang="en">
-the ngx_http_rewrite_module was rewritten from the scratch.
-Now it is possible to redirect, to return the error codes,
-to check the variables and referrers. The directives can be used
-inside locations.
-The redirect directive was canceled.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_geo_module.
-</para>
-<para lang="en">
-the ngx_http_geo_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы proxy_set_x_var и fastcgi_set_var.
-</para>
-<para lang="en">
-the proxy_set_x_var and fastcgi_set_var directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-конфигурация location с модификатором "=" могла использоваться
-в другом location.
-</para>
-<para lang="en">
-the location configuration with "=" modifier may be used in another
-location.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-правильный тип ответа выставлялся только для запросов, у которых в расширении
-были только маленькие буквы.
-</para>
-<para lang="en">
-the correct content type was set only for requests that use small caps letters
-in extension.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если для location установлен proxy_pass или fastcgi_pass, и доступ
-к нему запрещался, а ошибка перенаправлялась на статическую страницу,
-то происходил segmentation fault.
-</para>
-<para lang="en">
-if the proxy_pass or fastcgi_pass directives were set in the location,
-and access was denied, and the error was redirected to a static page,
-then the segmentation fault occurred.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в проксированном ответе в заголовке "Location" передавался
-относительный URL, то к нему добавлялось имя хоста и слэш;
-ошибка появилась в 0.1.14.
-</para>
-<para lang="en">
-if in a proxied "Location" header was a relative URL,
-then a host name and a slash were added to them;
-the bug had appeared in 0.1.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Linux в лог не записывался текст системной ошибки.
-</para>
-<para lang="en">
-the system error message was not logged on Linux.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.16" date="2005-01-25">
-
-<change type="bugfix">
-<para lang="ru">
-если ответ передавался chunk'ами, то при запросе HEAD выдавался
-завершающий chunk.
-</para>
-<para lang="en">
-if the response were transferred by chunks, then on the HEAD request
-the final chunk was issued.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-заголовок "Connection: keep-alive" выдавался, даже если директива
-keepalive_timeout запрещала использование keep-alive.
-</para>
-<para lang="en">
-the "Connection: keep-alive" header were issued, even if the
-keepalive_timeout directive forbade the keep-alive use.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в модуле ngx_http_fastcgi_module вызывали segmentation fault.
-</para>
-<para lang="en">
-the errors in the ngx_http_fastcgi_module caused the segmentation faults.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании SSL сжатый ответ мог передаваться не до конца.
-</para>
-<para lang="en">
-the compressed response encrypted by SSL may not transferred complete.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-опции TCP_NODELAY, TCP_NOPUSH и TCP_CORK, специфичные для TCP сокетов,
-не используются для unix domain сокетов.
-</para>
-<para lang="en">
-the TCP-specific TCP_NODELAY, TCP_NOPUSH, and TCP_CORK options,
-are not used for the unix domain sockets.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива rewrite поддерживает перезаписывание аргументов.
-</para>
-<para lang="en">
-the rewrite directive supports the arguments rewriting.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на запрос POST с заголовком "Content-Length: 0" возвращался ответ 400;
-ошибка появилась в 0.1.14.
-</para>
-<para lang="en">
-the response code 400 was returned for the POST request with the
-"Content-Length: 0" header;
-the bug had appeared in 0.1.14.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.15" date="2005-01-19">
-
-<change type="bugfix">
-<para lang="ru">
-ошибка соединения с FastCGI-сервером вызывала segmentation fault.
-</para>
-<para lang="en">
-the error while the connecting to the FastCGI server caused
-segmentation fault.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-корректная обработка регулярного выражения, в котором число
-выделенных частей не совпадает с числом подстановок.
-</para>
-<para lang="en">
-the correct handling of the regular expression, that
-has different number of the captures and substitutions.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-location, который передаётся FastCGI-серверу, может быть задан
-с помощью регулярного выражения.
-</para>
-<para lang="en">
-the location, that is passed to the FastCGI server, can be
-regular expression.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр FastCGI REQUEST_URI теперь передаётся вместе с аргументами
-и в том виде, в котором был получен от клиента.
-</para>
-<para lang="en">
-the FastCGI's parameter REQUEST_URI is now passed with the arguments
-and in the original state.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-для использования регулярных выражений в location нужно было
-собирать nginx вместе с ngx_http_rewrite_module.
-</para>
-<para lang="en">
-the ngx_http_rewrite_module module was required to be built to use
-the regular expressions in locations.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если бэкенд слушал на 80-ом порту, то при использовании директивы
-<nobr>"proxy_preserve_host  on"</nobr> в заголовке "Host" указывался
-также порт 80;
-ошибка появилась в 0.1.14.
-</para>
-<para lang="en">
-the directive <nobr>"proxy_preserve_host  on"</nobr> adds port 80
-to the "Host" headers, if upstream listen on port 80;
-the bug had appeared in 0.1.14.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если задать одинаковые пути в параметрах автоконфигурации
---http-client-body-temp-path=PATH и --http-proxy-temp-path=PATH
-или --http-client-body-temp-path=PATH и --http-fastcgi-temp-path=PATH,
-то происходил segmentation fault.
-</para>
-<para lang="en">
-the same paths in autoconfiguration parameters
---http-client-body-temp-path=PATH and --http-proxy-temp-path=PATH,
-or --http-client-body-temp-path=PATH and --http-fastcgi-temp-path=PATH
-caused segmentation fault.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.14" date="2005-01-18">
-
-<change type="feature">
-<para lang="ru">
-параметры автоконфигурации
---http-client-body-temp-path=PATH,
---http-proxy-temp-path=PATH
-и --http-fastcgi-temp-path=PATH
-</para>
-<para lang="en">
-the autoconfiguration directives:
---http-client-body-temp-path=PATH,
---http-proxy-temp-path=PATH,
-and --http-fastcgi-temp-path=PATH
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-имя каталога с временными файлами, содержащие тело запроса клиента,
-задаётся директивой client_body_temp_path,
-по умолчанию &lt;prefix&gt;/client_body_temp.
-</para>
-<para lang="en">
-the directory name for the temporary files with the client request body
-is specified by directive client_body_temp_path,
-by default it is &lt;prefix&gt;/client_body_temp.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_fastcgi_module и директивы
-fastcgi_pass,
-fastcgi_root,
-fastcgi_index,
-fastcgi_params,
-fastcgi_connect_timeout,
-fastcgi_send_timeout,
-fastcgi_read_timeout,
-fastcgi_send_lowat,
-fastcgi_header_buffer_size,
-fastcgi_buffers,
-fastcgi_busy_buffers_size,
-fastcgi_temp_path,
-fastcgi_max_temp_file_size,
-fastcgi_temp_file_write_size,
-fastcgi_next_upstream
-и fastcgi_x_powered_by.
-
-</para>
-<para lang="en">
-the ngx_http_fastcgi_module and the directives:
-fastcgi_pass,
-fastcgi_root,
-fastcgi_index,
-fastcgi_params,
-fastcgi_connect_timeout,
-fastcgi_send_timeout,
-fastcgi_read_timeout,
-fastcgi_send_lowat,
-fastcgi_header_buffer_size,
-fastcgi_buffers,
-fastcgi_busy_buffers_size,
-fastcgi_temp_path,
-fastcgi_max_temp_file_size,
-fastcgi_temp_file_write_size,
-fastcgi_next_upstream,
-and fastcgi_x_powered_by.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка "[alert] zero size buf";
-ошибка появилась в 0.1.3.
-</para>
-<para lang="en">
-the "[alert] zero size buf" error;
-the bug had appeared in 0.1.3.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-в директиве proxy_pass нужно обязательно указывать URI после имени хоста.
-</para>
-<para lang="en">
-the URI must be specified after the host name in the proxy_pass directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-если в URI встречался символ %3F, то он считался началом строки аргументов.
-</para>
-<para lang="en">
-the %3F symbol in the URI was considered as the argument string start.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-поддержка unix domain сокетов в модуле ngx_http_proxy_module.
-</para>
-<para lang="en">
-the unix domain sockets support in the ngx_http_proxy_module.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директивы ssl_engine и ssl_ciphers.<br/>
-Спасибо Сергею Скворцову за SSL-акселератор.
-</para>
-<para lang="en">
-the ssl_engine and ssl_ciphers directives.<br/>
-Thanks to Sergey Skvortsov for SSL-accelerator.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.13" date="2004-12-21">
-
-<change type="feature">
-<para lang="ru">
-директивы server_names_hash и server_names_hash_threshold.
-</para>
-<para lang="en">
-the server_names_hash and server_names_hash_threshold directives.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-имена *.domain.tld в директиве server_name не работали.
-</para>
-<para lang="en">
-the *.domain.tld names in the "server_name" directive did not work.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-параметр лога %request_length записывал неверную длину.
-</para>
-<para lang="en">
-the %request_length log parameter logged the incorrect length.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.12" date="2004-12-06">
-
-<change type="feature">
-<para lang="ru">
-параметр лога %request_length.
-</para>
-<para lang="en">
-the %request_length log parameter.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании /dev/poll, select и poll на платформах, где возможны
-ложные срабатывания указанных методов, могли быть длительные задержки
-при обработке запроса по keep-alive соединению.
-Наблюдалось по крайней мере на Solaris с использованием /dev/poll.
-</para>
-<para lang="en">
-when using the /dev/poll, select and poll on the platforms, where
-these methods may do the false reports, there may be the long delay when
-the request was passed via the keep-alive connection.
-It may be at least on Solaris when using the /dev/poll.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива send_lowat игнорируется на Linux, так как Linux не поддерживает
-опцию SO_SNDLOWAT.
-</para>
-<para lang="en">
-the send_lowat directive is ignored on Linux because Linux does not support
-the SO_SNDLOWAT option.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.11" date="2004-12-02">
-
-<change type="feature">
-<para lang="ru">
-директива worker_priority.
-</para>
-<para lang="en">
-the worker_priority directive.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-под FreeBSD директивы tcp_nopush и tcp_nodelay вместе влияют на передачу
-ответа.
-</para>
-<para lang="en">
-both tcp_nopush and tcp_nodelay directives affect the transferred response.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не вызывал initgroups().<br/>
-Спасибо Андрею Ситникову и Андрею Нигматулину.
-</para>
-<para lang="en">
-nginx did not call initgroups().<br/>
-Thanks to Andrew Sitnikov and Andrei Nigmatulin.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-ngx_http_auto_index_module теперь выдаёт размер файлов в байтах.
-</para>
-<para lang="en">
-now the ngx_http_autoindex_module shows the file size in the bytes.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ngx_http_auto_index_module возвращал ошибку 500, если в каталоге есть
-битый symlink.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module returned the 500 error if the broken symlink
-was in a directory.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-файлы больше 4G не передавались с использованием sendfile.
-</para>
-<para lang="en">
-the files bigger than 4G could not be transferred using sendfile.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если бэкенд резолвился в несколько адресов и при ожидании от него ответа
-происходила ошибка, то процесс зацикливался.
-</para>
-<para lang="en">
-if the backend was resolved to several backends and there was an error while
-the response waiting then process may got caught in an endless loop.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании метода /dev/poll рабочий процесс мог завершиться
-с сообщением "unknown cycle".
-</para>
-<para lang="en">
-the worker process may exit with the "unknown cycle" message when the /dev/poll
-method was used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки "close() channel failed".
-</para>
-<para lang="en">
-"close() channel failed" errors.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-автоматическое определение групп nobody и nogroup.
-</para>
-<para lang="en">
-the autodetection of the "nobody" and "nogroup" groups.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-директива send_lowat не работала на Linux.
-</para>
-<para lang="en">
-the send_lowat directive did not work on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-если в конфигурации не было раздела events, то происходил segmentation fault.
-</para>
-<para lang="en">
-the segmentation fault occurred if there was no events section
-in configuration.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-nginx не собирался под OpenBSD.
-</para>
-<para lang="en">
-nginx could not be built on OpenBSD.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-двойные слэшы в "://" в URI превращались в ":/".
-</para>
-<para lang="en">
-the double slashes in "://" in the URI were converted to ":/".
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.10" date="2004-11-26">
-
-<change type="bugfix">
-<para lang="ru">
-если в запросе без аргументов есть "//", "/./", "/../" или "%XX",
-то терялся последний символ в строке запроса;
-ошибка появилась в 0.1.9.
-</para>
-<para lang="en">
-if the request without arguments contains "//", "/./", "/../" or "%XX"
-then the last character in the request line was lost;
-the bug had appeared in 0.1.9.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-исправление в версии 0.1.9 для файлов больше 2G на Linux не работало.
-</para>
-<para lang="en">
-the fix in 0.1.9 for the files bigger than 2G on Linux did not work.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.9" date="2004-11-25">
-
-<change type="bugfix">
-<para lang="ru">
-если в запросе есть "//", "/./", "/../" или "%XX", то проксируемый
-запрос передавался без аргументов.
-</para>
-<para lang="en">
-the proxied request was sent without arguments if the request contains
-"//", "/./", "/../" or "%XX".
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при сжатии больших ответов иногда они передавались не полностью.
-</para>
-<para lang="en">
-the large compressed responses may be transferred not completely.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-не передавались файлы больше 2G на Linux, неподдерживающем sendfile64().
-</para>
-<para lang="en">
-the files bigger than 2G was not transferred on Linux that does not support
-sendfile64().
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Linux при конфигурации сборки нужно было обязательно использовать
-параметр --with-poll_module;
-ошибка появилась в 0.1.8.
-</para>
-<para lang="en">
-while the build configuration on Linux the --with-poll_module parameter
-was required;
-the bug had appeared in 0.1.8.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.8" date="2004-11-20">
-
-<change type="bugfix">
-<para lang="ru">
-ошибка в модуле ngx_http_autoindex_module при показе длинных имён файлов.
-</para>
-<para lang="en">
-in the ngx_http_autoindex_module if the long file names were in the listing.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-модификатор "^~" в директиве location.
-</para>
-<para lang="en">
-the "^~" modifier in the location directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_max_temp_file_size.
-</para>
-<para lang="en">
-the proxy_max_temp_file_size directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.7" date="2004-11-12">
-
-<change type="bugfix">
-<para lang="ru">
-при использовании sendfile, если передаваемый файл менялся, то мог
-произойти segmentation fault на FreeBSD;
-ошибка появилась в 0.1.5.
-</para>
-<para lang="en">
-on FreeBSD the segmentation fault may occur if the size of the transferred
-file was changed;
-the bug had appeared in 0.1.5.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.6" date="2004-11-11">
-
-<change type="bugfix">
-<para lang="ru">
-при некоторых комбинациях директив location c регулярными выражениями
-использовалась конфигурация не из того location.
-</para>
-<para lang="en">
-some location directive combinations with the regular expressions caused
-the wrong configuration choose.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.5" date="2004-11-11">
-
-<change type="bugfix">
-<para lang="ru">
-на Solaris и Linux могло быть очень много сообщений "recvmsg() returned
-not enough data".
-</para>
-<para lang="en">
-on Solaris and Linux there may be too many "recvmsg() returned not enough data"
-alerts.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в режиме прокси без использования sendfile на Solaris возникала
-ошибка "writev() failed <nobr>(22: Invalid argument)".</nobr>
-На других платформах, не поддерживающих sendfile, процесс зацикливался.
-</para>
-<para lang="en">
-there were the "writev() failed <nobr>(22: Invalid argument)"</nobr> errors on
-Solaris in proxy mode without sendfile. On other platforms that do not
-support sendfile at all the process got caught in an endless loop.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании sendfile в режиме прокси на Solaris возникал
-segmentation fault.
-</para>
-<para lang="en">
-segmentation fault on Solaris in proxy mode and using sendfile.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-segmentation fault на Solaris.
-</para>
-<para lang="en">
-segmentation fault on Solaris.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-обновление исполняемого файла на лету не работало на Linux.
-</para>
-<para lang="en">
-on-line upgrade did not work on Linux.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-в списке файлов, выдаваемом модулем ngx_http_autoindex_module,
-не перекодировались пробелы, кавычки и знаки процента.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module module did not escape the spaces,
-the quotes, and the percent signs in the directory listing.
-</para>
-</change>
-
-<change type="change">
-<para lang="ru">
-уменьшение операций копирования.
-</para>
-<para lang="en">
-the decrease of the copy operations.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива userid_p3p.
-</para>
-<para lang="en">
-the userid_p3p directive.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.4" date="2004-10-26">
-
-<change type="bugfix">
-<para lang="ru">
-ошибка в модуле ngx_http_autoindex_module.
-</para>
-<para lang="en">
-in the ngx_http_autoindex_module.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.3" date="2004-10-25">
-
-<change type="feature">
-<para lang="ru">
-модуль ngx_http_autoindex_module и директива autoindex.
-</para>
-<para lang="en">
-the ngx_http_autoindex_module and the autoindex directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива proxy_set_x_url.
-</para>
-<para lang="en">
-the proxy_set_x_url directive.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль проксировании мог привести к зацикливанию, если не использовался
-sendfile.
-</para>
-<para lang="en">
-proxy module may get caught in an endless loop when sendfile is not used.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.2" date="2004-10-21">
-
-<change type="feature">
-<para lang="ru">
-параметры --user=USER, --group=GROUP и --with-ld-opt=OPTIONS в configure.
-</para>
-<para lang="en">
-the --user=USER, --group=GROUP, and --with-ld-opt=OPTIONS options in configure.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива server_name поддерживает *.domain.tld.
-</para>
-<para lang="en">
-the server_name directive supports *.domain.tld.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-улучшена переносимость на неизвестные платформы.
-</para>
-<para lang="en">
-the portability improvements.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-нельзя переконфигурировать nginx, если конфигурационный файл указан
-в командной строке;
-ошибка появилась в 0.1.1.
-</para>
-<para lang="en">
-if configuration file was set in command line, the reconfiguration
-was impossible;
-the bug had appeared in 0.1.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль проксировании мог привести к зацикливанию, если не использовался
-sendfile.
-</para>
-<para lang="en">
-proxy module may get caught in an endless loop when sendfile is not used.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при использовании sendfile текст ответа не перекодировался
-согласно директивам модуля charset;
-ошибка появилась в 0.1.1.
-</para>
-<para lang="en">
-with sendfile the response was not recoded according to the charset
-module directives;
-the bug had appeared in 0.1.1.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-очень редкая ошибка при обработке kqueue.
-</para>
-<para lang="en">
-very seldom bug in the kqueue processing.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-модуль сжатия сжимал уже сжатые ответы, полученные при проксировании.
-</para>
-<para lang="en">
-the gzip module compressed the proxied responses that was already compressed.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.1" date="2004-10-11">
-
-<change type="feature">
-<para lang="ru">
-директива gzip_types.
-</para>
-<para lang="en">
-the gzip_types directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива tcp_nodelay.
-</para>
-<para lang="en">
-the tcp_nodelay directive.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-директива send_lowat работает не только на платформах, поддерживающих
-kqueue NOTE_LOWAT, но и на всех, поддерживающих SO_SNDLOWAT.
-</para>
-<para lang="en">
-the send_lowat directive is working not only on OSes that support
-kqueue NOTE_LOWAT, but also on OSes that support SO_SNDLOWAT.
-</para>
-</change>
-
-<change type="feature">
-<para lang="ru">
-эмуляция setproctitle() для Linux и Solaris.
-</para>
-<para lang="en">
-the setproctitle() emulation for Linux and Solaris.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка при переписывании заголовка "Location" при проксировании.
-</para>
-<para lang="en">
-the "Location" header rewrite bug fixed while the proxying.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибка в модуле ngx_http_chunked_module, приводившая к зацикливанию.
-</para>
-<para lang="en">
-the ngx_http_chunked_module module may get caught in an endless loop.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-ошибки в модуле /dev/poll.
-</para>
-<para lang="en">
-the /dev/poll module bugs fixed.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-при проксировании и использовании временных файлов ответы портились.
-</para>
-<para lang="en">
-the responses were corrupted when the temporary files were used
-while the proxying.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-бэкенду передавались запросы с неперекодированными символами.
-</para>
-<para lang="en">
-the unescaped requests were passed to the backend.
-</para>
-</change>
-
-<change type="bugfix">
-<para lang="ru">
-на Linux 2.4 при конфигурации сборки нужно было обязательно использовать
-параметр --with-poll_module.
-</para>
-<para lang="en">
-while the build configuration on Linux 2.4 the --with-poll_module parameter
-was required.
-</para>
-</change>
-
-</changes>
-
-
-<changes ver="0.1.0" date="2004-10-04">
-
-<change>
-<para lang="ru">
-Первая публично доступная версия.
-</para>
-<para lang="en">
-The first public version.
-</para>
-</change>
-
-</changes>
-
-
-</change_log>
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/xsls/changes.xsls ../asynch_mode_nginx/docs/xsls/changes.xsls
--- nginx-release-1.20.1/docs/xsls/changes.xsls	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/xsls/changes.xsls	1969-12-31 18:00:00.000000000 -0600
@@ -1,134 +0,0 @@
-X:stylesheet {
-
-X:output method="text";
-
-X:param lang="'en'";
-X:param configuration="'../xml/change_log_conf.xml'";
-
-X:var conf = "document($configuration)/configuration";
-X:var start = "$conf/start";
-X:var indent = "$conf/indent";
-X:var max = "$conf/length";
-X:var br = {&lt;br&gt;}
-
-
-X:template = "/" { !! "change_log"; }
-X:template = "change_log" { !! "changes"; }
-
-
-X:template = "changes" {
-    X:text {&#10;}
-
-    !{substring(concat($conf/changes[@lang=$lang]/title,
-                       //change_log/@title,
-                       ' ', @ver,
-                       '                                                    '),
-                1, $conf/changes[@lang=$lang]/length)}
-
-    X:if "$lang='ru'" {
-        !{substring(@date, 9, 2)}
-        X:text {.}
-        !{substring(@date, 6, 2)}
-        X:text {.}
-        !{substring(@date, 1, 4)}
-    }
-
-    X:if "$lang='en'" {
-        !{substring(@date, 9, 2)}
-        !{$conf/changes[@lang=$lang]/month[number(substring(current()/@date,
-                                                            6, 2))]}
-        !{substring(@date, 1, 4)}
-    }
-
-    X:text {&#10;}
-
-    !! "change";
-
-    X:text {&#10;}
-}
-
-
-X:template = "change" {
-    X:var prefix = "$conf/changes[@lang=$lang]/*[local-name(.)=current()/@type]"
-
-    X:var postfix = { X:if "$prefix" { X:text {: } } }
-
-    !! "para[@lang=$lang]" (prefix = "concat($start, $prefix, $postfix)");
-}
-
-
-X:template para(prefix) = "para" {
-    X:var text = { !!; }
-
-    X:text {&#10;}
-
-    !wrap(text = "normalize-space($text)",
-          prefix = { X:if "position() = 1" { !{$prefix} } else { !{$indent} } })
-}
-
-
-X:template wrap(text, prefix) {
-    X:if "$text" {
-        X:var offset = {
-            X:choose {
-                X:when "starts-with($text, concat($br, ' '))" {
-                    !{string-length($br) + 2}
-                }
-                X:when "starts-with($text, $br)" {
-                    !{string-length($br) + 1}
-                }
-                X:otherwise {
-                    1
-                }
-            }
-        }
-
-        X:var length = {
-            !length(text = "substring($text, $offset)",
-                    prefix = "string-length($prefix)",
-                    length = "$max")
-        }
-
-        !{$prefix}
-
-        !{normalize-space(translate(substring($text, $offset, $length),
-                                    '&#xA0;', ' '))}
-
-        X:text {&#10;}
-
-        !wrap(text = "substring($text, $length + $offset)", prefix = "$indent")
-    }
-}
-
-
-X:template length(text, prefix, length) {
-    X:var break = "substring-before(substring($text, 1,
-                                    $length - $prefix + string-length($br)),
-                                    $br)"
-
-    X:choose {
-        X:when "$break" { !{string-length($break)} }
-
-        X:when "$length = 0" { !{$max - $prefix} }
-
-        X:when "string-length($text) + $prefix &lt;= $length" {
-            !{$length - $prefix}
-        }
-
-        X:when "substring($text, $length - $prefix + 1, 1) = ' '" {
-            !{$length - $prefix + 1}
-        }
-
-        X:otherwise {
-            !length(text = "$text", prefix = "$prefix", length = "$length - 1")
-        }
-    }
-}
-
-
-X:template = "at" {@}
-X:template = "br" { !{$br} }
-X:template = "nobr" { !{translate(., ' ', '&#xA0;')} }
-
-
-}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/docs/xslt/changes.xslt ../asynch_mode_nginx/docs/xslt/changes.xslt
--- nginx-release-1.20.1/docs/xslt/changes.xslt	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/docs/xslt/changes.xslt	1969-12-31 18:00:00.000000000 -0600
@@ -1,128 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
-
-<xsl:output method="text"/>
-
-<xsl:param select="'en'" name="lang"/>
-<xsl:param select="'../xml/change_log_conf.xml'" name="configuration"/>
-
-<xsl:variable select="document($configuration)/configuration" name="conf"/>
-<xsl:variable select="$conf/start" name="start"/>
-<xsl:variable select="$conf/indent" name="indent"/>
-<xsl:variable select="$conf/length" name="max"/>
-<xsl:variable name="br">&lt;br&gt;</xsl:variable>
-
-
-<xsl:template match="/"> <xsl:apply-templates select="change_log"/> </xsl:template>
-<xsl:template match="change_log"> <xsl:apply-templates select="changes"/> </xsl:template>
-
-
-<xsl:template match="changes">
-    <xsl:text>&#10;</xsl:text>
-
-    <xsl:value-of select="substring(concat($conf/changes[@lang=$lang]/title,
-                       //change_log/@title,
-                       ' ', @ver,
-                       '                                                    '),
-                1, $conf/changes[@lang=$lang]/length)"/>
-
-    <xsl:if test="$lang='ru'">
-        <xsl:value-of select="substring(@date, 9, 2)"/>
-        <xsl:text>.</xsl:text>
-        <xsl:value-of select="substring(@date, 6, 2)"/>
-        <xsl:text>.</xsl:text>
-        <xsl:value-of select="substring(@date, 1, 4)"/>
-    </xsl:if>
-
-    <xsl:if test="$lang='en'">
-        <xsl:value-of select="substring(@date, 9, 2)"/>
-        <xsl:value-of select="$conf/changes[@lang=$lang]/month[number(substring(current()/@date,
-                                                            6, 2))]"/>
-        <xsl:value-of select="substring(@date, 1, 4)"/>
-    </xsl:if>
-
-    <xsl:text>&#10;</xsl:text>
-
-    <xsl:apply-templates select="change"/>
-
-    <xsl:text>&#10;</xsl:text>
-</xsl:template>
-
-
-<xsl:template match="change">
-    <xsl:variable select="$conf/changes[@lang=$lang]/*[local-name(.)=current()/@type]" name="prefix"/>
-
-    <xsl:variable name="postfix"> <xsl:if test="$prefix"> <xsl:text>: </xsl:text> </xsl:if> </xsl:variable>
-
-    <xsl:apply-templates select="para[@lang=$lang]"><xsl:with-param select="concat($start, $prefix, $postfix)" name="prefix"/></xsl:apply-templates>
-</xsl:template>
-
-
-<xsl:template name="para" match="para"><xsl:param name="prefix"/>
-    <xsl:variable name="text"> <xsl:apply-templates/> </xsl:variable>
-
-    <xsl:text>&#10;</xsl:text>
-
-    <xsl:call-template name="wrap"><xsl:with-param select="normalize-space($text)" name="text"/><xsl:with-param name="prefix"> <xsl:choose><xsl:when test="position() = 1"> <xsl:value-of select="$prefix"/> </xsl:when><xsl:otherwise> <xsl:value-of select="$indent"/> </xsl:otherwise></xsl:choose> </xsl:with-param></xsl:call-template></xsl:template>
-
-
-<xsl:template name="wrap"><xsl:param name="text"/><xsl:param name="prefix"/>
-    <xsl:if test="$text">
-        <xsl:variable name="offset">
-            <xsl:choose>
-                <xsl:when test="starts-with($text, concat($br, ' '))">
-                    <xsl:value-of select="string-length($br) + 2"/>
-                </xsl:when>
-                <xsl:when test="starts-with($text, $br)">
-                    <xsl:value-of select="string-length($br) + 1"/>
-                </xsl:when>
-                <xsl:otherwise>
-                    1
-                </xsl:otherwise>
-            </xsl:choose>
-        </xsl:variable>
-
-        <xsl:variable name="length">
-            <xsl:call-template name="length"><xsl:with-param select="substring($text, $offset)" name="text"/><xsl:with-param select="string-length($prefix)" name="prefix"/><xsl:with-param select="$max" name="length"/></xsl:call-template></xsl:variable>
-
-        <xsl:value-of select="$prefix"/>
-
-        <xsl:value-of select="normalize-space(translate(substring($text, $offset, $length),
-                                    '&#xA0;', ' '))"/>
-
-        <xsl:text>&#10;</xsl:text>
-
-        <xsl:call-template name="wrap"><xsl:with-param select="substring($text, $length + $offset)" name="text"/><xsl:with-param select="$indent" name="prefix"/></xsl:call-template></xsl:if>
-</xsl:template>
-
-
-<xsl:template name="length"><xsl:param name="text"/><xsl:param name="prefix"/><xsl:param name="length"/>
-    <xsl:variable select="substring-before(substring($text, 1,
-                                    $length - $prefix + string-length($br)),
-                                    $br)" name="break"/>
-
-    <xsl:choose>
-        <xsl:when test="$break"> <xsl:value-of select="string-length($break)"/> </xsl:when>
-
-        <xsl:when test="$length = 0"> <xsl:value-of select="$max - $prefix"/> </xsl:when>
-
-        <xsl:when test="string-length($text) + $prefix &lt;= $length">
-            <xsl:value-of select="$length - $prefix"/>
-        </xsl:when>
-
-        <xsl:when test="substring($text, $length - $prefix + 1, 1) = ' '">
-            <xsl:value-of select="$length - $prefix + 1"/>
-        </xsl:when>
-
-        <xsl:otherwise>
-            <xsl:call-template name="length"><xsl:with-param select="$text" name="text"/><xsl:with-param select="$prefix" name="prefix"/><xsl:with-param select="$length - 1" name="length"/></xsl:call-template></xsl:otherwise>
-    </xsl:choose>
-</xsl:template>
-
-
-<xsl:template match="at">@</xsl:template>
-<xsl:template match="br"> <xsl:value-of select="$br"/> </xsl:template>
-<xsl:template match="nobr"> <xsl:value-of select="translate(., ' ', '&#xA0;')"/> </xsl:template>
-
-
-</xsl:stylesheet>
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/LICENSE ../asynch_mode_nginx/LICENSE
--- nginx-release-1.20.1/LICENSE	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/LICENSE	2022-03-15 13:23:40.536402806 -0500
@@ -0,0 +1,32 @@
+/*
+ * BSD LICENSE
+ *
+ * Copyright (C) 2002-2021 Igor Sysoev
+ * Copyright (C) 2011-2021 Nginx, Inc.
+ * Copyright (C) 2014-2021 Intel, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/misc/GNUmakefile ../asynch_mode_nginx/misc/GNUmakefile
--- nginx-release-1.20.1/misc/GNUmakefile	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/misc/GNUmakefile	1969-12-31 18:00:00.000000000 -0600
@@ -1,154 +0,0 @@
-
-VER =		$(shell grep 'define NGINX_VERSION' src/core/nginx.h	\
-			| sed -e 's/^.*"\(.*\)".*/\1/')
-NGINX =		nginx-$(VER)
-TEMP =		tmp
-
-CC =		cl
-OBJS =		objs.msvc8
-OPENSSL =	openssl-1.1.1k
-ZLIB =		zlib-1.2.11
-PCRE =		pcre-8.44
-
-
-release: export
-
-	mv $(TEMP)/$(NGINX)/auto/configure $(TEMP)/$(NGINX)
-
-	# delete incomplete sources
-	rm $(TEMP)/$(NGINX)/src/event/ngx_event_acceptex.c
-	rm $(TEMP)/$(NGINX)/src/event/ngx_event_connectex.c
-	rm $(TEMP)/$(NGINX)/src/event/modules/ngx_iocp_module.*
-	rm -r $(TEMP)/$(NGINX)/src/os/win32
-
-	mv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)
-	mv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)
-	mv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)
-	mv $(TEMP)/$(NGINX)/docs/man $(TEMP)/$(NGINX)
-
-	$(MAKE) -f docs/GNUmakefile changes
-
-	rm -r $(TEMP)/$(NGINX)/docs
-	rm -r $(TEMP)/$(NGINX)/misc
-
-	tar -c -z -f $(NGINX).tar.gz --directory $(TEMP) $(NGINX)
-
-
-export:
-	rm -rf $(TEMP)
-	hg archive -X '.hg*' $(TEMP)/$(NGINX)
-
-
-RELEASE:
-	hg ci -m nginx-$(VER)-RELEASE
-	hg tag -m "release-$(VER) tag" release-$(VER)
-
-	$(MAKE) -f misc/GNUmakefile release
-
-
-win32:
-	./auto/configure						\
-		--with-cc=$(CC)						\
-		--builddir=$(OBJS)					\
-		--with-debug						\
-		--prefix= 						\
-		--conf-path=conf/nginx.conf				\
-		--pid-path=logs/nginx.pid				\
-		--http-log-path=logs/access.log				\
-		--error-log-path=logs/error.log				\
-		--sbin-path=nginx.exe					\
-		--http-client-body-temp-path=temp/client_body_temp	\
-		--http-proxy-temp-path=temp/proxy_temp			\
-		--http-fastcgi-temp-path=temp/fastcgi_temp		\
-		--http-scgi-temp-path=temp/scgi_temp			\
-		--http-uwsgi-temp-path=temp/uwsgi_temp			\
-		--with-cc-opt=-DFD_SETSIZE=1024				\
-		--with-pcre=$(OBJS)/lib/$(PCRE)				\
-		--with-zlib=$(OBJS)/lib/$(ZLIB)				\
-		--with-http_v2_module					\
-		--with-http_realip_module				\
-		--with-http_addition_module				\
-		--with-http_sub_module					\
-		--with-http_dav_module					\
-		--with-http_stub_status_module				\
-		--with-http_flv_module					\
-		--with-http_mp4_module					\
-		--with-http_gunzip_module				\
-		--with-http_gzip_static_module				\
-		--with-http_auth_request_module				\
-		--with-http_random_index_module				\
-		--with-http_secure_link_module				\
-		--with-http_slice_module				\
-		--with-mail						\
-		--with-stream						\
-		--with-openssl=$(OBJS)/lib/$(OPENSSL)			\
-		--with-openssl-opt="no-asm no-tests -D_WIN32_WINNT=0x0501" \
-		--with-http_ssl_module					\
-		--with-mail_ssl_module					\
-		--with-stream_ssl_module
-
-
-zip: export
-	rm -f $(NGINX).zip
-
-	mkdir -p $(TEMP)/$(NGINX)/docs.new
-	mkdir -p $(TEMP)/$(NGINX)/logs
-	mkdir -p $(TEMP)/$(NGINX)/temp
-
-	sed -i '' -e "s/$$/`printf '\r'`/" $(TEMP)/$(NGINX)/conf/*
-
-	mv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)/docs.new
-	mv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)/docs.new
-	mv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)
-
-	rm -r $(TEMP)/$(NGINX)/docs
-	mv $(TEMP)/$(NGINX)/docs.new $(TEMP)/$(NGINX)/docs
-
-	cp -p $(OBJS)/nginx.exe $(TEMP)/$(NGINX)
-
-	$(MAKE) -f docs/GNUmakefile changes
-	mv $(TEMP)/$(NGINX)/CHANGES* $(TEMP)/$(NGINX)/docs/
-
-	cp -p $(OBJS)/lib/$(OPENSSL)/LICENSE				\
-		$(TEMP)/$(NGINX)/docs/OpenSSL.LICENSE
-
-	cp -p $(OBJS)/lib/$(PCRE)/LICENCE				\
-		$(TEMP)/$(NGINX)/docs/PCRE.LICENCE
-
-	sed -ne '/^ (C) 1995-20/,/^  jloup@gzip\.org/p'			\
-		$(OBJS)/lib/$(ZLIB)/README				\
-		> $(TEMP)/$(NGINX)/docs/zlib.LICENSE
-
-	touch -r $(OBJS)/lib/$(ZLIB)/README				\
-		$(TEMP)/$(NGINX)/docs/zlib.LICENSE
-
-	rm -r $(TEMP)/$(NGINX)/auto
-	rm -r $(TEMP)/$(NGINX)/misc
-	rm -r $(TEMP)/$(NGINX)/src
-
-	cd $(TEMP) && zip -r ../$(NGINX).zip $(NGINX)
-
-
-icons:	src/os/win32/nginx.ico
-
-# 48x48, 32x32 and 16x16 icons
-
-src/os/win32/nginx.ico:	src/os/win32/nginx_icon48.xpm			\
-			src/os/win32/nginx_icon32.xpm			\
-			src/os/win32/nginx_icon16.xpm
-
-	test -d $(TEMP) || mkdir $(TEMP)
-
-	xpmtoppm --alphaout=$(TEMP)/nginx48.pbm				\
-		src/os/win32/nginx_icon48.xpm > $(TEMP)/nginx48.ppm
-
-	xpmtoppm --alphaout=$(TEMP)/nginx32.pbm				\
-		src/os/win32/nginx_icon32.xpm > $(TEMP)/nginx32.ppm
-
-	xpmtoppm --alphaout=$(TEMP)/nginx16.pbm				\
-		src/os/win32/nginx_icon16.xpm > $(TEMP)/nginx16.ppm
-
-	ppmtowinicon -output src/os/win32/nginx.ico -andpgms		\
-		$(TEMP)/nginx48.ppm $(TEMP)/nginx48.pbm			\
-		$(TEMP)/nginx32.ppm $(TEMP)/nginx32.pbm			\
-		$(TEMP)/nginx16.ppm $(TEMP)/nginx16.pbm
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/misc/README ../asynch_mode_nginx/misc/README
--- nginx-release-1.20.1/misc/README	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/misc/README	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-
-make -f misc/GNUmakefile release
-
-the required tools:
-*) xsltproc to build CHANGES,
-*) xslscript.pl ( http://hg.nginx.org/xslscript ) to build XSLTs
-   from XSLScript sources.
-
-
-make -f misc/GNUmakefile icons
-
-the required tool:
-*) netpbm to create Win32 icons from xpm sources.
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qat_module/config ../asynch_mode_nginx/modules/nginx_qat_module/config
--- nginx-release-1.20.1/modules/nginx_qat_module/config	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qat_module/config	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,15 @@
+# Copyright (C) Intel, Inc.
+
+ngx_addon_name=ngx_ssl_engine_qat_module
+
+if test -n "$ngx_module_link"; then
+    ngx_module_type=ENGINE
+    ngx_module_name=ngx_ssl_engine_qat_module
+    ngx_module_srcs="$ngx_addon_dir/ngx_ssl_engine_qat_module.c"
+
+    . auto/module
+else
+    SSL_ENGINE_MODULES="$SSL_ENGINE_MODULES ngx_ssl_engine_qat_module"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_ssl_engine_qat_module.c"
+fi
+
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qat_module/ngx_ssl_engine_qat_module.c ../asynch_mode_nginx/modules/nginx_qat_module/ngx_ssl_engine_qat_module.c
--- nginx-release-1.20.1/modules/nginx_qat_module/ngx_ssl_engine_qat_module.c	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qat_module/ngx_ssl_engine_qat_module.c	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,1198 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_ssl_engine.h>
+
+
+typedef struct {
+    ngx_str_t       engine_id;
+    /* if this engine can be released during worker is shutting down */
+    ngx_flag_t      releasable;
+
+    ngx_flag_t      enable_sw_fallback;
+    /* sync or async (default) */
+    ngx_str_t       offload_mode;
+
+    /* event or poll (default) */
+    ngx_str_t       notify_mode;
+
+    /* inline, internal (default), external or heuristic */
+    ngx_str_t       poll_mode;
+
+    /* xxx ns */
+    ngx_int_t       internal_poll_interval;
+
+    /* xxx ms */
+    ngx_int_t       external_poll_interval;
+
+    ngx_int_t       heuristic_poll_asym_threshold;
+
+    ngx_int_t       heuristic_poll_sym_threshold;
+
+    ngx_int_t       heuristic_poll_asym_multibuff_threshold;
+
+    ngx_int_t       heuristic_poll_sym_multibuff_threshold;
+
+    ngx_array_t    *small_pkt_offload_threshold;
+} ngx_ssl_engine_qat_conf_t;
+
+
+static ngx_int_t ngx_ssl_engine_qat_init(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_qat_send_ctrl(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_qat_register_handler(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_qat_release(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_qat_heuristic_poll(ngx_log_t *log);
+
+static char *ngx_ssl_engine_qat_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_ssl_engine_qat_set_threshold(ngx_conf_t *cf,
+    ngx_command_t *cmd, void *conf);
+
+static void *ngx_ssl_engine_qat_create_conf(ngx_cycle_t *cycle);
+static char *
+ngx_ssl_engine_qat_releasable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_ssl_engine_qat_init_conf(ngx_cycle_t *cycle, void *conf);
+
+static ngx_int_t ngx_ssl_engine_qat_process_init(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_qat_process_exit(ngx_cycle_t *cycle);
+
+
+#define EXTERNAL_POLL_DEFAULT_INTERVAL              1
+#define HEURISTIC_POLL_DEFAULT_INTERVAL             1
+
+#define HEURISTIC_POLL_ASYM_DEFAULT_THRESHOLD       48
+#define HEURISTIC_POLL_SYM_DEFAULT_THRESHOLD        24
+#define HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD  8
+
+#define GET_NUM_ASYM_REQUESTS_IN_FLIGHT             1
+#define GET_NUM_KDF_REQUESTS_IN_FLIGHT              2
+#define GET_NUM_CIPHER_PIPELINE_REQUESTS_IN_FLIGHT  3
+#define GET_NUM_ASYM_NUM_ITEMS_IN_QUEUE             4
+#define GET_NUM_KDF_NUM_ITEMS_IN_QUEUE              5
+#define GET_NUM_SYM_NUM_ITEMS_IN_QUEUE              6
+
+#define INLINE_POLL     1
+#define INTERNAL_POLL   2
+#define EXTERNAL_POLL   3
+#define HEURISTIC_POLL  4
+
+#define HEARTBEAT_POLL_TIMEOUT  1000
+
+static ENGINE          *qat_engine;
+
+static ngx_uint_t       qat_engine_enable_inline_polling;
+
+static ngx_uint_t       qat_engine_enable_internal_polling;
+
+static ngx_uint_t       qat_engine_enable_heartbeat_polling = 0;
+
+
+static ngx_uint_t       qat_engine_enable_external_polling;
+static ngx_int_t        qat_engine_external_poll_interval;
+static ngx_event_t      qat_engine_external_poll_event;
+static ngx_event_t      qat_engine_heartbeat_poll_event;
+static ngx_connection_t dumb;
+
+static ngx_uint_t   qat_engine_enable_heuristic_polling;
+static ngx_event_t  qat_engine_heuristic_poll_event;
+static ngx_int_t    qat_engine_heuristic_poll_asym_threshold;
+static ngx_int_t    qat_engine_heuristic_poll_sym_threshold;
+static ngx_int_t    qat_engine_heuristic_poll_asym_multibuff_threshold;
+static ngx_int_t    qat_engine_heuristic_poll_sym_multibuff_threshold;
+
+/* Since any polling mode change need to restart Nginx service
+ * The initial polling mode is record when Nginx master start
+ * for valid configuration check during Nginx worker reload
+ * 0:unset, 1:inline, 2:internal, 3:external, 4:heuristic
+ */
+static ngx_int_t    qat_engine_init_polling_mode = 0;
+
+typedef struct qat_instance_status_s {
+    ngx_flag_t busy;
+    ngx_flag_t finished;
+    ngx_int_t  checkpoint;
+} qat_instance_status_t;
+
+static qat_instance_status_t qat_instance_status;
+
+static int  num_heuristic_poll = 0;
+static int *num_asym_requests_in_flight = NULL;
+static int *num_kdf_requests_in_flight = NULL;
+static int *num_cipher_requests_in_flight = NULL;
+static int *num_asym_mb_items_in_queue = NULL;
+static int *num_kdf_mb_items_in_queue = NULL;
+static int *num_sym_mb_items_in_queue = NULL;
+
+static ngx_str_t ngx_ssl_engine_qat_module_name = ngx_string("qatengine");
+
+static ngx_command_t  ngx_ssl_engine_qat_commands[] = {
+
+    { ngx_string("qat_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_qat_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("qat_shutting_down_release"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_ssl_engine_qat_releasable,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, releasable),
+      NULL },
+
+    { ngx_string("qat_sw_fallback"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, enable_sw_fallback),
+      NULL },
+
+    { ngx_string("qat_offload_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, offload_mode),
+      NULL },
+
+    { ngx_string("qat_notify_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, notify_mode),
+      NULL },
+
+    { ngx_string("qat_poll_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, poll_mode),
+      NULL },
+
+    { ngx_string("qat_internal_poll_interval"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, internal_poll_interval),
+      NULL },
+
+    { ngx_string("qat_external_poll_interval"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, external_poll_interval),
+      NULL },
+
+    { ngx_string("qat_heuristic_poll_asym_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, heuristic_poll_asym_threshold),
+      NULL },
+
+    { ngx_string("qat_heuristic_poll_sym_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, heuristic_poll_sym_threshold),
+      NULL },
+
+    { ngx_string("qat_heuristic_poll_asym_multibuff_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, heuristic_poll_asym_multibuff_threshold),
+      NULL },
+
+    { ngx_string("qat_heuristic_poll_sym_multibuff_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, heuristic_poll_sym_multibuff_threshold),
+      NULL },
+
+    { ngx_string("qat_small_pkt_offload_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_1MORE,
+      ngx_ssl_engine_qat_set_threshold,
+      0,
+      offsetof(ngx_ssl_engine_qat_conf_t, small_pkt_offload_threshold),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_qat_module_ctx = {
+    &ngx_ssl_engine_qat_module_name,
+    ngx_ssl_engine_qat_create_conf,               /* create configuration */
+    ngx_ssl_engine_qat_init_conf,                 /* init configuration */
+
+    {
+        ngx_ssl_engine_qat_init,
+        ngx_ssl_engine_qat_send_ctrl,
+        ngx_ssl_engine_qat_register_handler,
+        ngx_ssl_engine_qat_release,
+        ngx_ssl_engine_qat_heuristic_poll
+    }
+};
+
+ngx_module_t  ngx_ssl_engine_qat_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_qat_module_ctx,      /* module context */
+    ngx_ssl_engine_qat_commands,         /* module directives */
+    NGX_SSL_ENGINE_MODULE,               /* module type */
+    NULL,                                /* init master */
+    NULL,                                /* init module */
+    ngx_ssl_engine_qat_process_init,     /* init process */
+    NULL,                                /* init thread */
+    NULL,                                /* exit thread */
+    ngx_ssl_engine_qat_process_exit,     /* exit process */
+    NULL,                                /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_int_t
+ngx_ssl_engine_qat_init(ngx_cycle_t *cycle)
+{
+    ngx_memset(&qat_instance_status, 0, sizeof(qat_instance_status));
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_qat_release(ngx_cycle_t *cycle)
+{
+    unsigned int i;
+    ngx_connection_t  *c;
+
+    ngx_ssl_engine_qat_conf_t *seqcf;
+
+    seqcf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_qat_module);
+    if(seqcf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    if(!seqcf->releasable || qat_instance_status.finished) {
+
+        return NGX_OK;
+    }
+
+    c = cycle->connections;
+
+    i = qat_instance_status.checkpoint;
+
+    for (; i < cycle->connection_n; i++) {
+        if (c[i].fd == -1) {
+            continue;
+        }
+
+        if ((c[i].ssl && !c[i].ssl->handshaked) ||
+            (!c[i].ssl && c[i].ssl_enabled)) {
+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
+                "connections in SSL handshake phase");
+            qat_instance_status.checkpoint = i;
+            qat_instance_status.busy = 1;
+            break;
+        }
+
+        qat_instance_status.busy = 0;
+
+    }
+
+    if(!qat_instance_status.busy) {
+        ENGINE *e = ENGINE_by_id((const char *) seqcf->engine_id.data);
+        ENGINE_GEN_INT_FUNC_PTR qat_finish = ENGINE_get_finish_function(e);
+
+        if(0 == *num_asym_requests_in_flight &&
+           0 == *num_kdf_requests_in_flight &&
+           0 == *num_cipher_requests_in_flight &&
+           0 == *num_asym_mb_items_in_queue &&
+           0 == *num_kdf_mb_items_in_queue &&
+           0 == *num_sym_mb_items_in_queue &&
+           1 == qat_finish(e)) {
+            qat_instance_status.finished = 1;
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0,
+                                 "QAT engine finished");
+        } else {
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0,
+                                 "QAT engine finished error");
+        }
+
+        ENGINE_free(e);
+    }
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_ssl_engine_qat_send_ctrl(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_qat_conf_t *seqcf;
+    ngx_ssl_engine_conf_t *secf;
+
+    ENGINE     *e;
+    ngx_str_t  *value;
+    ngx_uint_t  i;
+
+    seqcf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_qat_module);
+    if(seqcf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    e = ENGINE_by_id((const char *) seqcf->engine_id.data);
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%s\") failed",  seqcf->engine_id.data);
+        return NGX_ERROR;
+    }
+
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "async") == 0) {
+        /* Need to be consistent with the directive ssl_async */
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_EVENT_DRIVEN_POLLING_MODE", 0, NULL,
+            NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                            "QAT Engine failed: "
+                            "ENABLE_EVENT_DRIVEN_POLLING_MODE");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+
+    /* check the validity of possible polling mode switch for nginx reload */
+
+    if (qat_engine_enable_internal_polling
+        && qat_engine_init_polling_mode == INLINE_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from inline to internal polling is invalid, "
+                      "and still use inline polling");
+
+        qat_engine_enable_internal_polling = 0;
+        qat_engine_enable_inline_polling = 1;
+    }
+
+    if (qat_engine_enable_internal_polling
+        && qat_engine_init_polling_mode == EXTERNAL_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from external to internal polling is invalid, "
+                      "and still use external polling");
+
+        qat_engine_enable_internal_polling = 0;
+        qat_engine_enable_external_polling = 1;
+        qat_engine_external_poll_interval = EXTERNAL_POLL_DEFAULT_INTERVAL;
+    }
+
+    if (qat_engine_enable_internal_polling
+        && qat_engine_init_polling_mode == HEURISTIC_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from heuristic to internal polling is invalid, "
+                      "and still use heuristic polling");
+
+        qat_engine_enable_internal_polling = 0;
+        qat_engine_enable_heuristic_polling = 1;
+    }
+
+    /* check the offloaded algorithms in the inline polling mode */
+
+    secf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if(secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+
+    if (qat_engine_enable_inline_polling) {
+        if (secf->default_algorithms != NGX_CONF_UNSET_PTR) {
+            value = secf->default_algorithms->elts;
+            for (i = 0; i < secf->default_algorithms->nelts; i++) {
+                if (ngx_strcmp(value[i].data, "RSA") != 0) {
+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                                  "Only RSA can be offloaded to QAT "
+                                  "in the inline polling mode");
+                    return NGX_ERROR;
+                }
+            }
+        } else {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "Only RSA can be offloaded to QAT "
+                          "in the inline polling mode");
+            return NGX_ERROR;
+        }
+    }
+
+    if (qat_engine_enable_inline_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_INLINE_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "QAT Engine failed: ENABLE_INLINE_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (seqcf->enable_sw_fallback
+        && seqcf->enable_sw_fallback != NGX_CONF_UNSET) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_SW_FALLBACK", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "QAT Engine failed: ENABLE_SW_FALLBACK");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (qat_engine_enable_internal_polling
+        && seqcf->internal_poll_interval != NGX_CONF_UNSET) {
+        if (!ENGINE_ctrl_cmd(e, "SET_INTERNAL_POLL_INTERVAL",
+            (long) seqcf->internal_poll_interval, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "QAT Engine failed: SET_INTERNAL_POLL_INTERVAL");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (qat_engine_enable_external_polling || qat_engine_enable_heuristic_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_EXTERNAL_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "QAT Engine failed: ENABLE_EXTERNAL_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (qat_engine_enable_external_polling || qat_engine_enable_heuristic_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_HEURISTIC_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "QAT Engine failed: ENABLE_HEURISTIC_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (qat_engine_enable_external_polling || qat_engine_enable_heuristic_polling) {
+        if(seqcf->enable_sw_fallback
+            && seqcf->enable_sw_fallback != NGX_CONF_UNSET) {
+            qat_engine_enable_heartbeat_polling = 1;
+        }
+    }
+
+    if (seqcf->small_pkt_offload_threshold != NGX_CONF_UNSET_PTR) {
+        value = seqcf->small_pkt_offload_threshold->elts;
+        for (i = 0; i < seqcf->small_pkt_offload_threshold->nelts; i++) {
+            if (!ENGINE_ctrl_cmd(e, "SET_CRYPTO_SMALL_PACKET_OFFLOAD_THRESHOLD",
+                0, value[i].data, NULL, 0)) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "QAT Engine failed: "
+                              "SET_CRYPTO_SMALL_PACKET_OFFLOAD_THRESHOLD");
+                ENGINE_free(e);
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    /* ssl engine global variable set */
+    if (qat_engine_enable_heuristic_polling) {
+        ngx_ssl_engine_enable_heuristic_polling = 1;
+    }
+
+    /* record old polling mode to prevent invalid mode switch */
+
+    if (qat_engine_enable_inline_polling) {
+        qat_engine_init_polling_mode = INLINE_POLL;
+
+    } else if (qat_engine_enable_internal_polling) {
+        qat_engine_init_polling_mode = INTERNAL_POLL;
+
+    } else if (qat_engine_enable_external_polling) {
+        qat_engine_init_polling_mode = EXTERNAL_POLL;
+
+    } else if (qat_engine_enable_heuristic_polling) {
+        qat_engine_init_polling_mode = HEURISTIC_POLL;
+    }
+
+    ENGINE_free(e);
+
+    return NGX_OK;
+}
+
+static inline void
+qat_engine_heartbeat_poll(ngx_log_t *log) {
+    int poll_status = 0;
+
+    if(qat_instance_status.finished) {
+        return;
+    }
+
+    if (!ENGINE_ctrl_cmd(qat_engine, "HEARTBEAT_POLL",  0, &poll_status, NULL, 0)) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0, "QAT Engine failed: HEARTBEAT_POLL");
+    }
+}
+
+static void
+qat_engine_heartbeat_poll_handler(ngx_event_t *ev)
+{
+    qat_engine_heartbeat_poll(ev->log);
+
+    if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+        !ngx_exiting) {
+        ngx_add_timer(ev, HEARTBEAT_POLL_TIMEOUT);
+    }
+}
+
+static inline void
+qat_engine_poll(ngx_log_t *log) {
+    int poll_status = 0;
+
+    if (!ENGINE_ctrl_cmd(qat_engine, "POLL", 0, &poll_status, NULL, 0)) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0, "QAT Engine failed: POLL");
+    }
+}
+
+
+static void
+qat_engine_external_poll_handler(ngx_event_t *ev)
+{
+    if(qat_instance_status.finished) {
+        return;
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        qat_engine_poll(ev->log);
+    }
+
+    if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+        !ngx_exiting) {
+        ngx_add_timer(ev, qat_engine_external_poll_interval);
+    }
+}
+
+
+static void
+qat_engine_external_poll_init(ngx_log_t* log)
+{
+    memset(&qat_engine_external_poll_event, 0, sizeof(ngx_event_t));
+
+    dumb.fd = (ngx_socket_t) -1;
+    qat_engine_external_poll_event.data = &dumb;
+
+    qat_engine_external_poll_event.handler = qat_engine_external_poll_handler;
+    qat_engine_external_poll_event.log = log;
+    qat_engine_external_poll_event.cancelable = 0;
+
+    ngx_add_timer(&qat_engine_external_poll_event, 100);
+    qat_engine_external_poll_event.timer_set = 1;
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, log, 0, "Adding initial polling timer");
+}
+
+static void
+qat_engine_heuristic_poll_handler(ngx_event_t *ev)
+{
+    if(qat_instance_status.finished) {
+        return;
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        if (num_heuristic_poll == 0) {
+            qat_engine_poll(ev->log);
+        }
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+            !ngx_exiting) {
+            num_heuristic_poll = 0;
+            ngx_add_timer(ev, HEURISTIC_POLL_DEFAULT_INTERVAL);
+        }
+    }
+}
+
+static void
+qat_engine_heuristic_poll_init(ngx_log_t* log)
+{
+    memset(&qat_engine_heuristic_poll_event, 0, sizeof(ngx_event_t));
+
+    dumb.fd = (ngx_socket_t) -1;
+    qat_engine_heuristic_poll_event.data = &dumb;
+
+    qat_engine_heuristic_poll_event.handler = qat_engine_heuristic_poll_handler;
+    qat_engine_heuristic_poll_event.log = log;
+    qat_engine_heuristic_poll_event.cancelable = 0;
+}
+
+static void
+qat_engine_heartbeat_poll_init(ngx_log_t* log)
+{
+    memset(&qat_engine_heartbeat_poll_event, 0, sizeof(ngx_event_t));
+    dumb.fd = (ngx_socket_t) -1;
+    qat_engine_heartbeat_poll_event.data = &dumb;
+    qat_engine_heartbeat_poll_event.handler = qat_engine_heartbeat_poll_handler;
+    qat_engine_heartbeat_poll_event.log = log;
+    qat_engine_heartbeat_poll_event.cancelable = 0;
+    ngx_add_timer(&qat_engine_heartbeat_poll_event, HEARTBEAT_POLL_TIMEOUT);
+    qat_engine_heartbeat_poll_event.timer_set = 1;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_qat_register_handler(ngx_cycle_t *cycle)
+{
+    if (qat_engine_enable_external_polling) {
+        qat_engine_external_poll_init(cycle->log);
+    }
+
+    if (qat_engine_enable_heuristic_polling) {
+        qat_engine_heuristic_poll_init(cycle->log);
+    }
+
+    if (qat_engine_enable_heartbeat_polling) {
+        qat_engine_heartbeat_poll_init(cycle->log);
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_qat_heuristic_poll(ngx_log_t *log) {
+    int polled_flag = 0;
+    int threshold;
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight +  *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue <= 0)
+        return;
+
+    /* one-time try to retrieve QAT responses */
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight +  *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue
+        >= (int) *ngx_ssl_active) {
+        qat_engine_poll(log);
+        num_heuristic_poll ++;
+        polled_flag = 1;
+    }
+
+    if (!polled_flag) {
+        if (*num_asym_requests_in_flight > 0)
+            threshold = qat_engine_heuristic_poll_asym_threshold;
+        else if (*num_asym_mb_items_in_queue > 0)
+            threshold = qat_engine_heuristic_poll_asym_multibuff_threshold;
+        else if (*num_sym_mb_items_in_queue > 0)
+            threshold = qat_engine_heuristic_poll_sym_multibuff_threshold;
+        else
+            threshold = qat_engine_heuristic_poll_sym_threshold;
+
+        if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+            + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+            + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue
+            >= threshold) {
+            qat_engine_poll(log);
+            num_heuristic_poll ++;
+        }
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight+ *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0
+        && !qat_engine_heuristic_poll_event.timer_set) {
+        num_heuristic_poll = 0;
+        ngx_add_timer(&qat_engine_heuristic_poll_event,
+                      HEURISTIC_POLL_DEFAULT_INTERVAL);
+    }
+}
+
+
+static char *
+ngx_ssl_engine_qat_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    ngx_conf_t      pcf;
+
+    pcf = *cf;
+    cf->cmd_type = NGX_SSL_ENGINE_SUB_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_ssl_engine_qat_set_threshold(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t          *value, *s;
+    ngx_array_t       **a;
+    ngx_uint_t          i;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NGX_CONF_UNSET_PTR) {
+        *a = ngx_array_create(cf->pool, cf->args->nelts - 1, sizeof(ngx_str_t));
+        if (*a == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+        s = ngx_array_push(*a);
+        if (s == NULL) {
+            return NGX_CONF_ERROR;
+        }
+        *s = value[i];
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_qat_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_qat_conf_t  *seqcf;
+
+    seqcf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_qat_conf_t));
+    if (seqcf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     seqcf->offload_mode = NULL
+     *     seqcf->notify_mode = NULL
+     *     seqcf->poll_mode = NULL
+     */
+
+    qat_engine_enable_inline_polling = 0;
+    qat_engine_enable_internal_polling = 0;
+    qat_engine_enable_external_polling = 0;
+    qat_engine_enable_heuristic_polling = 0;
+
+    seqcf->releasable = NGX_CONF_UNSET;
+    seqcf->enable_sw_fallback = NGX_CONF_UNSET;
+    seqcf->external_poll_interval = NGX_CONF_UNSET;
+    seqcf->internal_poll_interval = NGX_CONF_UNSET;
+
+    seqcf->heuristic_poll_asym_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_sym_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_asym_multibuff_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_sym_multibuff_threshold = NGX_CONF_UNSET;
+
+    seqcf->small_pkt_offload_threshold = NGX_CONF_UNSET_PTR;
+
+    return seqcf;
+}
+
+
+static char *
+ngx_ssl_engine_qat_releasable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t  *value;
+    ngx_uint_t  i;
+    char  *rv;
+    ngx_ssl_engine_conf_t *secf;
+    ngx_ssl_engine_qat_conf_t *seqcf = conf;
+
+    secf = ngx_engine_cycle_get_conf(cf->cycle, ngx_ssl_engine_core_module);
+    if(secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_CONF_ERROR;
+    }
+
+
+    if (seqcf->poll_mode.data == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                      "Please specify polling mode before"
+                      "qat_shutting_down_release is set");
+        return NGX_CONF_ERROR;
+    }
+
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    if (seqcf->releasable) {
+        /* Currently qat release while worker shutting down feature
+         * is unavailable when CIPHERS is offloaded to QAT.
+         * Logic in below block will prevent the release if CIPHERS
+         * is offloaded to QAT.
+         */
+        if (secf->default_algorithms == NGX_CONF_UNSET_PTR) {
+            ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                          "QAT is unreleasable during worker shutting down due "
+                          "to CIPHERS is offloaded");
+            seqcf->releasable = 0;
+
+        } else {
+            value = secf->default_algorithms->elts;
+            for (i = 0; i < secf->default_algorithms->nelts; i++) {
+                if (ngx_strstr(value[i].data, "ALL") != NULL ||
+                    ngx_strstr(value[i].data, "CIPHERS") != NULL) {
+                    ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                                  "QAT is unreleasable during worker shutting "
+                                  "down due to CIPHERS is offloaded");
+                    seqcf->releasable = 0;
+                }
+            }
+        }
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "external") != 0 &&
+            ngx_strcmp(seqcf->poll_mode.data, "heuristic") != 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                          "QAT is releasable only external or heuristic polling "
+                          "mode is set");
+            seqcf->releasable = 0;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_ssl_engine_qat_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_ssl_engine_qat_conf_t *seqcf = conf;
+    ngx_ssl_engine_conf_t * corecf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if(corecf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_CONF_ERROR;
+    }
+
+
+    if (0 != corecf->ssl_engine_id.len) {
+        ngx_conf_init_str_value(seqcf->engine_id, corecf->ssl_engine_id.data);
+    } else {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0, "No engine id found.");
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_init_str_value(seqcf->offload_mode, "async");
+    ngx_conf_init_str_value(seqcf->notify_mode, "poll");
+    ngx_conf_init_str_value(seqcf->poll_mode, "internal");
+
+    ngx_conf_init_value(seqcf->releasable, 0);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_asym_threshold,
+                        HEURISTIC_POLL_ASYM_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_sym_threshold,
+                        HEURISTIC_POLL_SYM_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_asym_multibuff_threshold,
+                        HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_sym_multibuff_threshold,
+                        HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD);
+
+    /* check the validity of the conf vaules */
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "sync") != 0
+        && ngx_strcmp(seqcf->offload_mode.data, "async") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for qat_offload_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "event") != 0
+        && ngx_strcmp(seqcf->notify_mode.data, "poll") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for qat_notify_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_strcmp(seqcf->poll_mode.data, "inline") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "internal") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "external") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "heuristic") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for qat_poll_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    /* check the validity of the engine ctrl combination */
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "sync") == 0) {
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"sync + event + inline\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "external") == 0
+            || ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"sync + external/heuristic\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+    } else {
+        /* async mode */
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + inline\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "external") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + event + external\" "
+                          "is currently not supported");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + event + heuristic\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (seqcf->external_poll_interval > 1000
+        || seqcf->external_poll_interval == 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid external poll interval");
+        return NGX_CONF_ERROR;
+    }
+
+    if (seqcf->internal_poll_interval > 10000000
+        || seqcf->internal_poll_interval == 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid internal poll interval");
+        return NGX_CONF_ERROR;
+    }
+
+    if (seqcf->heuristic_poll_asym_threshold > 512
+        || seqcf->heuristic_poll_sym_threshold > 512
+        || seqcf->heuristic_poll_asym_multibuff_threshold > 512
+        || seqcf->heuristic_poll_sym_multibuff_threshold > 512 ) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid heuristic poll threshold");
+        return NGX_CONF_ERROR;
+    }
+
+    /* global variable set */
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+        qat_engine_enable_inline_polling = 1;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "internal") == 0) {
+        qat_engine_enable_internal_polling = 1;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "external") == 0) {
+        qat_engine_enable_external_polling = 1;
+        ngx_conf_init_value(seqcf->external_poll_interval,
+                            EXTERNAL_POLL_DEFAULT_INTERVAL);
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+        qat_engine_enable_heuristic_polling = 1;
+    }
+
+    qat_engine_external_poll_interval = seqcf->external_poll_interval;
+
+    qat_engine_heuristic_poll_asym_threshold
+        = seqcf->heuristic_poll_asym_threshold;
+
+    qat_engine_heuristic_poll_sym_threshold
+        = seqcf->heuristic_poll_sym_threshold;
+
+    qat_engine_heuristic_poll_asym_multibuff_threshold
+        = seqcf->heuristic_poll_asym_multibuff_threshold;
+
+    qat_engine_heuristic_poll_sym_multibuff_threshold
+        = seqcf->heuristic_poll_sym_multibuff_threshold;
+
+    return NGX_CONF_OK;
+}
+
+
+static ngx_int_t
+qat_engine_share_info(ngx_log_t *log) {
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_ASYM_REQUESTS_IN_FLIGHT,
+        &num_asym_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_KDF_REQUESTS_IN_FLIGHT,
+        &num_kdf_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_CIPHER_PIPELINE_REQUESTS_IN_FLIGHT,
+        &num_cipher_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_ASYM_NUM_ITEMS_IN_QUEUE,
+        &num_asym_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_KDF_NUM_ITEMS_IN_QUEUE,
+        &num_kdf_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(qat_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_SYM_NUM_ITEMS_IN_QUEUE,
+        &num_sym_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "QAT Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_qat_process_init(ngx_cycle_t *cycle)
+{
+    num_heuristic_poll = 0;
+    num_asym_requests_in_flight = NULL;
+    num_kdf_requests_in_flight = NULL;
+    num_cipher_requests_in_flight = NULL;
+    num_asym_mb_items_in_queue = NULL;
+    num_kdf_mb_items_in_queue  = NULL;
+    num_sym_mb_items_in_queue = NULL;
+
+
+    ngx_ssl_engine_qat_conf_t *conf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_qat_module);
+    if (conf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    if (0 == (const char *) conf->engine_id.len) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "engine id not found");
+        return NGX_ERROR;
+    }
+
+    qat_engine = ENGINE_by_id((const char *) conf->engine_id.data);
+    if (qat_engine == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%s\") failed", conf->engine_id.data);
+        return NGX_ERROR;
+    }
+
+    if (qat_engine_share_info(cycle->log) != NGX_OK) {
+        ENGINE_free(qat_engine);
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_qat_process_exit(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_qat_conf_t *conf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_qat_module);
+    if (conf == NULL) {
+        return;
+    }
+
+    if (qat_engine) {
+        ENGINE_finish(qat_engine);
+        ENGINE_free(qat_engine);
+    }
+
+    qat_engine = NULL;
+
+    ENGINE_cleanup();
+}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qat_module/README ../asynch_mode_nginx/modules/nginx_qat_module/README
--- nginx-release-1.20.1/modules/nginx_qat_module/README	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qat_module/README	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,160 @@
+# Copyright (C) Intel, Inc.
+
+This module is developed of QAT engine in Nginx engine framework.
+
+
+Installation
+
+1. Add below configuration line into the config.example
+    --add-dynamic-module=modules/nginx_qat_module/
+2. Build Nginx with the addon modules
+    $ ./config.example
+    $ make && make install
+
+
+Configuration
+
+1. Add dynamic loading configuration in nginx.conf
+    $ load_module modules/ngx_ssl_engine_qat_module.so;
+
+2. Using ssl_engine block to configure QAT engine
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms ALL;
+        qat_engine {
+            #qat_offload_mode async;
+            #qat_notify_mode poll;
+
+            #qat_poll_mode internal;
+            #qat_internal_poll_interval 10000;
+
+            #qat_poll_mode external;
+            #qat_external_poll_interval 1;
+
+            qat_poll_mode heuristic;
+        }
+    }
+
+
+Directives
+
+    Syntax:     qat_sw_fallback on | off;
+    Default:    off
+    Dependency: This feature only supports AES128-SHA, DHE-DSS-AES256-SHA256,
+                ECDHE-ECDSA-AES128-SHA256, ECDHE-RSA-AES128-SHA for TLS1.2.
+    Description:
+                If QAT enabled software fallback mode, the qat engine would
+                switch to software mode instead of stays in hardware while
+                malfunction.
+
+    Syntax:     qat_offload_mode async | sync;
+    Default:    async
+    Dependency: Consistent with the use of "ssl_asynch" directive
+    Description:
+                Synchronous or Asynchronous mode
+
+    Syntax:     qat_notify_mode event | poll;
+    Default:    poll
+    Dependency: N/A
+    Description:
+                QAT engine uses event driven polling feature or not
+
+    Syntax:     qat_poll_mode inline | internal | external | heuristic;
+    Default:    internal
+    Dependency: N/A
+    Description:
+                Different kinds of polling mode to check for messages from the
+                hardware accelerator
+                * inline: a busy loop is used, currently only available in the
+                synchronous RSA computation
+                * internal: a internal polling thread is created by QAT engine
+                * external: a timer-based polling is employed in each Nginx
+                worker process
+                * heuristic: an improvement of the external polling mode,
+                leveraging the application knowledge to intelligently determine
+                the proper polling moment
+
+    Syntax:     qat_shutting_down_release on | off;
+    Default:    off
+    Dependency: Work with offloading all supported algorithms except CIPHERS
+                qat_poll_mode must be set before this directive and only external
+                polling and heuristic polling mode are acceptable
+    Description:
+                QAT instance will be released when worker is in shutting down
+                state if this directive is set to 'on'. This directive is designed
+                for the keep-alive connection who is completed SSL handshake and
+                waiting for more HTTP commands. To support more flexiable 'reload'
+                operation, QAT instance is released from such kind of connection.
+                Currently this feature is not supported when CIPHERS are offloaded
+                to QAT.
+
+    Syntax:     qat_internal_poll_interval time;
+    Default:    10000
+    Dependency: Valid if (qat_poll_mode=internal)
+    Description:
+                Internal polling time interval (ns)
+                Valid value: 1 ~ 10000000
+
+    Syntax:     qat_external_poll_interval time;
+    Default:    1
+    Dependency: Valid if (qat_poll_mode=external)
+    Description:
+                External polling time interval (ms)
+                Valid value: 1 ~ 1000
+
+    Syntax:     qat_heuristic_poll_asym_threshold num;
+    Default:    48
+    Dependency: Valid if (qat_poll_mode=heuristic)
+    Description:
+                Threshold of the number of in-flight requests to trigger a
+                polling operation when there are in-flight asymmetric
+                crypto requests
+                Valid value: 1 ~ 512
+
+
+    Syntax:     qat_heuristic_poll_sym_threshold num;
+    Default:    24
+    Dependency: Valid if (qat_poll_mode=heuristic)
+    Description:
+                Threshold of the number of in-flight requests to trigger a
+                polling operation when there is no in-flight asymmetric
+                crypto request
+                Valid value: 1 ~ 512
+
+    Syntax:     qat_small_pkt_offload_threshold string ...;
+    Default:    2048
+    Dependency: Valid if cipher is offloaded
+    Description:
+                The input is the string of cipher algorithm name and
+                threshold value. Please refer to the README of QAT engine.
+                Example input:
+                    2048
+                    AES-128-CBC-HMAC-SHA1:4096
+                    AES-128-CBC-HMAC-SHA1:4096 AES-256-CBC-HMAC-SHA1:8192
+
+
+Note
+
+    1. Not all the combinations of offload mode, notify mode and poll mode are
+    valid. Please refer to the following tables to check the validity.
+
+    +-------+--------+----------+----------+-----------+
+    | sync  | inline | internal | external | heuristic |
+    +-------+--------+----------+----------+-----------+
+    | event |    N   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+    | poll  |    Y   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+
+    +-------+--------+----------+----------+-----------+
+    | async | inline | internal | external | heuristic |
+    +-------+--------+----------+----------+-----------+
+    | event |    N   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+    | poll  |    N   |     Y    |     Y    |     Y     |
+    +-------+--------+----------+----------+-----------+
+
+
+    2. Changing polling mode will not be effective until Nginx restart. It is
+    not possible to change the polling mode via soft restart, such as
+    'nginx -s reload' or 'kill -HUP [master-pid]'
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qatzip_module/config ../asynch_mode_nginx/modules/nginx_qatzip_module/config
--- nginx-release-1.20.1/modules/nginx_qatzip_module/config	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qatzip_module/config	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,44 @@
+# Copyright (C) Intel, Inc.
+
+ngx_addon_name=ngx_http_qatzip_filter_module
+
+if test -n "$ngx_module_link"; then
+    ngx_module_type=HTTP
+    ngx_module_name=ngx_http_qatzip_filter_module
+    ngx_module_srcs="$ngx_addon_dir/ngx_http_qatzip_filter_module.c"
+
+ngx_module_order="ngx_http_static_module \
+                  ngx_http_gzip_static_module \
+                  ngx_http_dav_module \
+                  ngx_http_autoindex_module \
+                  ngx_http_index_module \
+                  ngx_http_random_index_module \
+                  ngx_http_access_module \
+                  ngx_http_realip_module \
+                  ngx_http_write_filter_module \
+                  ngx_http_header_filter_module \
+                  ngx_http_chunked_filter_module \
+                  ngx_http_v2_filter_module \
+                  ngx_http_range_header_filter_module \
+                  ngx_http_qatzip_filter_module \
+                  ngx_http_postpone_filter_module \
+                  ngx_http_ssi_filter_module \
+                  ngx_http_charset_filter_module \
+                  ngx_http_xslt_filter_module \
+                  ngx_http_image_filter_module \
+                  ngx_http_sub_filter_module \
+                  ngx_http_addition_filter_module \
+                  ngx_http_gunzip_filter_module \
+                  ngx_http_userid_filter_module \
+                  ngx_http_headers_filter_module \
+                  ngx_http_copy_filter_module \
+                  ngx_http_range_body_filter_module \
+                  ngx_http_not_modified_filter_module \
+                  ngx_http_slice_filter_module"
+
+
+    . auto/module
+else
+    HTTP_MODULES="$HTTP_MODULES ngx_http_qatzip_filter_module"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_qatzip_filter_module.c"
+fi
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qatzip_module/ngx_http_qatzip_filter_module.c ../asynch_mode_nginx/modules/nginx_qatzip_module/ngx_http_qatzip_filter_module.c
--- nginx-release-1.20.1/modules/nginx_qatzip_module/ngx_http_qatzip_filter_module.c	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qatzip_module/ngx_http_qatzip_filter_module.c	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,1087 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <qatzip.h>
+#include <zlib.h>
+
+#define DEFAULT_STRM_BUFF_SZ     (256 * 1024)
+
+typedef struct {
+    ngx_flag_t           enable;
+    ngx_flag_t           sw_fallback_enable;
+    ngx_str_t            qatzip_sw;
+    ngx_flag_t           no_buffer;
+
+    ngx_hash_t           types;
+
+    ngx_bufs_t           bufs;
+
+    size_t               postpone_qatzipping;
+    ngx_int_t            level;
+    size_t               strm_buff_sz;
+    size_t               chunk_sz;
+    size_t               input_sz_thrshold;
+    size_t               wait_cnt_thrshold;
+    ssize_t              min_length;
+
+    ngx_array_t         *types_keys;
+} ngx_http_qatzip_conf_t;
+
+
+typedef struct {
+    ngx_chain_t         *in;
+    ngx_chain_t         *free;
+    ngx_chain_t         *busy;
+    ngx_chain_t         *out;
+    ngx_chain_t        **last_out;
+
+    ngx_chain_t         *copied;
+    ngx_chain_t         *copy_buf;
+
+    ngx_buf_t           *in_buf;
+    ngx_buf_t           *out_buf;
+    ngx_int_t            bufs;
+
+    unsigned             inited:1;
+    unsigned             last:1;
+    unsigned             redo:1;
+    unsigned             done:1;
+    unsigned             nomem:1;
+    unsigned             gzheader:1;
+    unsigned             buffering:1;
+    unsigned             avail_in:1;
+    unsigned             avail_out:1;
+
+    size_t               zin;
+    size_t               zout;
+
+    uint32_t             crc32;
+    QzStream_T           qzstream;
+    QzSession_T          qzsession;
+    ngx_http_request_t  *request;
+} ngx_http_qatzip_ctx_t;
+
+
+#if (NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
+
+struct gztrailer {
+    uint32_t  crc32;
+    uint32_t  zlen;
+};
+
+#else /* NGX_HAVE_BIG_ENDIAN || !NGX_HAVE_NONALIGNED */
+
+struct gztrailer {
+    u_char  crc32[4];
+    u_char  zlen[4];
+};
+
+#endif
+
+QzSession_T * g_last_session = NULL;
+static void ngx_http_qatzip_call_qzclose(ngx_cycle_t *cycle)
+{
+    qzClose(g_last_session);
+}
+
+
+
+static ngx_int_t ngx_http_qatzip_filter_buffer(ngx_http_qatzip_ctx_t *ctx,
+    ngx_chain_t *in);
+static ngx_int_t ngx_http_qatzip_filter_stream_init(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+static ngx_int_t ngx_http_qatzip_filter_gzheader(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+static ngx_int_t ngx_http_qatzip_filter_add_data(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+static ngx_int_t ngx_http_qatzip_filter_get_buf(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+static ngx_int_t ngx_http_qatzip_filter_compress(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+static ngx_int_t ngx_http_qatzip_filter_end_stream(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+
+static void ngx_http_qatzip_filter_free_copy_buf(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx);
+
+static ngx_int_t ngx_http_qatzip_add_variables(ngx_conf_t *cf);
+static ngx_int_t ngx_http_qatzip_ratio_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+
+static ngx_int_t ngx_http_qatzip_filter_init(ngx_conf_t *cf);
+static void *ngx_http_qatzip_create_conf(ngx_conf_t *cf);
+static char *ngx_http_qatzip_merge_conf(ngx_conf_t *cf,
+    void *parent, void *child);
+
+
+static ngx_conf_num_bounds_t  ngx_http_qatzip_comp_level_bounds = {
+    ngx_conf_check_num_bounds, 1, 9
+};
+static ngx_conf_num_bounds_t  ngx_http_qatzip_chunk_size_bounds = {
+    ngx_conf_check_num_bounds, 16*1024, 128*1024
+};
+static ngx_conf_num_bounds_t  ngx_http_qatzip_stream_size_bounds = {
+    ngx_conf_check_num_bounds, QZ_STRM_BUFF_MIN_SZ, QZ_STRM_BUFF_MAX_SZ
+};
+static ngx_conf_num_bounds_t  ngx_http_qatzip_sw_threshold_size_bounds = {
+    ngx_conf_check_num_bounds, QZ_COMP_THRESHOLD_MINIMUM, QZ_HW_BUFF_MAX_SZ
+};
+
+static ngx_command_t  ngx_http_qatzip_filter_commands[] = {
+
+    { ngx_string("qatzip_sw"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, qatzip_sw),
+      NULL },
+
+    { ngx_string("qatzip_buffers"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,
+      ngx_conf_set_bufs_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, bufs),
+      NULL },
+
+    { ngx_string("qatzip_types"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_types_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, types_keys),
+      &ngx_http_html_default_types[0] },
+
+    { ngx_string("qatzip_comp_level"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, level),
+      &ngx_http_qatzip_comp_level_bounds },
+
+    { ngx_string("qatzip_stream_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, strm_buff_sz),
+      &ngx_http_qatzip_stream_size_bounds },
+
+    { ngx_string("qatzip_chunk_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, chunk_sz),
+      &ngx_http_qatzip_chunk_size_bounds },
+
+    { ngx_string("qatzip_sw_threshold"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, input_sz_thrshold),
+      &ngx_http_qatzip_sw_threshold_size_bounds },
+
+    { ngx_string("qatzip_wait_cnt_threshold"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, wait_cnt_thrshold),
+      NULL },
+
+    { ngx_string("postpone_qatzipping"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, postpone_qatzipping),
+      NULL },
+
+    { ngx_string("qatzip_no_buffer"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, no_buffer),
+      NULL },
+
+    { ngx_string("qatzip_min_length"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_qatzip_conf_t, min_length),
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_http_module_t  ngx_http_qatzip_filter_module_ctx = {
+    ngx_http_qatzip_add_variables,           /* preconfiguration */
+    ngx_http_qatzip_filter_init,             /* postconfiguration */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    NULL,                                  /* create server configuration */
+    NULL,                                  /* merge server configuration */
+
+    ngx_http_qatzip_create_conf,             /* create location configuration */
+    ngx_http_qatzip_merge_conf               /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_http_qatzip_filter_module = {
+    NGX_MODULE_V1,
+    &ngx_http_qatzip_filter_module_ctx,      /* module context */
+    ngx_http_qatzip_filter_commands,         /* module directives */
+    NGX_HTTP_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    ngx_http_qatzip_call_qzclose,          /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t  ngx_http_qatzip_ratio = ngx_string("qatzip_ratio");
+
+static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
+static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;
+
+
+static ngx_int_t
+ngx_http_qatzip_header_filter(ngx_http_request_t *r)
+{
+    ngx_table_elt_t       *h;
+    ngx_http_qatzip_ctx_t   *ctx;
+    ngx_http_qatzip_conf_t  *conf;
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_qatzip_filter_module);
+
+    if (!conf->enable
+        || (r->headers_out.status != NGX_HTTP_OK
+            && r->headers_out.status != NGX_HTTP_FORBIDDEN
+            && r->headers_out.status != NGX_HTTP_NOT_FOUND)
+        || (r->headers_out.content_encoding
+            && r->headers_out.content_encoding->value.len)
+        || (r->headers_out.content_length_n != -1
+            && r->headers_out.content_length_n < conf->min_length)
+        || ngx_http_test_content_type(r, &conf->types) == NULL
+        || r->header_only)
+    {
+        return ngx_http_next_header_filter(r);
+    }
+
+    r->gzip_vary = 1;
+
+#if (NGX_HTTP_DEGRADATION)
+    {
+    ngx_http_core_loc_conf_t  *clcf;
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (clcf->gzip_disable_degradation && ngx_http_degraded(r)) {
+        return ngx_http_next_header_filter(r);
+    }
+    }
+#endif
+
+    if (!r->gzip_tested) {
+        if (ngx_http_gzip_ok(r) != NGX_OK) {
+            return ngx_http_next_header_filter(r);
+        }
+
+    } else if (!r->gzip_ok) {
+        return ngx_http_next_header_filter(r);
+    }
+
+    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_qatzip_ctx_t));
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_http_set_ctx(r, ctx, ngx_http_qatzip_filter_module);
+
+    ctx->request = r;
+    ctx->buffering = (conf->postpone_qatzipping != 0);
+
+    h = ngx_list_push(&r->headers_out.headers);
+    if (h == NULL) {
+        return NGX_ERROR;
+    }
+
+    h->hash = 1;
+    ngx_str_set(&h->key, "Content-Encoding");
+    ngx_str_set(&h->value, "gzip");
+    r->headers_out.content_encoding = h;
+
+    r->main_filter_need_in_memory = 1;
+
+    ngx_http_clear_content_length(r);
+    ngx_http_clear_accept_ranges(r);
+    ngx_http_weak_etag(r);
+
+    return ngx_http_next_header_filter(r);
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    int                   rc;
+    ngx_uint_t            flush;
+    ngx_chain_t          *cl;
+    ngx_http_qatzip_ctx_t  *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_qatzip_filter_module);
+
+    if (ctx == NULL || ctx->done || r->header_only) {
+        return ngx_http_next_body_filter(r, in);
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http qatzip filter");
+
+    if (ctx->buffering) {
+        if (in) {
+            switch (ngx_http_qatzip_filter_buffer(ctx, in)) {
+
+            case NGX_OK:
+                return NGX_OK;
+
+            case NGX_DONE:
+                in = NULL;
+                break;
+
+            default:  /* NGX_ERROR */
+                goto failed;
+            }
+
+        } else {
+            ctx->buffering = 0;
+        }
+    }
+
+    if (ngx_http_qatzip_filter_stream_init(r, ctx) != NGX_OK) {
+        goto failed;
+    }
+
+    if (in) {
+        if (ngx_chain_add_copy(r->pool, &ctx->in, in) != NGX_OK) {
+            goto failed;
+        }
+
+        r->connection->buffered |= NGX_HTTP_GZIP_BUFFERED;
+    }
+
+    if (ctx->nomem) {
+
+        /* flush busy buffers */
+
+        if (ngx_http_next_body_filter(r, NULL) == NGX_ERROR) {
+            goto failed;
+        }
+
+        cl = NULL;
+
+        ngx_chain_update_chains(r->pool, &ctx->free, &ctx->busy, &cl,
+                                (ngx_buf_tag_t) &ngx_http_qatzip_filter_module);
+        ctx->nomem = 0;
+        flush = 0;
+
+    } else {
+        flush = ctx->busy ? 1 : 0;
+    }
+
+    for ( ;; ) {
+
+        /* cycle while we can write to a client */
+
+        for ( ;; ) {
+
+            /* cycle while there is data to feed zlib and ... */
+
+            rc = ngx_http_qatzip_filter_add_data(r, ctx);
+
+            if (rc == NGX_DECLINED) {
+                break;
+            }
+
+            if (rc == NGX_AGAIN) {
+                continue;
+            }
+
+
+            /* ... there are buffers to write zlib output */
+
+            rc = ngx_http_qatzip_filter_get_buf(r, ctx);
+
+            if (rc == NGX_DECLINED) {
+                break;
+            }
+
+            if (rc == NGX_ERROR) {
+                goto failed;
+            }
+
+
+            rc = ngx_http_qatzip_filter_compress(r, ctx);
+
+            if (rc == NGX_OK) {
+                break;
+            }
+
+            if (rc == NGX_ERROR) {
+                goto failed;
+            }
+
+            /* rc == NGX_AGAIN */
+        }
+
+        if (ctx->out == NULL && !flush) {
+            ngx_http_qatzip_filter_free_copy_buf(r, ctx);
+
+            return ctx->busy ? NGX_AGAIN : NGX_OK;
+        }
+
+        if (!ctx->gzheader) {
+            if (ngx_http_qatzip_filter_gzheader(r, ctx) != NGX_OK) {
+                goto failed;
+            }
+        }
+
+        rc = ngx_http_next_body_filter(r, ctx->out);
+
+        if (rc == NGX_ERROR) {
+            goto failed;
+        }
+
+        ngx_http_qatzip_filter_free_copy_buf(r, ctx);
+
+        ngx_chain_update_chains(r->pool, &ctx->free, &ctx->busy, &ctx->out,
+                                (ngx_buf_tag_t) &ngx_http_qatzip_filter_module);
+        ctx->last_out = &ctx->out;
+
+        ctx->nomem = 0;
+        flush = 0;
+
+        if (ctx->done) {
+            goto done;
+        }
+    }
+
+    /* unreachable */
+
+failed:
+    ctx->done = 1;
+    ngx_http_qatzip_filter_free_copy_buf(r, ctx);
+    rc = NGX_ERROR;
+
+done:
+    qzEndStream(&ctx->qzsession, &ctx->qzstream);
+    if (ctx->inited) {
+        qzTeardownSession(&ctx->qzsession);
+        g_last_session = &ctx->qzsession;
+        ctx->inited = 0;
+    }
+
+    return rc;
+}
+
+static ngx_int_t
+ngx_http_qatzip_filter_buffer(ngx_http_qatzip_ctx_t *ctx, ngx_chain_t *in)
+{
+    size_t                 size, buffered;
+    ngx_buf_t             *b, *buf;
+    ngx_chain_t           *cl, **ll;
+    ngx_http_request_t    *r;
+    ngx_http_qatzip_conf_t  *conf;
+
+    r = ctx->request;
+
+    r->connection->buffered |= NGX_HTTP_GZIP_BUFFERED;
+
+    buffered = 0;
+    ll = &ctx->in;
+
+    for (cl = ctx->in; cl; cl = cl->next) {
+        buffered += cl->buf->last - cl->buf->pos;
+        ll = &cl->next;
+    }
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_qatzip_filter_module);
+
+    while (in) {
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        b = in->buf;
+
+        size = b->last - b->pos;
+        buffered += size;
+
+        if (b->flush || b->last_buf || buffered > conf->postpone_qatzipping) {
+            ctx->buffering = 0;
+        }
+
+        if (ctx->buffering && size) {
+
+            buf = ngx_create_temp_buf(r->pool, size);
+            if (buf == NULL) {
+                return NGX_ERROR;
+            }
+
+            buf->last = ngx_cpymem(buf->pos, b->pos, size);
+            b->pos = b->last;
+
+            buf->last_buf = b->last_buf;
+            buf->tag = (ngx_buf_tag_t) &ngx_http_qatzip_filter_module;
+
+            cl->buf = buf;
+
+        } else {
+            cl->buf = b;
+        }
+
+        *ll = cl;
+        ll = &cl->next;
+        in = in->next;
+    }
+
+    *ll = NULL;
+
+    return ctx->buffering ? NGX_OK : NGX_DONE;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_stream_init(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx)
+{
+
+    int                     rc;
+    QzSessionParams_T       params;
+    ngx_http_qatzip_conf_t  *conf;
+
+    if (ctx->inited) {
+        return NGX_OK;
+    }
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_qatzip_filter_module);
+
+    if (QZ_OK != qzGetDefaults(&params)) {
+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                      "Fail to get defulat params.\n");
+        return NGX_ERROR;
+    }
+    params.hw_buff_sz = conf->chunk_sz;
+    params.strm_buff_sz = conf->strm_buff_sz;
+    params.input_sz_thrshold = conf->input_sz_thrshold;
+    params.wait_cnt_thrshold = conf->wait_cnt_thrshold;
+    params.data_fmt = QZ_DEFLATE_RAW;
+    params.sw_backup = conf->sw_fallback_enable;
+
+    rc = qzInit(&ctx->qzsession, params.sw_backup);
+    if (rc != QZ_OK &&
+        rc != QZ_DUPLICATE &&
+        rc != QZ_NO_HW) {
+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                      "Fail to init HW with ret: %d.\n", rc);
+        return NGX_ERROR;
+    }
+
+    rc = qzSetupSession(&ctx->qzsession, &params);
+    if (rc != QZ_OK &&
+        rc != QZ_NO_HW) {
+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                      "qzSetupSession for testing %s error, return: %d\n", __func__, rc);
+        return NGX_ERROR;
+    }
+
+    ctx->last_out = &ctx->out;
+    ctx->last = 0;
+    ctx->inited = 1;
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_gzheader(ngx_http_request_t *r, ngx_http_qatzip_ctx_t *ctx)
+{
+    ngx_buf_t      *b;
+    ngx_chain_t    *cl;
+    static u_char  gzheader[10] =
+                               { 0x1f, 0x8b, Z_DEFLATED, 0, 0, 0, 0, 0, 0, 3 };
+
+    b = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));
+    if (b == NULL) {
+        return NGX_ERROR;
+    }
+
+    b->memory = 1;
+    b->pos = gzheader;
+    b->last = b->pos + 10;
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    cl->buf = b;
+    cl->next = ctx->out;
+    ctx->out = cl;
+
+    ctx->gzheader = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_add_data(ngx_http_request_t *r, ngx_http_qatzip_ctx_t *ctx)
+{
+    if (ctx->avail_in || ctx->redo) {
+        return NGX_OK;
+    }
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "qatzip in: %p", ctx->in);
+
+    if (ctx->in == NULL) {
+        return NGX_DECLINED;
+    }
+
+    if (ctx->copy_buf) {
+
+        /*
+         * to avoid CPU cache trashing we do not free() just quit buf,
+         * but postpone free()ing after zlib compressing and data output
+         */
+
+        ctx->copy_buf->next = ctx->copied;
+        ctx->copied = ctx->copy_buf;
+        ctx->copy_buf = NULL;
+    }
+
+    ctx->in_buf = ctx->in->buf;
+
+    if (ctx->in_buf->tag == (ngx_buf_tag_t) &ngx_http_qatzip_filter_module) {
+        ctx->copy_buf = ctx->in;
+    }
+
+    ctx->in = ctx->in->next;
+
+    ctx->qzstream.in = ctx->in_buf->pos;
+    ctx->qzstream.in_sz = ctx->in_buf->last - ctx->in_buf->pos;
+    ctx->avail_in = 1;
+
+    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "qatzip in:%p in_sz:%ud ai:%ud",
+                   ctx->qzstream.in, ctx->qzstream.in_sz, ctx->avail_in);
+
+    ctx->last = (ctx->in_buf->last_buf)?1:0;
+
+    if (0 == ctx->qzstream.in_sz) {
+        return NGX_AGAIN;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_get_buf(ngx_http_request_t *r, ngx_http_qatzip_ctx_t *ctx)
+{
+    ngx_http_qatzip_conf_t  *conf;
+
+    if (ctx->avail_out) {
+        ctx->qzstream.out = ctx->out_buf->last;
+        return NGX_OK;
+    }
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_qatzip_filter_module);
+
+    if (ctx->free) {
+        ctx->out_buf = ctx->free->buf;
+        ctx->free = ctx->free->next;
+
+    } else if (ctx->bufs < conf->bufs.num) {
+
+        ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
+        if (ctx->out_buf == NULL) {
+            return NGX_ERROR;
+        }
+
+        ctx->out_buf->tag = (ngx_buf_tag_t) &ngx_http_qatzip_filter_module;
+        ctx->out_buf->recycled = 1;
+        ctx->bufs++;
+
+    } else {
+        ctx->nomem = 1;
+        return NGX_DECLINED;
+    }
+
+    ctx->qzstream.out = ctx->out_buf->last;
+    ctx->qzstream.out_sz = conf->bufs.size;
+    ctx->avail_out = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_compress(ngx_http_request_t *r, ngx_http_qatzip_ctx_t *ctx)
+{
+    int                    rc;
+    ngx_chain_t           *cl;
+    ngx_http_qatzip_conf_t  *conf;
+    unsigned int orig_in_sz, orig_out_sz;
+
+    ngx_log_debug6(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                 "qzCompressStream in: in:%p out:%p in_sz:%ud out_sz:%ud last:%d redo:%d",
+                 ctx->qzstream.in, ctx->qzstream.out,
+                 ctx->qzstream.in_sz, ctx->qzstream.out_sz,
+                 ctx->last, ctx->redo);
+
+    orig_in_sz = ctx->qzstream.in_sz;
+    orig_out_sz = ctx->qzstream.out_sz;
+
+    rc = qzCompressStream(&ctx->qzsession, &ctx->qzstream, ctx->last);
+
+    if (rc != QZ_OK) {
+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                      "qzCompressStream() failed: %d, %d", ctx->last, rc);
+        return NGX_ERROR;
+    }
+
+    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "qzCompressStream out: in:%p out:%p in_sz:%ud out_sz:%ud rc:%d",
+                   ctx->qzstream.in, ctx->qzstream.out,
+                   ctx->qzstream.in_sz, ctx->qzstream.out_sz,
+                   rc);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "qatzip in_buf:%p pos:%p",
+                   ctx->in_buf, ctx->in_buf->pos);
+
+    ctx->in_buf->pos += ctx->qzstream.in_sz;
+    ctx->out_buf->last += ctx->qzstream.out_sz;
+    ctx->avail_in = (ctx->qzstream.in_sz < orig_in_sz)?1:0;
+    ctx->avail_out = (ctx->qzstream.out_sz < orig_out_sz)?1:0;
+    ctx->zin += ctx->qzstream.in_sz;
+    ctx->zout += ctx->qzstream.out_sz;
+
+    if (ctx->avail_in) {
+        ctx->qzstream.in_sz = ctx->in_buf->last - ctx->in_buf->pos;
+    } else {
+        ctx->qzstream.in_sz = 0;
+    }
+    ctx->qzstream.in = ctx->in_buf->pos;
+
+    if (ctx->avail_out) {
+        ctx->qzstream.out_sz = orig_out_sz - ctx->qzstream.out_sz;
+    } else {
+        ctx->qzstream.out_sz = 0;
+    }
+    ctx->qzstream.out = ctx->out_buf->last;
+
+    if (0 == ctx->avail_out &&
+        ctx->qzstream.pending_out > 0) {
+        /*more data pending out */
+
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        cl->buf = ctx->out_buf;
+        cl->next = NULL;
+        *ctx->last_out = cl;
+        ctx->last_out = &cl->next;
+
+        ctx->redo = 1;
+
+        return NGX_AGAIN;
+    }
+
+    ctx->redo = 0;
+
+    if (1 == ctx->last && 0 == ctx->avail_in && 0 == ctx->qzstream.pending_in) {
+
+        if (ngx_http_qatzip_filter_end_stream(r, ctx) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        return NGX_OK;
+    }
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_qatzip_filter_module);
+
+    if (conf->no_buffer && ctx->in == NULL) {
+
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        cl->buf = ctx->out_buf;
+        cl->next = NULL;
+        *ctx->last_out = cl;
+        ctx->last_out = &cl->next;
+
+        return NGX_OK;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_end_stream(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx)
+{
+    ngx_buf_t         *b;
+    ngx_chain_t       *cl;
+    struct gztrailer  *trailer;
+
+    ctx->crc32 = ctx->qzstream.crc_32;
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "In function %s, ctx crc32 is 0x%X\n", __FUNCTION__, ctx->crc32);
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    cl->buf = ctx->out_buf;
+    cl->next = NULL;
+    *ctx->last_out = cl;
+    ctx->last_out = &cl->next;
+
+    b = ngx_create_temp_buf(r->pool, 8);
+    if (b == NULL) {
+        return NGX_ERROR;
+    }
+
+    b->last_buf = 1;
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    cl->buf = b;
+    cl->next = NULL;
+    *ctx->last_out = cl;
+    ctx->last_out = &cl->next;
+    trailer = (struct gztrailer *) b->pos;
+    b->last += 8;
+
+#if (NGX_HAVE_LITTLE_ENDIAN && NGX_HAVE_NONALIGNED)
+
+    trailer->crc32 = ctx->crc32;
+    trailer->zlen = ctx->zin;
+
+#else
+
+    trailer->crc32[0] = (u_char) (ctx->crc32 & 0xff);
+    trailer->crc32[1] = (u_char) ((ctx->crc32 >> 8) & 0xff);
+    trailer->crc32[2] = (u_char) ((ctx->crc32 >> 16) & 0xff);
+    trailer->crc32[3] = (u_char) ((ctx->crc32 >> 24) & 0xff);
+
+    trailer->zlen[0] = (u_char) (ctx->zin & 0xff);
+    trailer->zlen[1] = (u_char) ((ctx->zin >> 8) & 0xff);
+    trailer->zlen[2] = (u_char) ((ctx->zin >> 16) & 0xff);
+    trailer->zlen[3] = (u_char) ((ctx->zin >> 24) & 0xff);
+
+#endif
+
+    ctx->done = 1;
+
+    r->connection->buffered &= ~NGX_HTTP_GZIP_BUFFERED;
+
+    return NGX_OK;
+}
+
+static void
+ngx_http_qatzip_filter_free_copy_buf(ngx_http_request_t *r,
+    ngx_http_qatzip_ctx_t *ctx)
+{
+    ngx_chain_t  *cl;
+
+    for (cl = ctx->copied; cl; cl = cl->next) {
+        ngx_pfree(r->pool, cl->buf->start);
+    }
+
+    ctx->copied = NULL;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_add_variables(ngx_conf_t *cf)
+{
+    ngx_http_variable_t  *var;
+
+    var = ngx_http_add_variable(cf, &ngx_http_qatzip_ratio, NGX_HTTP_VAR_NOHASH);
+    if (var == NULL) {
+        return NGX_ERROR;
+    }
+
+    var->get_handler = ngx_http_qatzip_ratio_variable;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_ratio_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_uint_t            zint, zfrac;
+    ngx_http_qatzip_ctx_t  *ctx;
+
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_qatzip_filter_module);
+
+    if (ctx == NULL || ctx->zout == 0) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN + 3);
+    if (v->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    zint = (ngx_uint_t) (ctx->zin / ctx->zout);
+    zfrac = (ngx_uint_t) ((ctx->zin * 100 / ctx->zout) % 100);
+
+    if ((ctx->zin * 1000 / ctx->zout) % 10 > 4) {
+
+        /* the rounding, e.g., 2.125 to 2.13 */
+
+        zfrac++;
+
+        if (zfrac > 99) {
+            zint++;
+            zfrac = 0;
+        }
+    }
+
+    v->len = ngx_sprintf(v->data, "%ui.%02ui", zint, zfrac) - v->data;
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_http_qatzip_create_conf(ngx_conf_t *cf)
+{
+    ngx_http_qatzip_conf_t  *conf;
+
+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_qatzip_conf_t));
+    if (conf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     conf->bufs.num = 0;
+     *     conf->types = { NULL };
+     *     conf->types_keys = NULL;
+     */
+
+    conf->enable = NGX_CONF_UNSET;
+    conf->sw_fallback_enable = NGX_CONF_UNSET;
+    conf->no_buffer = NGX_CONF_UNSET;
+
+    conf->postpone_qatzipping = NGX_CONF_UNSET_SIZE;
+    conf->level = NGX_CONF_UNSET;
+    conf->strm_buff_sz = NGX_CONF_UNSET_SIZE;
+    conf->chunk_sz = NGX_CONF_UNSET_SIZE;
+    conf->input_sz_thrshold = NGX_CONF_UNSET_SIZE;
+    conf->wait_cnt_thrshold = NGX_CONF_UNSET_SIZE;
+    conf->min_length = NGX_CONF_UNSET;
+
+    return conf;
+}
+
+
+static char *
+ngx_http_qatzip_merge_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_qatzip_conf_t *prev = parent;
+    ngx_http_qatzip_conf_t *conf = child;
+
+    ngx_conf_merge_value(conf->enable, prev->enable, 0);
+    ngx_conf_merge_value(conf->sw_fallback_enable, prev->sw_fallback_enable, 1);
+    ngx_conf_merge_value(conf->no_buffer, prev->no_buffer, 0);
+
+    ngx_conf_merge_bufs_value(conf->bufs, prev->bufs,
+                              (128 * 1024) / ngx_pagesize, ngx_pagesize);
+
+    ngx_conf_merge_size_value(conf->postpone_qatzipping, prev->postpone_qatzipping,
+                              0);
+    ngx_conf_merge_value(conf->level, prev->level, 1);
+    ngx_conf_merge_size_value(conf->strm_buff_sz, prev->strm_buff_sz,
+                                DEFAULT_STRM_BUFF_SZ);
+    ngx_conf_merge_size_value(conf->chunk_sz, prev->chunk_sz,
+                                QZ_HW_BUFF_SZ);
+    ngx_conf_merge_size_value(conf->input_sz_thrshold, prev->input_sz_thrshold,
+                                QZ_COMP_THRESHOLD_DEFAULT);
+    ngx_conf_merge_size_value(conf->wait_cnt_thrshold, prev->wait_cnt_thrshold,
+                                QZ_COMP_THRESHOLD_DEFAULT);
+    ngx_conf_merge_value(conf->min_length, prev->min_length, 20);
+    ngx_conf_merge_str_value(conf->qatzip_sw, prev->qatzip_sw, "failover");
+
+    if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
+                             &prev->types_keys, &prev->types,
+                             ngx_http_html_default_types)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    if (0 == ngx_strcmp(conf->qatzip_sw.data, "only")) {
+        conf->enable = 0;
+        conf->sw_fallback_enable = 0;
+    } else if (0 == ngx_strcmp(conf->qatzip_sw.data, "failover")) {
+        conf->enable = 1;
+        conf->sw_fallback_enable = 1;
+    } else if (0 == ngx_strcmp(conf->qatzip_sw.data, "no")) {
+        conf->enable = 1;
+        conf->sw_fallback_enable = 0;
+    } else {
+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                "You must set \"qatzip_sw\" to only\\failover\\no in nginx.conf");
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static ngx_int_t
+ngx_http_qatzip_filter_init(ngx_conf_t *cf)
+{
+    ngx_http_next_header_filter = ngx_http_top_header_filter;
+    ngx_http_top_header_filter = ngx_http_qatzip_header_filter;
+
+    ngx_http_next_body_filter = ngx_http_top_body_filter;
+    ngx_http_top_body_filter = ngx_http_qatzip_body_filter;
+
+    return NGX_OK;
+}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/modules/nginx_qatzip_module/README ../asynch_mode_nginx/modules/nginx_qatzip_module/README
--- nginx-release-1.20.1/modules/nginx_qatzip_module/README	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/modules/nginx_qatzip_module/README	2022-03-15 13:23:40.540402840 -0500
@@ -0,0 +1,76 @@
+# Copyright (C) Intel, Inc.
+
+This module is developed for accelerating GZIP compression with QATzip in Nginx
+dynamic module framework.
+
+Installation
+
+1. Add below configuration line into the config.example
+    --add-dynamic-module=modules/nginx_qatzip_module
+2. Build Nginx with the addon modules
+    $ ./config.example
+    $ make && make install
+
+
+Configuration
+
+1. Add dynamic loading configuration in nginx.conf
+    $ load_module modules/ngx_http_qatzip_filter_module.so;
+
+
+Directives
+
+    Syntax:     qatzip_sw only | failover | no;
+    Default:    qatzip_sw failover;
+    Context:    http, server, location, if in location
+    Description:
+                only,  QATzip is disabled.
+                failover, QATzip is enabled with software fallback feature.
+                no, QATzip is enabled without software fallback feature.
+
+    Syntax:     qatzip_chunk_size size;
+    Default:    qatzip_chunk_size 64k;
+    Context:    http, server, location
+    Description:
+                Sets the chunk buffer size in which data will be compressed into
+                one deflate block. The buffer size is limited, can be set to any
+                value between 16K ~ 128K, by default, it is 64K.
+
+    Syntax:     qatzip_stream_size size;
+    Default:    qatzip_stream_size 256k;
+    Context:    http, server, location
+    Description:
+                Sets the size of stream buffers in which data will be compressed into
+                multiple deflate blocks and only the last block has FINAL bit being set.
+                By default, the stream buffer size is 256K.
+
+    Syntax:     qatzip_sw_threshold size;
+    Default:    qatzip_sw_threshold 1k;
+    Context:    http, server, location
+    Description:
+                Sets threshold of switching between software compression and QATzip
+                compression. When response data size shorter than that, the software
+                compression method will be used. By default, the threshold is 1K.
+
+    Syntax:     qatzip_min_length length;
+    Default:    qatzip_min_length 20;
+    Context:    http, server, location
+    Description:
+                Sets the minimum length of a response that will be qatzipped.
+                The length is determined only from the “Content-Length”
+                response header field.
+
+    Syntax:     qatzip_comp_level level;
+    Default:    qatzip_comp_level 1;
+    Context:    http, server, location
+    Description:
+                Sets a qatzip compression level of a response.
+                Acceptable values are in the range from 1 to 9.
+
+    Syntax:     qatzip_buffers number size;
+    Default:    qatzip_buffers 32 4k|16 8k;
+    Context:    http, server, location
+    Description:
+                Sets the number and size of buffers used to compress a response.
+                By default, the buffer size is equal to one memory page.
+                This is either 4K or 8K, depending on a platform.
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/README.md ../asynch_mode_nginx/README.md
--- nginx-release-1.20.1/README.md	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/README.md	2022-03-15 13:23:40.536402806 -0500
@@ -0,0 +1,686 @@
+Asynch Mode for NGINX\*
+
+## Table of Contents
+
+- [Introduction](#introduction)
+- [Licensing](#licensing)
+- [Features](#features)
+- [Hardware Requirements](#hardware-requirements)
+- [Software Requirements](#software-requirements)
+- [Additional Information](#additional-information)
+- [Limitations](#limitations)
+- [Installation Instructions](#installation-instructions)
+    - [Asynch Mode for NGINX\* Installation](#asynch-mode-for-nginx-installation)
+    - [Build OpenSSL\* and QAT engine](#build-openssl-and-qat-engine)
+    - [Build QATzip](#build-qatzip)
+    - [Run Nginx official test](#run-nginx-official-test)
+- [SSL Engine Framework for Configuration](#ssl-engine-framework-for-configuration)
+- [Support for Nginx Side Polling](#support-for-nginx-side-polling)
+    - [External Polling Mode](#external-polling-mode)
+    - [Heuristic Polling Mode](#heuristic-polling-mode)
+- [QATzip Module Configuration](#qatzip-module-configuration)
+- [QAT Sample Configuration](#qat-sample-configuration)
+- [Known Issues](#known-issues)
+- [Intended Audience](#intended-audience)
+- [Legal](#legal)
+
+## Introduction
+
+Nginx\* [engine x] is an HTTP and reverse proxy server, a mail proxy server,
+and a generic TCP/UDP proxy server, originally written by Igor Sysoev.
+This project provides an extended Nginx working with asynchronous mode OpenSSL\*.
+With Intel&reg; QuickAssist Technology (QAT) acceleration, Asynch Mode for NGINX\*
+can provide significant performance improvement.
+
+## Licensing
+
+The Licensing of the files within this project is:
+
+Asynch Mode for NGINX\* - BSD License. Please
+see the `LICENSE` file contained in the top level folder. Further details can
+be found in the file headers of the relevant files.
+
+## Features
+
+* Asynchronous Mode in SSL/TLS processing (including http/stream/mail/proxy module)
+* SSL Engine Framework for engine configuration
+* Support for external polling mode and heursitic polling mode
+* Release hardware resource during worker is shutting down (For more details
+  information, please read modules/nginx_qat_module/README)
+* Support OpenSSL Cipher PIPELINE feature
+* Support QATzip module to accelerate GZIP compression with Intel&reg; Quickassist Technology
+* Support software fallback for asymmetric cryptography algorithms.
+* Support [QAT Engine multibuffer feature][10]
+[10]:https://github.com/intel/QAT_Engine#intel-qat-openssl-engine-multibuffer-support
+* Support FreeBSD Operating System.
+
+## Hardware Requirements
+
+Asynch Mode for NGINX\* supports Crypto and Compression offload to the following acceleration devices:
+
+* [Intel&reg; C62X Series Chipset][1]
+* [Intel&reg; Communications Chipset 8925 to 8955 Series][2]
+* [Intel&reg; Communications Chipset 8960 to 8970 Series][9]
+* [Intel&reg; C3XXX Series Chipset][11]
+
+[1]:https://www.intel.com/content/www/us/en/design/products-and-solutions/processors-and-chipsets/purley/intel-xeon-scalable-processors.html
+[2]:https://www.intel.com/content/www/us/en/ethernet-products/gigabit-server-adapters/quickassist-adapter-8950-brief.html
+[9]:https://www.intel.com/content/www/us/en/ethernet-products/gigabit-server-adapters/quickassist-adapter-8960-8970-brief.html
+[11]:https://www.intel.com/content/www/us/en/products/docs/processors/atom/c-series/c3000-family-brief.html
+
+## Software Requirements
+
+This release was validated on the following:
+
+* Asynch Mode for NGINX\* has been tested with the latest Intel&reg; QuickAssist Acceleration Driver.
+Please download the QAT driver from the link https://01.org/intel-quickassist-technology
+* OpenSSL-1.1.1l
+* QAT engine v0.6.10
+* QATzip v1.0.6
+
+## Additional Information
+
+* Asynch Mode for NGINX\* is developed based on Nginx-1.20.1.
+
+* Generate patch against official Nginx-1.20.1.
+
+```bash
+  git clone https://github.com/intel/asynch_mode_nginx.git
+  wget http://nginx.org/download/nginx-1.20.1.tar.gz
+  tar -xvzf nginx-1.20.1.tar.gz
+  diff -Naru -x .git nginx-1.20.1 asynch_mode_nginx > async_mode_nginx_1.20.1.patch
+```
+
+* Apply patch to official Nginx-1.20.1.
+
+```bash
+  wget http://nginx.org/download/nginx-1.20.1.tar.gz
+  tar -xvzf nginx-1.20.1.tar.gz
+  patch -p0 < async_mode_nginx_1.20.1.patch
+```
+
+* Generate patch against github official read-only mirror
+
+```bash
+  git clone https://github.com/intel/asynch_mode_nginx.git
+  wget https://github.com/nginx/nginx/archive/release-1.20.1.tar.gz
+  tar -xvzf release-1.20.1.tar.gz
+  diff -Naru -x .git -x .hgtags nginx-release-1.20.1 asynch_mode_nginx > async_mode_nginx_1.20.1.patch
+```
+
+* Apply patch to the github release pachage.
+
+```bash
+  wget https://github.com/nginx/nginx/archive/release-1.20.1.tar.gz
+  tar -xvzf release-1.20.1.tar.gz
+  patch -p0 < async_mode_nginx_1.20.1.patch
+```
+
+* Asynch Mode for NGINX\* SSL engine framework provides new directives:
+
+**Directives**
+```bash
+Syntax:     ssl_asynch on | off;
+Default:    ssl_asynch off;
+Context:    stream, mail, http, server
+
+    Enables SSL/TLS asynchronous mode
+```
+**Example**
+
+file: conf/nginx.conf
+
+```bash
+    http {
+        ssl_asynch  on;
+        server {...}
+    }
+```
+
+```bash
+    stream {
+        ssl_asynch  on;
+        server {...}
+    }
+```
+
+**Directives**
+```bash
+Syntax:     proxy_ssl_asynch on | off;
+Default:    proxy_ssl_asynch off;
+Context:    stream, http, server
+
+Enables the SSL/TLS protocol asynchronous mode for connections to a proxied server.
+```
+
+**Example**
+
+file: conf/nginx.conf
+
+```bash
+    http {
+        server {
+            location /ssl {
+                proxy_pass https://127.0.0.1:8082/outer;
+                proxy_ssl_asynch on;
+            }
+        }
+    }
+```
+
+**Directives**
+```bash
+Syntax:     grpc_ssl_asynch on | off;
+Default:    grpc_ssl_asynch off;
+Context:    http, server
+
+Enables the SSL/TLS protocol asynchronous mode for connections to a grpc server.
+```
+
+**Example**
+
+file: conf/nginx.conf
+
+```bash
+    http {
+        server {
+            location /grpcs {
+                grpc_pass https://127.0.0.1:8082/outer;
+                grpc_ssl_asynch on;
+            }
+        }
+    }
+```
+
+* Asynch Mode for NGINX\* provide new option `asynch` for `listen` directive.
+
+**Example**
+
+file: conf/nginx.conf
+
+```bash
+    http {
+        server{ listen 443 asynch; }
+    }
+```
+
+* Support OpenSSL Cipher PIPELINE feature (Deitals information about the pipeline
+  settings, please refer to [OpenSSL Docs][6])
+
+**Directives**
+```bash
+Syntax:     ssl_max_pipelines size;
+Default:    ssl_max_pipelines 0;
+Context:    server
+
+Set MAX number of pipelines
+```
+
+**Directives**
+```bash
+Syntax:     ssl_split_send_fragment size;
+Default:    ssl_split_send_fragment 0;
+Context:    server
+
+Set split size of sending fragment
+```
+
+**Directives**
+```bash
+Syntax:     ssl_max_send_fragment size;
+Default:    ssl_max_send_fragment 0;
+Context:    server
+
+Set max number of sending fragment
+```
+
+* [White Paper: Intel&reg; Quickassist Technology and OpenSSL-1.1.0:Performance][3]
+
+[3]: https://01.org/sites/default/files/downloads/intelr-quickassist-technology/intelquickassisttechnologyopensslperformance.pdf
+[6]: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_split_send_fragment.html
+
+## Limitations
+
+* Nginx supports `reload` operation, when QAT hardware is involved for crypto
+  offload, user should ensure that there are enough number of QAT instances.
+  For example, the available qat instance number should be 2x equal or more than
+  Nginx worker process number.
+
+    For example, in Nginx configuration file (`nginx.conf`) worker process number
+is configured as
+
+    ```bash
+       worker_processes 16;
+    ```
+
+    Then the instance configuration in QAT driver configuration file should be
+
+    ```bash
+        [SHIM]
+        NumberCyInstances = 1
+        NumberDcInstances = 0
+        NumProcesses = 32
+        LimitDevAccess = 0
+    ```
+
+* When configure "worker_process auto", Asynch Mode for NGINX\* will need instance number equal or larger than
+  2 times of CPU core number. Otherwise, Asynch Mode for NGINX\* might show various issue caused by leak of
+  instance.
+
+* Nginx supports QAT engine and QATzip module. By default, they use User Space
+  DMA-able Memory (USDM) Component. The USDM component is located within the
+  Upstream Intel&reg; QAT Driver source code in the following subdirectory:
+  `quickassist/utilities/libusdm_drv`. We should have this component enabled
+  and assignd enough memory before using nginx_qat_module or
+  nginx_qatzip_module, for example:
+
+    ```bash
+        echo 2048 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
+        insmod ./usdm_drv.ko max_huge_pages=2048 max_huge_pages_per_process=32
+    ```
+
+## Installation Instructions
+
+### Asynch Mode for NGINX\* Installation
+
+**Set the following environmental variables:**
+
+`NGINX_INSTALL_DIR` is the directory where Nginx will be installed to
+
+`OPENSSL_LIB` is the directory where the OpenSSL has been installed to
+
+`QZ_ROOT` is the directory where the QATzip has been compiled to
+
+**Configure nginx for compilation:**
+
+```bash
+    ./configure \
+        --prefix=$NGINX_INSTALL_DIR \
+        --with-http_ssl_module \
+        --add-dynamic-module=modules/nginx_qatzip_module \
+        --add-dynamic-module=modules/nginx_qat_module/ \
+        --with-cc-opt="-DNGX_SECURE_MEM -I$OPENSSL_LIB/include -I$ICP_ROOT/quickassist/include -I$ICP_ROOT/quickassist/include/dc -I$QZ_ROOT/include -Wno-error=deprecated-declarations" \
+        --with-ld-opt="-Wl,-rpath=$OPENSSL_LIB/lib -L$OPENSSL_LIB/lib -L$QZ_ROOT/src -lqatzip -lz"
+```
+
+**Compile and Install:**
+
+```bash
+    make
+    make install
+```
+
+**Nginx supports setting worker to non-root user, for example:**
+
+    Add user qat in group qat, for example run below command in your terminal:
+    ```bash
+        groupadd qat
+        useradd -g qat qat
+    ```
+
+    In nginx.conf, you can set worker as qat, qat is the user you added before:
+    ```bash
+        user qat qat;
+    ```
+
+    Then we need to give non-root worker enough permission to enable qat, you need to run folow
+    connamds in your terminal:
+    ```bash
+        chgrp qat /dev/qat_*
+        chmod 660 /dev/qat_*
+        chgrp qat /dev/usdm_drv
+        chmod 660 /dev/usdm_drv
+        chgrp qat /dev/uio*
+        chmod 660 /dev/uio*
+        chgrp qat /dev/hugepages
+        chmod 770 /dev/hugepages
+        chgrp qat /usr/local/lib/libqat_s.so
+        chgrp qat /usr/local/lib/libusdm_drv_s.so
+    ```
+
+### Build OpenSSL\* and QAT engine
+
+These instructions can be found on [QAT engine][4]
+
+[4]: https://github.com/intel/QAT_Engine#installation-instructions
+
+### Build QATzip
+
+These instructions can be found on [QATzip][5]
+
+[5]: https://github.com/intel/QATzip#installation-instructions
+
+### Run Nginx official test
+
+These instructions can be found on [Official test][8]
+
+[8]: https://github.com/intel/asynch_mode_nginx/blob/master/test/README.md
+
+### Performance Testing Best Known Methodology
+
+These instruction can be found on [9]
+[9]: https://github.com/intel/asynch_mode_nginx/blob/master/test/performance_bkm/README.md
+
+## SSL Engine Framework for Configuration
+
+As QAT engine is implemented as a standard OpenSSL\* engine, its behavior can be
+controlled from the OpenSSL\* configuration file (`openssl.conf`), which can be
+found on [QAT engine][7].
+
+[7]: https://github.com/intel/QAT_Engine#using-the-openssl-configuration-file-to-loadinitialize-engines
+
+**Note**:
+From v0.3.2 and later, this kind of configuration in `openssl.conf` will not be
+effective for Nginx. Please use the following method to configure Nginx SSL
+engine, such as Intel&reg; QAT.
+
+An SSL Engine Framework is introduced to provide a more powerful and flexible
+mechanism to configure Nginx SSL engine directly in the Nginx configuration file
+(`nginx.conf`).
+
+### ssl_engine configuration
+A new configuration block is introduced as `ssl_engine` which provides two
+general directives:
+
+Sets the engine module and engine id for OpenSSL async engine. For example:
+```bash
+Syntax:     use_engine [engine module name] [engine id];
+Default:    N/A
+Context:    ssl_engine
+Description:
+            Specify the engine module name against engine id
+```
+Sets the engine module and engine id for OpenSSL async engine by only providing
+the engine id. The engine module should be the same as engine id in this case.
+```bash
+Syntax:     use_engine [engine id];
+Default:    N/A
+Context:    ssl_engine
+Description:
+            Specify the engine id
+```
+
+```bash
+Syntax:     default_algorithms [ALL/RSA/EC/...];
+Default:    ALL
+Context:    ssl_engine
+Description:
+            Specify the algorithms need to be offloaded to the engine
+            More details information please refer to OpenSSL engine
+```
+
+A following configuration sub-block can be used to set engine specific
+configuration. The name of the sub-block should have a prefix using the
+engine name specified in `use_engine`, such as `[engine_name]_engine`.
+
+### nginx_qat_module
+Any 3rd party modules can be integrated into this framework. By default, a
+reference module `dasync_module` is provided in `src/engine/modules`
+and a QAT module `nginx_qat_module` is provided in `modules/nginx_qat_modules`.
+
+An example configuration in the `nginx.conf`:
+```bash
+    load_module modules/ngx_ssl_engine_qat_module.so;
+    ...
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms RSA,EC,DH,PKEY_CRYPTO;
+        qat_engine {
+            qat_sw_fallback on;
+            qat_offload_mode async;
+            qat_notify_mode poll;
+            qat_poll_mode heuristic;
+            qat_shutting_down_release on;
+        }
+    }
+```
+For more details directives of `nginx_qat_module`, please refer to
+`modules/nginx_qat_modules/README`.
+
+## Support for Nginx Side Polling
+The qat_module provides two kinds of Nginx side polling for QAT engine,
+
+* external polling mode
+* heuristic polling mode
+
+Please refer to the README file in the `modules/nginx_qat_modules` directory
+to install this dynamic module.
+
+**Note**:
+External polling and heuristic polling are unavailable in SSL proxy and stream
+module up to current release.
+
+### External Polling Mode
+
+A timer-based polling is employed in each Nginx worker process to collect
+accelerator's response.
+
+**Directives in the qat_module**
+```bash
+Syntax:     qat_external_poll_interval time;
+Default:    1
+Dependency: Valid if (qat_poll_mode=external)
+Context:    qat_engine
+Description:
+            External polling time interval (ms)
+            Valid value: 1 ~ 1000
+```
+**Example**
+file: conf/nginx.conf
+
+```bash
+    load_module modules/ngx_ssl_engine_qat_module.so;
+    ...
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms ALL;
+        qat_engine {
+            qat_offload_mode async;
+            qat_notify_mode poll;
+
+            qat_poll_mode external;
+            qat_external_poll_interval 1;
+        }
+    }
+```
+
+
+### Heuristic Polling Mode
+
+This mode can be regarded as an improvement of the timer-based external polling.
+It is the recommended polling mode to communicate with QAT accelerators because
+of its performance advantages. With the knowledge of the offload traffic, it
+controls the response reaping rate to match the request submission rate so as to
+maximize system efficiency with moderate latency, and adapt well to diverse
+types of network traffics.
+
+**Note:**
+
+* This mode is only available when using QAT engine v0.5.35 or later.
+* External polling timer is enabled by default when heuristic polling mode is enabled.
+
+In the heuristic polling mode, a polling operation is only triggered at a proper moment:
+
+* Number of in-flight offload requests reaches a pre-defined threshold (in consideration of efficiency)
+* All the active SSL connections have submitted their cryptographic requests and been waiting for
+the corresponding responses (in consideration of timeliness).
+
+**Directives in the qat_module**
+```bash
+Syntax:     qat_heuristic_poll_asym_threshold num;
+Default:    48
+Dependency: Valid if (qat_poll_mode=heuristic)
+Context:    qat_engine
+Description:
+            Threshold of the number of in-flight requests to trigger a polling
+            operation when there are in-flight asymmetric crypto requests
+            Valid value: 1 ~ 512
+
+
+Syntax:     qat_heuristic_poll_sym_threshold num;
+Default:    24
+Dependency: Valid if (qat_poll_mode=heuristic)
+Context:    qat_engine
+Description:
+            Threshold of the number of in-flight requests to trigger a polling
+            operation when there is no in-flight asymmetric crypto request
+            Valid value: 1 ~ 512
+```
+**Example**
+file: `conf/nginx.conf`
+
+```bash
+    load_module modules/ngx_ssl_engine_qat_module.so;
+    ...
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms ALL;
+        qat_engine {
+            qat_offload_mode async;
+            qat_notify_mode poll;
+
+            qat_poll_mode heuristic;
+            qat_heuristic_poll_asym_threshold 48;
+            qat_heuristic_poll_sym_threshold 24;
+        }
+    }
+```
+
+## QATzip Module Configuration
+
+This module is developed to accelerate GZIP compression with QAT accelerators
+through QATzip stream API released in v0.2.6.
+Software fallback feature of QATzip is released in v1.0.0.
+
+**Note:**
+
+* This mode is only available when using QATzip v1.0.0 or later.
+* This mode relys on gzip module for SW fallback feature.
+* The qatzip_sw is set to failover by default, do not load QATzip module if you
+do not want to enable qatzip. Or else it would be enabled and set to failover.
+
+**Directives in the qatzip_module**
+```bash
+    Syntax:     qatzip_sw only/failover/no;
+    Default:    qatzip_sw failover;
+    Context:    http, server, location, if in location
+    Description:
+                only: qatzip is disable, using gzip;
+                failover: qatzip is enable, qatzip sfotware fallback feature enable.
+                no: qatzip is enable, qatzip sfotware fallback feature disable.
+
+    Syntax:     qatzip_chunk_size size;
+    Default:    qatzip_chunk_size 64k;
+    Context:    http, server, location
+    Description:
+                Sets the chunk buffer size in which data will be compressed into
+                one deflate block. By default, the buffer size is equal to 64K.
+
+    Syntax:     qatzip_stream_size size;
+    Default:    qatzip_stream_size 256k;
+    Context:    http, server, location
+    Description:
+                Sets the size of stream buffers in which data will be compressed into
+                multiple deflate blocks and only the last block has FINAL bit being set.
+                By default, the stream buffer size is 256K.
+```
+
+**Example**
+file: `conf/nginx.conf`
+
+```bash
+    load_module modules/ngx_http_qatzip_filter_module.so;
+    ...
+
+    gzip_http_version   1.0;
+    gzip_proxied any;
+    qatzip_sw failover;
+    qatzip_min_length 128;
+    qatzip_comp_level 1;
+    qatzip_buffers 16 8k;
+    qatzip_types text/css text/javascript text/xml text/plain text/x-component application/javascript application/json application/xml application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml application/octet-stream image/jpeg;
+    qatzip_chunk_size   64k;
+    qatzip_stream_size  256k;
+    qatzip_sw_threshold 256;
+```
+For more details directives of `nginx_qatzip_module`, please refer to
+`modules/nginx_qatzip_modules/README`.
+
+## QAT Sample Configuration
+
+file: `conf/nginx.QAT-sample.conf`
+
+This is a sample configure file shows how to configure QAT in nginx.conf. This file includes:
+
+* Enable SSL QAT engine in heretic mode.
+* Support HTTPS async mode.
+* Enable QATzip support.
+* Select TLS-1.2 as the default ssl_protocols.
+
+**Note:**
+
+* The QAT configuration needs crypto and compression instance for the user space application.
+
+## Known Issues
+**'Orphan ring' errors in `dmesg` output when Nginx exit**<br/>
+   Working with current QAT driver (version 4.6.0 in 01.org), Nginx workers exit
+   with 'Orphan ring' errors. This issue has been fixed in future QAT driver release
+
+**Cache manager/loader process will allocate QAT instance via QAT engine**<br/>
+   According to current QAT engine design, child process forked by master
+   process will initialize QAT engine automatically in QAT engine `atfork`
+   hook function. If cache manager/loader processes are employed, QAT instances
+   will be allocated in the same way as worker process. Cache manager/loader
+   processes do not perform modules' `exit process` method in Nginx native design
+   which will introduce "Orphan ring" error message in `dmesg` output.
+
+**QATzip module does not support dictionary compression**<br/>
+   QATzip module supports GZIP compression acceleration now, does not support
+   user define dictionary compression yet.
+
+**Segment fault happens while sending HUP signal when QAT instances not enough**<br/>
+   If the available qat instance number is less than 2x Nginx worker process number, segment fault
+   happens while sending HUP signal to Asynch Mode for NGINX\*. Using `qat_sw_fallback on;` in qat_engine
+   directive as a workaround for this issue. And it needs special attention if the QAT instances
+   are enough when setting `worker_processes auto;`.
+
+**Insufficient HW resources would cause segment fault while sending HUP signal**<br/>
+   Before running nginx, please make sure you have arranged enough HW resources for nginx, including
+   memory and hard disk space. Disk space exhausted or out of memory would cause core dump when
+   nginx receives HUP signal during handshake phase.
+
+**TLS1.3 Early data function may failed when enable HKDF offload in QAT Engine**<br/>
+   When enable HKDF offload in QAT Engine, and enable early data function with TLS1.3 protocol in
+   Nginx configuration, early data operation in session reuse case may failed.
+
+## Intended Audience
+
+The target audience may be software developers, test and validation engineers,
+system integrators, end users and consumers for Asynch Mode for NGINX\* integrated
+Intel&reg; Quick Assist Technology.
+
+## Legal
+
+Intel disclaims all express and implied warranties, including without
+limitation, the implied warranties of merchantability, fitness for a
+particular purpose, and non-infringement, as well as any warranty arising
+from course of performance, course of dealing, or usage in trade.
+
+This document contains information on products, services and/or processes in
+development.  All information provided here is subject to change without
+notice. Contact your Intel representative to obtain the latest forecast
+, schedule, specifications and roadmaps.
+
+The products and services described may contain defects or errors known as
+errata which may cause deviations from published specifications. Current
+characterized errata are available on request.
+
+Copies of documents which have an order number and are referenced in this
+document may be obtained by calling 1-800-548-4725 or by visiting
+www.intel.com/design/literature.htm.
+
+Intel, the Intel logo are trademarks of Intel Corporation in the U.S.
+and/or other countries.
+
+\*Other names and brands may be claimed as the property of others
+
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/nginx.c ../asynch_mode_nginx/src/core/nginx.c
--- nginx-release-1.20.1/src/core/nginx.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/nginx.c	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -182,6 +183,10 @@
 static ngx_uint_t   ngx_show_help;
 static ngx_uint_t   ngx_show_version;
 static ngx_uint_t   ngx_show_configure;
+/* indicate that nginx start without ngx_ssl_init()
+ * which will involve OpenSSL configuration file to
+ * start OpenSSL engine */
+static ngx_uint_t   ngx_no_ssl_init;
 static u_char      *ngx_prefix;
 static u_char      *ngx_error_log;
 static u_char      *ngx_conf_file;
@@ -238,7 +243,8 @@
 
     /* STUB */
 #if (NGX_OPENSSL)
-    ngx_ssl_init(log);
+    if(!ngx_no_ssl_init)
+        ngx_ssl_init(log);
 #endif
 
     /*
@@ -248,6 +254,7 @@
 
     ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
     init_cycle.log = log;
+    init_cycle.no_ssl_init = ngx_no_ssl_init;
     ngx_cycle = &init_cycle;
 
     init_cycle.pool = ngx_create_pool(1024, log);
@@ -782,11 +789,13 @@
 
             case 't':
                 ngx_test_config = 1;
+                ngx_no_ssl_init = 1;
                 break;
 
             case 'T':
                 ngx_test_config = 1;
                 ngx_dump_config = 1;
+                ngx_no_ssl_init = 1;
                 break;
 
             case 'q':
@@ -854,6 +863,7 @@
                 return NGX_ERROR;
 
             case 's':
+                ngx_no_ssl_init = 1;
                 if (*p) {
                     ngx_signal = (char *) p;
 
@@ -879,6 +889,7 @@
 
             default:
                 ngx_log_stderr(0, "invalid option: \"%c\"", *(p - 1));
+                ngx_no_ssl_init = 1;
                 return NGX_ERROR;
             }
         }
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_buf.h ../asynch_mode_nginx/src/core/ngx_buf.h
--- nginx-release-1.20.1/src/core/ngx_buf.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_buf.h	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -137,7 +138,7 @@
      && !(b)->in_file && !(b)->flush && !(b)->last_buf)
 
 #define ngx_buf_size(b)                                                      \
-    (ngx_buf_in_memory(b) ? (off_t) ((b)->last - (b)->pos):                  \
+    (ngx_buf_in_memory(b) ? (off_t) (unsigned) ((b)->last - (b)->pos):       \
                             ((b)->file_last - (b)->file_pos))
 
 ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_conf_file.h ../asynch_mode_nginx/src/core/ngx_conf_file.h
--- nginx-release-1.20.1/src/core/ngx_conf_file.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_conf_file.h	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -129,6 +130,7 @@
 
     ngx_conf_handler_pt   handler;
     void                 *handler_conf;
+    ngx_flag_t            no_ssl_init;
 };
 
 
@@ -202,6 +204,12 @@
         conf = default;                                                      \
     }
 
+#define ngx_conf_init_str_value(conf, default)                               \
+    if (conf.data == NULL) {                                                 \
+        conf.len = sizeof(default) - 1;                                      \
+        conf.data = (u_char *) default;                                      \
+    }
+
 #define ngx_conf_merge_value(conf, prev, default)                            \
     if (conf == NGX_CONF_UNSET) {                                            \
         conf = (prev == NGX_CONF_UNSET) ? default : prev;                    \
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_connection.c ../asynch_mode_nginx/src/core/ngx_connection.c
--- nginx-release-1.20.1/src/core/ngx_connection.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_connection.c	2022-03-15 13:23:40.540402840 -0500
@@ -2,12 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>
 
 
 ngx_os_io_t  ngx_io;
@@ -1045,7 +1047,14 @@
                      * for closed shared listening sockets unless
                      * the events was explicitly deleted
                      */
-
+#if (NGX_SSL)
+                    if (c->asynch && ngx_del_async_conn) {
+                        if (c->num_async_fds) {
+                            ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                            c->num_async_fds--;
+                        }
+                    }
+#endif
                     ngx_del_event(c->read, NGX_READ_EVENT, 0);
 
                 } else {
@@ -1095,6 +1104,9 @@
 {
     ngx_uint_t         instance;
     ngx_event_t       *rev, *wev;
+#if (NGX_SSL)
+    ngx_event_t       *aev;
+#endif
     ngx_connection_t  *c;
 
     /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */
@@ -1128,11 +1140,18 @@
 
     rev = c->read;
     wev = c->write;
+#if (NGX_SSL)
+    aev = c->async;
+#endif
 
     ngx_memzero(c, sizeof(ngx_connection_t));
 
     c->read = rev;
     c->write = wev;
+#if (NGX_SSL)
+    c->async = aev;
+#endif
+
     c->fd = s;
     c->log = log;
 
@@ -1140,17 +1159,32 @@
 
     ngx_memzero(rev, sizeof(ngx_event_t));
     ngx_memzero(wev, sizeof(ngx_event_t));
+#if (NGX_SSL)
+    ngx_memzero(aev, sizeof(ngx_event_t));
+#endif
 
     rev->instance = !instance;
     wev->instance = !instance;
+#if (NGX_SSL)
+    aev->instance = !instance;
+#endif
 
     rev->index = NGX_INVALID_INDEX;
     wev->index = NGX_INVALID_INDEX;
+#if (NGX_SSL)
+    aev->index = NGX_INVALID_INDEX;
+#endif
 
     rev->data = c;
     wev->data = c;
+#if (NGX_SSL)
+    aev->data = c;
+#endif
 
     wev->write = 1;
+#if (NGX_SSL)
+    aev->async = 1;
+#endif
 
     return c;
 }
@@ -1189,11 +1223,32 @@
         ngx_del_timer(c->write);
     }
 
+#if (NGX_SSL)
+    if (c->async->timer_set) {
+        ngx_del_timer(c->async);
+    }
+
+    if (c->asynch && ngx_del_async_conn) {
+        if (c->num_async_fds) {
+            ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+            c->num_async_fds--;
+        }
+    }
+#endif
+
     if (!c->shared) {
         if (ngx_del_conn) {
             ngx_del_conn(c, NGX_CLOSE_EVENT);
 
         } else {
+#if (NGX_SSL)
+            if (c->asynch && ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+#endif
             if (c->read->active || c->read->disabled) {
                 ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
             }
@@ -1212,8 +1267,17 @@
         ngx_delete_posted_event(c->write);
     }
 
+#if (NGX_SSL)
+    if (c->async->posted) {
+        ngx_delete_posted_event(c->async);
+    }
+#endif
+
     c->read->closed = 1;
     c->write->closed = 1;
+#if (NGX_SSL)
+    c->async->closed = 1;
+#endif
 
     ngx_reusable_connection(c, 0);
 
@@ -1223,6 +1287,9 @@
 
     fd = c->fd;
     c->fd = (ngx_socket_t) -1;
+#if (NGX_SSL)
+    c->async_fd = (ngx_socket_t) -1;
+#endif
 
     if (c->shared) {
         return;
@@ -1270,6 +1337,13 @@
 #if (NGX_STAT_STUB)
         (void) ngx_atomic_fetch_add(ngx_stat_waiting, -1);
 #endif
+
+#if (NGX_SSL)
+        if (c->ssl_enabled && ngx_use_ssl_engine
+            && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+        }
+#endif
     }
 
     c->reusable = reusable;
@@ -1284,6 +1358,14 @@
 #if (NGX_STAT_STUB)
         (void) ngx_atomic_fetch_add(ngx_stat_waiting, 1);
 #endif
+
+#if (NGX_SSL)
+        if (c->ssl_enabled && ngx_use_ssl_engine
+            && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+            ngx_ssl_engine_heuristic_poll(c->log);
+        }
+#endif
     }
 }
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_connection.h ../asynch_mode_nginx/src/core/ngx_connection.h
--- nginx-release-1.20.1/src/core/ngx_connection.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_connection.h	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -123,9 +124,14 @@
     void               *data;
     ngx_event_t        *read;
     ngx_event_t        *write;
+#if (NGX_SSL)
+    ngx_event_t        *async;
+#endif
 
     ngx_socket_t        fd;
-
+#if (NGX_SSL)
+    ngx_socket_t        async_fd;
+#endif
     ngx_recv_pt         recv;
     ngx_send_pt         send;
     ngx_recv_chain_pt   recv_chain;
@@ -149,6 +155,8 @@
 
 #if (NGX_SSL || NGX_COMPAT)
     ngx_ssl_connection_t  *ssl;
+    ngx_flag_t          asynch;
+    unsigned            ssl_enabled:1;
 #endif
 
     ngx_udp_connection_t  *udp;
@@ -184,6 +192,9 @@
     unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */
 
     unsigned            need_last_buf:1;
+#if (NGX_SSL)
+    unsigned            num_async_fds:8;
+#endif
 
 #if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)
     unsigned            busy_count:2;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_cycle.c ../asynch_mode_nginx/src/core/ngx_cycle.c
--- nginx-release-1.20.1/src/core/ngx_cycle.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_cycle.c	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -81,6 +82,7 @@
     cycle->pool = pool;
     cycle->log = log;
     cycle->old_cycle = old_cycle;
+    cycle->no_ssl_init = old_cycle->no_ssl_init;
 
     cycle->conf_prefix.len = old_cycle->conf_prefix.len;
     cycle->conf_prefix.data = ngx_pstrdup(pool, &old_cycle->conf_prefix);
@@ -270,6 +272,7 @@
     conf.log = log;
     conf.module_type = NGX_CORE_MODULE;
     conf.cmd_type = NGX_MAIN_CONF;
+    conf.no_ssl_init = cycle->no_ssl_init;
 
 #if 0
     log->log_level = NGX_LOG_DEBUG_ALL;
@@ -1049,6 +1052,7 @@
         len = ngx_snprintf(pid, NGX_INT64_LEN + 2, "%P%N", ngx_pid) - pid;
 
         if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {
+            ngx_close_file(file.fd);
             rc = NGX_ERROR;
         }
     }
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_cycle.h ../asynch_mode_nginx/src/core/ngx_cycle.h
--- nginx-release-1.20.1/src/core/ngx_cycle.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_cycle.h	2022-03-15 13:23:40.540402840 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -73,6 +74,9 @@
     ngx_connection_t         *connections;
     ngx_event_t              *read_events;
     ngx_event_t              *write_events;
+#if (NGX_SSL)
+    ngx_event_t              *async_events;
+#endif
 
     ngx_cycle_t              *old_cycle;
 
@@ -83,6 +87,7 @@
     ngx_str_t                 error_log;
     ngx_str_t                 lock_file;
     ngx_str_t                 hostname;
+    ngx_flag_t                no_ssl_init;
 };
 
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_resolver.c ../asynch_mode_nginx/src/core/ngx_resolver.c
--- nginx-release-1.20.1/src/core/ngx_resolver.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_resolver.c	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -4463,6 +4464,9 @@
 
     rev->log = &rec->log;
     wev->log = &rec->log;
+#if (NGX_SSL)
+    c->async->log = &rec->log;
+#endif
 
     rec->udp = c;
 
@@ -4551,6 +4555,9 @@
 
     rev->log = &rec->log;
     wev->log = &rec->log;
+#if (NGX_SSL)
+    c->async->log = &rec->log;
+#endif
 
     rec->tcp = c;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/core/ngx_string.h ../asynch_mode_nginx/src/core/ngx_string.h
--- nginx-release-1.20.1/src/core/ngx_string.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/core/ngx_string.h	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -98,6 +99,16 @@
 
 #else
 
+#if (NGX_SECURE_MEM)
+
+#define _MIN_(a,b) (((a)<(b))?(a):(b))
+#define MEMCPY_S(dest, src, dest_sz, src_sz) \
+            memcpy((void *)(dest), (void *) (src), (size_t)_MIN_(dest_sz, src_sz))
+#define ngx_memcpy(dst, src, n)   (void) MEMCPY_S(dst, src, n, n)
+#define ngx_cpymem(dst, src, n)   (((u_char *) MEMCPY_S(dst, src, n, n)) + (n))
+
+#else
+
 /*
  * gcc3, msvc, and icc7 compile memcpy() to the inline "rep movs".
  * gcc3 compiles memcpy(d, s, 4) to the inline "mov"es.
@@ -106,8 +117,9 @@
 #define ngx_memcpy(dst, src, n)   (void) memcpy(dst, src, n)
 #define ngx_cpymem(dst, src, n)   (((u_char *) memcpy(dst, src, n)) + (n))
 
-#endif
+#endif /* NGX_SECURE_MEM */
 
+#endif /* NGX_MEMCPY_LIMIT */
 
 #if ( __INTEL_COMPILER >= 800 )
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/engine/modules/ngx_ssl_engine_dasync_module.c ../asynch_mode_nginx/src/engine/modules/ngx_ssl_engine_dasync_module.c
--- nginx-release-1.20.1/src/engine/modules/ngx_ssl_engine_dasync_module.c	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/src/engine/modules/ngx_ssl_engine_dasync_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -0,0 +1,236 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_ssl_engine.h>
+
+/* dummy async engine provided by OpenSSL */
+
+
+typedef struct {
+    /* only async for dasync engine, typically sync or async */
+    ngx_str_t       offload_mode;
+
+    /* no need for dasync engine, typically event or poll */
+    ngx_str_t       notify_mode;
+
+    /* no need for dasync engine */
+    ngx_str_t       poll_mode;
+} ngx_ssl_engine_dasync_conf_t;
+
+
+static ngx_int_t ngx_ssl_engine_dasync_send_ctrl(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_dasync_register_handler(ngx_cycle_t *cycle);
+
+static char *ngx_ssl_engine_dasync_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static void *ngx_ssl_engine_dasync_create_conf(ngx_cycle_t *cycle);
+static char *ngx_ssl_engine_dasync_init_conf(ngx_cycle_t *cycle, void *conf);
+
+static void ngx_ssl_engine_dasync_process_exit(ngx_cycle_t *cycle);
+
+
+static ngx_str_t      ssl_engine_dasync_name = ngx_string("dasync");
+
+static ngx_command_t  ngx_ssl_engine_dasync_commands[] = {
+
+    { ngx_string("dasync_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_dasync_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("dasync_offload_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, offload_mode),
+      NULL },
+
+    { ngx_string("dasync_notify_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, notify_mode),
+      NULL },
+
+    { ngx_string("dasync_poll_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, poll_mode),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_dasync_module_ctx = {
+    &ssl_engine_dasync_name,
+    ngx_ssl_engine_dasync_create_conf,               /* create configuration */
+    ngx_ssl_engine_dasync_init_conf,                 /* init configuration */
+
+    {
+        NULL,
+        ngx_ssl_engine_dasync_send_ctrl,
+        ngx_ssl_engine_dasync_register_handler,
+        NULL,
+        NULL
+    }
+};
+
+ngx_module_t  ngx_ssl_engine_dasync_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_dasync_module_ctx,      /* module context */
+    ngx_ssl_engine_dasync_commands,         /* module directives */
+    NGX_SSL_ENGINE_MODULE,                  /* module type */
+    NULL,                                   /* init master */
+    NULL,                                   /* init module */
+    NULL,                                   /* init process */
+    NULL,                                   /* init thread */
+    NULL,                                   /* exit thread */
+    ngx_ssl_engine_dasync_process_exit,     /* exit process */
+    NULL,                                   /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_int_t
+ngx_ssl_engine_dasync_send_ctrl(ngx_cycle_t *cycle)
+{
+    const char *engine_id = "dasync";
+    ENGINE     *e;
+
+    e = ENGINE_by_id(engine_id);
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"dasync\") failed");
+        return NGX_ERROR;
+    }
+
+    /* send ctrl before engine init */
+
+    /* ssl engine global variable set */
+
+    ENGINE_free(e);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_dasync_register_handler(ngx_cycle_t *cycle)
+{
+
+    /* set corresponding handler, e.g., external poll handler */
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_ssl_engine_dasync_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    ngx_conf_t      pcf;
+
+    pcf = *cf;
+    cf->cmd_type = NGX_SSL_ENGINE_SUB_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_dasync_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_dasync_conf_t  *sedcf;
+
+    sedcf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_dasync_conf_t));
+    if (sedcf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     sedcf->offload_mode = NULL
+     *     sedcf->notify_mode = NULL
+     *     sedcf->poll_mode = NULL
+     */
+
+    return sedcf;
+}
+
+
+static char *
+ngx_ssl_engine_dasync_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_ssl_engine_dasync_conf_t *sedcf = conf;
+
+    /* init the conf values not set by the user */
+
+    ngx_conf_init_str_value(sedcf->offload_mode, "async");
+
+    /* check the validity of the conf vaules */
+
+    if (ngx_strcmp(sedcf->offload_mode.data, "async") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for dasync_offload_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void
+ngx_ssl_engine_dasync_process_exit(ngx_cycle_t *cycle)
+{
+    ENGINE_cleanup();
+}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/engine/ngx_ssl_engine.c ../asynch_mode_nginx/src/engine/ngx_ssl_engine.c
--- nginx-release-1.20.1/src/engine/ngx_ssl_engine.c	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/src/engine/ngx_ssl_engine.c	2022-03-15 13:23:40.544402876 -0500
@@ -0,0 +1,529 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_ssl_engine.h>
+
+
+static char *ngx_ssl_engine_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static ngx_int_t ngx_ssl_engine_process_init(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_master_exit(ngx_cycle_t *cycle);
+
+static char *ngx_ssl_engine_use(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_ssl_engine_default_algorithms(ngx_conf_t *cf,
+    ngx_command_t *cmd, void *conf);
+
+static void *ngx_ssl_engine_core_create_conf(ngx_cycle_t *cycle);
+
+static void ngx_ssl_engine_table_cleanup(ENGINE *e);
+static char * ngx_ssl_engine_init_check(ngx_cycle_t *cycle, void *conf);
+
+/* indicating whether to use ssl engine: 0 or 1 */
+ngx_uint_t                  ngx_use_ssl_engine;
+
+ngx_ssl_engine_actions_t    ngx_ssl_engine_actions;
+ngx_uint_t                  ngx_ssl_engine_enable_heuristic_polling;
+
+ngx_str_t                   ngx_ssl_engine_name_curr = {
+    0,
+    NULL
+};
+ngx_str_t                   ngx_ssl_engine_name_prev = {
+    0,
+    NULL
+};
+
+ngx_flag_t                  ngx_ssl_engine_reload_processed = 0;
+
+static ngx_command_t  ngx_ssl_engine_commands[] = {
+
+    { ngx_string("ssl_engine"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_block,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+static ngx_core_module_t  ngx_ssl_engine_module_ctx = {
+    ngx_string("ssl_engine"),
+    NULL,
+    ngx_ssl_engine_init_check
+};
+
+ngx_module_t  ngx_ssl_engine_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_module_ctx,            /* module context */
+    ngx_ssl_engine_commands,               /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    ngx_ssl_engine_process_init,           /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    ngx_ssl_engine_master_exit,            /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t ssl_engine_core_name = ngx_string("ssl_engine_core");
+
+static ngx_command_t  ngx_ssl_engine_core_commands[] = {
+
+    { ngx_string("use_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_TAKE12,
+      ngx_ssl_engine_use,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("default_algorithms"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_1MORE,
+      ngx_ssl_engine_default_algorithms,
+      0,
+      offsetof(ngx_ssl_engine_conf_t, default_algorithms),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_core_module_ctx = {
+    &ssl_engine_core_name,
+    ngx_ssl_engine_core_create_conf,        /* create configuration */
+    NULL,                                   /* init configuration */
+
+    { NULL, NULL, NULL, NULL, NULL }
+};
+
+ngx_module_t  ngx_ssl_engine_core_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_core_module_ctx,        /* module context */
+    ngx_ssl_engine_core_commands,           /* module directives */
+    NGX_SSL_ENGINE_MODULE,                  /* module type */
+    NULL,                                   /* init master */
+    NULL,                                   /* init module */
+    NULL,                                   /* init process */
+    NULL,                                   /* init thread */
+    NULL,                                   /* exit thread */
+    NULL,                                   /* exit process */
+    NULL,                                   /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+/* OpenSSL will register all dynamic engines into its global engine tables
+ * To support dynamicaly update engine configuraion such as default_algorithm
+ * It needs to unregister all algorithms before applying new configuration
+ * Especially for remove some algorithms from previous configuation
+ */
+static void
+ngx_ssl_engine_table_cleanup(ENGINE *e)
+{
+    ENGINE_unregister_ciphers(e);
+    ENGINE_unregister_digests(e);
+    ENGINE_unregister_pkey_meths(e);
+    ENGINE_unregister_DSA(e);
+    ENGINE_unregister_EC(e);
+    ENGINE_unregister_RSA(e);
+    ENGINE_unregister_DH(e);
+}
+
+char *
+ngx_ssl_engine_name_record(ngx_str_t *name, ngx_pool_t *pool)
+{
+    ngx_memzero(&ngx_ssl_engine_name_prev, sizeof(ngx_ssl_engine_name_prev));
+    if (NULL != ngx_ssl_engine_name_curr.data &&
+        0 < ngx_ssl_engine_name_curr.len) {
+        ngx_ssl_engine_name_prev.data = ngx_pcalloc(pool, (ngx_ssl_engine_name_curr.len + 1));
+        ngx_ssl_engine_name_prev.len = ngx_ssl_engine_name_curr.len;
+        ngx_sprintf(ngx_ssl_engine_name_prev.data, "%s", ngx_ssl_engine_name_curr.data);
+    }
+
+    if (NULL == name) {
+        ngx_memzero(&ngx_ssl_engine_name_curr, sizeof(ngx_ssl_engine_name_curr));
+    } else {
+        ngx_ssl_engine_name_curr.data = ngx_pcalloc(pool, (name->len + 1));
+        ngx_ssl_engine_name_curr.len = name->len;
+        ngx_sprintf(ngx_ssl_engine_name_curr.data, "%s", name->data);
+    }
+
+    return NGX_CONF_OK;
+}
+
+char *
+ngx_ssl_engine_unload_check(ngx_cycle_t *cycle)
+{
+    ENGINE      *e;
+
+    if (NGX_PROCESS_SINGLE == ngx_process ||
+        NGX_PROCESS_MASTER == ngx_process) {
+        if (ngx_ssl_engine_reload_processed) {
+            return NGX_CONF_OK;
+        }
+        ngx_ssl_engine_reload_processed = 1;
+
+        if (NULL == ngx_get_conf(cycle->conf_ctx, ngx_ssl_engine_module)) {
+            ngx_ssl_engine_name_record(NULL, cycle->pool);
+        }
+
+        if(ngx_use_ssl_engine &&
+            NULL != ngx_ssl_engine_name_prev.data &&
+            0 < ngx_ssl_engine_name_prev.len &&
+            0 == ngx_ssl_engine_name_curr.len) {
+            ngx_memzero(&ngx_ssl_engine_actions, sizeof(ngx_ssl_engine_actions));
+            ngx_use_ssl_engine = 0;
+        }
+    }
+
+    if(0 == ngx_ssl_engine_name_prev.len ||
+        NULL == ngx_ssl_engine_name_prev.data) {
+        return NGX_CONF_OK;
+    }
+
+    if ((0 == ngx_ssl_engine_name_curr.len) ||
+        (0 < ngx_ssl_engine_name_curr.len &&
+        NULL != ngx_ssl_engine_name_curr.data &&
+        0 != ngx_strcmp(ngx_ssl_engine_name_curr.data, ngx_ssl_engine_name_prev.data))) {
+
+            e = ENGINE_by_id((const char *)ngx_ssl_engine_name_prev.data);
+            if (e == NULL) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                            "ENGINE_by_id(\"%s\") failed", (const char *)ngx_ssl_engine_name_prev.data);
+                return NGX_CONF_ERROR;
+            }
+
+            ngx_ssl_engine_table_cleanup(e);
+            ENGINE_GEN_INT_FUNC_PTR finish_function = ENGINE_get_finish_function(e);
+            finish_function(e);
+
+            if (NGX_PROCESS_SINGLE == ngx_process ||
+                NGX_PROCESS_MASTER == ngx_process) {
+                ENGINE_finish(e);
+                ENGINE_cleanup();
+            }
+            ENGINE_free(e);
+    }
+
+    return NGX_CONF_OK;
+}
+
+static ngx_int_t
+ngx_ssl_engine_set(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_conf_t *secf;
+
+    ENGINE      *e;
+    ngx_str_t   *value;
+    ngx_uint_t   i;
+
+
+    if (ngx_ssl_engine_send_ctrl(cycle) != NGX_OK) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ssl engine send ctrl failed");
+        return NGX_ERROR;
+    }
+
+    secf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if (secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    e = ENGINE_by_id((const char *) secf->ssl_engine_id.data);
+
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%V\") failed", &secf->ssl_engine_id);
+        return NGX_ERROR;
+    }
+
+    /* Cleanup OpenSSL engine tables */
+    ngx_ssl_engine_table_cleanup(e);
+
+    if (!ENGINE_init(e)) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0, "engine init failed");
+        ENGINE_free(e);
+        return NGX_ERROR;
+    }
+
+    if (secf->default_algorithms != NGX_CONF_UNSET_PTR) {
+        value = secf->default_algorithms->elts;
+        for (i = 0; i < secf->default_algorithms->nelts; i++) {
+            if (!ENGINE_set_default_string(e, (const char *) value[i].data)) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "ENGINE_set_default_string failed");
+                ENGINE_free(e);
+                return NGX_ERROR;
+            }
+        }
+    } else {
+        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "ENGINE_set_default failed");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    ENGINE_free(e);
+    return NGX_OK;
+}
+
+
+static char *
+ngx_ssl_engine_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    void         ***ctx;
+    ngx_uint_t      i;
+    ngx_uint_t      ngx_ssl_engine_max_module;
+    ngx_conf_t      pcf;
+
+    ngx_ssl_engine_module_t     *m;
+
+    if (*(void **) conf) {
+        return "is duplicate";
+    }
+
+    /* count the number of the engine modules and set up their indices */
+
+    ngx_ssl_engine_max_module = ngx_count_modules(cf->cycle,
+                                                  NGX_SSL_ENGINE_MODULE);
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(void *));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *ctx = ngx_pcalloc(cf->pool, ngx_ssl_engine_max_module * sizeof(void *));
+    if (*ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *(void **) conf = ctx;
+
+    for (i = 0; cf->cycle->modules[i]; i++) {
+        if (cf->cycle->modules[i]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        m = cf->cycle->modules[i]->ctx;
+
+        if (m->create_conf) {
+            (*ctx)[cf->cycle->modules[i]->ctx_index] =
+                                                     m->create_conf(cf->cycle);
+            if ((*ctx)[cf->cycle->modules[i]->ctx_index] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+    }
+
+    pcf = *cf;
+    cf->ctx = ctx;
+    cf->module_type = NGX_SSL_ENGINE_MODULE;
+    cf->cmd_type = NGX_SSL_ENGINE_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    for (i = 0; cf->cycle->modules[i]; i++) {
+        if (cf->cycle->modules[i]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        m = cf->cycle->modules[i]->ctx;
+
+        if (m->init_conf) {
+            rv = m->init_conf(cf->cycle,
+                              (*ctx)[cf->cycle->modules[i]->ctx_index]);
+            if (rv != NGX_CONF_OK) {
+                return rv;
+            }
+        }
+    }
+
+    /* ssl engine set must before parsing http conf */
+    if (ngx_use_ssl_engine && !cf->cycle->no_ssl_init) {
+        if (ngx_ssl_engine_set(cf->cycle) != NGX_OK) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0, "ssl engine set failed");
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_ssl_engine_init_check(ngx_cycle_t *cycle, void *conf)
+{
+    return ngx_ssl_engine_unload_check(cycle);
+}
+
+static ngx_int_t
+ngx_ssl_engine_process_init(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_unload_check(cycle);
+
+    if (ngx_use_ssl_engine) {
+        if (ngx_ssl_engine_register_handler(cycle) != NGX_OK) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "ssl engine register handler failed");
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_master_exit(ngx_cycle_t *cycle)
+{
+#if OPENSSL_VERSION_NUMBER < 0x10100003L
+    EVP_cleanup();
+#endif
+    ENGINE_cleanup();
+}
+
+
+static char *
+ngx_ssl_engine_use(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_ssl_engine_conf_t  *secf = conf;
+
+    ngx_int_t                 m;
+    ngx_str_t                *value;
+    ngx_ssl_engine_module_t  *module;
+
+    if (secf->ssl_engine_id.len != 0) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    for (m = 0; cf->cycle->modules[m]; m++) {
+        if (cf->cycle->modules[m]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        module = cf->cycle->modules[m]->ctx;
+        if (module->name->len == value[1].len) {
+            if (ngx_strcmp(module->name->data, value[1].data) == 0) {
+                if (3 == cf->args->nelts) {
+                    secf->ssl_engine_id = value[2];
+                } else {
+                    secf->ssl_engine_id = value[1];
+                }
+                ngx_use_ssl_engine = 1;
+                ngx_ssl_engine_actions = module->actions;
+
+                ngx_ssl_engine_name_record(module->name, cf->pool);
+
+                return NGX_CONF_OK;
+            }
+        }
+    }
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid engine type \"%V\"", &value[1]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static char *
+ngx_ssl_engine_default_algorithms(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t          *value, *s;
+    ngx_array_t       **a;
+    ngx_uint_t          i;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NGX_CONF_UNSET_PTR) {
+        *a = ngx_array_create(cf->pool, cf->args->nelts - 1, sizeof(ngx_str_t));
+        if (*a == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+        s = ngx_array_push(*a);
+        if (s == NULL) {
+            return NGX_CONF_ERROR;
+        }
+        *s = value[i];
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_core_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_conf_t  *secf;
+
+    secf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_conf_t));
+    if (secf == NULL) {
+        return NULL;
+    }
+
+    /* ngx_pcalloc makes secf->ssl_engine_id.len = 0 */
+    ngx_use_ssl_engine = 0;
+    ngx_ssl_engine_enable_heuristic_polling = 0;
+    secf->default_algorithms = NGX_CONF_UNSET_PTR;
+
+    return secf;
+}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/engine/ngx_ssl_engine.h ../asynch_mode_nginx/src/engine/ngx_ssl_engine.h
--- nginx-release-1.20.1/src/engine/ngx_ssl_engine.h	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/src/engine/ngx_ssl_engine.h	2022-03-15 13:23:40.544402876 -0500
@@ -0,0 +1,101 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#ifndef _NGX_ENGINE_H_INCLUDED_
+#define _NGX_ENGINE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+typedef struct {
+    ngx_int_t  (*init)(ngx_cycle_t *cycle);
+    ngx_int_t  (*send_ctrl)(ngx_cycle_t *cycle);
+    ngx_int_t  (*register_handler)(ngx_cycle_t *cycle);
+    ngx_int_t  (*release)(ngx_cycle_t *cycle);
+    void       (*heuristic_poll)(ngx_log_t *log);
+} ngx_ssl_engine_actions_t;
+
+extern ngx_uint_t                       ngx_use_ssl_engine;
+extern ngx_ssl_engine_actions_t         ngx_ssl_engine_actions;
+extern ngx_uint_t                       ngx_ssl_engine_enable_heuristic_polling;
+extern ngx_flag_t                       ngx_ssl_engine_reload_processed;
+
+#define ngx_ssl_engine_init             ngx_ssl_engine_actions.init
+#define ngx_ssl_engine_send_ctrl        ngx_ssl_engine_actions.send_ctrl
+#define ngx_ssl_engine_register_handler ngx_ssl_engine_actions.register_handler
+#define ngx_ssl_engine_release          ngx_ssl_engine_actions.release
+#define ngx_ssl_engine_heuristic_poll   ngx_ssl_engine_actions.heuristic_poll
+
+#define NGX_SSL_ENGINE_MODULE           0x55555555
+#define NGX_SSL_ENGINE_CONF             0x02000000
+#define NGX_SSL_ENGINE_SUB_CONF         0x04000000
+
+typedef struct {
+    ngx_str_t        ssl_engine_id;
+    ngx_array_t     *default_algorithms;
+} ngx_ssl_engine_conf_t;
+
+
+typedef struct {
+    ngx_str_t                  *name;
+
+    void                     *(*create_conf)(ngx_cycle_t *cycle);
+    char                     *(*init_conf)(ngx_cycle_t *cycle, void *conf);
+
+    ngx_ssl_engine_actions_t    actions;
+} ngx_ssl_engine_module_t;
+
+
+extern ngx_module_t     ngx_ssl_engine_module;
+extern ngx_module_t     ngx_ssl_engine_core_module;
+
+
+#define ngx_engine_ctx_get_conf(conf_ctx, module)                          \
+    (*(ngx_get_conf(conf_ctx, ngx_ssl_engine_module))) [module.ctx_index];
+
+#define ngx_engine_cycle_get_conf(cycle, module)                           \
+    (cycle->conf_ctx[ngx_ssl_engine_module.index] ?                        \
+        (*(ngx_get_conf(cycle->conf_ctx, ngx_ssl_engine_module)))          \
+            [module.ctx_index]:                                            \
+        NULL)
+
+char * ngx_ssl_engine_unload_check(ngx_cycle_t *cycle);
+
+#endif /* _NGX_ENGINE_H_INCLUDED_ */
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_devpoll_module.c ../asynch_mode_nginx/src/event/modules/ngx_devpoll_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_devpoll_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_devpoll_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -94,6 +95,8 @@
         ngx_devpoll_process_events,        /* process the events */
         ngx_devpoll_init,                  /* init the events */
         ngx_devpoll_done,                  /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }
 
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_epoll_module.c ../asynch_mode_nginx/src/event/modules/ngx_epoll_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_epoll_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_epoll_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -122,6 +123,11 @@
 #endif
 static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
     ngx_uint_t flags);
+#if (NGX_SSL)
+static ngx_int_t ngx_epoll_add_async_connection(ngx_connection_t *c);
+static ngx_int_t ngx_epoll_del_async_connection(ngx_connection_t *c,
+    ngx_uint_t flags);
+#endif
 
 #if (NGX_HAVE_FILE_AIO)
 static void ngx_epoll_eventfd_handler(ngx_event_t *ev);
@@ -196,6 +202,13 @@
         ngx_epoll_process_events,        /* process the events */
         ngx_epoll_init,                  /* init the events */
         ngx_epoll_done,                  /* done the events */
+#if (NGX_SSL)
+        ngx_epoll_add_async_connection,  /* add an async conn */
+        ngx_epoll_del_async_connection   /* del an async conn */
+#else
+        NULL,                            /* add an async conn */
+        NULL                             /* del an async conn */
+#endif
     }
 };
 
@@ -623,13 +636,11 @@
     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                    "epoll add event: fd:%d op:%d ev:%08XD",
                    c->fd, op, ee.events);
-
     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                      "socket add event epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }
-
     ev->active = 1;
 #if 0
     ev->oneshot = (flags & NGX_ONESHOT_EVENT) ? 1 : 0;
@@ -684,13 +695,11 @@
     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                    "epoll del event: fd:%d op:%d ev:%08XD",
                    c->fd, op, ee.events);
-
     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                      "socket del event epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }
-
     ev->active = 0;
 
     return NGX_OK;
@@ -707,13 +716,11 @@
 
     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                    "epoll add connection: fd:%d ev:%08XD", c->fd, ee.events);
-
     if (epoll_ctl(ep, EPOLL_CTL_ADD, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
-                      "epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
+                      "socket add_conn epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
         return NGX_ERROR;
     }
-
     c->read->active = 1;
     c->write->active = 1;
 
@@ -748,7 +755,7 @@
 
     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                     "socket del conn epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }
 
@@ -758,6 +765,53 @@
     return NGX_OK;
 }
 
+#if (NGX_SSL)
+static ngx_int_t
+ngx_epoll_add_async_connection(ngx_connection_t *c)
+{
+    struct epoll_event  ee;
+
+    ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;
+    ee.data.ptr = (void *) ((uintptr_t) c | (c->async->async << 1) | c->async->instance);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "epoll add async connection: fd:%d ev:%08XD", c->async_fd, ee.events);
+    if (epoll_ctl(ep, EPOLL_CTL_ADD, c->async_fd, &ee) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
+                      "async add conn epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->async_fd);
+        return NGX_ERROR;
+    }
+
+    c->async->active = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_epoll_del_async_connection(ngx_connection_t *c, ngx_uint_t flags)
+{
+    int                 op;
+    struct epoll_event  ee;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "epoll del async connection: fd:%d", c->async_fd);
+
+    op = EPOLL_CTL_DEL;
+    ee.events = 0;
+    ee.data.ptr = NULL;
+    if (epoll_ctl(ep, op, c->async_fd, &ee) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
+                      "async del conn epoll_ctl(%d, %d) failed", op, c->async_fd);
+        c->async_fd = -1;
+        return NGX_ERROR;
+    }
+    c->async_fd = -1;
+    c->async->active = 0;
+
+    return NGX_OK;
+}
+#endif
 
 #if (NGX_HAVE_EVENTFD)
 
@@ -791,6 +845,10 @@
     ngx_event_t       *rev, *wev;
     ngx_queue_t       *queue;
     ngx_connection_t  *c;
+#if (NGX_SSL)
+    ngx_int_t          async;
+    ngx_event_t       *aev;
+#endif
 
     /* NGX_TIMER_INFINITE == INFTIM */
 
@@ -837,7 +895,12 @@
         c = event_list[i].data.ptr;
 
         instance = (uintptr_t) c & 1;
+#if (NGX_SSL)
+        async = ((uintptr_t) c & 2) >> 1;
+        c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~3);
+#else
         c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~1);
+#endif
 
         rev = c->read;
 
@@ -880,7 +943,11 @@
         }
 #endif
 
+#if (NGX_SSL)
+        if ((revents & EPOLLIN) && rev->active && !async) {
+#else
         if ((revents & EPOLLIN) && rev->active) {
+#endif
 
 #if (NGX_HAVE_EPOLLRDHUP)
             if (revents & EPOLLRDHUP) {
@@ -904,7 +971,11 @@
 
         wev = c->write;
 
+#if (NGX_SSL)
+        if ((revents & EPOLLOUT) && wev->active && !async) {
+#else
         if ((revents & EPOLLOUT) && wev->active) {
+#endif
 
             if (c->fd == -1 || wev->instance != instance) {
 
@@ -930,6 +1001,33 @@
                 wev->handler(wev);
             }
         }
+
+#if (NGX_SSL)
+        aev = c->async;
+
+        if ((revents & EPOLLIN) && aev->active && async) {
+
+            if (c->async_fd == -1 || aev->instance!= instance) {
+                /*
+                 * the stale event from a file descriptor
+                 * that was just closed in this iteration
+                 */
+
+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
+                               "epoll: stale event %p", c);
+                continue;
+            }
+
+            aev->ready = 1;
+
+            if (flags & NGX_POST_EVENTS) {
+                ngx_post_event(aev, &ngx_posted_events);
+
+            } else {
+                aev->handler(aev);
+            }
+        }
+#endif
     }
 
     return NGX_OK;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_eventport_module.c ../asynch_mode_nginx/src/event/modules/ngx_eventport_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_eventport_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_eventport_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -187,6 +188,8 @@
         ngx_eventport_process_events,      /* process the events */
         ngx_eventport_init,                /* init the events */
         ngx_eventport_done,                /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }
 
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_iocp_module.c ../asynch_mode_nginx/src/event/modules/ngx_iocp_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_iocp_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_iocp_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -52,7 +52,7 @@
 };
 
 
-static ngx_event_module_t  ngx_iocp_module_ctx = {
+ngx_event_module_t  ngx_iocp_module_ctx = {
     &iocp_name,
     ngx_iocp_create_conf,                  /* create configuration */
     ngx_iocp_init_conf,                    /* init configuration */
@@ -93,8 +93,6 @@
     NULL,
     ngx_udp_overlapped_wsarecv,
     NULL,
-    NULL,
-    NULL,
     ngx_overlapped_wsasend_chain,
     0
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_kqueue_module.c ../asynch_mode_nginx/src/event/modules/ngx_kqueue_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_kqueue_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_kqueue_module.c	2022-03-15 13:23:40.544402876 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -34,6 +35,11 @@
     ngx_uint_t flags);
 static ngx_inline void ngx_kqueue_dump_event(ngx_log_t *log,
     struct kevent *kev);
+#if (NGX_SSL)
+static ngx_int_t ngx_kqueue_add_async_connection(ngx_connection_t *c);
+static ngx_int_t ngx_kqueue_del_async_connection(ngx_connection_t *c,
+    ngx_uint_t flags);
+#endif
 
 static void *ngx_kqueue_create_conf(ngx_cycle_t *cycle);
 static char *ngx_kqueue_init_conf(ngx_cycle_t *cycle, void *conf);
@@ -92,7 +98,14 @@
 #endif
         ngx_kqueue_process_events,         /* process the events */
         ngx_kqueue_init,                   /* init the events */
-        ngx_kqueue_done                    /* done the events */
+        ngx_kqueue_done,                   /* done the events */
+#if (NGX_SSL)
+        ngx_kqueue_add_async_connection,   /* add an async conn */
+        ngx_kqueue_del_async_connection    /* del an async conn */
+#else
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
+#endif
     }
 
 };
@@ -421,7 +434,16 @@
 
     kev = &change_list[nchanges];
 
+#if (NGX_SSL)
+    if (ev->async) {
+        kev->ident = c->async_fd;
+    }
+    else {
+        kev->ident = c->fd;
+    }
+#else
     kev->ident = c->fd;
+#endif
     kev->filter = (short) filter;
     kev->flags = (u_short) flags;
     kev->udata = NGX_KQUEUE_UDATA_T ((uintptr_t) ev | ev->instance);
@@ -492,7 +514,67 @@
 }
 
 #endif
+#if (NGX_SSL)
+static ngx_int_t
+ngx_kqueue_add_async_connection(ngx_connection_t *c)
+{
+    ngx_int_t          rc;
+    c->async->active = 1;
+    c->async->disabled = 0;
+
+    rc = ngx_kqueue_set_event(c->async, EVFILT_READ, EV_ADD|EV_ENABLE);
 
+    return rc;
+}
+
+static ngx_int_t
+ngx_kqueue_del_async_connection(ngx_connection_t *c, ngx_uint_t flags)
+{
+    ngx_int_t     rc;
+    ngx_event_t  *e;
+
+    c->async->active = 0;
+    c->async->disabled = 0;
+
+    if (c->async->index < nchanges
+        && ((uintptr_t) change_list[c->async->index].udata & (uintptr_t) ~1)
+            == (uintptr_t) c->async)
+    {
+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->async->log, 0,
+                       "async kevent deleted: %d: ft:%i",
+                       ngx_event_ident(c->async->data), EVFILT_READ);
+        /* if the event is still not passed to a kernel we will not pass it */
+        nchanges--;
+
+        if (c->async->index < nchanges) {
+            e = (ngx_event_t *)
+                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
+            change_list[c->async->index] = change_list[nchanges];
+            e->index = c->async->index;
+        }
+
+        return NGX_OK;
+    }
+
+    if (flags & NGX_CLOSE_EVENT) {
+        return NGX_OK;
+    }
+
+    if (flags & NGX_DISABLE_EVENT) {
+        c->async->disabled = 1;
+
+    } else {
+        flags |= EV_DELETE;
+    }
+
+    flags |= NGX_FLUSH_EVENT;
+    rc = ngx_kqueue_set_event(c->async, EVFILT_READ, flags);
+
+    c->async_fd = -1;
+
+    return rc;
+}
+#endif
 
 static ngx_int_t
 ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_poll_module.c ../asynch_mode_nginx/src/event/modules/ngx_poll_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_poll_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_poll_module.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -42,7 +43,9 @@
         NULL,                              /* trigger a notify */
         ngx_poll_process_events,           /* process the events */
         ngx_poll_init,                     /* init the events */
-        ngx_poll_done                      /* done the events */
+        ngx_poll_done,                     /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }
 
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_select_module.c ../asynch_mode_nginx/src/event/modules/ngx_select_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_select_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_select_module.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -50,7 +51,9 @@
         NULL,                              /* trigger a notify */
         ngx_select_process_events,         /* process the events */
         ngx_select_init,                   /* init the events */
-        ngx_select_done                    /* done the events */
+        ngx_select_done,                   /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }
 
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/modules/ngx_win32_select_module.c ../asynch_mode_nginx/src/event/modules/ngx_win32_select_module.c
--- nginx-release-1.20.1/src/event/modules/ngx_win32_select_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/modules/ngx_win32_select_module.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -52,7 +53,9 @@
         NULL,                              /* trigger a notify */
         ngx_select_process_events,         /* process the events */
         ngx_select_init,                   /* init the events */
-        ngx_select_done                    /* done the events */
+        ngx_select_done,                   /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }
 
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event_accept.c ../asynch_mode_nginx/src/event/ngx_event_accept.c
--- nginx-release-1.20.1/src/event/ngx_event_accept.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event_accept.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,18 +2,19 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>
 
 
 static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all);
 static void ngx_close_accepted_connection(ngx_connection_t *c);
 
-
 void
 ngx_event_accept(ngx_event_t *ev)
 {
@@ -244,6 +245,9 @@
 
         rev->log = log;
         wev->log = log;
+#if (NGX_SSL)
+        c->async->log = log;
+#endif
 
         /*
          * TODO: MT: - ngx_atomic_fetch_add()
@@ -409,6 +413,15 @@
 
 #endif
 
+#if (NGX_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
+
         if (ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT)
             == NGX_ERROR)
         {
@@ -442,6 +455,14 @@
 #if (NGX_STAT_STUB)
     (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
 #endif
+
+#if (NGX_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
 }
 
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event_acceptex.c ../asynch_mode_nginx/src/event/ngx_event_acceptex.c
--- nginx-release-1.20.1/src/event/ngx_event_acceptex.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event_acceptex.c	2022-03-15 13:23:40.548402910 -0500
@@ -41,8 +41,8 @@
         ngx_log_error(NGX_LOG_CRIT, c->log, ngx_socket_errno,
                       "setsockopt(SO_UPDATE_ACCEPT_CONTEXT) failed for %V",
                       &c->addr_text);
-        /* TODO: close socket */
-        return;
+    } else {
+        c->accept_context_updated = 1;
     }
 
     ngx_getacceptexsockaddrs(c->buffer->pos,
@@ -161,6 +161,8 @@
         c->recv_chain = ngx_recv_chain;
         c->send_chain = ngx_send_chain;
 
+        c->unexpected_eof = 1;
+
         c->listening = ls;
 
         rev = c->read;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event.c ../asynch_mode_nginx/src/event/ngx_event.c
--- nginx-release-1.20.1/src/event/ngx_event.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -77,6 +78,10 @@
 #endif
 
 
+ngx_atomic_t   ngx_ssl_active0 = 0;
+ngx_atomic_t  *ngx_ssl_active = &ngx_ssl_active0;
+
+
 
 static ngx_command_t  ngx_events_commands[] = {
 
@@ -170,7 +175,7 @@
     ngx_event_core_create_conf,            /* create configuration */
     ngx_event_core_init_conf,              /* init configuration */
 
-    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
+    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
 
@@ -612,6 +617,9 @@
 {
     ngx_uint_t           m, i;
     ngx_event_t         *rev, *wev;
+#if (NGX_SSL)
+    ngx_event_t         *aev;
+#endif
     ngx_listening_t     *ls;
     ngx_connection_t    *c, *next, *old;
     ngx_core_conf_t     *ccf;
@@ -755,6 +763,20 @@
         wev[i].closed = 1;
     }
 
+#if (NGX_SSL)
+    cycle->async_events = ngx_alloc(sizeof(ngx_event_t) * cycle->connection_n,
+                                    cycle->log);
+    if (cycle->async_events == NULL) {
+        return NGX_ERROR;
+    }
+
+    aev = cycle->async_events;
+    for (i = 0; i < cycle->connection_n; i++) {
+        aev[i].closed = 1;
+        aev[i].instance = 1;
+    }
+#endif
+
     i = cycle->connection_n;
     next = NULL;
 
@@ -765,6 +787,10 @@
         c[i].read = &cycle->read_events[i];
         c[i].write = &cycle->write_events[i];
         c[i].fd = (ngx_socket_t) -1;
+#if (NGX_SSL)
+        c[i].async = &cycle->async_events[i];
+        c[i].async_fd = (ngx_socket_t) -1;
+#endif
 
         next = &c[i];
     } while (i);
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event_connect.c ../asynch_mode_nginx/src/event/ngx_event_connect.c
--- nginx-release-1.20.1/src/event/ngx_event_connect.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event_connect.c	2022-03-15 13:23:40.548402910 -0500
@@ -188,6 +188,9 @@
 
     rev->log = pc->log;
     wev->log = pc->log;
+#if (NGX_SSL)
+    c->async->log = pc->log;
+#endif
 
     pc->connection = c;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event.h ../asynch_mode_nginx/src/event/ngx_event.h
--- nginx-release-1.20.1/src/event/ngx_event.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event.h	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -32,6 +33,10 @@
 
     unsigned         write:1;
 
+#if (NGX_SSL)
+    unsigned         async:1;
+#endif
+
     unsigned         accept:1;
 
     /* used to detect the stale events in kqueue and epoll */
@@ -101,6 +106,9 @@
     int              available;
 
     ngx_event_handler_pt  handler;
+#if (NGX_SSL)
+    ngx_event_handler_pt  saved_handler;
+#endif
 
 
 #if (NGX_HAVE_IOCP)
@@ -184,6 +192,9 @@
 
     ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
     void       (*done)(ngx_cycle_t *cycle);
+
+    ngx_int_t  (*add_async_conn)(ngx_connection_t *c);
+    ngx_int_t  (*del_async_conn)(ngx_connection_t *c, ngx_uint_t flags);
 } ngx_event_actions_t;
 
 
@@ -408,6 +419,8 @@
 #define ngx_del_event        ngx_event_actions.del
 #define ngx_add_conn         ngx_event_actions.add_conn
 #define ngx_del_conn         ngx_event_actions.del_conn
+#define ngx_add_async_conn   ngx_event_actions.add_async_conn
+#define ngx_del_async_conn   ngx_event_actions.del_async_conn
 
 #define ngx_notify           ngx_event_actions.notify
 
@@ -481,6 +494,9 @@
 #endif
 
 
+extern ngx_atomic_t  *ngx_ssl_active;
+
+
 #define NGX_UPDATE_TIME         1
 #define NGX_POST_EVENTS         2
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event_openssl.c ../asynch_mode_nginx/src/event/ngx_event_openssl.c
--- nginx-release-1.20.1/src/event/ngx_event_openssl.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event_openssl.c	2022-03-15 13:23:40.548402910 -0500
@@ -2,22 +2,19 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>
 
 
 #define NGX_SSL_PASSWORD_BUFFER_SIZE  4096
 
 
-typedef struct {
-    ngx_uint_t  engine;   /* unsigned  engine:1; */
-} ngx_openssl_conf_t;
-
-
 static X509 *ngx_ssl_load_certificate(ngx_pool_t *pool, char **err,
     ngx_str_t *cert, STACK_OF(X509) **chain);
 static EVP_PKEY *ngx_ssl_load_certificate_key(ngx_pool_t *pool, char **err,
@@ -85,56 +82,39 @@
 #endif
     ASN1_TIME *asn1time, ngx_log_t *log);
 
-static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);
-static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
-static void ngx_openssl_exit(ngx_cycle_t *cycle);
-
-
-static ngx_command_t  ngx_openssl_commands[] = {
-
-    { ngx_string("ssl_engine"),
-      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
-      ngx_openssl_engine,
-      0,
-      0,
-      NULL },
-
-      ngx_null_command
-};
-
-
-static ngx_core_module_t  ngx_openssl_module_ctx = {
-    ngx_string("openssl"),
-    ngx_openssl_create_conf,
-    NULL
-};
-
-
-ngx_module_t  ngx_openssl_module = {
-    NGX_MODULE_V1,
-    &ngx_openssl_module_ctx,               /* module context */
-    ngx_openssl_commands,                  /* module directives */
-    NGX_CORE_MODULE,                       /* module type */
-    NULL,                                  /* init master */
-    NULL,                                  /* init module */
-    NULL,                                  /* init process */
-    NULL,                                  /* init thread */
-    NULL,                                  /* exit thread */
-    NULL,                                  /* exit process */
-    ngx_openssl_exit,                      /* exit master */
-    NGX_MODULE_V1_PADDING
-};
-
-
-int  ngx_ssl_connection_index;
-int  ngx_ssl_server_conf_index;
-int  ngx_ssl_session_cache_index;
-int  ngx_ssl_session_ticket_keys_index;
-int  ngx_ssl_ocsp_index;
-int  ngx_ssl_certificate_index;
-int  ngx_ssl_next_certificate_index;
-int  ngx_ssl_certificate_name_index;
-int  ngx_ssl_stapling_index;
+static void ngx_ssl_handshake_async_handler(ngx_event_t * aev);
+static void ngx_ssl_read_async_handler(ngx_event_t * aev);
+static void ngx_ssl_write_async_handler(ngx_event_t * aev);
+static void ngx_ssl_shutdown_async_handler(ngx_event_t *aev);
+
+
+#define NGX_ASYNC_EVENT_TIMEOUT 10000
+
+
+int  ngx_ssl_connection_index = -1;
+int  ngx_ssl_server_conf_index = -1;
+int  ngx_ssl_session_cache_index = -1;
+int  ngx_ssl_session_ticket_keys_index = -1;
+int  ngx_ssl_ocsp_index = -1;
+int  ngx_ssl_certificate_index = -1;
+int  ngx_ssl_next_certificate_index = -1;
+int  ngx_ssl_certificate_name_index = -1;
+int  ngx_ssl_stapling_index = -1;
+
+
+static void
+ngx_ssl_empty_handler(ngx_event_t *ev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0, "ssl empty handler");
+
+    if(ev->timedout &&
+       ev->saved_handler &&
+       ev->saved_handler != ngx_ssl_empty_handler ) {
+        ev->saved_handler(ev);
+    }
+
+    return;
+}
 
 
 ngx_int_t
@@ -154,6 +134,8 @@
 
     ERR_clear_error();
 
+    ENGINE_load_builtin_engines();
+    ENGINE_load_dynamic();
 #else
 
     OPENSSL_config(NULL);
@@ -386,6 +368,10 @@
     SSL_CTX_set_mode(ssl->ctx, SSL_MODE_NO_AUTO_CHAIN);
 #endif
 
+    if(ssl->asynch) {
+        SSL_CTX_set_mode(ssl->ctx, SSL_MODE_ASYNC);
+    }
+
     SSL_CTX_set_read_ahead(ssl->ctx, 1);
 
     SSL_CTX_set_info_callback(ssl->ctx, ngx_ssl_info_callback);
@@ -426,6 +412,8 @@
     EVP_PKEY        *pkey;
     STACK_OF(X509)  *chain;
 
+    ngx_ssl_engine_unload_check(cf->cycle);
+
     x509 = ngx_ssl_load_certificate(cf->pool, &err, cert, &chain);
     if (x509 == NULL) {
         if (err != NULL) {
@@ -465,6 +453,7 @@
     }
 
     if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, x509) == 0) {
+
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                       "SSL_CTX_set_ex_data() failed");
         X509_free(x509);
@@ -1619,6 +1608,24 @@
 
     sc->session_ctx = ssl->ctx;
 
+    if (ssl->max_pipelines > 0) {
+        SSL_CTX_set_max_pipelines(ssl->ctx, ssl->max_pipelines);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set max_pipelines = %d", ssl->max_pipelines);
+    }
+
+    if (ssl->split_send_fragment > 0) {
+        SSL_CTX_set_split_send_fragment(ssl->ctx, ssl->split_send_fragment);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set split_send_fragment = %d", ssl->split_send_fragment);
+    }
+
+    if (ssl->max_send_fragment > 0) {
+        SSL_CTX_set_max_send_fragment(ssl->ctx, ssl->max_send_fragment);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set max_send_fragment = %d", ssl->max_send_fragment);
+    }
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
     if (SSL_CTX_get_max_early_data(ssl->ctx)) {
         sc->try_early_data = 1;
@@ -1655,6 +1662,12 @@
 
     c->ssl = sc;
 
+    if(ssl->asynch && !c->asynch) {
+        c->asynch = ssl->asynch;
+    } else if (c->asynch) {
+        SSL_set_mode(sc->connection,SSL_MODE_ASYNC);
+    }
+
     return NGX_OK;
 }
 
@@ -1697,6 +1710,82 @@
     return NGX_OK;
 }
 
+ngx_int_t
+ngx_ssl_async_process_fds(ngx_connection_t *c)
+{
+    OSSL_ASYNC_FD *add_fds = NULL;
+    OSSL_ASYNC_FD *del_fds = NULL;
+    size_t        num_add_fds = 0;
+    size_t        num_del_fds = 0;
+    unsigned      loop = 0;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "ngx_ssl_async_process_fds called");
+
+    if (!ngx_del_async_conn || !ngx_add_async_conn) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                      "Async notifications not supported");
+        return 0;
+    }
+
+    SSL_get_changed_async_fds(c->ssl->connection, NULL, &num_add_fds,
+                              NULL, &num_del_fds);
+
+    if (num_add_fds) {
+        add_fds = ngx_alloc(num_add_fds * sizeof(OSSL_ASYNC_FD), c->log);
+        if (add_fds == NULL) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                          "Memory Allocation Error");
+            return 0;
+        }
+    }
+
+    if (num_del_fds) {
+        del_fds = ngx_alloc(num_del_fds * sizeof(OSSL_ASYNC_FD), c->log);
+        if (del_fds == NULL) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                          "Memory Allocation Error");
+            if (add_fds)
+                ngx_free(add_fds);
+            return 0;
+        }
+    }
+
+    SSL_get_changed_async_fds(c->ssl->connection, add_fds, &num_add_fds,
+                              del_fds, &num_del_fds);
+
+    if (num_del_fds) {
+        for (loop = 0; loop < num_del_fds; loop++) {
+            c->async_fd = del_fds[loop];
+            if (c->num_async_fds) {
+                ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0, "%s: deleting fd = %d", __func__, c->async_fd);
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+    }
+    if (num_add_fds) {
+        for (loop = 0; loop < num_add_fds; loop++) {
+            if (c->num_async_fds == 0) {
+                c->num_async_fds++;
+                c->async_fd = add_fds[loop];
+                ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0, "%s: adding fd = %d", __func__, c->async_fd);
+                ngx_add_async_conn(c);
+            }
+        }
+    }
+
+    if (add_fds)
+        ngx_free(add_fds);
+    if (del_fds)
+        ngx_free(del_fds);
+
+    if (ngx_ssl_engine_enable_heuristic_polling) {
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+
+    return 1;
+}
 
 ngx_int_t
 ngx_ssl_handshake(ngx_connection_t *c)
@@ -1705,6 +1794,10 @@
     ngx_err_t  err;
     ngx_int_t  rc;
 
+    if (c->asynch && !c->async->handler) {
+        c->async->handler = ngx_ssl_empty_handler;
+    }
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
     if (c->ssl->try_early_data) {
         return ngx_ssl_try_early_data(c);
@@ -1723,6 +1816,10 @@
 
     if (n == 1) {
 
+        if(c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
         }
@@ -1762,6 +1859,9 @@
         if (rc == NGX_AGAIN) {
             c->read->handler = ngx_ssl_handshake_handler;
             c->write->handler = ngx_ssl_handshake_handler;
+            if (c->asynch) {
+                c->async->handler = ngx_ssl_handshake_async_handler;
+            }
             return NGX_AGAIN;
         }
 
@@ -1775,6 +1875,9 @@
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
 
     if (sslerr == SSL_ERROR_WANT_READ) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1791,6 +1894,9 @@
     }
 
     if (sslerr == SSL_ERROR_WANT_WRITE) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->write->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1806,6 +1912,32 @@
         return NGX_AGAIN;
     }
 
+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC)
+    {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_handshake_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        if (c->write->handler != ngx_ssl_empty_handler) {
+            c->write->saved_handler = c->write->handler;
+            c->write->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT recieved: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
 
     c->ssl->no_wait_shutdown = 1;
@@ -1860,6 +1992,9 @@
     }
 
     if (n == SSL_READ_EARLY_DATA_SUCCESS) {
+        if(c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
 
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
@@ -1894,6 +2029,9 @@
         if (rc == NGX_AGAIN) {
             c->read->handler = ngx_ssl_handshake_handler;
             c->write->handler = ngx_ssl_handshake_handler;
+            if (c->asynch) {
+                c->async->handler = ngx_ssl_handshake_async_handler;
+            }
             return NGX_AGAIN;
         }
 
@@ -1909,6 +2047,9 @@
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
 
     if (sslerr == SSL_ERROR_WANT_READ) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1925,6 +2066,9 @@
     }
 
     if (sslerr == SSL_ERROR_WANT_WRITE) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->write->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1939,6 +2083,32 @@
 
         return NGX_AGAIN;
     }
+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC)
+    {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_handshake_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        if (c->write->handler != ngx_ssl_empty_handler) {
+            c->write->saved_handler = c->write->handler;
+            c->write->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT recieved: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+
+        return NGX_AGAIN;
+    }
 
     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
 
@@ -2020,6 +2190,41 @@
 
 
 static void
+ngx_ssl_handshake_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL handshake async handler");
+
+    if (!aev->ready && aev->timedout) {
+        c->ssl->handler(c);
+        return;
+    }
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (c->write->saved_handler != ngx_ssl_empty_handler) {
+        c->write->handler = c->write->saved_handler;
+        c->write->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
+        return;
+    }
+
+    c->ssl->handler(c);
+}
+
+
+static void
 ngx_ssl_handshake_handler(ngx_event_t *ev)
 {
     ngx_connection_t  *c;
@@ -2368,6 +2573,23 @@
 
         ngx_log_error(NGX_LOG_NOTICE, c->log, 0, "SSL renegotiation disabled");
 
+        if (c->asynch \
+            && SSL_get_error(c->ssl->connection, n) == SSL_ERROR_WANT_ASYNC) {
+            c->async->ready = 0;
+            c->async->handler = ngx_ssl_read_async_handler;
+            if (c->read->handler != ngx_ssl_empty_handler) {
+                c->read->saved_handler = c->read->handler;
+                c->read->handler = ngx_ssl_empty_handler;
+            }
+            ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+            if (ngx_ssl_async_process_fds(c) == 0) {
+                return NGX_ERROR;
+            }
+
+            return NGX_AGAIN;
+        }
+
         while (ERR_peek_error()) {
             ngx_ssl_error(NGX_LOG_DEBUG, c->log, 0,
                           "ignoring stale global SSL error");
@@ -2385,6 +2607,10 @@
 
     if (n > 0) {
 
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_write_handler) {
 
             c->write->handler = c->ssl->saved_write_handler;
@@ -2402,13 +2628,16 @@
     }
 
     sslerr = SSL_get_error(c->ssl->connection, n);
-
     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
 
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
 
     if (sslerr == SSL_ERROR_WANT_READ) {
 
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_write_handler) {
 
             c->write->handler = c->ssl->saved_write_handler;
@@ -2428,8 +2657,12 @@
 
     if (sslerr == SSL_ERROR_WANT_WRITE) {
 
-        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
-                       "SSL_read: want write");
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");
+
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
 
         c->write->ready = 0;
 
@@ -2449,6 +2682,26 @@
         return NGX_AGAIN;
     }
 
+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC) {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_read_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT recieved: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     c->ssl->no_wait_shutdown = 1;
     c->ssl->no_send_shutdown = 1;
 
@@ -2465,6 +2718,32 @@
 
 
 static void
+ngx_ssl_read_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    if (c->destroyed) {
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL read async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    c->read->ready = 1;
+    c->read->handler(c->read);
+}
+
+
+static void
 ngx_ssl_write_handler(ngx_event_t *wev)
 {
     ngx_connection_t  *c;
@@ -2662,6 +2941,10 @@
 
     if (n > 0) {
 
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_read_handler) {
 
             c->read->handler = c->ssl->saved_read_handler;
@@ -2700,6 +2983,10 @@
 
     if (sslerr == SSL_ERROR_WANT_WRITE) {
 
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_read_handler) {
 
             c->read->handler = c->ssl->saved_read_handler;
@@ -2719,9 +3006,12 @@
 
     if (sslerr == SSL_ERROR_WANT_READ) {
 
-        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
-                       "SSL_write: want read");
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");
 
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;
 
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
@@ -2741,6 +3031,26 @@
         return NGX_AGAIN;
     }
 
+    if(c->asynch && sslerr == SSL_ERROR_WANT_ASYNC) {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_write_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT recieved: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     c->ssl->no_wait_shutdown = 1;
     c->ssl->no_send_shutdown = 1;
     c->write->error = 1;
@@ -2751,6 +3061,31 @@
 }
 
 
+static void
+ngx_ssl_write_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    if (c->destroyed) {
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL write async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    c->write->handler(c->write);
+}
+
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
 
 ssize_t
@@ -2901,6 +3236,10 @@
 
     ngx_ssl_ocsp_cleanup(c);
 
+    if(!c->ssl) {
+        return NGX_OK;
+    }
+
     if (SSL_in_init(c->ssl->connection)) {
         /*
          * OpenSSL 1.0.2f complains if SSL_shutdown() is called during
@@ -2908,6 +3247,32 @@
          * Avoid calling SSL_shutdown() if handshake wasn't completed.
          */
 
+        if(c->asynch) {
+            /* Check if there is inflight request.
+             * Wait till async job becomes finished.
+             */
+            if (SSL_want_async(c->ssl->connection)) {
+                ngx_ssl_async_process_fds(c);
+                if(!c->async->timer_set)
+                    ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+                return NGX_AGAIN;
+            }
+
+            /* Ignore errors from ngx_ssl_async_process_fds as
+               we want to carry on and close the SSL connection
+               anyway. */
+            ngx_ssl_async_process_fds(c);
+            if (ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+            if(ngx_del_conn && c->read->active) {
+                ngx_del_conn(c, NGX_DISABLE_EVENT);
+            }
+        }
+
         SSL_free(c->ssl->connection);
         c->ssl = NULL;
         c->recv = ngx_recv;
@@ -2954,6 +3319,22 @@
         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_shutdown: %d", n);
 
         if (n == 1) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
+
             SSL_free(c->ssl->connection);
             c->ssl = NULL;
             c->recv = ngx_recv;
@@ -2962,6 +3343,21 @@
         }
 
         if (n == 0 && tries-- > 1) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
             continue;
         }
 
@@ -2971,10 +3367,50 @@
 
         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                        "SSL_get_error: %d", sslerr);
+        if(c->asynch && n == -1) {
+            if (sslerr == SSL_ERROR_WANT_ASYNC) {
+                c->async->ready = 0;
+                c->async->handler = ngx_ssl_shutdown_async_handler;
+                c->read->saved_handler = ngx_ssl_shutdown_handler;
+                if (c->read->handler != ngx_ssl_empty_handler)
+                    c->read->handler = ngx_ssl_empty_handler;
+                c->write->handler = ngx_ssl_shutdown_handler;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "SSL ASYNC WANT recieved: \"%s\"", __func__);
+
+                ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on anyway */
+                ngx_ssl_async_process_fds(c);
+                return NGX_AGAIN;
+            }
+
+            /* Ignore errors from ngx_ssl_async_process_fds as
+               we want to carry on and close the SSL connection
+               anyway. */
+            ngx_ssl_async_process_fds(c);
+            if (ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+            if(ngx_del_conn && c->read->active) {
+                ngx_del_conn(c, NGX_DISABLE_EVENT);
+            }
+        }
 
         if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {
             c->read->handler = ngx_ssl_shutdown_handler;
             c->write->handler = ngx_ssl_shutdown_handler;
+            if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+                return NGX_ERROR;
+            }
+
+            //Work around: Readd write event on shutdown;
+            c->write->ready = 0;
+            c->write->active = 0;
 
             if (sslerr == SSL_ERROR_WANT_READ) {
                 c->read->ready = 0;
@@ -2993,10 +3429,29 @@
 
             ngx_add_timer(c->read, 3000);
 
+            if (sslerr == SSL_ERROR_WANT_WRITE) {
+                ngx_add_timer(c->write, 10000);
+            }
+
             return NGX_AGAIN;
         }
 
         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
             SSL_free(c->ssl->connection);
             c->ssl = NULL;
             c->recv = ngx_recv;
@@ -3018,6 +3473,37 @@
 
 
 static void
+ngx_ssl_shutdown_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t           *c;
+    ngx_connection_handler_pt   handler;
+
+    c = aev->data;
+    handler = c->ssl->handler;
+
+    if (!aev->ready && aev->timedout) {
+        c->timedout = 1;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, aev->log, 0,
+                   "SSL shutdown async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
+        return;
+    }
+
+    handler(c);
+}
+
+
+static void
 ngx_ssl_shutdown_handler(ngx_event_t *ev)
 {
     ngx_connection_t           *c;
@@ -5255,7 +5741,6 @@
     return NGX_OK;
 }
 
-
 static time_t
 ngx_ssl_parse_time(
 #if OPENSSL_VERSION_NUMBER > 0x10100000L
@@ -5293,85 +5778,3 @@
 
     return time;
 }
-
-
-static void *
-ngx_openssl_create_conf(ngx_cycle_t *cycle)
-{
-    ngx_openssl_conf_t  *oscf;
-
-    oscf = ngx_pcalloc(cycle->pool, sizeof(ngx_openssl_conf_t));
-    if (oscf == NULL) {
-        return NULL;
-    }
-
-    /*
-     * set by ngx_pcalloc():
-     *
-     *     oscf->engine = 0;
-     */
-
-    return oscf;
-}
-
-
-static char *
-ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
-{
-#ifndef OPENSSL_NO_ENGINE
-
-    ngx_openssl_conf_t *oscf = conf;
-
-    ENGINE     *engine;
-    ngx_str_t  *value;
-
-    if (oscf->engine) {
-        return "is duplicate";
-    }
-
-    oscf->engine = 1;
-
-    value = cf->args->elts;
-
-    engine = ENGINE_by_id((char *) value[1].data);
-
-    if (engine == NULL) {
-        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
-                      "ENGINE_by_id(\"%V\") failed", &value[1]);
-        return NGX_CONF_ERROR;
-    }
-
-    if (ENGINE_set_default(engine, ENGINE_METHOD_ALL) == 0) {
-        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
-                      "ENGINE_set_default(\"%V\", ENGINE_METHOD_ALL) failed",
-                      &value[1]);
-
-        ENGINE_free(engine);
-
-        return NGX_CONF_ERROR;
-    }
-
-    ENGINE_free(engine);
-
-    return NGX_CONF_OK;
-
-#else
-
-    return "is not supported";
-
-#endif
-}
-
-
-static void
-ngx_openssl_exit(ngx_cycle_t *cycle)
-{
-#if OPENSSL_VERSION_NUMBER < 0x10100003L
-
-    EVP_cleanup();
-#ifndef OPENSSL_NO_ENGINE
-    ENGINE_cleanup();
-#endif
-
-#endif
-}
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/event/ngx_event_openssl.h ../asynch_mode_nginx/src/event/ngx_event_openssl.h
--- nginx-release-1.20.1/src/event/ngx_event_openssl.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/event/ngx_event_openssl.h	2022-03-15 13:23:40.548402910 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -71,6 +72,10 @@
     SSL_CTX                    *ctx;
     ngx_log_t                  *log;
     size_t                      buffer_size;
+    ngx_flag_t                  asynch;
+    size_t                      max_pipelines;
+    size_t                      split_send_fragment;
+    size_t                      max_send_fragment;
 };
 
 
@@ -238,6 +243,7 @@
 
 ngx_int_t ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name);
 
+#define ngx_ssl_waiting_for_async(c) SSL_waiting_for_async(c->ssl->connection)
 
 ngx_int_t ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
@@ -294,7 +300,7 @@
 void ngx_cdecl ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
     char *fmt, ...);
 void ngx_ssl_cleanup_ctx(void *data);
-
+ngx_int_t ngx_ssl_async_process_fds(ngx_connection_t *c) ;
 
 extern int  ngx_ssl_connection_index;
 extern int  ngx_ssl_server_conf_index;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/modules/ngx_http_grpc_module.c ../asynch_mode_nginx/src/http/modules/ngx_http_grpc_module.c
--- nginx-release-1.20.1/src/http/modules/ngx_http_grpc_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/modules/ngx_http_grpc_module.c	2022-03-15 13:23:40.552402945 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Maxim Dounin
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -359,6 +360,12 @@
       &ngx_http_upstream_ignore_headers_masks },
 
 #if (NGX_HTTP_SSL)
+    { ngx_string("grpc_ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_asynch),
+      NULL },
 
     { ngx_string("grpc_ssl_session_reuse"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
@@ -4363,6 +4370,7 @@
     conf->upstream.intercept_errors = NGX_CONF_UNSET;
 
 #if (NGX_HTTP_SSL)
+    conf->upstream.ssl_asynch = NGX_CONF_UNSET;
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_server_name = NGX_CONF_UNSET;
     conf->upstream.ssl_verify = NGX_CONF_UNSET;
@@ -4448,6 +4456,8 @@
                               prev->upstream.intercept_errors, 0);
 
 #if (NGX_HTTP_SSL)
+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);
 
     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,
                               prev->upstream.ssl_session_reuse, 1);
@@ -4482,6 +4492,13 @@
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);
 
+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);
+
+    if(conf->upstream.ssl_asynch && !conf->ssl) {
+        conf->ssl = 1;
+    }
+
     if (conf->ssl && ngx_http_grpc_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -4871,6 +4888,7 @@
     }
 
     glcf->upstream.ssl->log = cf->log;
+    glcf->upstream.ssl->asynch = glcf->upstream.ssl_asynch;
 
     if (ngx_ssl_create(glcf->upstream.ssl, glcf->ssl_protocols, NULL)
         != NGX_OK)
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/modules/ngx_http_proxy_module.c ../asynch_mode_nginx/src/http/modules/ngx_http_proxy_module.c
--- nginx-release-1.20.1/src/http/modules/ngx_http_proxy_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/modules/ngx_http_proxy_module.c	2022-03-15 13:23:40.556402981 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -688,6 +689,13 @@
 
 #if (NGX_HTTP_SSL)
 
+    { ngx_string("proxy_ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_asynch),
+      NULL },
+
     { ngx_string("proxy_ssl_session_reuse"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -3399,6 +3407,7 @@
     conf->upstream.intercept_errors = NGX_CONF_UNSET;
 
 #if (NGX_HTTP_SSL)
+    conf->upstream.ssl_asynch = NGX_CONF_UNSET;
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_server_name = NGX_CONF_UNSET;
     conf->upstream.ssl_verify = NGX_CONF_UNSET;
@@ -3722,6 +3731,9 @@
 
 #if (NGX_HTTP_SSL)
 
+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);
+
     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,
                               prev->upstream.ssl_session_reuse, 1);
 
@@ -3755,6 +3767,10 @@
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);
 
+    if(conf->upstream.ssl_asynch && !conf->ssl) {
+        conf->ssl = 1;
+    }
+
     if (conf->ssl && ngx_http_proxy_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -4931,6 +4947,8 @@
 
     plcf->upstream.ssl->log = cf->log;
 
+    plcf->upstream.ssl->asynch = plcf->upstream.ssl_asynch;
+
     if (ngx_ssl_create(plcf->upstream.ssl, plcf->ssl_protocols, NULL)
         != NGX_OK)
     {
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/modules/ngx_http_ssl_module.c ../asynch_mode_nginx/src/http/modules/ngx_http_ssl_module.c
--- nginx-release-1.20.1/src/http/modules/ngx_http_ssl_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/modules/ngx_http_ssl_module.c	2022-03-15 13:23:40.556402981 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -46,6 +47,8 @@
 
 static char *ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
+static char *ngx_http_ssl_enable_asynch(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
 static char *ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
@@ -105,6 +108,13 @@
       offsetof(ngx_http_ssl_srv_conf_t, enable),
       &ngx_http_ssl_deprecated },
 
+    { ngx_string("ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_http_ssl_enable_asynch,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, enable_asynch),
+      NULL },
+
     { ngx_string("ssl_certificate"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_str_array_slot,
@@ -161,6 +171,27 @@
       offsetof(ngx_http_ssl_srv_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("ssl_max_pipelines"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, max_pipelines),
+      NULL },
+
+    { ngx_string("ssl_split_send_fragment"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, split_send_fragment),
+      NULL },
+
+    { ngx_string("ssl_max_send_fragment"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, max_send_fragment),
+      NULL },
+
     { ngx_string("ssl_verify_client"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_enum_slot,
@@ -619,10 +650,14 @@
      */
 
     sscf->enable = NGX_CONF_UNSET;
+    sscf->enable_asynch = NGX_CONF_UNSET;
     sscf->prefer_server_ciphers = NGX_CONF_UNSET;
     sscf->early_data = NGX_CONF_UNSET;
     sscf->reject_handshake = NGX_CONF_UNSET;
     sscf->buffer_size = NGX_CONF_UNSET_SIZE;
+    sscf->max_pipelines = NGX_CONF_UNSET_SIZE;
+    sscf->split_send_fragment = NGX_CONF_UNSET_SIZE;
+    sscf->max_send_fragment = NGX_CONF_UNSET_SIZE;
     sscf->verify = NGX_CONF_UNSET_UINT;
     sscf->verify_depth = NGX_CONF_UNSET_UINT;
     sscf->certificates = NGX_CONF_UNSET_PTR;
@@ -661,6 +696,17 @@
         }
     }
 
+    if (conf->enable_asynch == NGX_CONF_UNSET) {
+        if (prev->enable_asynch == NGX_CONF_UNSET) {
+            conf->enable_asynch = 0;
+
+        } else {
+            conf->enable_asynch = prev->enable_asynch;
+            conf->file = prev->file;
+            conf->line = prev->line;
+        }
+    }
+
     ngx_conf_merge_value(conf->session_timeout,
                          prev->session_timeout, 300);
 
@@ -677,6 +723,10 @@
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                          NGX_SSL_BUFSIZE);
 
+    ngx_conf_merge_size_value(conf->max_pipelines, prev->max_pipelines, 0);
+    ngx_conf_merge_size_value(conf->split_send_fragment, prev->split_send_fragment, 0);
+    ngx_conf_merge_size_value(conf->max_send_fragment, prev->max_send_fragment, 0);
+
     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);
 
@@ -744,6 +794,9 @@
             return NGX_CONF_ERROR;
         }
 
+        conf->ssl.asynch = conf->enable_asynch;
+
+
     } else if (conf->certificates) {
 
         if (conf->certificate_keys == NULL
@@ -837,6 +890,9 @@
     }
 
     conf->ssl.buffer_size = conf->buffer_size;
+    conf->ssl.max_pipelines = conf->max_pipelines;
+    conf->ssl.split_send_fragment = conf->split_send_fragment;
+    conf->ssl.max_send_fragment = conf->max_send_fragment;
 
     if (conf->verify) {
 
@@ -1049,6 +1105,37 @@
     }
 
     sscf->file = cf->conf_file->file.name.data;
+    sscf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_http_ssl_enable_asynch(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_ssl_srv_conf_t *sscf = conf;
+
+    char  *rv;
+
+    ngx_flag_t       *pssl, *pssl_asynch;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    /* If ssl_asynch on is configured, then ssl on is configured by default
+     * This will align 'ssl_asynch on;' and 'listen port ssl' diretives
+     * */
+    pssl = (ngx_flag_t *) ((char *)conf + offsetof(ngx_http_ssl_srv_conf_t, enable));
+    pssl_asynch = (ngx_flag_t *) ((char *)conf + cmd->offset);
+
+    if(*pssl_asynch && *pssl != 1) {
+        *pssl = *pssl_asynch;
+    }
+
+    sscf->file = cf->conf_file->file.name.data;
     sscf->line = cf->conf_file->line;
 
     return NGX_CONF_OK;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/modules/ngx_http_ssl_module.h ../asynch_mode_nginx/src/http/modules/ngx_http_ssl_module.h
--- nginx-release-1.20.1/src/http/modules/ngx_http_ssl_module.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/modules/ngx_http_ssl_module.h	2022-03-15 13:23:40.556402981 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -17,6 +18,8 @@
 typedef struct {
     ngx_flag_t                      enable;
 
+    ngx_flag_t                      enable_asynch;
+
     ngx_ssl_t                       ssl;
 
     ngx_flag_t                      prefer_server_ciphers;
@@ -29,6 +32,9 @@
     ngx_uint_t                      verify_depth;
 
     size_t                          buffer_size;
+    size_t                          max_pipelines;
+    size_t                          split_send_fragment;
+    size_t                          max_send_fragment;
 
     ssize_t                         builtin_session_cache;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/modules/ngx_http_upstream_keepalive_module.c ../asynch_mode_nginx/src/http/modules/ngx_http_upstream_keepalive_module.c
--- nginx-release-1.20.1/src/http/modules/ngx_http_upstream_keepalive_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/modules/ngx_http_upstream_keepalive_module.c	2022-03-15 13:23:40.556402981 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Maxim Dounin
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -288,6 +289,9 @@
     c->log = pc->log;
     c->read->log = pc->log;
     c->write->log = pc->log;
+#if (NGX_SSL)
+    c->async->log = pc->log;
+#endif
     c->pool->log = pc->log;
 
     if (c->read->timer_set) {
@@ -386,6 +390,11 @@
     if (c->write->timer_set) {
         ngx_del_timer(c->write);
     }
+#if (NGX_SSL)
+    if (c->async->timer_set) {
+        ngx_del_timer(c->async);
+    }
+#endif
 
     c->write->handler = ngx_http_upstream_keepalive_dummy_handler;
     c->read->handler = ngx_http_upstream_keepalive_close_handler;
@@ -395,6 +404,9 @@
     c->log = ngx_cycle->log;
     c->read->log = ngx_cycle->log;
     c->write->log = ngx_cycle->log;
+#if (NGX_SSL)
+    c->async->log = ngx_cycle->log;
+#endif
     c->pool->log = ngx_cycle->log;
 
     item->socklen = pc->socklen;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http.c ../asynch_mode_nginx/src/http/ngx_http.c
--- nginx-release-1.20.1/src/http/ngx_http.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http.c	2022-03-15 13:23:40.560403015 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -1195,6 +1196,7 @@
     ngx_http_conf_addr_t  *addr;
 #if (NGX_HTTP_SSL)
     ngx_uint_t             ssl;
+    ngx_uint_t             asynch;
 #endif
 #if (NGX_HTTP_V2)
     ngx_uint_t             http2;
@@ -1230,6 +1232,7 @@
 
 #if (NGX_HTTP_SSL)
         ssl = lsopt->ssl || addr[i].opt.ssl;
+        asynch = lsopt->asynch || addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         http2 = lsopt->http2 || addr[i].opt.http2;
@@ -1266,6 +1269,7 @@
         addr[i].opt.proxy_protocol = proxy_protocol;
 #if (NGX_HTTP_SSL)
         addr[i].opt.ssl = ssl;
+        addr[i].opt.asynch = asynch;
 #endif
 #if (NGX_HTTP_V2)
         addr[i].opt.http2 = http2;
@@ -1797,6 +1801,7 @@
         addrs[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         addrs[i].conf.http2 = addr[i].opt.http2;
@@ -1862,6 +1867,7 @@
         addrs6[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         addrs6[i].conf.http2 = addr[i].opt.http2;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http_core_module.c ../asynch_mode_nginx/src/http/ngx_http_core_module.c
--- nginx-release-1.20.1/src/http/ngx_http_core_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http_core_module.c	2022-03-15 13:23:40.560403015 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -4084,6 +4085,19 @@
                                "ngx_http_ssl_module");
             return NGX_CONF_ERROR;
 #endif
+        }
+
+        if (ngx_strcmp(value[n].data, "asynch") == 0) {
+#if (NGX_HTTP_SSL)
+            lsopt.ssl = 1;
+            lsopt.asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_http_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
         }
 
         if (ngx_strcmp(value[n].data, "http2") == 0) {
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http_core_module.h ../asynch_mode_nginx/src/http/ngx_http_core_module.h
--- nginx-release-1.20.1/src/http/ngx_http_core_module.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http_core_module.h	2022-03-15 13:23:40.560403015 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -54,7 +55,6 @@
 #define NGX_HTTP_KEEPALIVE_DISABLE_MSIE6   0x0004
 #define NGX_HTTP_KEEPALIVE_DISABLE_SAFARI  0x0008
 
-
 #define NGX_HTTP_SERVER_TOKENS_OFF      0
 #define NGX_HTTP_SERVER_TOKENS_ON       1
 #define NGX_HTTP_SERVER_TOKENS_BUILD    2
@@ -74,6 +74,7 @@
     unsigned                   bind:1;
     unsigned                   wildcard:1;
     unsigned                   ssl:1;
+    unsigned                   asynch:1;
     unsigned                   http2:1;
 #if (NGX_HAVE_INET6)
     unsigned                   ipv6only:1;
@@ -236,6 +237,7 @@
     ngx_http_virtual_names_t  *virtual_names;
 
     unsigned                   ssl:1;
+    unsigned                   asynch:1;
     unsigned                   http2:1;
     unsigned                   proxy_protocol:1;
 };
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http_request.c ../asynch_mode_nginx/src/http/ngx_http_request.c
--- nginx-release-1.20.1/src/http/ngx_http_request.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http_request.c	2022-03-15 13:23:40.560403015 -0500
@@ -2,11 +2,13 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
 #include <ngx_config.h>
 #include <ngx_core.h>
+#include <ngx_ssl_engine.h>
 #include <ngx_http.h>
 
 
@@ -340,6 +342,14 @@
     if (sscf->enable || hc->addr_conf->ssl) {
         hc->ssl = 1;
         c->log->action = "SSL handshaking";
+        c->ssl_enabled = 1;
+
+        c->asynch = hc->addr_conf->asynch;
+
+        if (ngx_use_ssl_engine && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+        }
+
         rev->handler = ngx_http_ssl_handshake;
     }
     }
@@ -447,9 +457,21 @@
          * We are trying to not hold c->buffer's memory for an idle connection.
          */
 
-        if (ngx_pfree(c->pool, b->start) == NGX_OK) {
-            b->start = NULL;
+        /* For the Async implementation we need the same buffer to be used
+         * again on any async calls that have not completed.
+         * As such we need to turn off this optimisation if an async request
+         * is still in progress.
+         */
+
+#if (NGX_HTTP_SSL)
+        if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+            if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+                b->start = NULL;
+            }
+#if (NGX_HTTP_SSL)
         }
+#endif
 
         return;
     }
@@ -1615,8 +1637,8 @@
     cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
 
     if (r->state != 0
-        && (size_t) (r->header_in->pos - old)
-                                     >= cscf->large_client_header_buffers.size)
+        && (size_t) (unsigned) (r->header_in->pos - old) \
+                  >= cscf->large_client_header_buffers.size)
     {
         return NGX_DECLINED;
     }
@@ -3151,52 +3173,62 @@
      * c->pool and are freed too.
      */
 
-    b = c->buffer;
-
-    if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+    /* For the Async implementation we need the same buffer to be used
+     * again on any async calls that have not completed.
+     * As such we need to turn off this optimisation if an async request
+     * is still in progress.
+     */
 
-        /*
-         * the special note for ngx_http_keepalive_handler() that
-         * c->buffer's memory was freed
-         */
+#if (NGX_HTTP_SSL)
+    if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+        b = c->buffer;
 
-        b->pos = NULL;
+        if (ngx_pfree(c->pool, b->start) == NGX_OK) {
 
-    } else {
-        b->pos = b->start;
-        b->last = b->start;
-    }
+            /*
+             * the special note for ngx_http_keepalive_handler() that
+             * c->buffer's memory was freed
+             */
 
-    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc free: %p",
-                   hc->free);
+            b->pos = NULL;
 
-    if (hc->free) {
-        for (cl = hc->free; cl; /* void */) {
-            ln = cl;
-            cl = cl->next;
-            ngx_pfree(c->pool, ln->buf->start);
-            ngx_free_chain(c->pool, ln);
+        } else {
+            b->pos = b->start;
+            b->last = b->start;
         }
 
-        hc->free = NULL;
-    }
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc free: %p",
+                       hc->free);
 
-    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc busy: %p %i",
-                   hc->busy, hc->nbusy);
+        if (hc->free) {
+            for (cl = hc->free; cl; /* void */) {
+                ln = cl;
+                cl = cl->next;
+                ngx_pfree(c->pool, ln->buf->start);
+                ngx_free_chain(c->pool, ln);
+            }
 
-    if (hc->busy) {
-        for (cl = hc->busy; cl; /* void */) {
-            ln = cl;
-            cl = cl->next;
-            ngx_pfree(c->pool, ln->buf->start);
-            ngx_free_chain(c->pool, ln);
+            hc->free = NULL;
         }
 
-        hc->busy = NULL;
-        hc->nbusy = 0;
-    }
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc busy: %p %i",
+                           hc->busy, hc->nbusy);
 
+        if (hc->busy) {
+            for (cl = hc->busy; cl; /* void */) {
+                ln = cl;
+                cl = cl->next;
+                ngx_pfree(c->pool, ln->buf->start);
+                ngx_free_chain(c->pool, ln);
+            }
+
+            hc->busy = NULL;
+            hc->nbusy = 0;
+        }
 #if (NGX_HTTP_SSL)
+    }
+
     if (c->ssl) {
         ngx_ssl_free_buffer(c);
     }
@@ -3205,6 +3237,14 @@
     rev->handler = ngx_http_keepalive_handler;
 
     if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {
             ngx_http_close_connection(c);
             return;
@@ -3329,14 +3369,25 @@
          * c->buffer's memory for a keepalive connection.
          */
 
-        if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+        /* For the Asynch implementation we need the same buffer to be used
+         * on subsequent read requests. As such we need to turn off this optimisation that
+         * frees the buffer between invocations as may end up with a buffer that is at a
+         * different address */
 
-            /*
-             * the special note that c->buffer's memory was freed
-             */
+#if (NGX_HTTP_SSL)
+        if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+            if (ngx_pfree(c->pool, b->start) == NGX_OK) {
 
-            b->pos = NULL;
+                /*
+                 * the special note that c->buffer's memory was freed
+                 */
+
+                b->pos = NULL;
+            }
+#if (NGX_HTTP_SSL)
         }
+#endif
 
         return;
     }
@@ -3424,6 +3475,14 @@
     wev->handler = ngx_http_empty_handler;
 
     if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {
             ngx_http_close_request(r, 0);
             return;
@@ -3767,6 +3826,14 @@
 
     ngx_close_connection(c);
 
+#if (NGX_HTTP_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
+
     ngx_destroy_pool(pool);
 }
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http_upstream.c ../asynch_mode_nginx/src/http/ngx_http_upstream.c
--- nginx-release-1.20.1/src/http/ngx_http_upstream.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http_upstream.c	2022-03-15 13:23:40.560403015 -0500
@@ -2,13 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_http.h>
-
+#include <ngx_ssl_engine.h>
 
 #if (NGX_HTTP_CACHE)
 static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r,
@@ -955,7 +956,8 @@
 
     case NGX_DECLINED:
 
-        if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) {
+        if ((size_t) (unsigned) (u->buffer.end - u->buffer.start) \
+            < u->conf->buffer_size) {
             u->buffer.start = NULL;
 
         } else {
@@ -1334,7 +1336,14 @@
         if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
 
             event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
-
+#if (NGX_HTTP_SSL)
+            if (c->asynch && ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+#endif
             if (ngx_del_event(ev, event, 0) != NGX_OK) {
                 ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1461,7 +1470,14 @@
     if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
 
         event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
-
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(ev, event, 0) != NGX_OK) {
             ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1593,6 +1609,9 @@
     c->log = r->connection->log;
     c->pool->log = c->log;
     c->read->log = c->log;
+#if (NGX_SSL)
+    c->async->log = c->log;
+#endif
     c->write->log = c->log;
 
     /* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts */
@@ -1714,6 +1733,10 @@
 
     r->connection->log->action = "SSL handshaking to upstream";
 
+    if (ngx_use_ssl_engine && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+    }
+
     rc = ngx_ssl_handshake(c);
 
     if (rc == NGX_AGAIN) {
@@ -1760,6 +1783,10 @@
     long  rc;
 
     if (c->ssl->handshaked) {
+        if (c->asynch && r->connection->error) {
+            ngx_http_upstream_finalize_request(r, u, NGX_HTTP_CLIENT_CLOSED_REQUEST);
+            return;
+        }
 
         if (u->conf->ssl_verify) {
             rc = SSL_get_verify_result(c->ssl->connection);
@@ -1912,8 +1939,22 @@
     return NGX_OK;
 }
 
-#endif
+static ngx_inline ngx_int_t
+ngx_http_upstream_ssl_check_want_async(ngx_http_request_t *r,
+    ngx_http_upstream_t *u)
+{
+    if (r->connection->error && u->peer.connection
+        && u->peer.connection->ssl && u->peer.connection->asynch
+        && SSL_in_init(u->peer.connection->ssl->connection)
+        && SSL_want_async(u->peer.connection->ssl->connection)) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "connection closed but need to wait until async job done");
+        return 1;
+    }
+    return 0;
+}
 
+#endif
 
 static ngx_int_t
 ngx_http_upstream_reinit(ngx_http_request_t *r, ngx_http_upstream_t *u)
@@ -4354,6 +4395,12 @@
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "finalize http upstream request: %i", rc);
 
+#if (NGX_HTTP_SSL)
+    if (ngx_http_upstream_ssl_check_want_async(r, u)) {
+        return;
+    }
+#endif
+
     if (u->cleanup == NULL) {
         /* the request was already finalized */
         ngx_http_finalize_request(r, NGX_DONE);
@@ -4458,7 +4505,8 @@
             }
         }
 
-        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);
+        if (u->pipe)
+            ngx_http_file_cache_free(r->cache, u->pipe->temp_file);
     }
 
 #endif
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/http/ngx_http_upstream.h ../asynch_mode_nginx/src/http/ngx_http_upstream.h
--- nginx-release-1.20.1/src/http/ngx_http_upstream.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/http/ngx_http_upstream.h	2022-03-15 13:23:40.560403015 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -229,6 +230,7 @@
 
 #if (NGX_HTTP_SSL || NGX_COMPAT)
     ngx_ssl_t                       *ssl;
+    ngx_flag_t                       ssl_asynch;
     ngx_flag_t                       ssl_session_reuse;
 
     ngx_http_complex_value_t        *ssl_name;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail.c ../asynch_mode_nginx/src/mail/ngx_mail.c
--- nginx-release-1.20.1/src/mail/ngx_mail.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail.c	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -404,6 +405,7 @@
         addrs[i].conf.ctx = addr[i].opt.ctx;
 #if (NGX_MAIL_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs[i].conf.addr_text = addr[i].opt.addr_text;
@@ -439,6 +441,7 @@
         addrs6[i].conf.ctx = addr[i].opt.ctx;
 #if (NGX_MAIL_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs6[i].conf.addr_text = addr[i].opt.addr_text;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail_core_module.c ../asynch_mode_nginx/src/mail/ngx_mail_core_module.c
--- nginx-release-1.20.1/src/mail/ngx_mail_core_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail_core_module.c	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -456,6 +457,23 @@
                                "ngx_mail_ssl_module");
             return NGX_CONF_ERROR;
 #endif
+        }
+
+        if (ngx_strcmp(value[i].data, "asynch") == 0) {
+#if (NGX_MAIL_SSL)
+            ngx_mail_ssl_conf_t  *sslcf;
+            sslcf = ngx_mail_conf_get_module_srv_conf(cf, ngx_mail_ssl_module);
+            sslcf->asynch = 1;
+
+            ls->ssl = 1;
+            ls->asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_mail_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
         }
 
         if (ngx_strncmp(value[i].data, "so_keepalive=", 13) == 0) {
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail.h ../asynch_mode_nginx/src/mail/ngx_mail.h
--- nginx-release-1.20.1/src/mail/ngx_mail.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail.h	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -37,6 +38,7 @@
     unsigned                bind:1;
     unsigned                wildcard:1;
     unsigned                ssl:1;
+    unsigned                asynch:1;
 #if (NGX_HAVE_INET6)
     unsigned                ipv6only:1;
 #endif
@@ -58,6 +60,7 @@
     ngx_str_t               addr_text;
     unsigned                ssl:1;
     unsigned                proxy_protocol:1;
+    ngx_uint_t              asynch;
 } ngx_mail_addr_conf_t;
 
 typedef struct {
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail_handler.c ../asynch_mode_nginx/src/mail/ngx_mail_handler.c
--- nginx-release-1.20.1/src/mail/ngx_mail_handler.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail_handler.c	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -134,6 +135,9 @@
 
 #if (NGX_MAIL_SSL)
     s->ssl = addr_conf->ssl;
+    if (addr_conf->asynch) {
+        c->asynch = addr_conf->asynch;
+    }
 #endif
 
     s->addr_text = &addr_conf->addr_text;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail_ssl_module.c ../asynch_mode_nginx/src/mail/ngx_mail_ssl_module.c
--- nginx-release-1.20.1/src/mail/ngx_mail_ssl_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail_ssl_module.c	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -19,6 +20,8 @@
 
 static char *ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
+static char *ngx_mail_ssl_asynch(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
 static char *ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
@@ -77,6 +80,13 @@
       offsetof(ngx_mail_ssl_conf_t, enable),
       &ngx_mail_ssl_deprecated },
 
+    { ngx_string("ssl_asynch"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_mail_ssl_asynch,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, asynch),
+      NULL },
+
     { ngx_string("starttls"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
       ngx_mail_ssl_starttls,
@@ -269,6 +279,7 @@
      */
 
     scf->enable = NGX_CONF_UNSET;
+    scf->asynch = NGX_CONF_UNSET;
     scf->starttls = NGX_CONF_UNSET_UINT;
     scf->certificates = NGX_CONF_UNSET_PTR;
     scf->certificate_keys = NGX_CONF_UNSET_PTR;
@@ -296,6 +307,7 @@
     ngx_pool_cleanup_t  *cln;
 
     ngx_conf_merge_value(conf->enable, prev->enable, 0);
+    ngx_conf_merge_value(conf->asynch, prev->asynch, 0);
     ngx_conf_merge_uint_value(conf->starttls, prev->starttls,
                          NGX_MAIL_STARTTLS_OFF);
 
@@ -338,9 +350,9 @@
 
     if (conf->listen) {
         mode = "listen ... ssl";
-
     } else if (conf->enable) {
         mode = "ssl";
+        conf->ssl.asynch = conf->asynch;
 
     } else if (conf->starttls != NGX_MAIL_STARTTLS_OFF) {
         mode = "starttls";
@@ -512,6 +524,34 @@
 
     return NGX_CONF_OK;
 }
+
+
+static char *
+ngx_mail_ssl_asynch(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_mail_ssl_conf_t *scf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    /* If ssl_asynch on is configured, then ssl on is configured by default
+     * This will align 'ssl_asynch on;' and 'listen port ssl' diretives
+     * */
+
+    if(scf->asynch && (scf->enable != 1)) {
+        scf->enable = scf->asynch;
+    }
+
+    scf->file = cf->conf_file->file.name.data;
+    scf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
 
 
 static char *
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/mail/ngx_mail_ssl_module.h ../asynch_mode_nginx/src/mail/ngx_mail_ssl_module.h
--- nginx-release-1.20.1/src/mail/ngx_mail_ssl_module.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/mail/ngx_mail_ssl_module.h	2022-03-15 13:23:40.564403051 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -21,6 +22,7 @@
 
 typedef struct {
     ngx_flag_t       enable;
+    ngx_flag_t       asynch;
     ngx_flag_t       prefer_server_ciphers;
 
     ngx_ssl_t        ssl;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/os/unix/ngx_process_cycle.c ../asynch_mode_nginx/src/os/unix/ngx_process_cycle.c
--- nginx-release-1.20.1/src/os/unix/ngx_process_cycle.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/os/unix/ngx_process_cycle.c	2022-03-15 13:23:40.568403085 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -9,7 +10,8 @@
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_channel.h>
-
+#include <ngx_ssl_engine.h>
+#include <openssl/rand.h>
 
 static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,
     ngx_int_t type);
@@ -210,6 +212,7 @@
 
         if (ngx_reconfigure) {
             ngx_reconfigure = 0;
+            ngx_ssl_engine_reload_processed = 0;
 
             if (ngx_new_binary) {
                 ngx_start_worker_processes(cycle, ccf->worker_processes,
@@ -312,6 +315,7 @@
 
         if (ngx_reconfigure) {
             ngx_reconfigure = 0;
+            ngx_ssl_engine_reload_processed = 0;
             ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");
 
             cycle = ngx_init_cycle(cycle);
@@ -593,6 +597,13 @@
                 && !ngx_terminate
                 && !ngx_quit)
             {
+#if (NGX_SSL)
+                /* Delay added to give Quickassist Driver time to cleanup
+                * if worker exit with non-zero code. */
+                if(ngx_processes[i].status != 0) {
+                    usleep(2000000);
+                }
+#endif
                 if (ngx_spawn_process(cycle, ngx_processes[i].proc,
                                       ngx_processes[i].data,
                                       ngx_processes[i].name, i)
@@ -692,7 +703,6 @@
     exit(0);
 }
 
-
 static void
 ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
 {
@@ -703,13 +713,22 @@
 
     ngx_worker_process_init(cycle, worker);
 
+    if(ngx_ssl_engine_init) {
+        ngx_ssl_engine_init(cycle);
+    }
+
     ngx_setproctitle("worker process");
 
     for ( ;; ) {
 
         if (ngx_exiting) {
+            if(ngx_ssl_engine_release) {
+                ngx_ssl_engine_release(cycle);
+            }
+
             if (ngx_event_no_timers_left() == NGX_OK) {
                 ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
+
                 ngx_worker_process_exit(cycle);
             }
         }
@@ -1016,6 +1035,8 @@
         return;
     }
 
+    ngx_memzero(&ch, sizeof(ngx_channel_t));
+
     c = ev->data;
 
     ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, "channel handler");
@@ -1029,6 +1050,14 @@
         if (n == NGX_ERROR) {
 
             if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {
+#if (NGX_SSL)
+                if (c->asynch && ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->num_async_fds--;
+                    }
+                }
+#endif
                 ngx_del_conn(c, 0);
             }
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/os/win32/nginx.ico ../asynch_mode_nginx/src/os/win32/nginx.ico
--- nginx-release-1.20.1/src/os/win32/nginx.ico	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/os/win32/nginx.ico	2022-03-15 13:23:40.568403085 -0500
@@ -1 +0,0 @@
-    00   0  6        0  f          (   0   `          H                                                                                 ?    ?                                 ?                                        ?    ?                               ?    ?                                                                                                               ?    ?                                  ?  ?                                                      (       @                                                                                           ???< x x   ????        (                                                   8  8  9  s  q  8   8  8                                            
\ No newline at end of file
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream.c ../asynch_mode_nginx/src/stream/ngx_stream.c
--- nginx-release-1.20.1/src/stream/ngx_stream.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream.c	2022-03-15 13:23:40.568403085 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -569,8 +570,9 @@
         addrs[i].addr = sin->sin_addr.s_addr;
 
         addrs[i].conf.ctx = addr[i].opt.ctx;
-#if (NGX_STREAM_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_STREAM_SSL)
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs[i].conf.addr_text = addr[i].opt.addr_text;
@@ -604,8 +606,9 @@
         addrs6[i].addr6 = sin6->sin6_addr;
 
         addrs6[i].conf.ctx = addr[i].opt.ctx;
-#if (NGX_STREAM_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_STREAM_SSL)
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs6[i].conf.addr_text = addr[i].opt.addr_text;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream_core_module.c ../asynch_mode_nginx/src/stream/ngx_stream_core_module.c
--- nginx-release-1.20.1/src/stream/ngx_stream_core_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream_core_module.c	2022-03-15 13:23:40.568403085 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -741,6 +742,24 @@
 #endif
         }
 
+        if (ngx_strcmp(value[i].data, "asynch") == 0) {
+#if (NGX_STREAM_SSL)
+            ngx_stream_ssl_conf_t  *sslcf;
+            sslcf = ngx_stream_conf_get_module_srv_conf(cf,
+                                                        ngx_stream_ssl_module);
+            sslcf->asynch = 1;
+
+            ls->ssl = 1;
+            ls->asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_stream_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
         if (ngx_strncmp(value[i].data, "so_keepalive=", 13) == 0) {
 
             if (ngx_strcmp(&value[i].data[13], "on") == 0) {
@@ -850,6 +869,10 @@
         if (ls->ssl) {
             return "\"ssl\" parameter is incompatible with \"udp\"";
         }
+
+        if (ls->asynch) {
+            return "\"asynch\" parameter is incompatible with \"udp\"";
+        }
 #endif
 
         if (ls->so_keepalive) {
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream.h ../asynch_mode_nginx/src/stream/ngx_stream.h
--- nginx-release-1.20.1/src/stream/ngx_stream.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream.h	2022-03-15 13:23:40.568403085 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -25,7 +26,6 @@
 #include <ngx_stream_upstream.h>
 #include <ngx_stream_upstream_round_robin.h>
 
-
 #define NGX_STREAM_OK                        200
 #define NGX_STREAM_BAD_REQUEST               400
 #define NGX_STREAM_FORBIDDEN                 403
@@ -51,6 +51,9 @@
     unsigned                       bind:1;
     unsigned                       wildcard:1;
     unsigned                       ssl:1;
+#if (NGX_STREAM_SSL)
+    unsigned                       asynch:1;
+#endif
 #if (NGX_HAVE_INET6)
     unsigned                       ipv6only:1;
 #endif
@@ -73,6 +76,9 @@
     ngx_stream_conf_ctx_t         *ctx;
     ngx_str_t                      addr_text;
     unsigned                       ssl:1;
+#if (NGX_STREAM_SSL)
+    unsigned                       asynch:1;
+#endif
     unsigned                       proxy_protocol:1;
 } ngx_stream_addr_conf_t;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream_handler.c ../asynch_mode_nginx/src/stream/ngx_stream_handler.c
--- nginx-release-1.20.1/src/stream/ngx_stream_handler.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream_handler.c	2022-03-15 13:23:40.568403085 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -9,7 +10,7 @@
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_stream.h>
-
+#include <ngx_ssl_engine.h>
 
 static void ngx_stream_log_session(ngx_stream_session_t *s);
 static void ngx_stream_close_connection(ngx_connection_t *c);
@@ -268,7 +269,6 @@
     }
 
     size = p - buf;
-
     if (c->recv(c, buf, size) != (ssize_t) size) {
         ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
         return;
@@ -325,7 +325,7 @@
 }
 
 
-static void
+void
 ngx_stream_close_connection(ngx_connection_t *c)
 {
     ngx_pool_t  *pool;
@@ -352,6 +352,14 @@
 
     ngx_close_connection(c);
 
+#if (NGX_STREAM_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
+
     ngx_destroy_pool(pool);
 }
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream_proxy_module.c ../asynch_mode_nginx/src/stream/ngx_stream_proxy_module.c
--- nginx-release-1.20.1/src/stream/ngx_stream_proxy_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream_proxy_module.c	2022-03-15 13:23:40.572403121 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -36,6 +37,7 @@
 
 #if (NGX_STREAM_SSL)
     ngx_flag_t                       ssl_enable;
+    ngx_flag_t                       ssl_asynch;
     ngx_flag_t                       ssl_session_reuse;
     ngx_uint_t                       ssl_protocols;
     ngx_str_t                        ssl_ciphers;
@@ -253,6 +255,13 @@
       offsetof(ngx_stream_proxy_srv_conf_t, ssl_enable),
       NULL },
 
+    { ngx_string("proxy_ssl_asynch"),
+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_STREAM_SRV_CONF_OFFSET,
+      offsetof(ngx_stream_proxy_srv_conf_t, ssl_asynch),
+      NULL },
+
     { ngx_string("proxy_ssl_session_reuse"),
       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -750,6 +759,9 @@
     pc->log = c->log;
     pc->pool = c->pool;
     pc->read->log = c->log;
+#if (NGX_SSL)
+    pc->async->log = c->log;
+#endif
     pc->write->log = c->log;
 
     if (rc != NGX_AGAIN) {
@@ -2004,6 +2016,7 @@
 
 #if (NGX_STREAM_SSL)
     conf->ssl_enable = NGX_CONF_UNSET;
+    conf->ssl_asynch = NGX_CONF_UNSET;
     conf->ssl_session_reuse = NGX_CONF_UNSET;
     conf->ssl_server_name = NGX_CONF_UNSET;
     conf->ssl_verify = NGX_CONF_UNSET;
@@ -2064,6 +2077,8 @@
 
     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);
 
+    ngx_conf_merge_value(conf->ssl_asynch, prev->ssl_asynch, 0);
+
     ngx_conf_merge_value(conf->ssl_session_reuse,
                               prev->ssl_session_reuse, 1);
 
@@ -2100,6 +2115,10 @@
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);
 
+    if(conf->ssl_asynch && !conf->ssl_enable) {
+        conf->ssl_enable = 1;
+    }
+
     if (conf->ssl_enable && ngx_stream_proxy_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -2124,6 +2143,8 @@
 
     pscf->ssl->log = cf->log;
 
+    pscf->ssl->asynch = pscf->ssl_asynch;
+
     if (ngx_ssl_create(pscf->ssl, pscf->ssl_protocols, NULL) != NGX_OK) {
         return NGX_ERROR;
     }
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream_ssl_module.c ../asynch_mode_nginx/src/stream/ngx_stream_ssl_module.c
--- nginx-release-1.20.1/src/stream/ngx_stream_ssl_module.c	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream_ssl_module.c	2022-03-15 13:23:40.572403121 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -78,6 +79,13 @@
 
 static ngx_command_t  ngx_stream_ssl_commands[] = {
 
+    { ngx_string("ssl_asynch"),
+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_STREAM_SRV_CONF_OFFSET,
+      offsetof(ngx_stream_ssl_conf_t, asynch),
+      NULL },
+
     { ngx_string("ssl_handshake_timeout"),
       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_msec_slot,
@@ -328,6 +336,8 @@
     if (c->ssl == NULL) {
         c->log->action = "SSL handshaking";
 
+        c->asynch = sslcf->ssl.asynch;
+
         rv = ngx_stream_ssl_init_connection(&sslcf->ssl, c);
 
         if (rv != NGX_OK) {
@@ -606,6 +616,7 @@
      *     scf->shm_zone = NULL;
      */
 
+    scf->asynch = NGX_CONF_UNSET;
     scf->handshake_timeout = NGX_CONF_UNSET_MSEC;
     scf->certificates = NGX_CONF_UNSET_PTR;
     scf->certificate_keys = NGX_CONF_UNSET_PTR;
@@ -631,6 +642,8 @@
 
     ngx_pool_cleanup_t  *cln;
 
+    ngx_conf_merge_value(conf->asynch, prev->asynch, 0);
+
     ngx_conf_merge_msec_value(conf->handshake_timeout,
                          prev->handshake_timeout, 60000);
 
@@ -670,6 +683,7 @@
 
 
     conf->ssl.log = cf->log;
+    conf->ssl.asynch = conf->asynch;
 
     if (!conf->listen) {
         return NGX_CONF_OK;
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/src/stream/ngx_stream_ssl_module.h ../asynch_mode_nginx/src/stream/ngx_stream_ssl_module.h
--- nginx-release-1.20.1/src/stream/ngx_stream_ssl_module.h	2021-05-25 07:35:38.000000000 -0500
+++ ../asynch_mode_nginx/src/stream/ngx_stream_ssl_module.h	2022-03-15 13:23:40.572403121 -0500
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */
 
 
@@ -21,6 +22,8 @@
 
     ngx_ssl_t        ssl;
 
+    ngx_flag_t       asynch;
+
     ngx_uint_t       listen;
     ngx_uint_t       protocols;
 
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/access_log.t ../asynch_mode_nginx/test/nginx-tests/access_log.t
--- nginx-release-1.20.1/test/nginx-tests/access_log.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/access_log.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,291 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for access_log.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite gzip/)->plan(19)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$uri:$status";
+    log_format long "long line $uri:$status";
+    log_format addr "$remote_addr:$remote_port:$server_addr:$server_port";
+    log_format binary $binary_remote_addr;
+
+    log_format default  escape=default  $arg_a$arg_b$arg_c;
+    log_format none     escape=none     $arg_a$arg_b$arg_c;
+    log_format json     escape=json     $arg_a$arg_b$arg_c;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /combined {
+            access_log %%TESTDIR%%/combined.log;
+            return 200 OK;
+
+            location /combined/off {
+                access_log off;
+                return 200 OK;
+            }
+        }
+
+        location /filtered {
+            access_log %%TESTDIR%%/filtered.log test
+                       if=$arg_logme;
+            return 200 OK;
+        }
+
+        location /filtered/complex {
+            access_log %%TESTDIR%%/complex.log test
+                       if=$arg_logme$arg_logmetoo;
+            return 200 OK;
+        }
+
+        location /filtered/noreuse {
+            access_log %%TESTDIR%%/noreuse.log test buffer=16k
+                       if=$arg_a;
+            access_log %%TESTDIR%%/noreuse.log test buffer=16k
+                       if=$arg_b;
+            return 200 OK;
+        }
+
+        location /compressed {
+            access_log %%TESTDIR%%/compressed.log test
+                       gzip buffer=1m flush=100ms;
+            return 200 OK;
+        }
+
+        location /multi {
+            access_log %%TESTDIR%%/multi1.log test;
+            access_log %%TESTDIR%%/multi2.log test;
+            access_log %%TESTDIR%%/long.log long;
+            return 200 OK;
+        }
+
+        location /varlog {
+            access_log %%TESTDIR%%/varlog_${arg_logname} test;
+            return 200 OK;
+        }
+
+        location /cache {
+            open_log_file_cache max=3 inactive=20s valid=1m min_uses=2;
+            access_log %%TESTDIR%%/dir/cache_${arg_logname} test;
+            return 200 OK;
+        }
+
+        location /addr {
+            access_log %%TESTDIR%%/addr.log addr;
+        }
+
+        location /binary {
+            access_log %%TESTDIR%%/binary.log binary;
+        }
+
+        location /escape {
+            access_log %%TESTDIR%%/test.log default;
+            access_log %%TESTDIR%%/none.log none;
+            access_log %%TESTDIR%%/json.log json;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir "$d/dir";
+
+$t->run();
+
+###############################################################################
+
+http_get('/combined');
+http_get('/combined/off');
+
+http_get('/filtered');
+http_get('/filtered/empty?logme=');
+http_get('/filtered/zero?logme=0');
+http_get('/filtered/good?logme=1');
+http_get('/filtered/work?logme=yes');
+
+http_get('/filtered/complex');
+http_get('/filtered/complex/one?logme=1');
+http_get('/filtered/complex/two?logmetoo=1');
+http_get('/filtered/complex/either1?logme=A&logmetoo=B');
+http_get('/filtered/complex/either2?logme=A');
+http_get('/filtered/complex/either3?logmetoo=B');
+http_get('/filtered/complex/either4?logme=0&logmetoo=0');
+http_get('/filtered/complex/neither?logme=&logmetoo=');
+
+http_get('/filtered/noreuse1/zero?a=0');
+http_get('/filtered/noreuse1/good?a=1');
+http_get('/filtered/noreuse2/zero?b=0');
+http_get('/filtered/noreuse2/good?b=1');
+
+http_get('/compressed');
+
+http_get('/multi');
+
+http_get('/varlog');
+http_get('/varlog?logname=');
+http_get('/varlog?logname=0');
+http_get('/varlog?logname=filename');
+
+my $s = http('', start => 1);
+http_get('/addr', socket => $s);
+my $addr = $s->sockhost();
+my $port = $s->sockport();
+my $saddr = $s->peerhost();
+my $sport = $s->peerport();
+
+http_get('/binary');
+
+http_get('/escape?a="1 \\ ' . pack("n", 0x1b1c) . ' "&c=2');
+
+http_get('/cache?logname=lru');
+http_get('/cache?logname=lru');
+http_get('/cache?logname=once');
+http_get('/cache?logname=first');
+http_get('/cache?logname=first');
+http_get('/cache?logname=second');
+http_get('/cache?logname=second');
+
+rename "$d/dir", "$d/dir_moved";
+
+http_get('/cache?logname=lru');
+http_get('/cache?logname=once');
+http_get('/cache?logname=first');
+http_get('/cache?logname=second');
+
+rename "$d/dir_moved",  "$d/dir";
+
+# wait for file to appear with nonzero size thanks to the flush parameter
+
+for (1 .. 10) {
+    last if -s "$d/compressed.log";
+    select undef, undef, undef, 0.1;
+}
+
+# verify that "gzip" parameter turns on compression
+
+my $log;
+
+SKIP: {
+    eval { require IO::Uncompress::Gunzip; };
+    skip("IO::Uncompress::Gunzip not installed", 1) if $@;
+
+    my $gzipped = $t->read_file('compressed.log');
+    IO::Uncompress::Gunzip::gunzip(\$gzipped => \$log);
+    like($log, qr!^/compressed:200!s, 'compressed log - flush time');
+}
+
+# now verify all other logs
+
+$t->stop();
+
+
+# verify that by default, 'combined' format is used, 'off' disables logging
+
+like($t->read_file('combined.log'),
+    qr!^\Q$addr - - [\E .*
+        \Q] "GET /combined HTTP/1.0" 200 2 "-" "-"\E$!x,
+    'default log format');
+
+# verify that log filtering works
+
+$log = $t->read_file('filtered.log');
+is($log, "/filtered/good:200\n/filtered/work:200\n", 'log filtering');
+
+# verify "if=" argument works with complex value
+
+my $exp_complex = <<'EOF';
+/filtered/complex/one:200
+/filtered/complex/two:200
+/filtered/complex/either1:200
+/filtered/complex/either2:200
+/filtered/complex/either3:200
+/filtered/complex/either4:200
+EOF
+
+is($t->read_file('complex.log'), $exp_complex, 'if with complex value');
+
+# buffer created with false "if" is not reused among multiple access_log
+
+$log = $t->read_file('noreuse.log');
+is($log, "/filtered/noreuse1/good:200\n/filtered/noreuse2/good:200\n",
+    'log filtering with buffering');
+
+# multiple logs in a same location
+
+is($t->read_file('multi1.log'), "/multi:200\n", 'multiple logs 1');
+
+# same content in the second log
+
+is($t->read_file('multi2.log'), "/multi:200\n", 'multiple logs 2');
+
+is($t->read_file('long.log'), "long line /multi:200\n", 'long line format');
+
+# test log destinations with variables
+
+is($t->read_file('varlog_0'), "/varlog:200\n", 'varlog literal zero name');
+is($t->read_file('varlog_filename'), "/varlog:200\n", 'varlog good name');
+
+is($t->read_file('addr.log'), "$addr:$port:$saddr:$sport\n", 'addr');
+
+# binary data is escaped
+# that's "\\x7F\\x00\\x00\\x01\n" in $binary_remote_addr for "127.0.0.1"
+
+my $expected = join '', map { sprintf "\\x%02X", $_ } split /\./, $addr;
+
+is($t->read_file('binary.log'), "$expected\n", 'binary');
+
+# characters escaping
+
+is($t->read_file('test.log'),
+    '\x221 \x5C \x1B\x1C \x22-2' . "\n", 'escape - default');
+is($t->read_file('none.log'),
+    '"1 \\ ' . pack("n", 0x1b1c) . " \"2\n", 'escape - none');
+is($t->read_file('json.log'),
+    '\"1 \\\\ \u001B\u001C \"2' . "\n", 'escape - json');
+
+SKIP: {
+skip 'win32', 4 if $^O eq 'MSWin32';
+
+is(@{[$t->read_file('/dir/cache_lru') =~ /\//g]}, 2, 'cache - closed lru');
+is(@{[$t->read_file('/dir/cache_once') =~ /\//g]}, 1, 'cache - min_uses');
+is(@{[$t->read_file('/dir/cache_first') =~ /\//g]}, 3, 'cache - cached 1');
+is(@{[$t->read_file('/dir/cache_second') =~ /\//g]}, 3, 'cache - cached 2');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/access_log_variables.t ../asynch_mode_nginx/test/nginx-tests/access_log_variables.t
--- nginx-release-1.20.1/test/nginx-tests/access_log_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/access_log_variables.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,128 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for log module variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format time_iso8601  '$uri $time_iso8601';
+    log_format time_local    '$uri $time_local';
+    log_format msec          '$uri $msec';
+    log_format request       '$uri $status $request_length $request_time';
+    log_format bytes         '$uri $bytes_sent $body_bytes_sent';
+    log_format pipe          '$uri $pipe';
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /iso8601 {
+            access_log %%TESTDIR%%/iso8601.log time_iso8601;
+            return 200;
+        }
+
+        location /local {
+            access_log %%TESTDIR%%/local.log time_local;
+            return 200;
+        }
+
+        location /msec {
+            access_log %%TESTDIR%%/msec.log msec;
+            return 200;
+        }
+
+        location /request {
+            access_log %%TESTDIR%%/request.log request;
+            return 200;
+        }
+
+        location /bytes {
+           access_log %%TESTDIR%%/bytes.log bytes;
+           return 200 OK;
+        }
+
+        location /pipe {
+            access_log %%TESTDIR%%/pipe.log pipe;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/iso8601');
+http_get('/local');
+http_get('/msec');
+http_get('/request');
+my $bytes_sent = length http_get('/bytes');
+
+# pipelined requests
+
+http(<<EOF);
+GET /pipe HTTP/1.1
+Host: localhost
+
+GET /pipe HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+$t->stop();
+
+my $log = $t->read_file('iso8601.log');
+like($log, qr!/iso8601 \d{4}-\d\d-\d\dT\d\d:\d\d:\d\d[+-]\d\d:\d\d!,
+    'time_iso8601');
+
+$log = $t->read_file('local.log');
+like($log, qr!/local \d\d/[A-Z][a-z]{2}/\d{4}:\d\d:\d\d:\d\d [+-]\d{4}!,
+    'time_local');
+
+$log = $t->read_file('msec.log');
+like($log, qr!/msec [\d\.]+!, 'msec');
+
+$log = $t->read_file('request.log');
+like($log, qr!/request 200 39 [\d\.]+!, 'request');
+
+$log = $t->read_file('bytes.log');
+is($log, "/bytes $bytes_sent 2\n", 'bytes sent');
+
+$log = $t->read_file('pipe.log');
+is($log, "/pipe .\n/pipe p\n", 'pipe');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/access.t ../asynch_mode_nginx/test/nginx-tests/access.t
--- nginx-release-1.20.1/test/nginx-tests/access.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/access.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+
+# Tests for nginx access module.
+
+# At the moment only the new "unix:" syntax is tested (cf "all").
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy access unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /inet/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /inet6/ {
+            proxy_pass http://[::1]:%%PORT_8081%%/;
+        }
+
+        location /unix/ {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       [::1]:%%PORT_8081%%;
+        listen       unix:%%TESTDIR%%/unix.sock;
+
+        location /allow_all {
+            allow all;
+        }
+
+        location /allow_unix {
+            allow unix:;
+        }
+
+        location /deny_all {
+            deny all;
+        }
+
+        location /deny_unix {
+            deny unix:;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(12);
+
+###############################################################################
+
+# tests with inet socket
+
+like(http_get('/inet/allow_all'), qr/404 Not Found/, 'inet allow all');
+like(http_get('/inet/allow_unix'), qr/404 Not Found/, 'inet allow unix');
+like(http_get('/inet/deny_all'), qr/403 Forbidden/, 'inet deny all');
+like(http_get('/inet/deny_unix'), qr/404 Not Found/, 'inet deny unix');
+
+# tests with inet6 socket
+
+like(http_get('/inet6/allow_all'), qr/404 Not Found/, 'inet6 allow all');
+like(http_get('/inet6/allow_unix'), qr/404 Not Found/, 'inet6 allow unix');
+like(http_get('/inet6/deny_all'), qr/403 Forbidden/, 'inet6 deny all');
+like(http_get('/inet6/deny_unix'), qr/404 Not Found/, 'inet6 deny unix');
+
+# tests with unix socket
+
+like(http_get('/unix/allow_all'), qr/404 Not Found/, 'unix allow all');
+like(http_get('/unix/allow_unix'), qr/404 Not Found/, 'unix allow unix');
+like(http_get('/unix/deny_all'), qr/403 Forbidden/, 'unix deny all');
+like(http_get('/unix/deny_unix'), qr/403 Forbidden/, 'unix deny unix');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/addition_buffered.t ../asynch_mode_nginx/test/nginx-tests/addition_buffered.t
--- nginx-release-1.20.1/test/nginx-tests/addition_buffered.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/addition_buffered.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,68 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for addition module with buffered data from other filters.
+
+# In particular, sub filter may have a partial match buffered.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy sub addition/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /proxy/ {
+            sub_filter foo bar;
+            add_after_body /after.html;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('after.html', 'after');
+$t->write_file('body.html', 'XXXXX');
+
+$t->run();
+
+###############################################################################
+
+# if data is buffered, there should be no interleaved data in output
+
+like(http_get('/proxy/body.html'), qr/^XXXXXafter$/m, 'request');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/addition.t ../asynch_mode_nginx/test/nginx-tests/addition.t
--- nginx-release-1.20.1/test/nginx-tests/addition.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/addition.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for addition module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite addition/)->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /regular {
+            return 200 "body";
+        }
+
+        location /b.html {
+            add_before_body /add_before;
+            return 200 "body";
+        }
+
+        location /a.html {
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /ba.html {
+            add_before_body /add_before;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype {
+            add_before_body /add_before;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype2 {
+            addition_types text/plain;
+            add_after_body /add_after;
+            return 200 "body";
+        }
+
+        location /notype.html {
+            types {}
+            add_before_body /add_before;
+            return 200 "body";
+        }
+
+        location /add_before {
+            return 200 "before";
+        }
+
+        location /add_after {
+            return 200 "after";
+        }
+
+        location /self.html {
+            add_after_body /self.html;
+            return 200 "self";
+        }
+
+        location /return202.html {
+            add_after_body /add_after;
+            return 202 "body";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/regular'), qr/^body$/ms, 'no addition');
+like(http_get('/b.html'), qr/^beforebody$/ms, 'add_before');
+like(http_get('/a.html'), qr/^bodyafter$/ms, 'add_after');
+like(http_get('/ba.html'), qr/^beforebodyafter$/ms, 'both');
+like(http_get('/notype'), qr/^body$/ms, 'no content type');
+like(http_get('/notype2'), qr/^bodyafter$/ms, 'addition_types');
+like(http_get('/notype.html'), qr/^body$/ms, 'empty content type');
+like(http_get('/self.html'), qr/^selfself$/ms, 'self');
+like(http_get('/return202.html'), qr/HTTP\/1.. 202.*^body$/ms, 'not 200');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/auth_basic.t ../asynch_mode_nginx/test/nginx-tests/auth_basic.t
--- nginx-release-1.20.1/test/nginx-tests/auth_basic.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/auth_basic.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for auth basic module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http auth_basic/)->plan(21)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            auth_basic           "closed site";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+
+            location /inner {
+                auth_basic off;
+                alias %%TESTDIR%%/;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEETHIS');
+
+$t->write_file(
+    'htpasswd',
+    'crypt:' . crypt('password', 'salt') . "\n" .
+    'crypt1:' . crypt('password', '$1$salt$') . "\n" .
+    'crypt2:' . '$1$' . "\n" .
+    'apr1:' . '$apr1$salt$Xxd1irWT9ycqoYxGFn4cb.' . "\n" .
+    'apr12:' . '$apr1$' . "\n" .
+    'plain:' . '{PLAIN}password' . "\n" .
+    'ssha:' . '{SSHA}yI6cZwQadOA1e+/f+T+H3eCQQhRzYWx0' . "\n" .
+    'ssha2:' . '{SSHA}_____wQadOA1e+/f+T+H3eCQQhRzYWx0' . "\n" .
+    'ssha3:' . '{SSHA}Zm9vCg==' . "\n" .
+    'sha:' . '{SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g=' . "\n" .
+    'sha2:' . '{SHA}_____Mm5Pz8GgiULbPgzG37mj9g=' . "\n" .
+    'sha3:' . '{SHA}Zm9vCg==' . "\n"
+);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!401 Unauthorized!ms, 'rejects unathorized');
+
+SKIP: {
+
+skip 'no crypt on win32', 5 if $^O eq 'MSWin32';
+
+like(http_get_auth('/', 'crypt', 'password'), qr!SEETHIS!, 'normal crypt');
+unlike(http_get_auth('/', 'crypt', '123'), qr!SEETHIS!, 'normal wrong');
+
+like(http_get_auth('/', 'crypt1', 'password'), qr!SEETHIS!, 'crypt $1$ (md5)');
+unlike(http_get_auth('/', 'crypt1', '123'), qr!SEETHIS!, 'crypt $1$ wrong');
+
+like(http_get_auth('/', 'crypt2', '1'), qr!401 Unauthorized!,
+    'crypt $1$ broken');
+
+}
+
+like(http_get_auth('/', 'apr1', 'password'), qr!SEETHIS!, 'apr1 md5');
+like(http_get_auth('/', 'plain', 'password'), qr!SEETHIS!, 'plain password');
+like(http_get_auth('/', 'ssha', 'password'), qr!SEETHIS!, 'ssha');
+like(http_get_auth('/', 'sha', 'password'), qr!SEETHIS!, 'sha');
+
+unlike(http_get_auth('/', 'apr1', '123'), qr!SEETHIS!, 'apr1 md5 wrong');
+unlike(http_get_auth('/', 'plain', '123'), qr!SEETHIS!, 'plain wrong');
+unlike(http_get_auth('/', 'ssha', '123'), qr!SEETHIS!, 'ssha wrong');
+unlike(http_get_auth('/', 'sha', '123'), qr!SEETHIS!, 'sha wrong');
+
+like(http_get_auth('/', 'apr12', '1'), qr!401 Unauthorized!, 'apr1 md5 broken');
+like(http_get_auth('/', 'ssha2', '1'), qr!401 Unauthorized!, 'ssha broken 1');
+like(http_get_auth('/', 'ssha3', '1'), qr!401 Unauthorized!, 'ssha broken 2');
+like(http_get_auth('/', 'sha2', '1'), qr!401 Unauthorized!, 'sha broken 1');
+like(http_get_auth('/', 'sha3', '1'), qr!401 Unauthorized!, 'sha broken 2');
+
+like(http_get_auth('/', 'notfound', '1'), qr!401 Unauthorized!, 'not found');
+like(http_get('/inner/'), qr!SEETHIS!, 'inner off');
+
+###############################################################################
+
+sub http_get_auth {
+    my ($url, $user, $password) = @_;
+
+    my $auth = encode_base64($user . ':' . $password, '');
+
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic $auth
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/auth_delay.t ../asynch_mode_nginx/test/nginx-tests/auth_delay.t
--- nginx-release-1.20.1/test/nginx-tests/auth_delay.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/auth_delay.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for auth_delay directive using auth basic module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http auth_basic/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            auth_delay           2s;
+
+            auth_basic           "closed site";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('htpasswd', 'user:' . '{PLAIN}good' . "\n");
+
+$t->try_run('no auth_delay')->plan(4);
+
+###############################################################################
+
+my $t1 = time();
+like(http_get_auth('/', 'user', 'bad'), qr/401 Unauthorize/, 'not authorized');
+cmp_ok(time() - $t1, '>=', 2, 'auth delay');
+
+$t1 = time();
+like(http_get_auth('/', 'user', 'good'), qr/200 OK/, 'authorized');
+cmp_ok(time() - $t1, '<', 2, 'no delay');
+
+###############################################################################
+
+sub http_get_auth {
+    my ($url, $user, $password) = @_;
+
+    my $auth = encode_base64($user . ':' . $password, '');
+
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic $auth
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/auth_request_satisfy.t ../asynch_mode_nginx/test/nginx-tests/auth_request_satisfy.t
--- nginx-release-1.20.1/test/nginx-tests/auth_request_satisfy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/auth_request_satisfy.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,137 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for auth request module with satisfy directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+    ->has(qw/http rewrite access auth_basic auth_request/)
+    ->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /all/allow {
+            satisfy all;
+            allow all;
+            auth_request /auth;
+        }
+
+        location /all/deny {
+            satisfy all;
+            deny all;
+            auth_request /auth;
+        }
+
+        location /all/basic {
+            satisfy all;
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+            auth_request /auth;
+        }
+
+        location /any/allow {
+            satisfy any;
+            allow all;
+            auth_request /auth;
+        }
+
+        location /any/deny {
+            satisfy any;
+            deny all;
+            auth_request /auth;
+        }
+
+        location /any/basic {
+            satisfy any;
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+            auth_request /auth;
+        }
+
+        location = /auth {
+            if ($request_uri ~ "open$") {
+                return 204;
+            }
+            if ($request_uri ~ "unauthorized$") {
+                return 401;
+            }
+            if ($request_uri ~ "forbidden$") {
+                return 403;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('htpasswd', 'user:{PLAIN}secret' . "\n");
+$t->run();
+
+###############################################################################
+
+# satisfy all - first 401/403 wins
+
+like(http_get('/all/allow+open'), qr/ 404 /, 'all allow+open');
+like(http_get('/all/allow+unauthorized'), qr/ 401 /, 'all allow+unauthorized');
+like(http_get('/all/allow+forbidden'), qr/ 403 /, 'all allow+forbidden');
+
+like(http_get('/all/deny+open'), qr/ 403 /, 'all deny+open');
+like(http_get('/all/deny+unauthorized'), qr/ 403 /, 'all deny+unauthorized');
+like(http_get('/all/deny+forbidden'), qr/ 403 /, 'all deny+forbidden');
+
+like(http_get('/all/basic+open'), qr/ 401 /, 'all basic+open');
+like(http_get('/all/basic+unauthorized'), qr/ 401 /, 'all basic+unauthorized');
+like(http_get('/all/basic+forbidden'), qr/ 401 /, 'all basic+forbidden');
+
+# satisfy any - first ok wins
+# additionally, 403 shouldn't override 401 status
+
+like(http_get('/any/allow+open'), qr/ 404 /, 'any allow+open');
+like(http_get('/any/allow+unauthorized'), qr/ 404 /, 'any allow+unauthorized');
+like(http_get('/any/allow+forbidden'), qr/ 404 /, 'any allow+forbidden');
+
+like(http_get('/any/deny+open'), qr/ 404 /, 'any deny+open');
+like(http_get('/any/deny+unauthorized'), qr/ 401 /, 'any deny+unauthorized');
+like(http_get('/any/deny+forbidden'), qr/ 403 /, 'any deny+forbidden');
+
+like(http_get('/any/basic+open'), qr/ 404 /, 'any basic+open');
+like(http_get('/any/basic+unauthorized'), qr/ 401 /, 'any basic+unauthorized');
+like(http_get('/any/basic+forbidden'), qr/ 401 /, 'any basic+forbidden');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/auth_request_set.t ../asynch_mode_nginx/test/nginx-tests/auth_request_set.t
--- nginx-release-1.20.1/test/nginx-tests/auth_request_set.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/auth_request_set.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,145 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for auth request module, auth_request_set.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy auth_request/)
+    ->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /t1.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            add_header X-Set-Username $username;
+        }
+
+        location = /t2.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = /fallback;
+        }
+        location = /fallback {
+            add_header X-Set-Username $username;
+            return 204;
+        }
+
+        location = /t3.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = @fallback;
+        }
+        location @fallback {
+            add_header X-Set-Username $username;
+            return 204;
+        }
+
+        location = /t4.html {
+            auth_request /auth;
+            auth_request_set $username $upstream_http_x_username;
+            error_page 404 = /t4-fallback.html;
+        }
+        location = /t4-fallback.html {
+            auth_request /auth2;
+            auth_request_set $username $upstream_http_x_username;
+            add_header X-Set-Username $username;
+        }
+
+        location = /t5.html {
+            auth_request /auth;
+            auth_request_set $args "setargs";
+            proxy_pass http://127.0.0.1:8081/t5.html;
+        }
+
+        location = /t6.html {
+            add_header X-Unset-Username "x${username}x";
+            return 204;
+        }
+
+        location = /auth {
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location = /auth2 {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location = /auth {
+            add_header X-Username "username";
+            return 204;
+        }
+
+        location = /auth2 {
+            add_header X-Username "username2";
+            return 204;
+        }
+
+        location = /t5.html {
+            add_header X-Args $args;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t4-fallback.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html'), qr/X-Set-Username: username/, 'set normal');
+like(http_get('/t2.html'), qr/X-Set-Username: username/, 'set after redirect');
+like(http_get('/t3.html'), qr/X-Set-Username: username/,
+    'set after named location');
+like(http_get('/t4.html'), qr/X-Set-Username: username2/,
+    'set on second auth');
+
+# there are two variables with set_handler: $args and $limit_rate
+# we do test $args as it's a bit more simple thing to do
+
+like(http_get('/t5.html'), qr/X-Args: setargs/, 'variable with set_handler');
+
+# check that using variable without setting it returns empty content
+
+like(http_get('/t6.html'), qr/X-Unset-Username: xx/, 'unset variable');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/auth_request.t ../asynch_mode_nginx/test/nginx-tests/auth_request.t
--- nginx-release-1.20.1/test/nginx-tests/auth_request.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/auth_request.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,257 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for auth request module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+    ->has(qw/http rewrite proxy cache fastcgi auth_basic auth_request/)
+    ->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /open {
+            auth_request /auth-open;
+        }
+        location = /auth-open {
+            return 204;
+        }
+
+        location /open-static {
+            auth_request /auth-open-static;
+        }
+        location = /auth-open-static {
+            # nothing, use static file
+        }
+
+        location /unauthorized {
+            auth_request /auth-unauthorized;
+        }
+        location = /auth-unauthorized {
+            return 401;
+        }
+
+        location /forbidden {
+            auth_request /auth-forbidden;
+        }
+        location = /auth-forbidden {
+            return 403;
+        }
+
+        location /error {
+            auth_request /auth-error;
+        }
+        location = /auth-error {
+            return 404;
+        }
+
+        location /off {
+            auth_request off;
+        }
+
+        location /proxy {
+            auth_request /auth-proxy;
+        }
+        location = /auth-proxy {
+            proxy_pass http://127.0.0.1:8080/auth-basic;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+        location = /auth-basic {
+            auth_basic "restricted";
+            auth_basic_user_file %%TESTDIR%%/htpasswd;
+        }
+
+        location = /proxy-double {
+            proxy_pass http://127.0.0.1:8080/auth-error;
+            proxy_intercept_errors on;
+            error_page 404 = /proxy-double-fallback;
+            client_body_buffer_size 4k;
+        }
+        location = /proxy-double-fallback {
+            auth_request /auth-proxy-double;
+            proxy_pass http://127.0.0.1:8080/auth-open;
+        }
+        location = /auth-proxy-double {
+            proxy_pass http://127.0.0.1:8080/auth-open;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+
+        location /proxy-cache {
+            auth_request /auth-proxy-cache;
+        }
+        location = /auth-proxy-cache {
+            proxy_pass http://127.0.0.1:8080/auth-basic;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+        }
+
+        location /fastcgi {
+            auth_request /auth-fastcgi;
+        }
+        location = /auth-fastcgi {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_pass_request_body off;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('htpasswd', 'user:{PLAIN}secret' . "\n");
+$t->write_file('auth-basic', 'INVISIBLE');
+$t->write_file('auth-open-static', 'INVISIBLE');
+$t->run();
+
+###############################################################################
+
+like(http_get('/open'), qr/ 404 /, 'auth open');
+like(http_get('/unauthorized'), qr/ 401 /, 'auth unauthorized');
+like(http_get('/forbidden'), qr/ 403 /, 'auth forbidden');
+like(http_get('/error'), qr/ 500 /, 'auth error');
+like(http_get('/off'), qr/ 404 /, 'auth off');
+
+like(http_post('/open'), qr/ 404 /, 'auth post open');
+like(http_post('/unauthorized'), qr/ 401 /, 'auth post unauthorized');
+
+like(http_get('/open-static'), qr/ 404 /, 'auth open static');
+unlike(http_get('/open-static'), qr/INVISIBLE/, 'auth static no content');
+
+like(http_get('/proxy'), qr/ 401 /, 'proxy auth unauthorized');
+like(http_get('/proxy'), qr/WWW-Authenticate: Basic realm="restricted"/,
+    'proxy auth has www-authenticate');
+like(http_get_auth('/proxy'), qr/ 404 /, 'proxy auth pass');
+unlike(http_get_auth('/proxy'), qr/INVISIBLE/, 'proxy auth no content');
+
+like(http_post('/proxy'), qr/ 401 /, 'proxy auth post');
+
+like(http_get_auth('/proxy-cache'), qr/ 404 /, 'proxy auth with cache');
+like(http_get('/proxy-cache'), qr/ 404 /, 'proxy auth cached');
+
+# Consider the following scenario:
+#
+# 1. proxy_pass reads request body, then goes to fallback via error_page
+# 2. auth request uses proxy_pass, and upstream module closes request body file
+#    in ngx_http_upstream_send_response()
+# 3. oops: fallback has no body
+#
+# To prevent this we always allocate fake request body for auth request.
+#
+# Note that this doesn't happen when using header_only as relevant code
+# in ngx_http_upstream_send_response() isn't reached.  It may be reached
+# with proxy_cache or proxy_store, but they will shutdown client connection
+# in case of header_only and hence do not work for us at all.
+
+like(http_post_big('/proxy-double'), qr/ 204 /, 'proxy auth with body read');
+
+SKIP: {
+    eval { require FCGI; };
+    skip 'FCGI not installed', 2 if $@;
+    skip 'win32', 2 if $^O eq 'MSWin32';
+
+    $t->run_daemon(\&fastcgi_daemon);
+    $t->waitforsocket('127.0.0.1:' . port(8081));
+
+    like(http_get('/fastcgi'), qr/ 404 /, 'fastcgi auth open');
+    unlike(http_get('/fastcgi'), qr/INVISIBLE/, 'fastcgi auth no content');
+}
+
+###############################################################################
+
+sub http_get_auth {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+Authorization: Basic dXNlcjpzZWNyZXQ=
+
+EOF
+}
+
+sub http_post {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10" . CRLF .
+        CRLF .
+        "1234567890";
+
+    return http($p, %extra);
+}
+
+sub http_post_big {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10240" . CRLF .
+        CRLF .
+        ("1234567890" x 1024);
+
+    return http($p, %extra);
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    while ($request->Accept() >= 0) {
+        print <<EOF;
+Content-Type: text/html
+
+INVISIBLE
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/autoindex_format.t ../asynch_mode_nginx/test/nginx-tests/autoindex_format.t
--- nginx-release-1.20.1/test/nginx-tests/autoindex_format.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/autoindex_format.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,176 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for autoindex module with autoindex_format directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http autoindex symlink/)->plan(37)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        autoindex on;
+
+        location /xml/ {
+            autoindex_format xml;
+            alias %%TESTDIR%%/;
+        }
+        location /json/ {
+            autoindex_format json;
+            alias %%TESTDIR%%/;
+        }
+        location /jsonp/ {
+            autoindex_format jsonp;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/test-dir");
+symlink("$d/test-dir", "$d/test-dir-link");
+
+$t->write_file('test-file', 'x' x 42);
+symlink("$d/test-file", "$d/test-file-link");
+
+$t->write_file('test-\'-quote', '');
+$t->write_file('test-"-double', '');
+$t->write_file('test-<>-angle', '');
+
+mkdir($d . '/utf8');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 45), '');
+
+$t->run();
+
+###############################################################################
+
+my ($r, $mtime, $data);
+
+$r = http_get('/xml/');
+$mtime = qr/mtime="\d{4}-\d\d-\d\dT\d\d:\d\d:\d\dZ"/;
+
+like($r, qr!Content-Type: text/xml; charset=utf-8!, 'xml content type');
+like($r, qr!<file(\s+\w+="[^=]*?")+\s*>test-file</file>!,
+    'xml file format');
+like($r, qr!<directory(\s+\w+="[^=]*?")+\s*>test-dir</directory>!,
+    'xml dir format');
+
+($data) = $r =~ qr!<file\s+(.*?)>test-file</file>!;
+like($data, $mtime, 'xml file mtime');
+like($data, qr!size="42"!, 'xml file size');
+
+($data) = $r =~ qr!<file\s+(.*?)>test-file-link</file>!;
+like($data, $mtime, 'xml file link mtime');
+like($data, qr!size="42"!, 'xml file link size');
+
+($data) = $r =~ qr!<directory\s+(.*?)>test-dir</directory>!;
+like($data, $mtime, 'xml dir mtime');
+unlike($data, qr!size="\d+"!, 'xml dir size');
+
+($data) = $r =~ qr!<directory\s+(.*?)>test-dir-link</directory>!;
+like($data, $mtime, 'xml dir link mtime');
+unlike($data, qr!size="\d+"!, 'xml dir link size');
+
+like($r, qr!<file.*?>test-\'-quote</file>!, 'xml quote');
+like($r, qr!<file.*?>test-\&quot;-double</file>!, 'xml double');
+like($r, qr!<file.*?>test-&lt;&gt;-angle</file>!, 'xml angle');
+
+
+$r = http_get('/json/');
+$mtime = qr/"mtime"\s*:\s*"\w{3}, \d\d \w{3} \d{4} \d\d:\d\d:\d\d \w{3}"/;
+
+my $string = qr!"(?:[^\\"]+|\\["\\/bfnrt])*"!;
+my $number = qr!-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][-+]?\d+)?!;
+my $kv = qr!\s*$string\s*:\s*($string|$number)\s*!;
+
+like($r, qr!Content-Type: application/json!, 'json content type');
+like($r, qr!{$kv(,$kv)*}!, 'json format');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-file".*?})!;
+like($data, qr!"type"\s*:\s*"file"!, 'json file');
+like($data, $mtime, 'json file mtime');
+like($data, qr!"size"\s*:\s*42!, 'json file size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-file-link".*?})!;
+like($data, qr!"type"\s*:\s*"file"!, 'json file link');
+like($data, $mtime, 'json file link mtime');
+like($data, qr!"size"\s*:\s*42!, 'json file link size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-dir".*?})!;
+like($data, qr!"type"\s*:\s*"directory"!, 'json dir');
+like($data, $mtime, 'json dir mtime');
+unlike($data, qr!"size"\s*:\s*$number!, 'json dir size');
+
+($data) = $r =~ qr!(\{[^}]*?"name"\s*:\s*"test-dir-link".*?})!;
+like($data, qr!"type"\s*:\s*"directory"!, 'json dir link');
+like($data, $mtime, 'json dir link mtime');
+unlike($data, qr!"size"\s*:\s*$number!, 'json dir link size');
+
+like($r, qr!"name"\s*:\s*"test-'-quote"!, 'json quote');
+like($r, qr!"name"\s*:\s*"test-\\\"-double"!, 'json double');
+like($r, qr!"name"\s*:\s*"test-<>-angle"!, 'json angle');
+
+like(http_get_body('/jsonp/test-dir/?callback=foo'),
+    qr/^\s*foo\s*\(\s*\[\s*\]\s*\)\s*;\s*$/ms, 'jsonp callback');
+like(http_get_body('/jsonp/test-dir/?callback='),
+    qr/^\s*\[\s*\s*\]\s*$/ms, 'jsonp callback empty');
+
+# utf8 tests
+
+$r = http_get('/xml/utf8/');
+like($r, qr!test-utf8-(\xd1\x84){3}</file>!ms, 'xml utf8');
+like($r, qr!test-utf8-(\xd1\x84){45}</file>!ms, 'xml utf8 long');
+
+$r = http_get('/json/utf8/');
+like($r, qr!test-utf8-(\xd1\x84){3}"!ms, 'json utf8');
+like($r, qr!test-utf8-(\xd1\x84){45}"!ms, 'json utf8 long');
+
+###############################################################################
+
+sub http_get_body {
+    my ($uri) = @_;
+
+    return undef if !defined $uri;
+
+    http_get($uri) =~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms;
+
+    return $2;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/autoindex.t ../asynch_mode_nginx/test/nginx-tests/autoindex.t
--- nginx-release-1.20.1/test/nginx-tests/autoindex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/autoindex.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,110 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for autoindex module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http autoindex charset symlink/)->plan(16)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            autoindex on;
+        }
+        location /utf8/ {
+            autoindex on;
+            charset utf-8;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/test-dir");
+symlink("$d/test-dir", "$d/test-dir-link");
+
+$t->write_file('test-file', '');
+symlink("$d/test-file", "$d/test-file-link");
+
+$t->write_file('test-colon:blah', '');
+$t->write_file('test-long-' . ('0' x 50), '');
+$t->write_file('test-long-' . ('>' x 50), '');
+$t->write_file('test-escape-url-%', '');
+$t->write_file('test-escape-url2-?', '');
+$t->write_file('test-escape-html-<>&', '');
+
+mkdir($d . '/utf8');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 45), '');
+$t->write_file('utf8/test-utf8-<>&-' . "\xd1\x84", '');
+$t->write_file('utf8/test-utf8-<>&-' . ("\xd1\x84" x 45), '');
+$t->write_file('utf8/test-utf8-' . ("\xd1\x84" x 3) . '-' . ('>' x 45), '');
+
+mkdir($d . '/test-dir-escape-<>&');
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+
+like($r, qr!href="test-file"!ms, 'file');
+like($r, qr!href="test-file-link"!ms, 'symlink to file');
+like($r, qr!href="test-dir/"!ms, 'directory');
+like($r, qr!href="test-dir-link/"!ms, 'symlink to directory');
+
+unlike($r, qr!href="test-colon:blah"!ms, 'colon not scheme');
+like($r, qr!test-long-0{37}\.\.&gt;!ms, 'long name');
+
+like($r, qr!href="test-escape-url-%25"!ms, 'escaped url');
+like($r, qr!href="test-escape-url2-%3f"!msi, 'escaped ? in url');
+like($r, qr!test-escape-html-&lt;&gt;&amp;!ms, 'escaped html');
+like($r, qr!test-long-(&gt;){37}\.\.&gt;!ms, 'long escaped html');
+
+$r = http_get('/utf8/');
+
+like($r, qr!test-utf8-(\xd1\x84){3}</a>!ms, 'utf8');
+like($r, qr!test-utf8-(\xd1\x84){37}\.\.!ms, 'utf8 long');
+
+like($r, qr!test-utf8-&lt;&gt;&amp;-\xd1\x84</a>!ms, 'utf8 escaped');
+like($r, qr!test-utf8-&lt;&gt;&amp;-(\xd1\x84){33}\.\.!ms,
+    'utf8 escaped long');
+like($r, qr!test-utf8-(\xd1\x84){3}-(&gt;){33}\.\.!ms, 'utf8 long escaped');
+
+like(http_get('/test-dir-escape-<>&/'), qr!test-dir-escape-&lt;&gt;&amp;!ms,
+    'escaped title');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/binary_upgrade.t ../asynch_mode_nginx/test/nginx-tests/binary_upgrade.t
--- nginx-release-1.20.1/test/nginx-tests/binary_upgrade.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/binary_upgrade.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for binary upgrade.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'can leave orphaned process group')
+    unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new(qr/http unix/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->run();
+
+###############################################################################
+
+my $pid = $t->read_file('nginx.pid');
+ok($pid, 'master pid');
+
+kill 'USR2', $pid;
+
+for (1 .. 30) {
+    last if -e "$d/nginx.pid" && -e "$d/nginx.pid.oldbin";
+    select undef, undef, undef, 0.2
+}
+
+isnt($t->read_file('nginx.pid'), $pid, 'master pid changed');
+
+kill 'QUIT', $pid;
+
+for (1 .. 30) {
+    last if ! -e "$d/nginx.pid.oldbin";
+    select undef, undef, undef, 0.2
+}
+
+ok(-e "$d/unix.sock", 'unix socket exists on old master shutdown');
+
+# unix socket on new master termination
+
+$pid = $t->read_file('nginx.pid');
+
+kill 'USR2', $pid;
+
+for (1 .. 30) {
+    last if -e "$d/nginx.pid" && -e "$d/nginx.pid.oldbin";
+    select undef, undef, undef, 0.2
+}
+
+kill 'TERM', $t->read_file('nginx.pid');
+
+for (1 .. 30) {
+    last if ! -e "$d/nginx.pid.oldbin";
+    select undef, undef, undef, 0.2
+}
+
+TODO: {
+$TODO = 'not yet' unless $t->has_version('1.19.1');
+
+ok(-e "$d/unix.sock", 'unix socket exists on new master termination');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/body_chunked.t ../asynch_mode_nginx/test/nginx-tests/body_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/body_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/body_chunked.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,234 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx request body reading, with chunked transfer-coding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8080 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /b {
+            client_body_buffer_size 2k;
+            client_body_in_file_only on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /large {
+            client_max_body_size 1k;
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /next {
+            proxy_pass http://u/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/', '0123456789' x 512),
+    qr/X-Body-File/ms, 'body in file');
+
+like(read_body_file(http_get_body('/b', '0123456789' x 512)),
+    qr/^(0123456789){512}$/s, 'body in file only');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/large', '0123456789' x 128), qr/ 413 /, 'body too large');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'chunked body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'chunked body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+    '0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+    'chunked body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+    '0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+    'chunked body discard 2');
+
+# invalid chunks
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+like(
+    http(
+        'GET / HTTP/1.1' . CRLF
+        . 'Host: localhost' . CRLF
+        . 'Connection: close' . CRLF
+        . 'Transfer-Encoding: chunked' . CRLF . CRLF
+        . '4' . CRLF
+        . 'SEE-THIS' . CRLF
+        . '0' . CRLF . CRLF
+    ),
+    qr/400 Bad/, 'runaway chunk'
+);
+
+like(
+    http(
+        'GET /discard HTTP/1.1' . CRLF
+        . 'Host: localhost' . CRLF
+        . 'Connection: close' . CRLF
+        . 'Transfer-Encoding: chunked' . CRLF . CRLF
+        . '4' . CRLF
+        . 'SEE-THIS' . CRLF
+        . '0' . CRLF . CRLF
+    ),
+    qr/400 Bad/, 'runaway chunk discard'
+);
+
+}
+
+# proxy_next_upstream
+
+like(http_get_body('/next', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body chunked next upstream');
+# invalid Transfer-Encoding
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_transfer_encoding('identity'), qr/501 Not Implemented/,
+    'transfer encoding identity');
+like(http_transfer_encoding("chunked\nTransfer-Encoding: chunked"),
+    qr/400 Bad/, 'transfer encoding repeat');
+}
+
+like(http_transfer_encoding('chunked, identity'), qr/501 Not Implemented/,
+    'transfer encoding list');
+
+###############################################################################
+
+sub read_body_file {
+    my ($r) = @_;
+    return '' unless $r =~ m/X-Body-File: (.*)/;
+    open FILE, $1
+        or return "$!";
+    local $/;
+    my $content = <FILE>;
+    close FILE;
+    return $content;
+}
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $body) . CRLF
+        . $body . CRLF
+        . "0" . CRLF . CRLF
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $last) . CRLF
+        . $last . CRLF
+        . "0" . CRLF . CRLF
+    );
+}
+
+sub http_transfer_encoding {
+    my ($encoding) = @_;
+
+    http("GET / HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Transfer-Encoding: $encoding" . CRLF . CRLF
+        . "0" . CRLF . CRLF);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/body.t ../asynch_mode_nginx/test/nginx-tests/body.t
--- nginx-release-1.20.1/test/nginx-tests/body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/body.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,221 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx request body reading.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8080 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /b {
+            client_body_buffer_size 2k;
+            client_body_in_file_only on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            add_header X-Original-Uri "$request_uri";
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            add_header X-Body-File "$request_body_file";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /large {
+            client_max_body_size 1k;
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /next {
+            proxy_pass http://u/;
+        }
+        location /redirect {
+            error_page 404 http://example.com/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/', '0123456789' x 512),
+    qr/X-Body-File/ms, 'body in file');
+
+like(read_body_file(http_get_body('/b', '0123456789' x 512)),
+    qr/^(0123456789){512}$/s, 'body in file only');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/large', '0123456789' x 128), qr/ 413 /, 'body too large');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+    '0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+    '0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard 2');
+
+# proxy with file only
+
+like(http_get_body('/small', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# proxy with file only - reuse of r->header_in
+
+like(
+    http(
+        'GET /small HTTP/1.0' . CRLF
+        . 'Content-Length: 10' . CRLF . CRLF
+        . '01234',
+        sleep => 0.1,
+        body => '56789'
+    ),
+    qr!X-Body: 0123456789\x0d?\x0a.*X-Original-Uri: /small!ms,
+    'small body in file only, not preread'
+);
+
+# proxy_next_upstream
+
+like(http_get_body('/next', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body next upstream');
+
+# discarded request body in redirect via error_page
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+unlike(
+    http(
+        'POST /redirect HTTP/1.1' . CRLF
+        . 'Host: localhost' . CRLF
+        . 'Content-Length: 10' . CRLF . CRLF
+        . '0123456789' .
+        'GET /next HTTP/1.0' . CRLF . CRLF
+    ),
+    qr/400 Bad Request/ms, 'redirect - discard request body'
+);
+
+}
+
+###############################################################################
+
+sub read_body_file {
+    my ($r) = @_;
+    return '' unless $r =~ m/X-Body-File: (.*)/;
+    open FILE, $1
+        or return "$!";
+    local $/;
+    my $content = <FILE>;
+    close FILE;
+    return $content;
+}
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Content-Length: " . (length $body) . CRLF . CRLF
+        . $body
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Content-Length: " . (length $last) . CRLF . CRLF
+        . $last
+    );
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/charset_gzip_static.t ../asynch_mode_nginx/test/nginx-tests/charset_gzip_static.t
--- nginx-release-1.20.1/test/nginx-tests/charset_gzip_static.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/charset_gzip_static.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,145 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for charset filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy charset gzip_static/)->plan(13)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+    }
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t1 {
+            charset utf-8;
+            gzip_static on;
+        }
+
+        location /t2 {
+            gzip_static on;
+            charset A;
+            source_charset B;
+        }
+
+        location /t {
+            gzip_static on;
+        }
+
+        location /p/ {
+            charset utf-8;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+
+        location /p.ab/ {
+            charset A;
+            source_charset B;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+
+        location /p.aa/ {
+            charset A;
+            source_charset A;
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_http_version 1.1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t1.html.gz', '');
+
+my $in = 'X' x 99;
+my $out = '';
+
+eval {
+    require IO::Compress::Gzip;
+    IO::Compress::Gzip::gzip(\$in => \$out);
+};
+
+$t->write_file('t2.html', $in);
+$t->write_file('t2.html.gz', $out);
+
+$t->write_file('t.html', '');
+$t->write_file('t.html.gz', '');
+
+###############################################################################
+
+# charset filter currently ignores responses with Content-Encoding set
+# (except ones with r->ignore_content_encoding used by gzip_static)
+# as it can't convert such content; there are two problems though:
+#
+# - it make sense to indicate charset
+#   if conversion isn't needed
+#
+# - gzip_static may need conversion, too
+#
+# proper solution seems to be to always allow charset indication, but
+# don't try to do anything if recoding is needed
+
+like(http_get('/t1.html'), qr!text/html; charset=!, 'plain');
+like(http_gzip_request('/t1.html'), qr!text/html; charset=.*gzip!ms, 'gzip');
+
+like(http_get('/t2.html'), qr!text/html; charset=A.*Y{99}!ms, 'recode plain');
+like(http_gzip_request('/t2.html'), qr!text/html\x0d.*gzip!ms, 'recode gzip');
+http_gzip_like(http_gzip_request('/t2.html'), qr!X{99}!, 'recode content');
+
+like(http_get('/t.html'), qr!text/html\x0d!, 'nocharset plain');
+like(http_gzip_request('/t.html'), qr!text/html\x0d.*gzip!ms, 'nocharset gzip');
+
+like(http_get('/p/t.html'), qr!text/html; charset=!, 'proxy plain');
+like(http_gzip_request('/p/t.html'), qr!text/html; charset=.*gzip!ms,
+    'proxy gzip');
+
+like(http_get('/p.ab/t.html'), qr!text/html; charset=A!ms,
+    'proxy recode plain');
+like(http_gzip_request('/p.ab/t.html'), qr!text/html\x0d.*gzip!ms,
+    'proxy recode gzip');
+
+like(http_get('/p.aa/t.html'), qr!text/html; charset=A!ms,
+    'proxy nullrecode plain');
+like(http_gzip_request('/p.aa/t.html'), qr!text/html; charset=A.*gzip!ms,
+    'proxy nullrecode gzip');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/charset.t ../asynch_mode_nginx/test/nginx-tests/charset.t
--- nginx-release-1.20.1/test/nginx-tests/charset.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/charset.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for charset filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset proxy/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+        text/foo  foo;
+    }
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            charset utf-8;
+        }
+
+        location /t3.foo {
+            charset utf-8;
+            charset_types text/foo;
+        }
+
+        location /t4.any {
+            charset utf-8;
+            charset_types *;
+        }
+
+        location /t5.html {
+            charset $arg_c;
+        }
+
+        location /t.html {
+            charset A;
+            source_charset B;
+        }
+
+        location /proxy/ {
+            charset B;
+            override_charset on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', '');
+$t->write_file('t2.foo', '');
+$t->write_file('t3.foo', '');
+$t->write_file('t4.any', '');
+$t->write_file('t5.html', '');
+$t->write_file('t.html', 'X' x 99);
+
+###############################################################################
+
+like(http_get('/t1.html'), qr!text/html; charset=utf-8!, 'charset indicated');
+like(http_get('/t2.foo'), qr!text/foo\x0d!, 'wrong type');
+like(http_get('/t3.foo'), qr!text/foo; charset=utf-8!, 'charset_types');
+like(http_get('/t4.any'), qr!text/plain; charset=utf-8!, 'charset_types any');
+like(http_get('/t5.html?c=utf-8'), qr!text/html; charset=utf-8!, 'variables');
+
+like(http_get('/t.html'), qr!Y{99}!, 'recode');
+like(http_get('/proxy/t.html'), qr!X{99}!, 'override charset');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/config_dump.t ../asynch_mode_nginx/test/nginx-tests/config_dump.t
--- nginx-release-1.20.1/test/nginx-tests/config_dump.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/config_dump.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,113 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for dumped nginx configuration (nginx -T).
+# Among other things, test that configuration blocks are properly processed.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map/);
+
+$t->plan(13)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+include %%TESTDIR%%/inc.conf;
+include %%TESTDIR%%/inc.conf;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        default  0;
+        foo      bar;
+        include  map.conf;
+        include  map.conf;
+    }
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('inc.conf', 'include inc2.conf;');
+$t->write_file('inc2.conf', '#inc2.conf');
+$t->write_file('map.conf', '#map.conf;');
+
+$t->run();
+
+###############################################################################
+
+my $d = $t->testdir;
+
+my $dump = $t->dump_config();
+like($dump, qr!^# configuration file $d/nginx.conf:$!m, 'nginx.conf found');
+like($dump, qr!^# configuration file $d/inc.conf:$!m, 'inc.conf found');
+like($dump, qr!^# configuration file $d/inc2.conf:$!m, 'inc2.conf found');
+like($dump, qr!^# configuration file $d/map.conf:$!m, 'map.conf found');
+
+unlike($dump, qr!(# configuration file $d/inc.conf:).*\1!s, 'inc.conf uniq');
+unlike($dump, qr!(# configuration file $d/inc2.conf:).*\1!s, 'inc2.conf uniq');
+unlike($dump, qr!(# configuration file $d/map.conf:).*\1!s, 'map.conf uniq');
+
+is(getconf($t, $dump, 'nginx.conf'), $t->read_file('nginx.conf'), 'content');
+is(getconf($t, $dump, 'inc.conf'), $t->read_file('inc.conf'), 'content inc');
+is(getconf($t, $dump, 'map.conf'), $t->read_file('map.conf'), 'content inc 2');
+
+unlink($t->testdir . "/inc.conf");
+unlink($t->testdir . "/map.conf");
+
+$dump = $t->dump_config();
+unlike($dump, qr!file $d/inc.conf!, 'missing inc.conf');
+unlike($dump, qr!file $d/map.conf!, 'missing map.conf');
+like($dump, qr!file $d/nginx.conf test failed!, 'test failed');
+
+$t->write_file('inc.conf', 'include inc2.conf;');
+$t->write_file('inc2.conf', '#inc2.conf');
+$t->write_file('map.conf', '#map.conf;');
+
+###############################################################################
+
+sub getconf {
+    my ($t, $string, $conf) = @_;
+    my $prefix = "# configuration file $d/$conf:\n";
+    my $offset = index($string, $prefix) + length($prefix);
+    my $len = length($t->read_file($conf));
+    my $s = substr($string, $offset, $len);
+    $s =~ tr/\r//d;
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/dav_chunked.t ../asynch_mode_nginx/test/nginx-tests/dav_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/dav_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/dav_chunked.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx dav module with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http dav/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        client_body_buffer_size 2k;
+
+        location / {
+            dav_methods PUT;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+1234567890
+0
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put chunked');
+is($t->read_file('file'), '1234567890', 'put content');
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+like($r, qr/204 No Content/, 'put chunked empty');
+is($t->read_file('file'), '', 'put empty content');
+
+my $body = ('a' . CRLF . '1234567890' . CRLF) x 1024 . '0' . CRLF . CRLF;
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+$body
+EOF
+
+like($r, qr/204 No Content/, 'put chunked big');
+is($t->read_file('file'), '1234567890' x 1024, 'put big content');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/dav.t ../asynch_mode_nginx/test/nginx-tests/dav.t
--- nginx-release-1.20.1/test/nginx-tests/dav.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/dav.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,288 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx dav module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http dav/)->plan(28);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        absolute_redirect off;
+
+        location / {
+            dav_methods PUT DELETE MKCOL COPY MOVE;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+            dav_methods PUT DELETE MKCOL COPY MOVE;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http(<<EOF . '0123456789');
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put file');
+is(-s $t->testdir() . '/file', 10, 'put file size');
+
+$r = http(<<EOF);
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 0
+
+EOF
+
+like($r, qr/204 No Content/, 'put file again');
+unlike($r, qr/Content-Length|Transfer-Encoding/, 'no length in 204');
+is(-s $t->testdir() . '/file', 0, 'put file again size');
+
+$r = http(<<EOF);
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 0
+
+EOF
+
+like($r, qr/204 No Content/, 'delete file');
+unlike($r, qr/Content-Length|Transfer-Encoding/, 'no length in 204');
+ok(!-f $t->testdir() . '/file', 'file deleted');
+
+$r = http(<<EOF . '0123456789' . 'extra');
+PUT /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms,
+    'put file extra data');
+is(-s $t->testdir() . '/file', 10,
+    'put file extra data size');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$r = http(<<EOF . '0123456789');
+PUT /file%20sp HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr!Location: /file%20sp\x0d?$!ms, 'put file escaped');
+
+}
+
+# 201 replies contain body, response should indicate it's empty
+
+$r = http(<<EOF);
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'mkcol');
+
+SKIP: {
+skip 'perl too old', 1 if !$^V or $^V lt v5.12.0;
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+like($r, qr!(?(?{ $r =~ /Location/ })Location: /test/)!, 'mkcol location');
+
+}
+
+}
+
+$r = http(<<EOF);
+COPY /test/ HTTP/1.1
+Host: localhost
+Destination: /test-moved/
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'copy dir');
+
+$r = http(<<EOF);
+MOVE /test/ HTTP/1.1
+Host: localhost
+Destination: /test-moved/
+Connection: close
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'move dir');
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file-moved%20escape
+Connection: close
+
+EOF
+
+like($r, qr/204 No Content/, 'copy file escaped');
+is(-s $t->testdir() . '/file-moved escape', 10, 'file copied unescaped');
+
+$t->write_file('file.exist', join '', (1 .. 42));
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+
+EOF
+
+like($r, qr/204 No Content/, 'copy file overwrite');
+is(-s $t->testdir() . '/file.exist', 10, 'target file truncated');
+
+$r = http(<<EOF . '0123456789');
+PUT /i/alias HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/201 Created.*(Content-Length|\x0d\0a0\x0d\x0a)/ms, 'put alias');
+like($r, qr!Location: /i/alias\x0d?$!ms, 'location alias');
+is(-s $t->testdir() . '/alias', 10, 'put alias size');
+
+# request methods with unsupported request body
+
+$r = http(<<EOF . '0123456789');
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'mkcol body');
+
+$r = http(<<EOF . '0123456789');
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'copy body');
+
+
+$r = http(<<EOF . '0123456789');
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: 10
+
+EOF
+
+like($r, qr/415 Unsupported/, 'delete body');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.7');
+
+$r = http(<<EOF);
+MKCOL /test/ HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'mkcol body chunked');
+
+$r = http(<<EOF);
+COPY /file HTTP/1.1
+Host: localhost
+Destination: /file.exist
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'copy body chunked');
+
+$r = http(<<EOF);
+DELETE /file HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+a
+0123456789
+0
+
+EOF
+
+like($r, qr/415 Unsupported/, 'delete body chunked');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/debug_connection_syslog.t ../asynch_mode_nginx/test/nginx-tests/debug_connection_syslog.t
--- nginx-release-1.20.1/test/nginx-tests/debug_connection_syslog.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/debug_connection_syslog.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for debug_connection with syslog.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection ::1;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% alert;
+    error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(5);
+
+###############################################################################
+
+my ($s1, $s2) = map {
+    IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$_"
+    )
+        or die "Can't open syslog socket $_: $!";
+} port(8981), port(8982);
+
+is(get_syslog('/', $s1), '', 'no debug_connection syslog 1');
+is(get_syslog('/', $s2), '', 'no debug_connection syslog 2');
+
+my @msgs = get_syslog('/debug', $s1, $s2);
+like($msgs[0], qr/\[debug\]/, 'debug_connection syslog 1');
+like($msgs[1], qr/\[debug\]/, 'debug_connection syslog 2');
+is($msgs[0], $msgs[1], 'debug_connection syslog1 syslog2 match');
+
+###############################################################################
+
+sub get_syslog {
+    my ($uri, @s) = @_;
+    my @data;
+
+    http_get($uri);
+
+    map {
+        my $data = '';
+        IO::Select->new($_)->can_read(1);
+        while (IO::Select->new($_)->can_read(0.1)) {
+            my ($buffer);
+            sysread($_, $buffer, 4096);
+            $data .= $buffer;
+        }
+        push @data, $data;
+    } (@s);
+
+    return $data[0] if scalar @data == 1;
+    return @data;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/debug_connection.t ../asynch_mode_nginx/test/nginx-tests/debug_connection.t
--- nginx-release-1.20.1/test/nginx-tests/debug_connection.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/debug_connection.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,74 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for debug_connection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection ::1;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log %%TESTDIR%%/debug1.log alert;
+    error_log %%TESTDIR%%/debug2.log alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(5);
+
+###############################################################################
+
+http_get('/');
+
+select undef, undef, undef, 0.1;
+is($t->read_file('debug1.log'), '', 'no debug_connection file 1');
+is($t->read_file('debug2.log'), '', 'no debug_connection file 2');
+
+http_get('/debug');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('debug1.log'), qr/\[debug\]/, 'debug_connection file 1');
+like($t->read_file('debug2.log'), qr/\[debug\]/, 'debug_connection file 2');
+is($t->read_file('debug1.log'), $t->read_file('debug2.log'),
+    'debug_connection file1 file2 match');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/debug_connection_unix.t ../asynch_mode_nginx/test/nginx-tests/debug_connection_unix.t
--- nginx-release-1.20.1/test/nginx-tests/debug_connection_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/debug_connection_unix.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,74 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for debug_connection with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http --with-debug unix proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+    debug_connection unix:;
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    error_log %%TESTDIR%%/debug1.log alert;
+    error_log %%TESTDIR%%/debug2.log alert;
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location /debug {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no unix support')->plan(5);
+
+###############################################################################
+
+http_get('/');
+
+select undef, undef, undef, 0.1;
+is($t->read_file('debug1.log'), '', 'no debug_connection file 1');
+is($t->read_file('debug2.log'), '', 'no debug_connection file 2');
+
+http_get('/debug');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('debug1.log'), qr/\[debug\]/, 'debug_connection file 1');
+like($t->read_file('debug2.log'), qr/\[debug\]/, 'debug_connection file 2');
+is($t->read_file('debug1.log'), $t->read_file('debug2.log'),
+    'debug_connection file1 file2 match');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/empty_gif.t ../asynch_mode_nginx/test/nginx-tests/empty_gif.t
--- nginx-release-1.20.1/test/nginx-tests/empty_gif.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/empty_gif.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+
+# Tests for empty gif module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http empty_gif/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            empty_gif;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+my $gif = unhex(<<'EOF');
+0x0000:  47 49 46 38 39 61 01 00  01 00 80 01 00 00 00 00  |GIF89a.. ........|
+0x0010:  ff ff ff 21 f9 04 01 00  00 01 00 2c 00 00 00 00  |...!.... ...,....|
+0x0020:  01 00 01 00 00 02 02 4c  01 00 3b                 |.......L ..;|
+EOF
+
+###############################################################################
+
+is(http_get_body('/'), $gif, 'empty gif');
+like(http_get('/'), qr!Content-Type: image/gif!i, 'get content type');
+like(http_head('/'), qr!Content-Type: image/gif!i, 'head content type');
+like(http('PUT / HTTP/1.0' . CRLF . CRLF), qr!405 Not Allowed!i, 'put');
+
+###############################################################################
+
+sub unhex {
+    my ($input) = @_;
+    my $buffer = '';
+
+    for my $l ($input =~ m/:  +((?:[0-9a-f]{2,4} +)+) /gms) {
+        for my $v ($l =~ m/[0-9a-f]{2}/g) {
+            $buffer .= chr(hex($v));
+        }
+    }
+
+    return $buffer;
+}
+
+sub http_get_body {
+    my ($uri) = @_;
+
+    return undef if !defined $uri;
+
+    my $text = http_get($uri);
+
+    if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+        return undef;
+    }
+
+    return $2;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/error_log.t ../asynch_mode_nginx/test/nginx-tests/error_log.t
--- nginx-release-1.20.1/test/nginx-tests/error_log.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/error_log.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,197 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for error_log.
+# Various log levels emitted with limit_req_log_level.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)
+    ->plan(25)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+    limit_req zone=one;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /debug {
+            error_log %%TESTDIR%%/e_debug_debug.log debug;
+            error_log %%TESTDIR%%/e_debug_info.log info;
+            error_log stderr debug;
+        }
+        location /info {
+            limit_req_log_level info;
+            error_log %%TESTDIR%%/e_info_debug.log debug;
+            error_log %%TESTDIR%%/e_info_info.log info;
+            error_log %%TESTDIR%%/e_info_notice.log notice;
+            error_log stderr info;
+        }
+        location /notice {
+            limit_req_log_level notice;
+            error_log %%TESTDIR%%/e_notice_info.log info;
+            error_log %%TESTDIR%%/e_notice_notice.log notice;
+            error_log %%TESTDIR%%/e_notice_warn.log warn;
+            error_log stderr notice;
+        }
+        location /warn {
+            limit_req_log_level warn;
+            error_log %%TESTDIR%%/e_warn_notice.log notice;
+            error_log %%TESTDIR%%/e_warn_warn.log warn;
+            error_log %%TESTDIR%%/e_warn_error.log error;
+            error_log stderr warn;
+        }
+        location /error {
+            error_log %%TESTDIR%%/e_error_warn.log warn;
+            error_log %%TESTDIR%%/e_error_error.log;
+            error_log %%TESTDIR%%/e_error_alert.log alert;
+            error_log stderr;
+        }
+
+        location /file_low {
+            error_log %%TESTDIR%%/e_multi_low.log warn;
+            error_log %%TESTDIR%%/e_multi_low.log;
+        }
+        location /file_dup {
+            error_log %%TESTDIR%%/e_multi.log;
+            error_log %%TESTDIR%%/e_multi.log;
+        }
+        location /file_high {
+            error_log %%TESTDIR%%/e_multi_high.log emerg;
+            error_log %%TESTDIR%%/e_multi_high.log;
+        }
+
+        location /stderr_low {
+            error_log stderr warn;
+            error_log stderr;
+        }
+        location /stderr_dup {
+            error_log stderr;
+            error_log stderr;
+        }
+        location /stderr_high {
+            error_log stderr emerg;
+            error_log stderr;
+        }
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+    or die "Can't open stderr file: $!";
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+# charge limit_req
+
+http_get('/');
+
+SKIP: {
+
+skip "no --with-debug", 3 unless $t->has_module('--with-debug');
+
+http_get('/debug');
+isnt(lines($t, 'e_debug_debug.log', '[debug]'), 0, 'file debug debug');
+is(lines($t, 'e_debug_info.log', '[debug]'), 0, 'file debug info');
+isnt(lines($t, 'stderr', '[debug]'), 0, 'stderr debug');
+
+}
+
+http_get('/info');
+is(lines($t, 'e_info_debug.log', '[info]'), 1, 'file info debug');
+is(lines($t, 'e_info_info.log', '[info]'), 1, 'file info info');
+is(lines($t, 'e_info_notice.log', '[info]'), 0, 'file info notice');
+is(lines($t, 'stderr', '[info]'), 1, 'stderr info');
+
+http_get('/notice');
+is(lines($t, 'e_notice_info.log', '[notice]'), 1, 'file notice info');
+is(lines($t, 'e_notice_notice.log', '[notice]'), 1, 'file notice notice');
+is(lines($t, 'e_notice_warn.log', '[notice]'), 0, 'file notice warn');
+is(lines($t, 'stderr', '[notice]'), 1, 'stderr notice');
+
+http_get('/warn');
+is(lines($t, 'e_warn_notice.log', '[warn]'), 1, 'file warn notice');
+is(lines($t, 'e_warn_warn.log', '[warn]'), 1, 'file warn warn');
+is(lines($t, 'e_warn_error.log', '[warn]'), 0, 'file warn error');
+is(lines($t, 'stderr', '[warn]'), 1, 'stderr warn');
+
+http_get('/error');
+is(lines($t, 'e_error_warn.log', '[error]'), 1, 'file error warn');
+is(lines($t, 'e_error_error.log', '[error]'), 1, 'file error error');
+is(lines($t, 'e_error_alert.log', '[error]'), 0, 'file error alert');
+is(lines($t, 'stderr', '[error]'), 1, 'stderr error');
+
+# count log messages emitted with various error_log levels
+
+http_get('/file_low');
+is(lines($t, 'e_multi_low.log', '[error]'), 2, 'file low');
+
+http_get('/file_dup');
+is(lines($t, 'e_multi.log', '[error]'), 2, 'file dup');
+
+http_get('/file_high');
+is(lines($t, 'e_multi_high.log', '[error]'), 1, 'file high');
+
+http_get('/stderr_low');
+is(lines($t, 'stderr', '[error]'), 2, 'stderr low');
+
+http_get('/stderr_dup');
+is(lines($t, 'stderr', '[error]'), 2, 'stderr dup');
+
+http_get('/stderr_high');
+is(lines($t, 'stderr', '[error]'), 1, 'stderr high');
+
+###############################################################################
+
+sub lines {
+    my ($t, $file, $pattern) = @_;
+
+    if ($file eq 'stderr') {
+        return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+    }
+
+    my $path = $t->testdir() . '/' . $file;
+    open my $fh, '<', $path or return "$!";
+    my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+    close $fh;
+    return $value;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_body2.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_body2.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_body2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_body2.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for fastcgi backend with large request body,
+# with fastcgi_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 backup;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass u;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+            # fastcgi_next_upstream error timeout;
+            fastcgi_read_timeout 1s;
+        }
+
+        location /in_memory {
+            fastcgi_pass u2;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+            # fastcgi_next_upstream error timeout;
+            fastcgi_read_timeout 1s;
+            client_body_buffer_size 128k;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon, port(8081));
+$t->run_daemon(\&fastcgi_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+like(http_get_length('/', 'x' x 102400), qr/X-Length: 102400/,
+    'body length - in file');
+
+like(http_get_length('/in_memory', 'x' x 102400), qr/X-Length: 102400/,
+    'body length - in memory');
+
+###############################################################################
+
+sub http_get_length {
+    my ($url, $body) = @_;
+    my $length = length $body;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my ($port) = @_;
+    my $socket = FCGI::OpenSocket("127.0.0.1:$port", 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    while( $request->Accept() >= 0 ) {
+        read(STDIN, my $body, $ENV{'CONTENT_LENGTH'});
+        my $len = length $body;
+
+        sleep 3 if $port == port(8081);
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Length: $len
+
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_body.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_body.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_body.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,184 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_param CONTENT_LENGTH $content_length;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: _eos\x0d?$/ms, 'fastcgi no body');
+
+like(http_get_length('/', ''), qr/X-Body: _eos\x0d?$/ms, 'fastcgi empty body');
+like(http_get_length('/', 'foobar'), qr/X-Body: foobar_eos\x0d?$/ms,
+    'fastcgi body');
+
+like(http(<<EOF), qr/X-Body: foobar_eos\x0d?$/ms, 'fastcgi chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+6
+foobar
+0
+
+EOF
+
+like(http(<<EOF), qr/X-Body: _eos\x0d?$/ms, 'fastcgi empty chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+###############################################################################
+
+sub http_get_length {
+    my ($url, $body) = @_;
+    my $length = length $body;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+    my ($buf) = @_;
+    my $h;
+
+    return undef unless length $$buf;
+
+    @{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+    $h->{content} = substr $$buf, 8, $h->{clen};
+    $h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+    $$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+    return $h;
+}
+
+sub fastcgi_respond($$$$) {
+    my ($socket, $version, $id, $body) = @_;
+
+    # stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, length($body), 0));
+    $socket->write($body);
+
+    # close stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+    # end request
+    $socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+    $socket->write(pack("NCxxx", 0, 0));
+}
+
+sub fastcgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+        Test::Nginx::log_core('||', "fastcgi connection");
+
+        $client->sysread(my $buf, 1024) or next;
+
+        my ($version, $id);
+        my $body = '';
+
+        while (my $h = fastcgi_read_record(\$buf)) {
+            $version = $h->{version};
+            $id = $h->{id};
+
+            Test::Nginx::log_core('||', "fastcgi record: "
+                . " $h->{version}, $h->{type}, $h->{id}, "
+                . "'$h->{content}'");
+
+            if ($h->{type} == 5) {
+                $body .= $h->{content} if $h->{clen} > 0;
+
+                # count stdin end-of-stream
+                $body .= '_eos' if $h->{clen} == 0;
+            }
+        }
+
+        # respond
+        fastcgi_respond($client, $version, $id, <<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_buffering.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_buffering.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with fastcgi_buffering off.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi ssi/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_buffering off;
+        }
+
+        location /inmemory.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('inmemory.html',
+    '<!--#include virtual="/include$request_uri" set="x" -->' .
+    'set: <!--#echo var="x" -->');
+
+$t->run()->plan(2);
+
+$t->run_daemon(\&fastcgi_daemon)->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi unbuffered');
+like(http_get('/inmemory.html'), qr/set: SEE-THIS/, 'fastcgi inmemory');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        # this intentionally uses multiple print()'s to test
+        # parsing of multiple records
+
+        print(
+            "Status: 200 OK" . CRLF .
+            "Content-Type: text/plain" . CRLF . CRLF
+        );
+
+        print "SEE";
+        print "-THIS" . CRLF;
+        print "$count" . CRLF;
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_cache.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_cache.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_cache.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_cache.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path   %%TESTDIR%%/cache  levels=1:2
+                         keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_cache NAME;
+            fastcgi_cache_key $request_uri;
+            fastcgi_cache_valid 302 1m;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS.*^1$/ms, 'fastcgi request');
+like(http_get('/'), qr/SEE-THIS.*^1$/ms, 'fastcgi request cached');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in cached HEAD');
+
+SKIP: {
+skip 'broken with header crossing buffer boundary', 2
+    unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/stderr'), qr/SEE-THIS.*^2$/ms, 'large stderr handled');
+like(http_get('/stderr'), qr/SEE-THIS.*^2$/ms, 'large stderr cached');
+
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        if ($ENV{REQUEST_URI} eq '/stderr') {
+            warn "sample stderr text" x 512;
+        }
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_extra_data.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_extra_data.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_extra_data.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_extra_data.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
+
+# Test for fastcgi backend, responses with extra data or premature close.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()
+    ->has(qw/http fastcgi cache rewrite addition/)->plan(22)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_param REQUEST_URI $request_uri;
+    fastcgi_param REQUEST_METHOD $request_method;
+
+    fastcgi_cache_path cache keys_zone=one:1m;
+    fastcgi_cache_key $request_uri;
+    fastcgi_cache_valid any 1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            add_after_body /after;
+        }
+
+        location /unbuf/ {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_buffering off;
+            add_after_body /after;
+        }
+
+        location /head/ {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_cache one;
+            add_after_body /after;
+        }
+
+        location /after {
+            return 200 ":after\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/, 'response with extra data');
+like(http_get('/short'), qr/SEE-THIS(?!.*:after)/s, 'too short response');
+like(http_get('/empty'), qr/200 OK(?!.*:after)/s, 'empty too short response');
+
+}
+
+like(http_head('/'), qr/200 OK(?!.*SEE-THIS)/s, 'no data in HEAD');
+like(http_head('/short'), qr/200 OK(?!.*SEE-THIS)/s, 'too short to HEAD');
+like(http_head('/empty'), qr/200 OK/, 'empty response to HEAD');
+
+# unbuffered responses
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/unbuf/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/,
+    'unbuffered with extra data');
+like(http_get('/unbuf/short'), qr/SEE-THIS(?!.*:after)/s,
+    'unbuffered too short response');
+like(http_get('/unbuf/empty'), qr/200 OK(?!.*:after)/s,
+    'unbuffered empty too short responsde');
+
+}
+
+like(http_head('/unbuf/'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered no data in HEAD');
+like(http_head('/unbuf/short'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered too short response to HEAD');
+like(http_head('/unbuf/empty'), qr/200 OK/,
+    'unbuffered empty response to HEAD');
+
+# caching of responsses to HEAD requests
+
+like(http_head('/head/empty'), qr/200 OK(?!.*SEE-THIS)/s, 'head no body');
+like(http_head('/head/matching'), qr/200 OK(?!.*SEE-THIS)/s, 'head matching');
+like(http_head('/head/extra'), qr/200 OK(?!.*SEE-THIS)/s, 'head extra');
+like(http_head('/head/short'), qr/200 OK(?!.*SEE-THIS)/s, 'head too short');
+
+like(http_get('/head/empty'), qr/200 OK/, 'head no body cached');
+like(http_get('/head/matching'), qr/SEE-THIS/, 'head matching cached');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/head/extra'), qr/SEE-THIS(?!-BUT-NOT-THIS)/s,
+    'head extra cached');
+like(http_get('/head/short'), qr/SEE-THIS(?!.*:after)/s,
+    'head too short cached');
+
+}
+
+# "zero size buf" alerts (ticket #2018)
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.2');
+
+like(http_get('/zero'), qr/200 OK(?!.*NOT-THIS)/s, 'zero size');
+like(http_get('/unbuf/zero'), qr/200 OK(?!.*NOT-THIS)/s,
+    'unbuffered zero size');
+
+}
+
+$t->todo_alerts() unless $t->has_version('1.19.2')
+    or !$t->has_version('1.19.1');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my ($uri, $head);
+
+    while( $request->Accept() >= 0 ) {
+        $uri = $ENV{REQUEST_URI};
+        $uri =~ s!^/unbuf!!;
+
+        $head = $ENV{REQUEST_METHOD} eq 'HEAD';
+
+        if ($uri eq '/') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 8\n\n";
+            print "SEE-THIS-BUT-NOT-THIS\n";
+
+        } elsif ($uri eq '/zero') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 0\n\n";
+            print "NOT-THIS\n";
+
+        } elsif ($uri eq '/short') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 100\n\n";
+            print "SEE-THIS-TOO-SHORT-RESPONSE\n";
+
+        } elsif ($uri eq '/empty') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 100\n\n";
+
+        } elsif ($uri eq '/head/empty') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 8\n\n";
+            print "SEE-THIS" unless $head;
+
+        } elsif ($uri eq '/head/matching') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 8\n\n";
+            print "SEE-THIS";
+
+        } elsif ($uri eq '/head/extra') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 8\n\n";
+            print "SEE-THIS-BUT-NOT-THIS\n";
+
+        } elsif ($uri eq '/head/short') {
+            print "Content-Type: text/html\n";
+            print "Content-Length: 100\n\n";
+            print "SEE-THIS\n";
+        }
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_header_params.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_header_params.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_header_params.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_header_params.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,116 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi header params.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param HTTP_X_BLAH "blah";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_headers('/'), qr/SEE-THIS/,
+    'fastcgi request with many ignored headers');
+
+###############################################################################
+
+sub http_get_headers {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_keepalive.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_keepalive.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,186 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi upstream_keepalive/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass backend;
+            fastcgi_keep_conn on;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^request: 3$/m, 'fastcgi third request');
+
+like(http_get('/single'), qr/^connection: 1$/m, 'single connection used');
+
+# New connection to fastcgi application should be established after HEAD
+# requests since nginx doesn't read whole response (as it doesn't need
+# body).
+
+unlike(http_head('/head'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/after'), qr/^connection: 2$/m, 'new connection after HEAD');
+
+###############################################################################
+
+# Simple FastCGI responder implementation.  Unlike FCGI and FCGI::Async it's
+# able to count connections.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+    my ($socket) = @_;
+
+    my ($n, $h, $header);
+
+    $n = $socket->read($header, 8);
+    return undef if !defined $n or $n != 8;
+
+    @{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $header);
+
+    $n = $socket->read($h->{content}, $h->{clen});
+    return undef if $n != $h->{clen};
+
+    $n = $socket->read($h->{padding}, $h->{plen});
+    return undef if $n != $h->{plen};
+
+    $h->{socket} = $socket;
+    return $h;
+}
+
+sub fastcgi_respond($$) {
+    my ($h, $body) = @_;
+
+    # stdout
+    $h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id},
+        length($body), 8));
+    $h->{socket}->write($body);
+    select(undef, undef, undef, 0.1);
+    $h->{socket}->write(pack("xxxxxxxx"));
+    select(undef, undef, undef, 0.1);
+
+    # write some text to stdout and stderr split over multiple network
+    # packets to test if we correctly set pipe length in various places
+
+    my $tt = "test text, just for test";
+
+    $h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id},
+        length($tt . $tt), 0) . $tt);
+    select(undef, undef, undef, 0.1);
+    $h->{socket}->write($tt . pack("CC", $h->{version}, 7));
+    select(undef, undef, undef, 0.1);
+    $h->{socket}->write(pack("nnCx", $h->{id}, length($tt), 0));
+    select(undef, undef, undef, 0.1);
+    $h->{socket}->write($tt);
+    select(undef, undef, undef, 0.1);
+
+    # close stdout
+    $h->{socket}->write(pack("CCnnCx", $h->{version}, 6, $h->{id}, 0, 0));
+
+    select(undef, undef, undef, 0.1);
+
+    # end request
+    $h->{socket}->write(pack("CCnnCx", $h->{version}, 3, $h->{id}, 8, 0));
+    select(undef, undef, undef, 0.1);
+    $h->{socket}->write(pack("NCxxx", 0, 0));
+}
+
+sub fastcgi_test_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my $ccount = 0;
+    my $rcount = 0;
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+        Test::Nginx::log_core('||', "fastcgi connection");
+
+        $ccount++;
+
+        while (my $h = fastcgi_read_record($client)) {
+            Test::Nginx::log_core('||', "fastcgi record: "
+                . " $h->{version}, $h->{type}, $h->{id}, "
+                . "'$h->{content}'");
+
+            # skip everything unless stdin, then respond
+            next if $h->{type} != 5;
+
+            $rcount++;
+
+            # respond
+            fastcgi_respond($h, <<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+request: $rcount
+connection: $ccount
+EOF
+        }
+
+        $ccount-- unless $rcount;
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_merge_params2.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_merge_params2.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_merge_params2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_merge_params2.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for fastcgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                        keys_zone=NAME:1m;
+
+    fastcgi_cache_key   stub;
+
+    # no fastcgi_param at all, cache switched on at server level
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        fastcgi_cache  NAME;
+
+        location / {
+            fastcgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_cache   off;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+    'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+    'if-unmodified-since cleared with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+    'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+    'if-unmodified-since preserved without cache');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        my $ims = $ENV{HTTP_IF_MODIFIED_SINCE};
+        my $iums = $ENV{HTTP_IF_UNMODIFIED_SINCE};
+        my $blah = $ENV{HTTP_X_BLAH};
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_merge_params.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_merge_params.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_merge_params.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_merge_params.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,139 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for fastcgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi cache/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    fastcgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                        keys_zone=NAME:1m;
+
+    fastcgi_cache_key   stub;
+
+    fastcgi_param       HTTP_X_BLAH  "blah";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        fastcgi_cache  NAME;
+
+        location / {
+            fastcgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_cache   off;
+        }
+
+        location /custom/ {
+            fastcgi_pass    127.0.0.1:8081;
+            fastcgi_param   HTTP_X_BLAH  "custom";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+    'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+    'if-unmodified-since cleared with cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+    'custom params with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+    'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+    'if-unmodified-since preserved without cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+    'custom params without cache');
+
+like(http_get_ims('/custom/'), qr/ims=;/,
+    'if-modified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/iums=;/,
+    'if-unmodified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/blah=custom;/,
+    'custom params with cache custom');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        my $ims = $ENV{HTTP_IF_MODIFIED_SINCE};
+        my $iums = $ENV{HTTP_IF_UNMODIFIED_SINCE};
+        my $blah = $ENV{HTTP_X_BLAH};
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_request_buffering_chunked.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_request_buffering_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_request_buffering_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_request_buffering_chunked.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,424 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body with fastcgi backend,
+# chunked transfer-encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        fastcgi_request_buffering off;
+        fastcgi_param REQUEST_URI $request_uri;
+
+        location / {
+            client_body_buffer_size 2k;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /preread {
+            fastcgi_pass 127.0.0.1:8082;
+        }
+        location /error_page {
+            fastcgi_pass 127.0.0.1:8081;
+            error_page 404 /404;
+            fastcgi_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: \x0d\x0a?/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+    qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082));
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789', last => 1), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789', last => 1), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234', many => 1);
+ok($s, 'chunks');
+
+SKIP: {
+skip 'chunks failed', 3 unless $s;
+
+is($s->{preread}, '01234many', 'chunks - preread');
+is($s->{upload}('56789', many => 1, last => 1), '56789many', 'chunks - body');
+
+like($s->{http_end}(), qr/200 OK/, 'chunks - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $body) . CRLF
+        . $body . CRLF
+        . "0" . CRLF . CRLF
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $last) . CRLF
+        . $last . CRLF
+        . "0" . CRLF . CRLF
+    );
+}
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+    my ($buf) = @_;
+    my $h;
+
+    return undef unless length $$buf;
+
+    @{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+    $h->{content} = substr $$buf, 8, $h->{clen};
+    $h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+    $$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+    return $h;
+}
+
+sub fastcgi_respond($$$$) {
+    my ($socket, $version, $id, $body) = @_;
+
+    # stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, length($body), 8));
+    $socket->write($body);
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("xxxxxxxx"));
+    select(undef, undef, undef, 0.1);
+
+    # write some text to stdout and stderr split over multiple network
+    # packets to test if we correctly set pipe length in various places
+
+    my $tt = "test text, just for test";
+
+    $socket->write(pack("CCnnCx", $version, 6, $id,
+        length($tt . $tt), 0) . $tt);
+    select(undef, undef, undef, 0.1);
+    $socket->write($tt . pack("CC", $version, 7));
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("nnCx", $id, length($tt), 0));
+    select(undef, undef, undef, 0.1);
+    $socket->write($tt);
+    select(undef, undef, undef, 0.1);
+
+    # close stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+    select(undef, undef, undef, 0.1);
+
+    # end request
+    $socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+    my ($url, $port, $body, %extra) = @_;
+    my ($server, $client, $s);
+    my ($last, $many) = (0, 0);
+    my ($version, $id);
+
+    $last = $extra{last} if defined $extra{last};
+    $many = $extra{many} if defined $extra{many};
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+
+    if (defined $body) {
+        $r .= sprintf("%x", length $body) . CRLF;
+        $r .= $body . CRLF;
+    }
+    if (defined $body && $many) {
+        $r .= sprintf("%x", length 'many') . CRLF;
+        $r .= 'many' . CRLF;
+    }
+    if ($last) {
+        $r .= "0" . CRLF . CRLF;
+    }
+
+    $s = http($r, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(5);
+
+        $client = $server->accept();
+
+        log2c("(new connection $client)");
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    $client->sysread(my $buf, 1024);
+    log2i($buf);
+
+    $body = '';
+
+    while (my $h = fastcgi_read_record(\$buf)) {
+        $version = $h->{version};
+        $id = $h->{id};
+
+        # skip everything unless stdin
+        next if $h->{type} != 5;
+
+        $body .= $h->{content};
+    }
+
+    my $f = { preread => $body };
+    $f->{upload} = sub {
+        my ($body, %extra) = @_;
+        my ($last, $many) = (0, 0);
+
+        $last = $extra{last} if defined $extra{last};
+        $many = $extra{many} if defined $extra{many};
+
+        my $buf = sprintf("%x", length $body) . CRLF;
+        $buf .= $body . CRLF;
+        if ($many) {
+            $buf .= sprintf("%x", length 'many') . CRLF;
+            $buf .= 'many' . CRLF;
+        }
+        if ($last) {
+            $buf .= "0" . CRLF . CRLF;
+        }
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            log_out($buf);
+            $s->write($buf);
+
+            $client->sysread($buf, 1024);
+            log2i($buf);
+
+            $body = '';
+
+            while (my $h = fastcgi_read_record(\$buf)) {
+
+                # skip everything unless stdin
+                next if $h->{type} != 5;
+
+                $body .= $h->{content};
+            }
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $body;
+    };
+    $f->{http_end} = sub {
+        my $buf = '';
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+            $client->close;
+
+            $s->sysread($buf, 1024);
+            log_in($buf);
+
+            $s->close();
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    my ($body, $buf);
+
+    while( $request->Accept() >= 0 ) {
+        $count++;
+        $body = '';
+
+        do {
+            read(STDIN, $buf, 1024);
+            $body .= $buf;
+        } while (length $buf);
+
+        if ($ENV{REQUEST_URI} eq '/error_page') {
+            print "Status: 404 Not Found" . CRLF . CRLF;
+            next;
+        }
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_request_buffering.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_request_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_request_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_request_buffering.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,374 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body with fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        fastcgi_request_buffering off;
+        fastcgi_param REQUEST_URI $request_uri;
+        fastcgi_param CONTENT_LENGTH $content_length;
+
+        location / {
+            client_body_buffer_size 2k;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            fastcgi_pass 127.0.0.1:8081;
+        }
+        location /preread {
+            fastcgi_pass 127.0.0.1:8082;
+        }
+        location /error_page {
+            fastcgi_pass 127.0.0.1:8081;
+            error_page 404 /404;
+            fastcgi_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: \x0d\x0a?/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+    qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 10, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Content-Length: " . (length $body) . CRLF . CRLF
+        . $body
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Content-Length: " . (length $last) . CRLF . CRLF
+        . $last
+    );
+}
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+    my ($buf) = @_;
+    my $h;
+
+    return undef unless length $$buf;
+
+    @{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+    $h->{content} = substr $$buf, 8, $h->{clen};
+    $h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+    $$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+    return $h;
+}
+
+sub fastcgi_respond($$$$) {
+    my ($socket, $version, $id, $body) = @_;
+
+    # stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, length($body), 8));
+    $socket->write($body);
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("xxxxxxxx"));
+    select(undef, undef, undef, 0.1);
+
+    # write some text to stdout and stderr split over multiple network
+    # packets to test if we correctly set pipe length in various places
+
+    my $tt = "test text, just for test";
+
+    $socket->write(pack("CCnnCx", $version, 6, $id,
+        length($tt . $tt), 0) . $tt);
+    select(undef, undef, undef, 0.1);
+    $socket->write($tt . pack("CC", $version, 7));
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("nnCx", $id, length($tt), 0));
+    select(undef, undef, undef, 0.1);
+    $socket->write($tt);
+    select(undef, undef, undef, 0.1);
+
+    # close stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+    select(undef, undef, undef, 0.1);
+
+    # end request
+    $socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+    select(undef, undef, undef, 0.1);
+    $socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+    my ($url, $port, $length, $body) = @_;
+    my ($server, $client, $s);
+    my ($version, $id);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+    if (defined $body) {
+        $r .= $body;
+    }
+
+    $s = http($r, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(5);
+
+        $client = $server->accept();
+
+        log2c("(new connection $client)");
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    $client->sysread(my $buf, 1024);
+    log2i($buf);
+
+    $body = '';
+
+    while (my $h = fastcgi_read_record(\$buf)) {
+        $version = $h->{version};
+        $id = $h->{id};
+
+        # skip everything unless stdin
+        next if $h->{type} != 5;
+
+        $body .= $h->{content};
+    }
+
+    my $f = { preread => $body };
+    $f->{upload} = sub {
+        my $buf = shift;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            log_out($buf);
+            $s->write($buf);
+
+            $client->sysread($buf, 1024);
+            log2i($buf);
+
+            $body = '';
+
+            while (my $h = fastcgi_read_record(\$buf)) {
+
+                # skip everything unless stdin
+                next if $h->{type} != 5;
+
+                $body .= $h->{content};
+            }
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $body;
+    };
+    $f->{http_end} = sub {
+        my $buf = '';
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+            $client->close;
+
+            $s->sysread($buf, 1024);
+            log_in($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    my $body;
+
+    while( $request->Accept() >= 0 ) {
+        $count++;
+        read(STDIN, $body, $ENV{'CONTENT_LENGTH'});
+
+        if ($ENV{REQUEST_URI} eq '/error_page') {
+            print "Status: 404 Not Found" . CRLF . CRLF;
+            next;
+        }
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_split.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_split.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_split.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_split.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend.
+# Incorrect split headers handling after switching to next server,
+# as reported by Lucas Molas.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CR LF CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass u;
+            fastcgi_param REQUEST_URI $request_uri;
+            fastcgi_next_upstream invalid_header;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon, port(8081));
+$t->run_daemon(\&fastcgi_daemon, port(8082));
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+like(http_get('/'), qr/^Good: header/ms, 'fastcgi next upstream');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my ($port) = @_;
+    my $socket = FCGI::OpenSocket("127.0.0.1:$port", 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        if ($port == port(8081)) {
+            print 'BAD';
+        }
+        if ($port == port(8082)) {
+            print 'Good: header' . CRLF . CRLF;
+        }
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi.t ../asynch_mode_nginx/test/nginx-tests/fastcgi.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+
+        location /catch {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI "/stderr";
+            fastcgi_catch_stderr sample;
+        }
+
+        location /var {
+            fastcgi_pass $arg_b;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^3$/m, 'fastcgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/stderr'), qr/SEE-THIS/, 'large stderr handled');
+like(http_get('/catch'), qr/502 Bad/, 'catch stderr');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+    'fastcgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'fastcgi with variables to upstream');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        if ($ENV{REQUEST_URI} eq '/stderr') {
+            warn "sample stderr text" x 512;
+        }
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_unix.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_unix.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_unix.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for fastcgi backend with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi unix/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            fastcgi_pass unix:%%TESTDIR%%/unix.sock;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+
+        location /var {
+            fastcgi_pass $arg_b;
+            fastcgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&fastcgi_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+    last if -S $path;
+    select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'fastcgi request');
+like(http_get('/redir'), qr/ 302 /, 'fastcgi redirect');
+like(http_get('/'), qr/^3$/m, 'fastcgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get('/stderr'), qr/SEE-THIS/, 'large stderr handled');
+
+like(http_get("/var?b=unix:$path"), qr/SEE-THIS/, 'fastcgi with variables');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket(shift, 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $count;
+    while( $request->Accept() >= 0 ) {
+        $count++;
+
+        if ($ENV{REQUEST_URI} eq '/stderr') {
+            warn "sample stderr text" x 512;
+        }
+
+        print <<EOF;
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/fastcgi_variables.t ../asynch_mode_nginx/test/nginx-tests/fastcgi_variables.t
--- nginx-release-1.20.1/test/nginx-tests/fastcgi_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/fastcgi_variables.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,91 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Test for fastcgi variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require FCGI; };
+plan(skip_all => 'FCGI not installed') if $@;
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http fastcgi rewrite/)->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Script-Name $fastcgi_script_name;
+        add_header X-Path-Info $fastcgi_path_info;
+
+        location / {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_index index.php;
+        }
+
+        location /info {
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_split_path_info ^(.+\.php)(.*)$;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&fastcgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/X-Script-Name: \/index\.php/ms, 'script name');
+like(http_get('/info.php/path/info'), qr/X-Script-Name: \/info\.php/ms,
+    'info script name');
+like(http_get('/info.php/path/info'), qr/X-Path-Info: \/path\/info/ms,
+    'info path');
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8081), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    while( $request->Accept() >= 0 ) {
+        print CRLF . CRLF;
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/geo_binary.t ../asynch_mode_nginx/test/nginx-tests/geo_binary.t
--- nginx-release-1.20.1/test/nginx-tests/geo_binary.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/geo_binary.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx geo module with binary base.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long configuration parsing') unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/http geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo_base_create {
+        ranges;
+        include  base.conf;
+    }
+
+    geo $geo_base_include {
+        ranges;
+        include  base.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP   $remote_addr;
+            add_header X-GBc  $geo_base_create;
+            add_header X-GBi  $geo_base_include;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('base.conf', join('', map {
+    "127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." . $_ % 256 .
+    "-127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." .$_ % 256 . " " .
+    ($_ == 1 ? "loopback" : "range$_") . ";" } (0 .. 100000)));
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(2);
+
+###############################################################################
+
+my $r = http_get('/1');
+like($r, qr/^X-GBc: loopback/m, 'geo binary base create');
+like($r, qr/^X-GBi: loopback/m, 'geo binary base include');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/geoip.t ../asynch_mode_nginx/test/nginx-tests/geoip.t
--- nginx-release-1.20.1/test/nginx-tests/geoip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/geoip.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,199 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for geoip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_geoip/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geoip_proxy    127.0.0.1/32;
+
+    geoip_country  %%TESTDIR%%/country.dat;
+    geoip_city     %%TESTDIR%%/city.dat;
+    geoip_org      %%TESTDIR%%/org.dat;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Country-Code      $geoip_country_code;
+            add_header X-Country-Code3     $geoip_country_code3;
+            add_header X-Country-Name      $geoip_country_name;
+
+            add_header X-Area-Code         $geoip_area_code;
+            add_header X-C-Continent-Code  $geoip_city_continent_code;
+            add_header X-C-Country-Code    $geoip_city_country_code;
+            add_header X-C-Country-Code3   $geoip_city_country_code3;
+            add_header X-C-Country-Name    $geoip_city_country_name;
+            add_header X-Dma-Code          $geoip_dma_code;
+            add_header X-Latitude          $geoip_latitude;
+            add_header X-Longitude         $geoip_longitude;
+            add_header X-Region            $geoip_region;
+            add_header X-Region-Name       $geoip_region_name;
+            add_header X-City              $geoip_city;
+            add_header X-Postal-Code       $geoip_postal_code;
+
+            add_header X-Org               $geoip_org;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+# country database:
+#
+# "10.0.0.1","10.0.0.1","RU","Russian Federation"
+# "2001:db8::","2001:db8::","US","United States"
+
+my $data = '';
+
+for my $i (0 .. 156) {
+    # skip to offset 32 if 1st bit set in ipv6 address wins
+    $data .= pack_node($i + 1) . pack_node(32), next if $i == 2;
+    # otherwise default to RU
+    $data .= pack_node(0xffffb9) . pack_node(0xffff00), next if $i == 31;
+    # continue checking bits set in ipv6 address
+    $data .= pack_node(0xffff00) . pack_node($i + 1), next
+        if grep $_ == $i, (44, 49, 50, 52, 53, 55, 56, 57);
+    # last bit set in ipv6 address
+    $data .= pack_node(0xffffe1) . pack_node(0xffff00), next if $i == 156;
+    $data .= pack_node($i + 1) . pack_node(0xffff00);
+}
+
+$data .= chr(0x00) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(12);
+
+$t->write_file('country.dat', $data);
+
+# city database:
+#
+# "167772161","167772161","RU","48","Moscow","119034","55.7543",37.6202",,
+
+$data = '';
+
+for my $i (0 .. 31) {
+    $data .= pack_node(32) . pack_node($i + 1), next if $i == 4 or $i == 6;
+    $data .= pack_node(32) . pack_node($i + 2), next if $i == 31;
+    $data .= pack_node($i + 1) . pack_node(32);
+}
+
+$data .= chr(42);
+$data .= chr(185);
+$data .= pack('Z*', 48);
+$data .= pack('Z*', 'Moscow');
+$data .= pack('Z*', 119034);
+$data .= pack_node(int((55.7543 + 180) * 10000));
+$data .= pack_node(int((37.6202 + 180) * 10000));
+$data .= chr(0) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(2);
+$data .= pack_node(32);
+
+$t->write_file('city.dat', $data);
+
+# organization database:
+#
+# "167772161","167772161","Nginx"
+
+$data = '';
+
+for my $i (0 .. 31) {
+    $data .= pack_org(32) . pack_org($i + 1), next if $i == 4 or $i == 6;
+    $data .= pack_org(32) . pack_org($i + 2), next if $i == 31;
+    $data .= pack_org($i + 1) . pack_org(32);
+}
+
+$data .= chr(42);
+$data .= pack('Z*', 'Nginx');
+$data .= chr(0xFF) x 3;
+$data .= chr(5);
+$data .= pack_node(32);
+
+$t->write_file('org.dat', $data);
+$t->write_file('index.html', '');
+$t->try_run('no inet6 support')->plan(20);
+
+###############################################################################
+
+my $r = http_xff('10.0.0.1');
+like($r, qr/X-Country-Code: RU/, 'geoip country code');
+like($r, qr/X-Country-Code3: RUS/, 'geoip country code 3');
+like($r, qr/X-Country-Name: Russian Federation/, 'geoip country name');
+
+like($r, qr/X-Area-Code: 0/, 'geoip area code');
+like($r, qr/X-C-Continent-Code: EU/, 'geoip city continent code');
+like($r, qr/X-C-Country-Code: RU/, 'geoip city country code');
+like($r, qr/X-C-Country-Code3: RUS/, 'geoip city country code 3');
+like($r, qr/X-C-Country-Name: Russian Federation/, 'geoip city country name');
+like($r, qr/X-Dma-Code: 0/, 'geoip dma code');
+like($r, qr/X-Latitude: 55.7543/, 'geoip latitude');
+like($r, qr/X-Longitude: 37.6202/, 'geoip longitude');
+like($r, qr/X-Region: 48/, 'geoip region');
+like($r, qr/X-Region-Name: Moscow City/, 'geoip region name');
+like($r, qr/X-City: Moscow/, 'geoip city');
+like($r, qr/X-Postal-Code: 119034/, 'geoip postal code');
+
+like($r, qr/X-Org: Nginx/, 'geoip org');
+
+like(http_xff('::ffff:10.0.0.1'), qr/X-Org: Nginx/, 'geoip ipv6 ipv4-mapped');
+
+$r = http_xff('2001:db8::');
+like($r, qr/X-Country-Code: US/, 'geoip ipv6 country code');
+like($r, qr/X-Country-Code3: USA/, 'geoip ipv6 country code 3');
+like($r, qr/X-Country-Name: United States/, 'geoip ipv6 country name');
+
+###############################################################################
+
+sub http_xff {
+    my ($xff) = @_;
+    return http(<<EOF);
+GET / HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+sub pack_node {
+    substr pack('V', shift), 0, 3;
+}
+
+sub pack_org {
+    pack('V', shift);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/geo_ipv6.t ../asynch_mode_nginx/test/nginx-tests/geo_ipv6.t
--- nginx-release-1.20.1/test/nginx-tests/geo_ipv6.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/geo_ipv6.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for geo module with IPv6.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+    }
+
+    geo $geo_delete {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+        delete          ::1/128;
+    }
+
+    geo $geo_proxy {
+        ranges;
+        proxy                ::1;
+        default              default;
+        192.0.2.1-192.0.2.1  test;
+    }
+
+    geo $arg_ip $geo_arg {
+        default       default;
+        ::1/128       loopback;
+        192.0.2.0/24  test;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+    }
+
+    server {
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            add_header X-Geo  $geo;
+            add_header X-Del  $geo_delete;
+            add_header X-XFF  $geo_proxy;
+            add_header X-Arg  $geo_arg;
+        }
+
+        location /addr {
+            add_header X-IP   $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('addr', '');
+$t->try_run('no inet6 support');
+
+plan(skip_all => 'no ::1 on host')
+    if http_get('/addr') !~ /X-IP: ::1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/'), qr/^X-Geo: loopback/m, 'geo ipv6');
+like(http_get('/'), qr/^X-Del: world/m, 'geo ipv6 delete');
+
+like(http_xff('::ffff:192.0.2.1'), qr/^X-XFF: test/m, 'geo ipv6 ipv4-mapped');
+like(http_get('/?ip=::ffff:192.0.2.1'), qr/^X-Arg: test/m,
+    'geo ipv6 ipv4-mapped from variable');
+
+###############################################################################
+
+sub http_xff {
+    my ($xff) = @_;
+    return http(<<EOF);
+GET / HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/geo.t ../asynch_mode_nginx/test/nginx-tests/geo.t
--- nginx-release-1.20.1/test/nginx-tests/geo.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/geo.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,251 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx geo module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_include {
+        include       geo.conf;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_delete {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+        delete        127.0.0.0/8;
+    }
+
+    geo $arg_ip $geo_from_arg {
+        default       default;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $arg_ip $geo_arg_ranges {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+
+        # ranges with two /16 networks
+        # the latter network has greater two least octets
+        # (see 1301a58b5dac for details)
+        10.10.3.0-10.11.2.255  foo;
+        10.12.3.0-10.13.2.255  foo2;
+        delete                 10.10.3.0-10.11.2.255;
+    }
+
+    geo $geo_proxy {
+        default       default;
+        proxy         127.0.0.1;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $geo_proxy_recursive {
+        proxy_recursive;
+        default       default;
+        proxy         127.0.0.1;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $geo_ranges {
+        ranges;
+        default                    default;
+        127.0.0.0-127.255.255.255  loopback;
+        192.0.2.0-192.0.2.255      test;
+    }
+
+    geo $geo_ranges_include {
+        ranges;
+        default                default;
+        include                geo-ranges.conf;
+        192.0.2.0-192.0.2.255  test;
+    }
+
+    geo $geo_ranges_delete {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.1    loopback;
+        delete                 127.0.0.0-127.0.0.0;
+        delete                 127.0.0.2-127.0.0.255;
+        delete                 127.0.0.1-127.0.0.1;
+    }
+
+    # delete range with two /16
+    geo $geo_ranges_delete_2 {
+        ranges;
+        default              default;
+        127.0.0.0-127.1.0.0  loopback;
+        delete               127.0.0.0-127.1.0.0;
+    }
+
+    geo $geo_before {
+        ranges;
+        default                default;
+        127.0.0.1-127.0.0.255  loopback;
+        127.0.0.0-127.0.0.0    test;
+    }
+
+    geo $geo_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+        127.0.0.2-127.0.0.255  test;
+    }
+
+    geo $geo_insert {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.2    test2;
+        127.0.0.1-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_before {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.0-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.255  loopback;
+     }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP   $remote_addr;
+            add_header X-Geo  $geo;
+            add_header X-Inc  $geo_include;
+            add_header X-Del  $geo_delete;
+            add_header X-Ran  $geo_ranges;
+            add_header X-RIn  $geo_ranges_include;
+            add_header X-ABe  $geo_before;
+            add_header X-AAf  $geo_after;
+            add_header X-Ins  $geo_insert;
+            add_header X-IBe  $geo_insert_before;
+            add_header X-IAf  $geo_insert_after;
+            add_header X-Arg  $geo_from_arg;
+            add_header X-ARa  $geo_arg_ranges;
+            add_header X-XFF  $geo_proxy;
+            add_header X-XFR  $geo_proxy_recursive;
+        }
+
+        location /2 {
+            add_header X-RDe  $geo_ranges_delete;
+            add_header X-RD2  $geo_ranges_delete_2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->write_file('geo.conf', '127.0.0.0/8  loopback;');
+$t->write_file('geo-ranges.conf', '127.0.0.0-127.255.255.255  loopback;');
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(22);
+
+###############################################################################
+
+my $r = http_get('/1');
+like($r, qr/^X-Geo: loopback/m, 'geo');
+like($r, qr/^X-Inc: loopback/m, 'geo include');
+like($r, qr/^X-Del: world/m, 'geo delete');
+like($r, qr/^X-Ran: loopback/m, 'geo ranges');
+like($r, qr/^X-RIn: loopback/m, 'geo ranges include');
+
+like(http_get('/2'), qr/^X-RDe: default/m, 'geo ranges delete');
+like(http_get('/2'), qr/^X-RD2: default/m, 'geo ranges delete 2');
+
+like($r, qr/^X-ABe: loopback/m, 'geo ranges add before');
+like($r, qr/^X-AAf: loopback/m, 'geo ranges add after');
+like($r, qr/^X-Ins: loopback/m, 'geo ranges insert');
+like($r, qr/^X-IBe: loopback/m, 'geo ranges insert before');
+like($r, qr/^X-IAf: loopback/m, 'geo ranges insert after');
+
+like(http_get('/1?ip=192.0.2.1'), qr/^X-Arg: test/m, 'geo from variable');
+like(http_get('/1?ip=10.0.0.1'), qr/^X-Arg: default/m, 'geo default');
+like(http_get('/1?ip=10.0.0.1'), qr/^X-ARa: default/m, 'geo ranges default');
+like(http_get('/1?ip=10.13.2.1'), qr/^X-ARa: foo2/m, 'geo ranges add');
+like(http_get('/1?ip=10.11.2.1'), qr/^X-ARa: default/m,
+    'geo delete range from variable');
+
+like(http_xff('192.0.2.1'), qr/^X-XFF: test/m, 'geo proxy');
+like(http_xff('10.0.0.1'), qr/^X-XFF: default/m, 'geo proxy default');
+like(http_xff('10.0.0.1, 192.0.2.1'), qr/^X-XFF: test/m, 'geo proxy long');
+
+like(http_xff('192.0.2.1, 127.0.0.1'), qr/^X-XFF: loopback/m,
+    'geo proxy_recursive off');
+like(http_xff('192.0.2.1, 127.0.0.1'), qr/^X-XFR: test/m,
+    'geo proxy_recursive on');
+
+###############################################################################
+
+sub http_xff {
+    my ($xff) = @_;
+    return http(<<EOF);
+GET /1 HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/geo_unix.t ../asynch_mode_nginx/test/nginx-tests/geo_unix.t
--- nginx-release-1.20.1/test/nginx-tests/geo_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/geo_unix.t	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,113 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http geo module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http geo proxy unix/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $geo {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $remote_addr $geora {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $geor {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $remote_addr $georra {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $arg_ip $geo_arg {
+        default                  default;
+        192.0.2.0/24             test;
+    }
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location / {
+            add_header X-Geo          $geo;
+            add_header X-Addr         $geora;
+            add_header X-Ranges       $geor;
+            add_header X-Ranges-Addr  $georra;
+            add_header X-Arg          $geo_arg;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+
+        location / {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+like($r, qr/^X-Geo: none/m, 'geo unix');
+like($r, qr/^X-Ranges: none/m, 'geo unix ranges');
+like($r, qr/^X-Addr: none/m, 'geo unix remote addr');
+like($r, qr/^X-Ranges-Addr: none/m, 'geo unix ranges remote addr');
+
+like(http_get('/?ip=192.0.2.1'), qr/^X-Arg: test/m, 'geo unix variable');
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+is(-e $t->testdir() . '/unix.sock', undef, 'unix socket removed');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/grpc_next_upstream.t ../asynch_mode_nginx/test/nginx-tests/grpc_next_upstream.t
--- nginx-release-1.20.1/test/nginx-tests/grpc_next_upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/grpc_next_upstream.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc module, grpc_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 grpc rewrite/)->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=2;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            grpc_pass u;
+            grpc_next_upstream http_500 http_404 invalid_header;
+        }
+
+        location /all/ {
+            grpc_pass u2;
+            grpc_next_upstream http_500 http_404;
+            error_page 404 /all/404;
+            grpc_intercept_errors on;
+        }
+
+        location /all/404 {
+            return 200 "$upstream_addr\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2;
+        server_name  localhost;
+
+        location / {
+            return 404;
+        }
+        location /ok {
+            return 200 "AND-THIS\n";
+        }
+        location /500 {
+            return 500;
+        }
+        location /444 {
+            return 444;
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST-OK-IF-YOU-SEE-THIS\n";
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+# check if both request fallback to a backend
+# which returns valid response
+
+like(http_get('/'), qr/SEE-THIS/, 'grpc request');
+like(http_get('/'), qr/SEE-THIS/, 'second request');
+
+# make sure backend isn't switched off after
+# grpc_next_upstream http_404
+
+like(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'not down');
+
+# next upstream on invalid_header
+
+like(http_get('/444'), qr/SEE-THIS/, 'request 444');
+like(http_get('/444'), qr/SEE-THIS/, 'request 444 second');
+
+# next upstream on http_500
+
+like(http_get('/500'), qr/SEE-THIS/, 'request 500');
+like(http_get('/500'), qr/SEE-THIS/, 'request 500 second');
+
+# make sure backend switched off with http_500
+
+unlike(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'down after 500');
+
+# make sure all backends are tried once
+
+like(http_get('/all/rr'),
+    qr/^127.0.0.1:($p1, 127.0.0.1:$p2|$p2, 127.0.0.1:$p1)$/mi,
+    'all tried once');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/grpc_pass.t ../asynch_mode_nginx/test/nginx-tests/grpc_pass.t
--- nginx-release-1.20.1/test/nginx-tests/grpc_pass.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/grpc_pass.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,194 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the grpc_pass directive with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 grpc rewrite/)
+    ->has_daemon('openssl')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            grpc_pass $host:%%PORT_8081%%;
+        }
+
+        location /grpc {
+            grpc_pass grpc://$host:%%PORT_8081%%;
+        }
+
+        location /grpcs {
+            %%GRPC_ASYNCH_ENABLE%%
+            grpc_pass grpcs://$host:%%PORT_8082%%;
+        }
+
+        location /arg {
+            grpc_pass $arg_b;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2;
+        listen       127.0.0.1:8082 http2 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $http_host;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+$t->try_run('no grpc_pass variables')->plan(5);
+
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+like(http_get('/basic'), qr/200 OK/, 'no scheme');
+like(http_get('/grpc'), qr/200 OK/, 'grpc scheme');
+
+SKIP: {
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+skip 'OpenSSL too old', 1 unless defined $1 and $1 ge '1.0.2';
+
+like(http_get('/grpcs'), qr/200 OK/, 'grpcs scheme');
+
+}
+
+like(http_get('/arg?b=grpc://127.0.0.1:' . port(8081)), qr/200 OK/, 'addrs');
+like(http_get('/arg?b=grpc://u'), qr/200 OK/, 'no_port');
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant A        => 1;
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if ($name eq 'localhost' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/grpc_request_buffering.t ../asynch_mode_nginx/test/nginx-tests/grpc_request_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/grpc_request_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/grpc_request_buffering.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,197 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc module, request body buffered.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 grpc mirror proxy/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location /mirror { }
+
+        location / {
+            grpc_pass 127.0.0.1:8081;
+            add_header X-Body $request_body;
+            mirror /mirror;
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8082/mirror;
+            proxy_intercept_errors on;
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            grpc_pass 127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-body'}, 'Hello', 'request body in memory');
+
+# tcp_nopush usage on peer connections
+# reopen window for request body after initial window was exhausted
+
+$frames = $f->{http_start}('/proxy');
+is(eval(join '+', map { $_->{length} } grep { $_->{type} eq "DATA" } @$frames),
+    65535, 'preserve_output - first body bytes');
+
+# expect body cleanup is disabled with preserve_output (ticket #1565).
+# after request body first bytes were proxied on behalf of initial window size,
+# send response header from upstream, this leads to body cleanup code path
+
+$frames = $f->{http_end}();
+is(eval(join '+', map { $_->{length} } grep { $_->{type} eq "DATA" } @$frames),
+    465, 'preserve_output - last body bytes');
+
+like(`grep -F '[crit]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no crits');
+
+###############################################################################
+
+sub grpc {
+    my ($server, $client, $f, $s, $c, $sid, $uri);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $p,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    $f->{http_start} = sub {
+        ($uri, my %extra) = @_;
+        $s = Test::Nginx::HTTP2->new() if !defined $s;
+        my ($body) = $uri eq '/proxy' ? 'Hello' x 13200 : 'Hello';
+        $s->new_stream({ body => $body, headers => [
+            { name => ':method', value => 'POST', mode => 0 },
+            { name => ':scheme', value => 'http', mode => 0 },
+            { name => ':path', value => $uri },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-length', value => length($body) }]});
+
+        if (!$extra{reuse}) {
+            eval {
+                local $SIG{ALRM} = sub { die "timeout\n" };
+                alarm(5);
+
+                $client = $server->accept() or return;
+
+                alarm(0);
+            };
+            alarm(0);
+            if ($@) {
+                log_in("died: $@");
+                return undef;
+            }
+
+            log2c("(new connection $client)");
+
+            $client->sysread(my $buf, 24) == 24 or return; # preface
+
+            $c = Test::Nginx::HTTP2->new(1, socket => $client,
+                pure => 1, preface => "") or return;
+        }
+
+        my $frames = $uri eq '/proxy'
+            ? $c->read(all => [{ length => 65535 }])
+            : $c->read(all => [{ fin => 1 }]);
+
+        if (!$extra{reuse}) {
+            $c->h2_settings(0);
+            $c->h2_settings(1);
+        }
+
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        $sid = $frame->{sid};
+        return $frames;
+    };
+    $f->{http_end} = sub {
+        $c->new_stream({ body_more => 1, headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc' },
+        ]}, $sid);
+
+        # reopen window for request body after response HEADERS is sent
+
+        if ($uri eq '/proxy') {
+            $c->h2_window(2**16, $sid);
+            $c->h2_window(2**16);
+            return $c->read(all => [{ sid => $sid, fin => 1 }]);
+        }
+
+        $c->h2_body('Hello world', { body_more => 1 });
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0', mode => 2 },
+            { name => 'grpc-message', value => '', mode => 2 },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    return $f;
+}
+
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/grpc_ssl.t ../asynch_mode_nginx/test/nginx-tests/grpc_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/grpc_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/grpc_ssl.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,297 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc backend with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite http_v2 grpc/)
+    ->has(qw/upstream_keepalive http_ssl/)->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(33);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        ssl_verify_client optional;
+        ssl_client_certificate client.crt;
+
+        location / {
+            grpc_pass 127.0.0.1:8082;
+            add_header X-Connection $connection;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+        %%GRPC_ASYNCH_ENABLE%%
+
+        location / {
+            grpc_pass grpcs://127.0.0.1:8081;
+            grpc_ssl_name localhost;
+            grpc_ssl_verify on;
+            grpc_ssl_trusted_certificate localhost.crt;
+
+            grpc_ssl_certificate client.crt;
+            grpc_ssl_certificate_key client.key;
+            grpc_ssl_password_file password;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            limit_except GET {
+                # nothing
+            }
+        }
+
+        location /KeepAlive {
+            grpc_pass grpcs://u;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('client') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', 'client');
+
+$t->run();
+
+###############################################################################
+
+my $p = port(8082);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+ok((my $sid = $frame->{sid}) % 2, 'request - HEADERS sid odd');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'request - content type');
+is($frame->{headers}{te}, 'trailers', 'request - te');
+
+$frames = $f->{data}('Hello');
+($frame) = grep { $_->{type} eq "SETTINGS" } @$frames;
+is($frame->{flags}, 1, 'request - SETTINGS ack');
+is($frame->{sid}, 0, 'request - SETTINGS sid');
+is($frame->{length}, 0, 'request - SETTINGS length');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+is($frame->{sid}, $sid, 'request - DATA sid match');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'response - HEADERS flags');
+is($frame->{sid}, 1, 'response - HEADERS sid');
+is($frame->{headers}{':status'}, '200', 'response - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'response - content type');
+ok($frame->{headers}{server}, 'response - server');
+ok($frame->{headers}{date}, 'response - date');
+ok(my $c = $frame->{headers}{'x-connection'}, 'response - connection');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'response - DATA');
+is($frame->{length}, 11, 'response - DATA length');
+is($frame->{flags}, 0, 'response - DATA flags');
+is($frame->{sid}, 1, 'response - DATA sid');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'response - trailers flags');
+is($frame->{sid}, 1, 'response - trailers sid');
+is($frame->{headers}{'grpc-message'}, '', 'response - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'response - trailers status');
+
+# next request is on a new backend connection, no sid incremented
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{headers}{'x-connection'}, '>', $c, 'response 2 - connection');
+
+# upstream keepalive
+
+$f->{http_start}('/KeepAlive');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive - connection');
+
+$f->{http_start}('/KeepAlive');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive - connection reuse');
+
+###############################################################################
+
+sub grpc {
+    my ($server, $client, $f, $s, $c, $sid, $uri);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $p,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    $f->{http_start} = sub {
+        ($uri, my %extra) = @_;
+        my $body_more = 1 if $uri !~ /LongHeader/;
+        $s = Test::Nginx::HTTP2->new() if !defined $s;
+        $s->new_stream({ body_more => $body_more, headers => [
+            { name => ':method', value => 'POST', mode => 0 },
+            { name => ':scheme', value => 'http', mode => 0 },
+            { name => ':path', value => $uri, },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-type', value => 'application/grpc' },
+            { name => 'te', value => 'trailers', mode => 2 }]});
+
+        if (!$extra{reuse}) {
+            eval {
+                local $SIG{ALRM} = sub { die "timeout\n" };
+                alarm(5);
+
+                $client = $server->accept() or return;
+
+                alarm(0);
+            };
+            alarm(0);
+            if ($@) {
+                log_in("died: $@");
+                return undef;
+            }
+
+            log2c("(new connection $client)");
+
+            $client->sysread(my $buf, 24) == 24 or return; # preface
+
+            $c = Test::Nginx::HTTP2->new(1, socket => $client,
+                pure => 1, preface => "") or return;
+        }
+
+        my $frames = $c->read(all => [{ fin => 4 }]);
+
+        if (!$extra{reuse}) {
+            $c->h2_settings(0);
+            $c->h2_settings(1);
+        }
+
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        $sid = $frame->{sid};
+        return $frames;
+    };
+    $f->{data} = sub {
+        my ($body, %extra) = @_;
+        $s->h2_body($body, { %extra });
+        return $c->read(all => [{ sid => $sid,
+            length => length($body) }]);
+    };
+    $f->{http_end} = sub {
+        $c->new_stream({ body_more => 1, headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => 1, huff => 1 },
+        ]}, $sid);
+        $c->h2_body('Hello world', { body_more => 1 });
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/grpc.t ../asynch_mode_nginx/test/nginx-tests/grpc.t
--- nginx-release-1.20.1/test/nginx-tests/grpc.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/grpc.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,883 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for grpc backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite http_v2 grpc/)
+    ->has(qw/upstream_keepalive/)->plan(123);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+        http2_body_preread_size 128k;
+        large_client_header_buffers 4 32k;
+
+        location / {
+            grpc_pass grpc://127.0.0.1:8081;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            limit_except GET {
+                # nothing
+            }
+        }
+
+        location /KeepAlive {
+            grpc_pass u;
+        }
+
+        location /LongHeader {
+            grpc_pass 127.0.0.1:8081;
+            grpc_set_header X-LongHeader $arg_h;
+        }
+
+        location /LongField {
+            grpc_pass 127.0.0.1:8081;
+            grpc_buffer_size 65k;
+        }
+
+        location /SetHost {
+            grpc_pass 127.0.0.1:8081;
+            grpc_set_header Host custom;
+        }
+
+        location /SetArgs {
+            grpc_pass 127.0.0.1:8081;
+            set $args $arg_c;
+        }
+    }
+}
+
+EOF
+
+# suppress deprecation warning
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $p = port(8081);
+my $f = grpc();
+
+my $frames = $f->{http_start}('/SayHello');
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'request - HEADERS flags');
+ok((my $sid = $frame->{sid}) % 2, 'request - HEADERS sid odd');
+is($frame->{headers}{':method'}, 'POST', 'request - method');
+is($frame->{headers}{':scheme'}, 'http', 'request - scheme');
+is($frame->{headers}{':path'}, '/SayHello', 'request - path');
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'request - authority');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'request - content type');
+is($frame->{headers}{te}, 'trailers', 'request - te');
+
+$frames = $f->{data}('Hello');
+($frame) = grep { $_->{type} eq "SETTINGS" } @$frames;
+is($frame->{flags}, 1, 'request - SETTINGS ack');
+is($frame->{sid}, 0, 'request - SETTINGS sid');
+is($frame->{length}, 0, 'request - SETTINGS length');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello', 'request - DATA');
+is($frame->{length}, 5, 'request - DATA length');
+is($frame->{flags}, 1, 'request - DATA flags');
+is($frame->{sid}, $sid, 'request - DATA sid match');
+
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'response - HEADERS flags');
+is($frame->{sid}, 1, 'response - HEADERS sid');
+is($frame->{headers}{':status'}, '200', 'response - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'response - content type');
+ok($frame->{headers}{server}, 'response - server');
+ok($frame->{headers}{date}, 'response - date');
+ok(my $c = $frame->{headers}{'x-connection'}, 'response - connection');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'response - DATA');
+is($frame->{length}, 11, 'response - DATA length');
+is($frame->{flags}, 0, 'response - DATA flags');
+is($frame->{sid}, 1, 'response - DATA sid');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'response - trailers flags');
+is($frame->{sid}, 1, 'response - trailers sid');
+is($frame->{headers}{'grpc-message'}, '', 'response - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'response - trailers status');
+
+# next request is on a new backend connection, no sid incremented
+
+$frames = $f->{http_start}('/SayHello');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'request 2 - HEADERS sid again');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{headers}{'x-connection'}, '>', $c, 'response 2 - connection');
+
+# upstream keepalive
+
+$frames = $f->{http_start}('/KeepAlive');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'keepalive - HEADERS sid');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive - connection');
+
+$frames = $f->{http_start}('/KeepAlive', reuse => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+cmp_ok($frame->{sid}, '>', $sid, 'keepalive - HEADERS sid next');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive - connection reuse');
+
+# upstream keepalive
+# pending control frame ack after the response
+
+undef $f;
+$f = grpc();
+
+$frames = $f->{http_start}('/KeepAlive');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'keepalive 2 - HEADERS sid');
+$f->{data}('Hello');
+$f->{settings}(0, 1 => 4096);
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($c = $frame->{headers}{'x-connection'}, 'keepalive 2 - connection');
+
+$frames = $f->{http_start}('/KeepAlive', reuse => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'upstream keepalive reused');
+
+cmp_ok($frame->{sid}, '>', $sid, 'keepalive 2 - HEADERS sid next');
+$f->{data}('Hello');
+$frames = $f->{http_end}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{'x-connection'}, $c, 'keepalive 2 - connection reuse');
+
+undef $f;
+$f = grpc();
+
+# various header compression formats
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 3);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'without indexing');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'without indexing 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 4);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'without indexing new');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'without indexing new 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 5);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'never indexed');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'never indexed 2');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 6);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'never indexed new');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'never indexed new 2');
+
+# padding & priority
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(prio => 137, dep => 0x01020304);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'priority');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7, prio => 137, dep => 0x01020304);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding priority');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+$f->{http_start}('/SaySplit');
+$f->{data}('Hello');
+$frames = $f->{http_end}(padding => 7, prio => 137, dep => 0x01020304,
+    split => [(map{1}(1..20)), 30], split_delay => 0.1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'padding priority split');
+
+}
+
+# grpc error, no empty data frame expected
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_err}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'grpc error - HEADERS flags');
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok(!$frame, 'grpc error - no DATA frame');
+
+# malformed response body length not equal to content-length
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_err2}(cl => 42);
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'response body less than content-length');
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_err2}(cl => 8);
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'response body more than content-length');
+
+}
+
+# continuation from backend, expect parts assembled
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{continuation}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'continuation - HEADERS flags');
+is($frame->{headers}{':status'}, '200', 'continuation - status');
+is($frame->{headers}{'content-type'}, 'application/grpc',
+    'continuation - content type');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'continuation - DATA');
+is($frame->{length}, 11, 'continuation - DATA length');
+is($frame->{flags}, 0, 'continuation - DATA flags');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'continuation - trailers flags');
+is($frame->{headers}{'grpc-message'}, '', 'continuation - trailers message');
+is($frame->{headers}{'grpc-status'}, '0', 'continuation - trailers status');
+
+# continuation from backend, header split
+
+$f->{http_start}('/SayHello');
+$f->{data}('Hello');
+$frames = $f->{http_end}(mode => 6, continuation => [map { 1 } (1 .. 42)]);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, '200', 'continuation - header split');
+
+# continuation to backend
+
+$frames = $f->{http_start}('/LongHeader?h=' . ('Z' x 31337));
+@$frames = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+is(@$frames, 4, 'continuation - frames');
+
+$frame = shift @$frames;
+is($frame->{type}, 'HEADERS', 'continuation - HEADERS');
+is($frame->{length}, 16384, 'continuation - HEADERS length');
+is($frame->{flags}, 1, 'continuation - HEADERS flags');
+ok($frame->{sid}, 'continuation - HEADERS sid');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION');
+is($frame->{length}, 16384, 'continuation - CONTINUATION length');
+is($frame->{flags}, 0, 'continuation - CONTINUATION flags');
+ok($frame->{sid}, 'continuation - CONTINUATION sid');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION 2');
+is($frame->{length}, 16384, 'continuation - CONTINUATION 2 length');
+is($frame->{flags}, 0, 'continuation - CONTINUATION 2 flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - CONTINUATION n');
+cmp_ok($frame->{length}, '<', 16384, 'continuation - CONTINUATION n length');
+is($frame->{flags}, 4, 'continuation - CONTINUATION n flags');
+is($frame->{headers}{':path'}, '/LongHeader?h=' . 'Z' x 31337,
+    'continuation - path');
+is($frame->{headers}{'x-longheader'}, 'Z' x 31337, 'continuation - header');
+
+$f->{http_end}();
+
+# long header field
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**7);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**7}, 'y' x 2**7, 'long header field 1');
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**8);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**8}, 'y' x 2**8, 'long header field 2');
+
+$f->{http_start}('/LongField');
+$f->{data}('Hello');
+$frames = $f->{field_len}(2**15);
+($frame) = grep { $_->{flags} & 0x4 } @$frames;
+is($frame->{headers}{'x' x 2**15}, 'y' x 2**15, 'long header field 3');
+
+# Intermediary Encapsulation Attacks, malformed header fields
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}(n => 'n:n');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid header name colon');
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}(n => 'NN');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid header name uppercase');
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}(n => "n\nn");
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid header name ctl');
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}(v => "v\nv");
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid header value ctl');
+
+# invalid HPACK index
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}('m' => 0);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid index - indexed header');
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}('m' => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid index - with indexing');
+
+$f->{http_start}('/');
+$f->{data}('Hello');
+$frames = $f->{field_bad}('m' => 3);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':status'}, 502, 'invalid index - without indexing');
+
+# flow control
+
+$f->{http_start}('/FlowControl');
+$frames = $f->{data_len}(('Hello' x 13000) . ('x' x 550), 65535);
+my $sum = eval join '+', map { $_->{type} eq "DATA" && $_->{length} } @$frames;
+is($sum, 65535, 'flow control - iws length');
+
+$f->{update}(10);
+$f->{update_sid}(10);
+
+$frames = $f->{data_len}(undef, 10);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 10, 'flow control - update length');
+is($frame->{flags}, 0, 'flow control - update flags');
+
+$f->{update_sid}(10);
+$f->{update}(10);
+
+$frames = $f->{data_len}(undef, 5);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 5, 'flow control - rest length');
+is($frame->{flags}, 1, 'flow control - rest flags');
+
+$f->{http_end}();
+
+# preserve output
+
+$f->{http_start}('/Preserve');
+$f->{data}('Hello');
+$frames = $f->{http_pres}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 4, 'preserve - HEADERS');
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 20480, 'preserve - DATA');
+
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'preserve - trailers');
+
+# DATA padding
+
+$f->{http_start}('/SayPadding');
+$f->{data}('Hello');
+$frames = $f->{http_end}(body_padding => 42);
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'DATA padding');
+is($frame->{length}, 11, 'DATA padding - length');
+is($frame->{flags}, 0, 'DATA padding - flags');
+
+# DATA padding with Content-Length
+
+TODO: {
+local $TODO = 'not yet'
+    if $t->has_version('1.19.1') and !$t->has_version('1.19.9');
+
+$f->{http_start}('/SayPadding');
+$f->{data}('Hello');
+$frames = $f->{http_end}(body_padding => 42, cl => length('Hello world'));
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'Hello world', 'DATA padding cl');
+is($frame->{length}, 11, 'DATA padding cl - length');
+is($frame->{flags}, 0, 'DATA padding cl - flags');
+
+}
+
+# :authority inheritance
+
+$frames = $f->{http_start}('/SayHello?if=1');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':authority'}, "127.0.0.1:$p", 'authority in if');
+$f->{data}('Hello');
+$f->{http_end}();
+
+# misc tests
+
+$frames = $f->{http_start}('/SetHost');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok(!$frame->{headers}{':authority'}, 'set host - authority');
+is($frame->{headers}{'host'}, 'custom', 'set host - host');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs?f');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs', 'set args');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs?c=1');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs?1', 'set args len');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/SetArgs esc');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/SetArgs%20esc', 'uri escape');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':path'}, '/', 'root index');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/', method => 'GET');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':method'}, 'GET', 'method get');
+$f->{data}('Hello');
+$f->{http_end}();
+
+$frames = $f->{http_start}('/', method => 'HEAD');
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}{':method'}, 'HEAD', 'method head');
+$f->{data}('Hello');
+$f->{http_end}();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.0');
+
+# receiving END_STREAM followed by WINDOW_UPDATE on incomplete request body
+
+$f->{http_start}('/Discard_WU');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'discard WINDOW_UPDATE - trailers');
+
+# receiving END_STREAM followed by RST_STREAM NO_ERROR
+
+$f->{http_start}('/Discard_NE');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, 5, 'discard NO_ERROR - trailers');
+
+}
+
+# receiving END_STREAM followed by several RST_STREAM NO_ERROR
+
+$f->{http_start}('/Discard_NE3');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, undef, 'discard NO_ERROR many - no trailers');
+
+# receiving END_STREAM followed by RST_STREAM CANCEL
+
+$f->{http_start}('/Discard_CNL');
+$frames = $f->{discard}();
+(undef, $frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{flags}, undef, 'discard CANCEL - no trailers');
+
+undef $f;
+$f = grpc();
+
+# upstream keepalive, grpc error
+# receiving END_STREAM followed by RST_STREAM NO_ERROR
+
+$f->{http_start}('/KeepAlive');
+$f->{data}('Hello');
+$frames = $f->{http_err_rst}();
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame->{headers}{'grpc-status'}, 'keepalive 3 - grpc error, rst');
+
+$frames = $f->{http_start}('/KeepAlive', reuse => 1);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.5');
+
+ok($frame, 'keepalive 3 - connection reused');
+
+}
+
+undef $f;
+$f = grpc();
+
+###############################################################################
+
+sub grpc {
+    my ($server, $client, $f, $s, $c, $sid, $csid, $uri);
+    my $n = 0;
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $p,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    $f->{http_start} = sub {
+        ($uri, my %extra) = @_;
+        my $body_more = 1 if $uri !~ /LongHeader/;
+        my $meth = $extra{method} || 'POST';
+        $s = Test::Nginx::HTTP2->new() if !defined $s;
+        $csid = $s->new_stream({ body_more => $body_more, headers => [
+            { name => ':method', value => $meth, mode => !!$meth },
+            { name => ':scheme', value => 'http', mode => 0 },
+            { name => ':path', value => $uri, },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-type', value => 'application/grpc' },
+            { name => 'te', value => 'trailers', mode => 2 }]});
+
+        if (!$extra{reuse}) {
+            eval {
+                local $SIG{ALRM} = sub { die "timeout\n" };
+                alarm(5);
+
+                $client = $server->accept() or return;
+
+                alarm(0);
+            };
+            alarm(0);
+            if ($@) {
+                log_in("died: $@");
+                return undef;
+            }
+
+            log2c("(new connection $client)");
+            $n++;
+
+            $client->sysread(my $buf, 24) == 24 or return; # preface
+
+            $c = Test::Nginx::HTTP2->new(1, socket => $client,
+                pure => 1, preface => "") or return;
+        }
+
+        my $frames = $c->read(all => [{ fin => 4 }]);
+
+        if (!$extra{reuse}) {
+            $c->h2_settings(0);
+            $c->h2_settings(1);
+        }
+
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        $sid = $frame->{sid};
+        return $frames;
+    };
+    $f->{data} = sub {
+        my ($body, %extra) = @_;
+        $s->h2_body($body, { %extra });
+        return $c->read(all => [{ sid => $sid,
+            length => length($body) }]);
+    };
+    $f->{data_len} = sub {
+        my ($body, $len) = @_;
+        $s->h2_body($body) if defined $body;
+        return $c->read(all => [{ sid => $sid, length => $len }]);
+    };
+    $f->{update} = sub {
+        $c->h2_window(shift);
+    };
+    $f->{update_sid} = sub {
+        $c->h2_window(shift, $sid);
+    };
+    $f->{settings} = sub {
+        $c->h2_settings(@_);
+    };
+    $f->{http_end} = sub {
+        my (%extra) = @_;
+        my $h = [
+            { name => ':status', value => '200',
+                mode => $extra{mode} || 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => $extra{mode} || 1, huff => 1 },
+            { name => 'x-connection', value => $n,
+                mode => 2, huff => 1 }];
+        push @$h, { name => 'content-length', value => $extra{cl} }
+            if $extra{cl};
+        $c->new_stream({ body_more => 1, headers => $h, %extra }, $sid);
+        $c->h2_body('Hello world', { body_more => 1,
+            body_padding => $extra{body_padding} });
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{http_pres} = sub {
+        my (%extra) = @_;
+        $s->h2_settings(0, 0x4 => 8192);
+        $c->new_stream({ body_more => 1, %extra, headers => [
+            { name => ':status', value => '200',
+                mode => $extra{mode} || 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => $extra{mode} || 1, huff => 1 },
+            { name => 'x-connection', value => $n,
+                mode => 2, huff => 1 },
+        ]}, $sid);
+        for (1 .. 20) {
+            $c->h2_body(sprintf('Hello %02d', $_) x 128, {
+                body_more => 1,
+                body_padding => $extra{body_padding} });
+            $c->h2_ping("PING");
+        }
+        # reopen window
+        $s->h2_window(2**24);
+        $s->h2_window(2**24, $csid);
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ sid => $csid, fin => 1 }]);
+    };
+    $f->{http_err} = sub {
+        $c->new_stream({ headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => 1, huff => 1 },
+            { name => 'grpc-status', value => '12',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => 'unknown service',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{http_err_rst} = sub {
+        $c->start_chain();
+        $c->new_stream({ headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc' },
+            { name => 'grpc-status', value => '12', mode => 2 },
+            { name => 'grpc-message', value => 'unknown service',
+                mode => 2 },
+        ]}, $sid);
+        $c->h2_rst($sid, 0);
+        $c->send_chain();
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{http_err2} = sub {
+        my %extra = @_;
+        $c->new_stream({ body_more => 1, headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => 1, huff => 1 },
+            { name => 'content-length', value => $extra{cl},
+                mode => 1, huff => 1 },
+        ]}, $sid);
+        $c->h2_body('Hello world',
+            { body_more => 1, body_split => [5] });
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ type => 'RST_STREAM' }]);
+    };
+    $f->{continuation} = sub {
+        $c->new_stream({ continuation => 1, body_more => 1, headers => [
+            { name => ':status', value => '200', mode => 0 },
+        ]}, $sid);
+        $c->h2_continue($sid, { continuation => 1, headers => [
+            { name => 'content-type', value => 'application/grpc',
+                mode => 1, huff => 1 },
+        ]});
+        $c->h2_continue($sid, { headers => [
+            # an empty CONTINUATION frame is legitimate
+        ]});
+        $c->h2_body('Hello world', { body_more => 1 });
+        $c->new_stream({ continuation => 1, headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+        $c->h2_continue($sid, { headers => [
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]});
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{field_len} = sub {
+        my ($len) = @_;
+        $c->new_stream({ continuation => [map {2**14} (0..$len/2**13)],
+            body_more => 1, headers => [
+            { name => ':status', value => '200', mode => 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => 1, huff => 1 },
+            { name => 'x' x $len, value => 'y' x $len, mode => 6 },
+        ]}, $sid);
+        $c->h2_body('Hello world', { body_more => 1 });
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0',
+                mode => 2, huff => 1 },
+            { name => 'grpc-message', value => '',
+                mode => 2, huff => 1 },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{field_bad} = sub {
+        my (%extra) = @_;
+        my $n = defined $extra{'n'} ? $extra{'n'} : 'n';
+        my $v = defined $extra{'v'} ? $extra{'v'} : 'v';
+        my $m = defined $extra{'m'} ? $extra{'m'} : 2;
+        $c->new_stream({ headers => [
+            { name => ':status', value => '200' },
+            { name => $n, value => $v, mode => $m },
+        ]}, $sid);
+
+        return $s->read(all => [{ fin => 1 }]);
+    };
+    $f->{discard} = sub {
+        my (%extra) = @_;
+        $c->new_stream({ body_more => 1, %extra, headers => [
+            { name => ':status', value => '200',
+                mode => $extra{mode} || 0 },
+            { name => 'content-type', value => 'application/grpc',
+                mode => $extra{mode} || 1, huff => 1 },
+            { name => 'x-connection', value => $n,
+                mode => 2, huff => 1 },
+        ]}, $sid);
+        $c->h2_body('Hello world', { body_more => 1,
+            body_padding => $extra{body_padding} });
+
+        # stick trailers and subsequent frames for reproducibility
+
+        $c->start_chain();
+        $c->new_stream({ headers => [
+            { name => 'grpc-status', value => '0', mode => 2 }
+        ]}, $sid);
+        $c->h2_window(42, $sid) if $uri eq '/Discard_WU';
+        $c->h2_rst($sid, 0) if $uri eq '/Discard_NE';
+        $c->h2_rst($sid, 0), $c->h2_rst($sid, 0), $c->h2_rst($sid, 0)
+            if $uri eq '/Discard_NE3';
+        $c->h2_rst($sid, 8) if $uri eq '/Discard_CNL';
+        $c->send_chain();
+
+        return $s->read(all => [{ fin => 1 }], wait => 2)
+            if $uri eq '/Discard_WU' || $uri eq '/Discard_NE';
+        return $s->read(all => [{ type => 'RST_STREAM' }]);
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gunzip_memcached.t ../asynch_mode_nginx/test/nginx-tests/gunzip_memcached.t
--- nginx-release-1.20.1/test/nginx-tests/gunzip_memcached.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gunzip_memcached.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with memcached.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip memcached rewrite/)
+    ->has_daemon('memcached')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gunzip on;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+            memcached_gzip_flag 2;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+    # repcached patch adds additional listen socket
+    push @memopts, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+    # UDP port is on by default in memcached 1.2.7+
+    push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+
+$t->run()->plan(2);
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start memcached";
+
+# Put compressed value into memcached.  This requires compress_threshold to be
+# set and compressed value to be at least 20% less than original one.
+
+my $memd = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+    compress_threshold => 1, connect_timeout => 1.0);
+$memd->set('/', 'TEST' x 10)
+    or die "can't put value into memcached: $!";
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'memcached response gzipped');
+like(http_get('/'), qr/TEST/, 'memcached response gunzipped');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gunzip_perl.t ../asynch_mode_nginx/test/nginx-tests/gunzip_perl.t
--- nginx-release-1.20.1/test/nginx-tests/gunzip_perl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gunzip_perl.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip perl/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gunzip on;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->header_out("Content-Encoding", "gzip");
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                use IO::Compress::Gzip;
+                my $in = "TEST";
+                my $out;
+                IO::Compress::Gzip::gzip(\\$in => \\$out);
+                $r->print($out);
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'perl response gzipped');
+like(http_get('/'), qr/TEST/, 'perl response gunzipped');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gunzip_ssi.t ../asynch_mode_nginx/test/nginx-tests/gunzip_ssi.t
--- nginx-release-1.20.1/test/nginx-tests/gunzip_ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gunzip_ssi.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip ssi proxy gzip_static/)
+    ->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            gunzip on;
+            gzip_vary on;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_set_header Accept-Encoding gzip;
+        }
+
+        location /t.html {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            default_type text/plain;
+            gzip_static on;
+            gzip_http_version 1.0;
+            gzip_types text/plain;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t.html', 'xxx <!--#include virtual="/t1" --> xxx');
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/t.html');
+unlike($r, qr/Content-Encoding/, 'no content encoding');
+like($r, qr/^xxx (X\d\d\dXXXXXX){100} xxx$/m, 'correct gunzipped response');
+
+$r = http_gzip_request('/t.html');
+unlike($r, qr/Content-Encoding/, 'gzip - no content encoding');
+like($r, qr/(X\d\d\dXXXXXX){100}/m, 'gzip - correct gunzipped response');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gunzip_static.t ../asynch_mode_nginx/test/nginx-tests/gunzip_static.t
--- nginx-release-1.20.1/test/nginx-tests/gunzip_static.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gunzip_static.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,105 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module with gzip_static always.  It is basically
+# the copy of gunzip.t with minor modifications.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip gzip_static rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gunzip on;
+            gzip_vary on;
+            gzip_static always;
+        }
+        location = /double {
+            error_page 404 @double;
+            gzip_static on;
+        }
+        location @double {
+            rewrite ^ /t1 break;
+            gunzip on;
+            gzip_static always;
+        }
+        location /error {
+            error_page 500 /t1;
+            return 500;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t2.gz', $out . $out);
+$t->write_file('t3', 'not compressed');
+
+$t->run()->plan(12);
+
+###############################################################################
+
+pass('runs');
+
+like(http_get('/t1'), qr/(?!Content-Encoding).*^(X\d\d\dXXXXXX){100}$/m,
+    'correct gunzipped response');
+like(http_gzip_request('/t1'), qr/Content-Encoding: gzip.*\Q$out\E/ms,
+    'gzip still works');
+
+like(http_get('/double'), qr/(?!Content-Encoding).^(X\d\d\dXXXXXX){100}$/ms,
+    'gunzip with gzip_tested');
+like(http_gzip_request('/double'), qr/Content-Encoding: gzip.*\Q$out\E/ms,
+    'gzip still works with gzip_tested');
+
+like(http_get('/t2'), qr/^(X\d\d\dXXXXXX){200}$/m, 'multiple gzip members');
+
+like(http_get('/error'), qr/^(X\d\d\dXXXXXX){100}$/m, 'errors gunzipped');
+
+unlike(http_head('/t1'), qr/Content-Encoding/, 'head - no content encoding');
+
+like(http_get('/t1'), qr/Vary/, 'get vary');
+like(http_head('/t1'), qr/Vary/, 'head vary');
+unlike(http_get('/t3'), qr/Vary/, 'no vary on non-gzipped get');
+unlike(http_head('/t3'), qr/Vary/, 'no vary on non-gzipped head');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gunzip.t ../asynch_mode_nginx/test/nginx-tests/gunzip.t
--- nginx-release-1.20.1/test/nginx-tests/gunzip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gunzip.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gunzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http gunzip proxy gzip_static rewrite/)
+    ->plan(13);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gunzip on;
+            gzip_vary on;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_set_header Accept-Encoding gzip;
+        }
+        location /error {
+            error_page 500 /t1;
+            return 500;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            default_type text/plain;
+            gzip_static on;
+            gzip_http_version 1.0;
+            gzip_types text/plain;
+        }
+    }
+}
+
+EOF
+
+my $in = join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99));
+my $out;
+
+IO::Compress::Gzip::gzip(\$in => \$out);
+
+$t->write_file('t1.gz', $out);
+$t->write_file('t2.gz', $out . $out);
+$t->write_file('t3', 'not compressed');
+
+my $emptyin = '';
+my $emptyout;
+IO::Compress::Gzip::gzip(\$emptyin => \$emptyout);
+
+$t->write_file('empty.gz', $emptyout);
+
+$t->run();
+
+###############################################################################
+
+pass('runs');
+
+my $r = http_get('/t1');
+unlike($r, qr/Content-Encoding/, 'no content encoding');
+like($r, qr/^(X\d\d\dXXXXXX){100}$/m, 'correct gunzipped response');
+
+$r = http_gzip_request('/t1');
+like($r, qr/Content-Encoding: gzip/, 'gzip still works - encoding');
+like($r, qr/\Q$out\E/, 'gzip still works - content');
+
+like(http_get('/t2'), qr/^(X\d\d\dXXXXXX){200}$/m, 'multiple gzip members');
+
+like(http_get('/error'), qr/^(X\d\d\dXXXXXX){100}$/m, 'errors gunzipped');
+
+unlike(http_head('/t1'), qr/Content-Encoding/, 'head - no content encoding');
+
+like(http_get('/t1'), qr/Vary/, 'get vary');
+like(http_head('/t1'), qr/Vary/, 'head vary');
+unlike(http_get('/t3'), qr/Vary/, 'no vary on non-gzipped get');
+unlike(http_head('/t3'), qr/Vary/, 'no vary on non-gzipped head');
+
+like(http_get('/empty'), qr/ 200 /, 'gunzip empty');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gzip_flush.t ../asynch_mode_nginx/test/nginx-tests/gzip_flush.t
--- nginx-release-1.20.1/test/nginx-tests/gzip_flush.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gzip_flush.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,75 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for gzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http gzip perl/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        %%GZIP_MIN_LENGTH_0%%
+        %%QATZIP_ENABLE%%
+        %%QATZIP_MIN_LENGTH_0%%
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print("DA");
+                $r->flush();
+                $r->flush();
+                $r->print("TA");
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/DATA/, 'request with flush');
+
+# gzip filter wasn't able to handle empty flush buffers, see
+# http://nginx.org/pipermail/nginx/2010-November/023693.html
+
+http_gzip_like(http_gzip_request('/'), qr/DATA/, 'gzip request with flush');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/gzip.t ../asynch_mode_nginx/test/nginx-tests/gzip.t
--- nginx-release-1.20.1/test/nginx-tests/gzip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/gzip.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx gzip filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy gzip/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            gzip on;
+            %%QATZIP_ENABLE%%
+        }
+        location /proxy/ {
+            gzip on;
+            %%QATZIP_ENABLE%%
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location /local/ {
+            gzip off;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'X' x 64);
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = http_gzip_request('/');
+like($r, qr/^Content-Encoding: gzip/m, 'gzip');
+http_gzip_like($r, qr/^X{64}\Z/, 'gzip content correct');
+
+$r = http_gzip_request('/proxy/');
+like($r, qr/^Content-Encoding: gzip/m, 'gzip proxied');
+http_gzip_like($r, qr/^X{64}\Z/, 'gzip proxied content');
+
+# Accept-Ranges headers should be cleared
+
+unlike(http_gzip_request('/'), qr/Accept-Ranges/im, 'cleared accept-ranges');
+unlike(http_gzip_request('/proxy/'), qr/Accept-Ranges/im,
+    'cleared headers from proxy');
+
+# HEAD requests should return correct headers
+
+like(http_gzip_head('/'), qr/Content-Encoding: gzip/, 'gzip head');
+unlike(http_head('/'), qr/Content-Encoding: gzip/, 'no gzip head');
+
+###############################################################################
+
+sub http_gzip_head {
+    my ($uri) = @_;
+    return http(<<EOF);
+HEAD $uri HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: gzip
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_auth_request.t ../asynch_mode_nginx/test/nginx-tests/h2_auth_request.t
--- nginx-release-1.20.1/test/nginx-tests/h2_auth_request.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_auth_request.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with auth_request.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite proxy auth_request/)
+    ->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 200;
+        }
+        location /auth {
+            add_header X-Body-File $request_body_file;
+            client_body_buffer_size 512;
+            auth_request /auth_request;
+            proxy_pass http://127.0.0.1:8081/auth_proxy;
+        }
+        location /auth_request {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_pass_request_body off;
+            proxy_set_header Content-Length "";
+        }
+        location /auth_proxy {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+# second stream is used to induce body corruption issue
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/auth', method => 'POST', body => 'A' x 600 });
+$s->new_stream({ path => '/auth', method => 'POST', body => 'B' x 600 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{'x-body'}, 'A' x 600, 'auth request body');
+isnt($frame->{headers}->{'x-body-file'}, undef, 'auth request body file');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_fastcgi_request_buffering.t ../asynch_mode_nginx/test/nginx-tests/h2_fastcgi_request_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/h2_fastcgi_request_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_fastcgi_request_buffering.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,280 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body and fastcgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 fastcgi/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            fastcgi_request_buffering off;
+            fastcgi_pass 127.0.0.1:8081;
+            fastcgi_param REQUEST_URI $request_uri;
+            client_body_buffer_size 1k;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(48);
+
+###############################################################################
+
+# unbuffered request body to fastcgi
+
+my $f = get_body('/');
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789_eos', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/');
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128, 'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128, 'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128 . '_eos', 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+    '56789many_eos', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}(''), '_eos', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/');
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789_eos',
+    'split - part');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body to fastcgi, content-length
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl');
+
+is($f->{upload}('01234', body_more => 1), '01234', 'cl - part');
+is($f->{upload}('56789'), '56789_eos', 'cl - part 2');
+is($f->{http_end}(), 200, 'cl - response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'cl buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128,
+    'cl buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128,
+    'cl buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128 . '_eos', 'cl buffer - above');
+is($f->{http_end}(), 200, 'cl buffer - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl much');
+is($f->{upload}('0123456789', body_more => 1), '0123456789', 'cl much - part');
+is($f->{upload}('many'), '', 'cl much - part 2');
+is($f->{http_end}(), 400, 'cl much - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl less');
+is($f->{upload}('0123', body_more => 1), '0123', 'cl less - part');
+is($f->{upload}('56789'), '', 'cl less - part 2');
+is($f->{http_end}(), 400, 'cl less - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'cl many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '01234many', 'cl many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]), '56789many_eos',
+    'cl many - part 2');
+is($f->{http_end}(), 200, 'cl many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'cl empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'cl empty - part');
+is($f->{upload}(''), '_eos', 'cl empty - part 2');
+is($f->{http_end}(), 200, 'cl empty - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'cl split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789_eos', 'cl split');
+is($f->{http_end}(), 200, 'cl split - response');
+
+###############################################################################
+
+# Simple FastCGI responder implementation.
+
+# http://www.fastcgi.com/devkit/doc/fcgi-spec.html
+
+sub fastcgi_read_record($) {
+    my ($buf) = @_;
+    my $h;
+
+    return undef unless length $$buf;
+
+    @{$h}{qw/ version type id clen plen /} = unpack("CCnnC", $$buf);
+
+    $h->{content} = substr $$buf, 8, $h->{clen};
+    $h->{padding} = substr $$buf, 8 + $h->{clen}, $h->{plen};
+
+    $$buf = substr $$buf, 8 + $h->{clen} + $h->{plen};
+
+    return $h;
+}
+
+sub fastcgi_respond($$$$) {
+    my ($socket, $version, $id, $body) = @_;
+
+    # stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, length($body), 0));
+    $socket->write($body);
+
+    # close stdout
+    $socket->write(pack("CCnnCx", $version, 6, $id, 0, 0));
+
+    # end request
+    $socket->write(pack("CCnnCx", $version, 3, $id, 8, 0));
+    $socket->write(pack("NCxxx", 0, 0));
+}
+
+sub get_body {
+    my ($url, %extra) = @_;
+    my ($server, $client, $f);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Timeout => 3,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $s = Test::Nginx::HTTP2->new();
+    my $sid = exists $extra{'content-length'}
+        ? $s->new_stream({ headers => [
+            { name => ':method', value => 'GET' },
+            { name => ':scheme', value => 'http' },
+            { name => ':path', value => $url, },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-length',
+                value => $extra{'content-length'} }],
+            body_more => 1 })
+        : $s->new_stream({ path => $url, body_more => 1 });
+
+    $client = $server->accept() or return;
+
+    log2c("(new connection $client)");
+
+    $f->{headers} = backend_read($client);
+
+    my $h = fastcgi_read_record(\$f->{headers});
+    my $version = $h->{version};
+    my $id = $h->{id};
+
+    $f->{upload} = sub {
+        my ($body, %extra) = @_;
+        my $len = length($body);
+        my $wait = $extra{wait};
+
+        $s->h2_body($body, { %extra });
+
+        $body = '';
+
+        for (1 .. 10) {
+            my $buf = backend_read($client, $wait) or return '';
+
+            while (my $h = fastcgi_read_record(\$buf)) {
+
+                # skip everything unless stdin
+                next if $h->{type} != 5;
+
+                $body .= $h->{content};
+
+                # mark the end-of-stream indication
+                $body .= "_eos" if $h->{clen} == 0;
+            }
+
+            last if length($body) >= $len;
+        }
+
+        return $body;
+    };
+    $f->{http_end} = sub {
+        local $SIG{PIPE} = 'IGNORE';
+
+        fastcgi_respond($client, $version, $id, <<EOF);
+Status: 200 OK
+Connection: close
+
+OK
+EOF
+
+        $client->close;
+
+        my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        return $frame->{headers}->{':status'};
+    };
+    return $f;
+}
+
+sub backend_read {
+    my ($s, $timo) = @_;
+    my $buf = '';
+
+    if (IO::Select->new($s)->can_read($timo || 8)) {
+        $s->sysread($buf, 16384) or return;
+        log2i($buf);
+    }
+    return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_headers.t ../asynch_mode_nginx/test/nginx-tests/h2_headers.t
--- nginx-release-1.20.1/test/nginx-tests/h2_headers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_headers.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,1210 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 headers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite/)->plan(104)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082 http2 sndbuf=128;
+        server_name  localhost;
+
+        http2_max_field_size 128k;
+        http2_max_header_size 128k;
+        large_client_header_buffers 2 64k;
+
+        location / {
+            add_header X-Sent-Foo $http_x_foo;
+            add_header X-Referer $http_referer;
+            return 200;
+        }
+        location /frame_size {
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            alias %%TESTDIR%%/t2.html;
+        }
+        location /continuation {
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            add_header X-LongHeader $arg_h;
+            return 200 body;
+
+            location /continuation/204 {
+                return 204;
+            }
+        }
+        location /proxy/ {
+            add_header X-UC-a $upstream_cookie_a;
+            add_header X-UC-c $upstream_cookie_c;
+            proxy_pass http://127.0.0.1:8083/;
+            proxy_set_header X-Cookie-a $cookie_a;
+            proxy_set_header X-Cookie-c $cookie_c;
+        }
+        location /proxy2/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+        location /set-cookie {
+            add_header Set-Cookie a=b;
+            add_header Set-Cookie c=d;
+            return 200;
+        }
+        location /cookie {
+            add_header X-Cookie $http_cookie;
+            add_header X-Cookie-a $cookie_a;
+            add_header X-Cookie-c $cookie_c;
+            return 200;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084 http2;
+        server_name  localhost;
+
+        http2_max_field_size 512;
+        large_client_header_buffers 4 512;
+    }
+
+    server {
+        listen       127.0.0.1:8085 http2;
+        server_name  localhost;
+
+        http2_max_header_size 512;
+        large_client_header_buffers 1 512;
+    }
+
+    server {
+        listen       127.0.0.1:8086 http2;
+        server_name  localhost;
+
+        underscores_in_headers on;
+        add_header X-Sent-Foo $http_x_foo always;
+    }
+
+    server {
+        listen       127.0.0.1:8087 http2;
+        server_name  localhost;
+
+        ignore_invalid_headers off;
+        add_header X-Sent-Foo $http_x_foo always;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+
+# suppress deprecation warning
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# 6.1. Indexed Header Field Representation
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'indexed header field');
+
+# 6.2.1. Literal Header Field with Incremental Indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 1, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 1, huff => 0 },
+    { name => ':path', value => '/', mode => 1, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 1, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 1, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 1, huff => 1 },
+    { name => ':path', value => '/', mode => 1, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 1, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - huffman');
+
+# 6.2.1. Literal Header Field with Incremental Indexing -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 2, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 2, huff => 0 },
+    { name => ':path', value => '/', mode => 2, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 2, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 2, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 2, huff => 1 },
+    { name => ':path', value => '/', mode => 2, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 2, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal with indexing - new huffman');
+
+# 6.2.2. Literal Header Field without Indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 3, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+    { name => ':path', value => '/', mode => 3, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 3, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 3, huff => 1 },
+    { name => ':path', value => '/', mode => 3, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 3, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing - huffman');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 3, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+    { name => ':path', value => '/', mode => 3, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+    { name => 'referer', value => 'foo', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'literal without indexing - multibyte index');
+is($frame->{headers}->{'x-referer'}, 'foo',
+    'literal without indexing - multibyte index value');
+
+# 6.2.2. Literal Header Field without Indexing -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 4, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 4, huff => 0 },
+    { name => ':path', value => '/', mode => 4, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 4, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal without indexing - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 4, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 4, huff => 1 },
+    { name => ':path', value => '/', mode => 4, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 4, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'literal without indexing - new huffman');
+
+# 6.2.3. Literal Header Field Never Indexed
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 5, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 5, huff => 0 },
+    { name => ':path', value => '/', mode => 5, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 5, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 5, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 5, huff => 1 },
+    { name => ':path', value => '/', mode => 5, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 5, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - huffman');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 5, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 5, huff => 0 },
+    { name => ':path', value => '/', mode => 5, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 5, huff => 0 },
+    { name => 'referer', value => 'foo', mode => 5, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'literal never indexed - multibyte index');
+is($frame->{headers}->{'x-referer'}, 'foo',
+    'literal never indexed - multibyte index value');
+
+# 6.2.3. Literal Header Field Never Indexed -- New Name
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 6, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 6, huff => 0 },
+    { name => ':path', value => '/', mode => 6, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 6, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - new');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 6, huff => 1 },
+    { name => ':scheme', value => 'http', mode => 6, huff => 1 },
+    { name => ':path', value => '/', mode => 6, huff => 1 },
+    { name => ':authority', value => 'localhost', mode => 6, huff => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'literal never indexed - new huffman');
+
+# reuse literal with multibyte indexing
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'referer', value => 'foo', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'value with indexing - new');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 0 },
+    { name => 'referer', value => 'foo', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'value with indexing - indexed');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'name with indexing - new');
+
+# reuse literal with multibyte indexing - reused name
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 0 },
+    { name => 'x-foo', value => 'X-Bar', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'name with indexing - indexed');
+
+# reuse literal with multibyte indexing - reused name only
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 0 },
+    { name => 'x-foo', value => 'X-Baz', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Baz',
+    'name with indexing - indexed name');
+
+# response header field with characters not suitable for huffman encoding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x-foo', value => '{{{{{', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, '{{{{{', 'rare chars');
+like($s->{headers}, qr/\Q{{{{{/, 'rare chars - no huffman encoding');
+
+# response header field with huffman encoding
+# NB: implementation detail, not obligated
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x-foo', value => 'aaaaa', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'aaaaa', 'well known chars');
+unlike($s->{headers}, qr/aaaaa/, 'well known chars - huffman encoding');
+
+# response header field with huffman encoding - complete table mod \0, CR, LF
+# first saturate with short-encoded characters (NB: implementation detail)
+
+my $field = pack "C*", ((map { 97 } (1 .. 862)), 1 .. 9, 11, 12, 14 .. 255);
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x-foo', value => $field, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, $field, 'all chars');
+unlike($s->{headers}, qr/abcde/, 'all chars - huffman encoding');
+
+# 6.3.  Dynamic Table Size Update
+
+# remove some indexed headers from the dynamic table
+# by maintaining dynamic table space only for index 0
+# 'x-foo' has index 0, and 'referer' has index 1
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'referer', value => 'foo', mode => 1 },
+    { name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ table_size => 61, headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => 'x-foo', value => 'X-Bar', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame, undef, 'updated table size - remaining index');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'referer', value => 'foo', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{code}, 0x9, 'invalid index');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'unknown', value => 'foo', mode => 3 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{code}, 0x9, 'invalid index in literal header field');
+
+# 5.4.1.  Connection Error Handling
+#   An endpoint that encounters a connection error SHOULD first send a
+#   GOAWAY frame <..>
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid index - GOAWAY');
+
+# RFC 7541, 2.3.3.  Index Address Space
+#   Indices strictly greater than the sum of the lengths of both tables
+#   MUST be treated as a decoding error.
+
+# 4.3.  Header Compression and Decompression
+#   A decoding error in a header block MUST be treated
+#   as a connection error of type COMPRESSION_ERROR.
+
+is($frame->{last_sid}, $sid, 'invalid index - GOAWAY last stream');
+is($frame->{code}, 9, 'invalid index - GOAWAY COMPRESSION_ERROR');
+
+# HPACK zero index
+
+# RFC 7541, 6.1  Indexed Header Field Representation
+#   The index value of 0 is not used.  It MUST be treated as a decoding
+#   error if found in an indexed header field representation.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => '', value => '', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+ok($frame, 'zero index - GOAWAY');
+is($frame->{code}, 9, 'zero index - GOAWAY COMPRESSION_ERROR');
+
+# invalid table size update
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ table_size => 4097, headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => 'x-foo', value => 'X-Bar', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid table size - GOAWAY');
+is($frame->{last_sid}, $sid, 'invalid table size - GOAWAY last stream');
+is($frame->{code}, 9, 'invalid table size - GOAWAY COMPRESSION_ERROR');
+
+# request header field with multiple values
+
+# 8.1.2.5.  Compressing the Cookie Header Field
+#   To allow for better compression efficiency, the Cookie header field
+#   MAY be split into separate header fields <..>.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/cookie', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'cookie', value => 'a=b', mode => 2},
+    { name => 'cookie', value => 'c=d', mode => 2}]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-cookie-a'}, 'b',
+    'multiple request header fields - cookie');
+is($frame->{headers}->{'x-cookie-c'}, 'd',
+    'multiple request header fields - cookie 2');
+is($frame->{headers}->{'x-cookie'}, 'a=b; c=d',
+    'multiple request header fields - semi-colon');
+
+# request header field with multiple values to HTTP backend
+
+# 8.1.2.5.  Compressing the Cookie Header Field
+#   these MUST be concatenated into a single octet string
+#   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ")
+#   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
+#   connection <..>
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/proxy/cookie', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'cookie', value => 'a=b', mode => 2 },
+    { name => 'cookie', value => 'c=d', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-cookie'}, 'a=b; c=d',
+    'multiple request header fields proxied - semi-colon');
+is($frame->{headers}->{'x-sent-cookie2'}, '',
+    'multiple request header fields proxied - dublicate cookie');
+is($frame->{headers}->{'x-sent-cookie-a'}, 'b',
+    'multiple request header fields proxied - cookie 1');
+is($frame->{headers}->{'x-sent-cookie-c'}, 'd',
+    'multiple request header fields proxied - cookie 2');
+
+# response header field with multiple values
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/set-cookie' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'set-cookie'}[0], 'a=b',
+    'multiple response header fields - cookie');
+is($frame->{headers}->{'set-cookie'}[1], 'c=d',
+    'multiple response header fields - cookie 2');
+
+# response header field with multiple values from HTTP backend
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy/set-cookie' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'set-cookie'}[0], 'a=b',
+    'multiple response header proxied - cookie');
+is($frame->{headers}->{'set-cookie'}[1], 'c=d',
+    'multiple response header proxied - cookie 2');
+is($frame->{headers}->{'x-uc-a'}, 'b',
+    'multiple response header proxied - upstream cookie');
+is($frame->{headers}->{'x-uc-c'}, 'd',
+    'multiple response header proxied - upstream cookie 2');
+
+# CONTINUATION in response
+# put three long header fields (not less than SETTINGS_MAX_FRAME_SIZE/2)
+# to break header block into separate frames, one such field per frame
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**13 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+my @data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+my $data = $data[-1];
+is(@{$data->{headers}{'x-longheader'}}, 3,
+    'response CONTINUATION - headers');
+is($data->{headers}{'x-longheader'}[0], 'x' x 2**13,
+    'response CONTINUATION - header 1');
+is($data->{headers}{'x-longheader'}[1], 'x' x 2**13,
+    'response CONTINUATION - header 2');
+is($data->{headers}{'x-longheader'}[2], 'x' x 2**13,
+    'response CONTINUATION - header 3');
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'response CONTINUATION - max frame size');
+
+# same but without response DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation/204?h=' . 'x' x 2**13 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+$data = $data[-1];
+is(@{$data->{headers}{'x-longheader'}}, 3,
+    'no body CONTINUATION - headers');
+is($data->{headers}{'x-longheader'}[0], 'x' x 2**13,
+    'no body CONTINUATION - header 1');
+is($data->{headers}{'x-longheader'}[1], 'x' x 2**13,
+    'no body CONTINUATION - header 2');
+is($data->{headers}{'x-longheader'}[2], 'x' x 2**13,
+    'no body CONTINUATION - header 3');
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'no body CONTINUATION - max frame size');
+
+# response header block is always split by SETTINGS_MAX_FRAME_SIZE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**15 });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+@data = sort { $a <=> $b } map { $_->{length} } @data;
+cmp_ok($data[-1], '<=', 2**14, 'response header frames limited');
+
+# response header frame sent in parts
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$s->h2_settings(0, 0x5 => 2**17);
+
+$sid = $s->new_stream({ path => '/frame_size?h=' . 'x' x 2**15 });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'response header - parts');
+
+SKIP: {
+skip 'response header failed', 1 unless $frame;
+
+is(length join('', @{$frame->{headers}->{'x-longheader'}}), 98304,
+    'response header - headers');
+
+}
+
+# response header block split and sent in parts
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 2**15 });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+@data = grep { $_->{type} =~ "HEADERS|CONTINUATION" } @$frames;
+ok(@data, 'response header split');
+
+SKIP: {
+skip 'response header split failed', 2 unless @data;
+
+my ($lengths) = sort { $b <=> $a } map { $_->{length} } @data;
+cmp_ok($lengths, '<=', 16384, 'response header split - max size');
+
+is(length join('', @{$data[-1]->{headers}->{'x-longheader'}}), 98304,
+    'response header split - headers');
+
+}
+
+# max_field_size - header field name
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x' x 511, value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size less');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x' x 511, value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size second');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x' x 512, value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field name size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name =>  'x' x 513, value => 'value', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'field name size greater');
+
+# max_field_size - header field value
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'name', value => 'x' x 511, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field value size less');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'name', value => 'x' x 511, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'field value size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8084));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'name', value => 'x' x 513, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'field value size greater');
+
+# max_header_size
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 450, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size less');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 450, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size second');
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 451, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size equal');
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 452, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame, undef, 'header size greater');
+
+# header size is based on (decompressed) header list
+# two extra 1-byte indices would otherwise fit in max_header_size
+
+$s = Test::Nginx::HTTP2->new(port(8085));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 400, mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size new index');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 400, mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+ok($frame, 'header size indexed');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t2.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'longname', value => 'x' x 400, mode => 0 },
+    { name => 'longname', value => 'x' x 400, mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0xb, 'header size indexed greater');
+
+# HPACK table boundary
+
+$s = Test::Nginx::HTTP2->new();
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x' x 2016, value => 'x' x 2048, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x' x 2016, value => 'x' x 2048, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary');
+
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x' x 33, value => 'x' x 4031, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x' x 33, value => 'x' x 4031, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary - header field name');
+
+$s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x', value => 'x' x 64, mode => 2 }]}), fin => 1 }]);
+$frames = $s->read(all => [{ sid => $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 },
+    { name => 'x', value => 'x' x 64, mode => 0 }]}), fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HPACK table boundary - header field value');
+
+# ensure that request header field value with newline doesn't get split
+#
+# 10.3.  Intermediary Encapsulation Attacks
+#   Any request or response that contains a character not permitted
+#   in a header field value MUST be treated as malformed.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/proxy2/', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x-foo', value => "x-bar\r\nreferer:see-this", mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# 10.3.  Intermediary Encapsulation Attacks
+#   An intermediary therefore cannot translate an HTTP/2 request or response
+#   containing an invalid field name into an HTTP/1.1 message.
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame->{headers}->{'x-referer'}, 'see-this', 'newline in request header');
+
+# 8.1.2.6.  Malformed Requests and Responses
+#   Malformed requests or responses that are detected MUST be treated
+#   as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{sid}, $sid, 'newline in request header - RST_STREAM sid');
+is($frame->{length}, 4, 'newline in request header - RST_STREAM length');
+is($frame->{flags}, 0, 'newline in request header - RST_STREAM flags');
+is($frame->{code}, 1, 'newline in request header - RST_STREAM code');
+
+# invalid header name as seen with underscore should not lead to ignoring rest
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x_foo', value => "x-bar", mode => 2 },
+    { name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'see-this', 'after invalid header name');
+
+# other invalid header name characters as seen with ':' result in RST_STREAM
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x:foo', value => "x-bar", mode => 2 },
+    { name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{sid}, $sid, 'colon in header name - RST_STREAM sid');
+is($frame->{code}, 1, 'colon in header name - RST_STREAM code');
+
+# header name with underscore - underscores_in_headers on
+
+$s = Test::Nginx::HTTP2->new(port(8086));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x_foo', value => "x-bar", mode => 2 },
+    { name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'x-bar',
+    'underscore in header name - underscores_in_headers');
+
+# header name with underscore - ignore_invalid_headers off
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'x_foo', value => "x-bar", mode => 2 },
+    { name => 'referer', value => "see-this", mode => 1 }]});
+$frames = $s->read(all => [{ type => 'HEADERS' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'x-bar',
+    'underscore in header name - ignore_invalid_headers');
+
+# missing mandatory request header ':scheme'
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'incomplete headers');
+
+# empty request header ':authority'
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => '', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'empty authority');
+
+# client sent invalid :path header
+
+$sid = $s->new_stream({ path => 't1.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'invalid path');
+
+
+# ngx_http_v2_parse_int() error handling
+
+# NGX_ERROR
+
+$s = Test::Nginx::HTTP2->new();
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C3NC", 1, 0x1, 5, 1, 0xff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x6, 'invalid index length');
+
+$s = Test::Nginx::HTTP2->new();
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C3NC2", 2, 0x1, 5, 1, 0x42, 0xff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x6, 'invalid literal length');
+
+# NGX_DECLINED
+
+$s = Test::Nginx::HTTP2->new();
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C3NN", 5, 0x1, 5, 1, 0xffffffff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x9, 'too long index');
+
+$s = Test::Nginx::HTTP2->new();
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C3NCN", 6, 0x1, 5, 1, 0x42, 0xffffffff));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+is($frame->{code}, 0x9, 'too long literal');
+
+# NGX_AGAIN
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ split => [35], split_delay => 1.1, headers => [
+    { name => ':method', value => 'GET', mode => 3, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+    { name => ':path', value => '/', mode => 3, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+    { name => 'referer', value => 'foo', mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, 'foo', 'header split index');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ split => [37], split_delay => 1.1, headers => [
+    { name => ':method', value => 'GET', mode => 3, huff => 0 },
+    { name => ':scheme', value => 'http', mode => 3, huff => 0 },
+    { name => ':path', value => '/', mode => 3, huff => 0 },
+    { name => ':authority', value => 'localhost', mode => 3, huff => 0 },
+    { name => 'referer', value => '1234' x 32, mode => 3, huff => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-referer'}, '1234' x 32, 'header split field length');
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8083),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        next if $headers eq '';
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/cookie') {
+
+            my ($cookie, $cookie2) = $headers =~ /Cookie: (.+)/ig;
+            $cookie2 = '' unless defined $cookie2;
+
+            my ($cookie_a, $cookie_c) = ('', '');
+            $cookie_a = $1 if $headers =~ /X-Cookie-a: (.+)/i;
+            $cookie_c = $1 if $headers =~ /X-Cookie-c: (.+)/i;
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Sent-Cookie: $cookie
+X-Sent-Cookie2: $cookie2
+X-Sent-Cookie-a: $cookie_a
+X-Sent-Cookie-c: $cookie_c
+
+EOF
+
+        } elsif ($uri eq '/set-cookie') {
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+Set-Cookie: a=b
+Set-Cookie: c=d
+
+EOF
+
+        }
+
+    } continue {
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_limit_conn.t ../asynch_mode_nginx/test/nginx-tests/h2_limit_conn.t
--- nginx-release-1.20.1/test/nginx-tests/h2_limit_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_limit_conn.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with limit_conn.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 limit_conn/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_conn_zone  $binary_remote_addr  zone=conn:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /t.html {
+            limit_conn conn 1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 1);
+
+my $sid = $s->new_stream({ path => '/t.html' });
+my $frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'limit_conn first stream');
+
+my $sid2 = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid2, length => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+is($frame->{headers}->{':status'}, 503, 'limit_conn rejected');
+
+$s->h2_settings(0, 0x4 => 2**16);
+
+$s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+# limit_conn + client's RST_STREAM
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 1);
+
+$sid = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+$s->h2_rst($sid, 5);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'RST_STREAM 1');
+
+$sid2 = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid2, length => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+is($frame->{headers}->{':status'}, 200, 'RST_STREAM 2');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_limit_req.t ../asynch_mode_nginx/test/nginx-tests/h2_limit_req.t
--- nginx-release-1.20.1/test/nginx-tests/h2_limit_req.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_limit_req.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,176 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with limit_req.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite limit_req/)
+    ->plan(7);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=1r/s;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+        location /limit_req {
+            limit_req  zone=req burst=2;
+            alias %%TESTDIR%%/t.html;
+        }
+        location /proxy_limit_req/ {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+            limit_req  zone=req burst=2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# request body delayed in limit_req
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+$s->h2_body('TEST');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+    'request body - limit req');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+select undef, undef, undef, 1.1;
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+    'request body - limit req - limited');
+
+# request body delayed in limit_req - with an empty DATA frame
+# "zero size buf in output" alerts seen
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body_more => 1 });
+$s->h2_body('');
+select undef, undef, undef, 1.1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request body - limit req - empty');
+
+# predict send windows
+
+$sid = $s->new_stream();
+my ($maxwin) = sort {$a <=> $b} $s->{streams}{$sid}, $s->{conn_window};
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 5;
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy_limit_req/', body => 'TEST2' });
+select undef, undef, undef, 1.1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST2',
+    'request body - limit req 2');
+
+}
+
+# partial request body data frame received (to be discarded) within request
+# delayed in limit_req, the rest of data frame is received after response
+
+$s = Test::Nginx::HTTP2->new();
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 4;
+
+$sid = $s->new_stream({ path => '/limit_req', body => 'TEST', split => [61],
+    split_delay => 1.1 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'discard body - limit req - limited');
+
+}
+
+$sid = $s->new_stream({ path => '/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'discard body - limit req - next');
+
+# ditto, but instead of receiving the rest of data frame, connection is closed
+# 'http request already closed while closing request' alert can be produced
+
+SKIP: {
+skip 'not enough window', 1 if $maxwin < 4;
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/limit_req', body => 'TEST', split => [61],
+    abort => 1 });
+
+select undef, undef, undef, 1.1;
+close $s->{socket};
+
+pass('discard body - limit req - eof');
+
+}
+
+###############################################################################
+
+sub read_body_file {
+    my ($path) = @_;
+    return unless $path;
+    open FILE, $path or return "$!";
+    local $/;
+    my $content = <FILE>;
+    close FILE;
+    return $content;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_max_requests.t ../asynch_mode_nginx/test/nginx-tests/h2_max_requests.t
--- nginx-release-1.20.1/test/nginx-tests/h2_max_requests.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_max_requests.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,222 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol, http2_max_requests directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw(SOL_SOCKET SO_RCVBUF);
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2 sndbuf=1m;
+        server_name  localhost;
+
+        http2_max_requests 2;
+        keepalive_requests 2;
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8081 http2;
+        server_name  localhost;
+
+        keepalive_timeout 0;
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+
+        keepalive_time 1s;
+
+        add_header X-Conn $connection_requests:$connection_time;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THAT' x 50000);
+$t->write_file('t.html', 'SEE-THAT');
+
+# suppress deprecation warning
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->try_run('no keepalive_time')->plan(19);
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+
+# to test lingering close, let full response settle down in send buffer space
+# so that client additional data past server-side close would trigger TCP RST
+
+$s->{socket}->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or die $!;
+$s->h2_settings(0, 0x4 => 2**20);
+$s->h2_window(2**21);
+
+my $frames = $s->read(all => [{ sid => $s->new_stream(), fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'max requests');
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }], wait => 0.5)
+    unless grep { $_->{type} eq "GOAWAY" } @$frames;
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame, undef, 'max requests - GOAWAY');
+
+# max requests limited
+
+my $sid = $s->new_stream();
+
+# wait server to finish and close socket if lingering close were disabled
+
+select undef, undef, undef, 0.1;
+$s->h2_ping("SEE-THIS");
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }, { type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'max requests limited');
+
+TODO: {
+local $TODO = 'not yet' if ($^O eq 'linux' or $^O eq 'freebsd')
+    and !$t->has_version('1.19.1');
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+my $sum = eval join '+', map { $_->{length} } @data;
+is($sum, 400000, 'max requests limited - all data received');
+
+}
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'max requests limited - GOAWAY');
+is($frame->{last_sid}, $sid, 'max requests limited - GOAWAY last stream');
+
+# keepalive_timeout 0
+
+SKIP: {
+skip 'not yet', 2 unless $t->has_version('1.19.7');
+
+$s = Test::Nginx::HTTP2->new(port(8081));
+$sid = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }, { type => 'GOAWAY' }]);
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.8');
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'keepalive_timeout 0');
+
+}
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'keepalive_timeout 0 - GOAWAY');
+
+}
+
+# keepalive_time
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'keepalive time request');
+like($frame->{headers}->{'x-conn'}, qr/^1:0/, 'keepalive time variables');
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame, undef, 'keepalive time - no GOAWAY yet');
+
+select undef, undef, undef, 1.1;
+
+$sid = $s->new_stream({ path => '/t.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }, { type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'keepalive time request 2');
+like($frame->{headers}->{'x-conn'}, qr/^2:[^0]/, 'keepalive time variables 2');
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'keepalive time limit - GOAWAY');
+is($frame->{last_sid}, $sid, 'keepalive time limit - GOAWAY last stream');
+
+# graceful shutdown in idle state
+
+$s = Test::Nginx::HTTP2->new();
+$s->{socket}->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or die $!;
+$s->h2_settings(0, 0x4 => 2**20);
+$s->h2_window(2**21);
+
+$sid = $s->new_stream();
+
+# wait server to finish and close socket if lingering close were disabled
+
+select undef, undef, undef, 0.1;
+
+$t->reload();
+
+select undef, undef, undef, 0.3;
+
+$s->h2_ping("SEE-THIS");
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }, { type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'graceful shutdown in idle');
+
+TODO: {
+local $TODO = 'not yet' if ($^O eq 'linux' or $^O eq 'freebsd')
+    and !$t->has_version('1.19.1');
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+my $sum = eval join '+', map { $_->{length} } @data;
+is($sum, 400000, 'graceful shutdown in idle - all data received');
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'graceful shutdown in idle - GOAWAY');
+is($frame->{last_sid}, $sid, 'graceful shutdown in idle - GOAWAY last stream');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_priority.t ../asynch_mode_nginx/test/nginx-tests/h2_priority.t
--- nginx-release-1.20.1/test/nginx-tests/h2_priority.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_priority.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,458 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with priority.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)->plan(20)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->run();
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# stream muliplexing + PRIORITY frames
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+my $sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_priority(0, $sid);
+$s->h2_priority(255, $sid2);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+my $frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "$sid2 $sid", 'weight - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_priority(255, $sid);
+$s->h2_priority(0, $sid2);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "$sid $sid2", 'weight - PRIORITY 2');
+
+# stream muliplexing + HEADERS PRIORITY flag
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html', prio => 0 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', prio => 255 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'weight - HEADERS PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html', prio => 255 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', prio => 0 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'weight - HEADERS PRIORITY 2');
+
+# 5.3.1.  Stream Dependencies
+
+# PRIORITY frame
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 3, 0);
+$s->h2_priority(16, 1, 3);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'dependency - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'dependency - PRIORITY 2');
+
+# PRIORITY - self dependency
+
+# 5.3.1.  Stream Dependencies
+#   A stream cannot depend on itself.  An endpoint MUST treat this as a
+#   stream error of type PROTOCOL_ERROR.
+# Instead, we respond with a connection error of type PROTOCOL_ERROR.
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream();
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$s->h2_priority(0, $sid, $sid);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+my ($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, $sid, 'dependency - PRIORITY self - GOAWAY');
+is($frame->{code}, 1, 'dependency - PRIORITY self - PROTOCOL_ERROR');
+
+}
+
+# HEADERS PRIORITY flag, reprioritize prior PRIORITY frame records
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 0);
+
+$sid = $s->new_stream({ path => '/t1.html', dep => 3 });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid2 $sid", 'dependency - HEADERS PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 0);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html', dep => 1 });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid $sid2", 'dependency - HEADERS PRIORITY 2');
+
+# HEADERS - self dependency
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ dep => 1 });
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+my ($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, 0, 'dependency - HEADERS self - GOAWAY');
+is($frame->{code}, 1, 'dependency - HEADERS self - PROTOCOL_ERROR');
+
+}
+
+# PRIORITY frame, weighted dependencies
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 5, 0);
+$s->h2_priority(255, 1, 5);
+$s->h2_priority(0, 3, 5);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+my $sid3 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid3, fin => 0x4 }]);
+
+$s->h2_window(2**16, 1);
+$s->h2_window(2**16, 3);
+$s->h2_window(2**16, 5);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+    { sid => $sid3, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid3 $sid $sid2", 'weighted dependency - PRIORITY 1');
+
+# and vice versa
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_priority(16, 5, 0);
+$s->h2_priority(0, 1, 5);
+$s->h2_priority(255, 3, 5);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+$sid3 = $s->new_stream({ path => '/t2.html' });
+$s->read(all => [{ sid => $sid3, fin => 0x4 }]);
+
+$s->h2_window(2**16, 1);
+$s->h2_window(2**16, 3);
+$s->h2_window(2**16, 5);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 },
+    { sid => $sid3, fin => 1 },
+]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sids = join ' ', map { $_->{sid} } @data;
+is($sids, "$sid3 $sid2 $sid", 'weighted dependency - PRIORITY 2');
+
+# PRIORITY - reprioritization with circular dependency - after [3] removed
+# initial dependency tree:
+# 1 <- [3] <- 5
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_window(2**18);
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+$s->h2_priority(16, 5, 3);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid2, length => 2**16 - 1 }]);
+
+$sid3 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid3, length => 2**16 - 1 }]);
+
+$s->h2_window(2**16, $sid2);
+
+$frames = $s->read(all => [{ sid => $sid2, fin => 1 }]);
+$sids = join ' ', map { $_->{sid} } grep { $_->{type} eq "DATA" } @$frames;
+is($sids, $sid2, 'removed dependency');
+
+for (1 .. 40) {
+    $s->read(all => [{ sid => $s->new_stream(), fin => 1 }]);
+}
+
+# make circular dependency
+# 1 <- 5 -- current dependency tree before reprioritization
+# 5 <- 1
+# 1 <- 5
+
+$s->h2_priority(16, 1, 5);
+$s->h2_priority(16, 5, 1);
+
+$s->h2_window(2**16, $sid);
+$s->h2_window(2**16, $sid3);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid3, fin => 1 },
+]);
+
+my ($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+is($frame->{length}, 81, 'removed dependency - first stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid3 } @$frames;
+is($frame->{length}, 81, 'removed dependency - last stream');
+
+# PRIORITY - reprioritization with circular dependency - exclusive [5]
+# 1 <- [5] <- 3
+
+$s = Test::Nginx::HTTP2->new();
+
+$s->h2_window(2**18);
+
+$s->h2_priority(16, 1, 0);
+$s->h2_priority(16, 3, 1);
+$s->h2_priority(16, 5, 1, excl => 1);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid2, length => 2**16 - 1 }]);
+
+$sid3 = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid3, length => 2**16 - 1 }]);
+
+$s->h2_window(2**16, $sid);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+$sids = join ' ', map { $_->{sid} } grep { $_->{type} eq "DATA" } @$frames;
+is($sids, $sid, 'exclusive dependency - parent removed');
+
+# make circular dependency
+# 5 <- 3 -- current dependency tree before reprioritization
+# 3 <- 5
+
+$s->h2_priority(16, 5, 3);
+
+$s->h2_window(2**16, $sid2);
+$s->h2_window(2**16, $sid3);
+
+$frames = $s->read(all => [
+    { sid => $sid2, fin => 1 },
+    { sid => $sid3, fin => 1 },
+]);
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid2 } @$frames;
+is($frame->{length}, 81, 'exclusive dependency - first stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == $sid3 } @$frames;
+is($frame->{length}, 81, 'exclusive dependency - last stream');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_cache.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_cache.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_cache.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_cache.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,167 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy cache/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache    keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /cache {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+        }
+
+        location /proxy_buffering_off {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache NAME;
+            proxy_cache_valid 1m;
+            proxy_buffering off;
+        }
+
+        location / { }
+
+        location /slow {
+            limit_rate 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('slow.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# simple proxy cache test
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/cache/t.html' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'proxy cache');
+
+my $etag = $frame->{headers}->{'etag'};
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, length 'SEE-THIS', 'proxy cache - DATA');
+is($frame->{data}, 'SEE-THIS', 'proxy cache - DATA payload');
+
+$t->write_file('t.html', 'NOOP');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/cache/t.html' },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'if-none-match', value => $etag }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 304, 'proxy cache conditional');
+
+$t->write_file('t.html', 'SEE-THIS');
+
+# request body with cached response
+
+$sid = $s->new_stream({ path => '/cache/t.html', body_more => 1 });
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'proxy cache - request body');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'proxy cache - request body - next');
+
+# HEADERS could be received with fin, followed by DATA
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/t.html?1', method => 'HEAD' });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }], wait => 0.2);
+push @$frames, $_ for @{$s->read(all => [{ sid => $sid }], wait => 0.2)};
+ok(!grep ({ $_->{type} eq "DATA" } @$frames), 'proxy cache HEAD - no body');
+
+# HEAD on empty cache with proxy_buffering off
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream(
+    { path => '/proxy_buffering_off/t.html?1', method => 'HEAD' });
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+push @$frames, $_ for @{$s->read(all => [{ sid => $sid }], wait => 0.2)};
+ok(!grep ({ $_->{type} eq "DATA" } @$frames),
+    'proxy cache HEAD buffering off - no body');
+
+SKIP: {
+skip 'win32', 1 if $^O eq 'MSWin32';
+
+# client cancels stream with a cacheable request that was sent to upstream
+# HEADERS should not be produced for the canceled stream
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/slow.html' });
+
+$s->h2_rst($sid, 8);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }], wait => 1.2);
+ok(!(grep { $_->{type} eq "HEADERS" } @$frames), 'no headers');
+
+}
+
+# client closes connection after sending a cacheable request producing alert
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/cache/t.html?4' });
+
+undef $s;
+select undef, undef, undef, 0.2;
+
+$t->stop();
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_protocol.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_protocol.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,81 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with proxy_protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 realip/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol http2;
+        server_name  localhost;
+
+        location /pp {
+            set_real_ip_from 127.0.0.1/32;
+            real_ip_header proxy_protocol;
+            alias %%TESTDIR%%/t.html;
+            add_header X-PP $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $proxy = 'PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+my $s = Test::Nginx::HTTP2->new(port(8080), proxy => $proxy);
+my $sid = $s->new_stream({ path => '/pp' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'PROXY HEADERS frame');
+is($frame->{headers}->{'x-pp'}, '192.0.2.1', 'PROXY remote addr');
+
+# invalid PROXY protocol string
+
+$proxy = 'BOGUS TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+$s = Test::Nginx::HTTP2->new(port(8080), preface => $proxy, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid PROXY - GOAWAY frame');
+is($frame->{code}, 1, 'invalid PROXY - error code');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering_redirect.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering_redirect.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering_redirect.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering_redirect.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/bad;
+            proxy_intercept_errors on;
+            error_page 502 = /pass;
+        }
+
+        location /bad {
+            return 502;
+        }
+
+        location /pass {
+            proxy_pass http://127.0.0.1:8081/good;
+        }
+
+        location /good {
+            limit_rate 100;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+# unbuffered request body
+
+SKIP: {
+skip 'leaves coredump', 1 unless $t->has_version('1.17.4')
+    or $ENV{TEST_NGINX_UNSAFE};
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$t->todo_alerts() unless $t->has_version('1.17.4');
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ body_more => 1 });
+
+$s->h2_body('SEE-', { body_more => 1 });
+sleep 1;
+$s->h2_body('THIS');
+
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'discard body rest on redirect');
+
+}
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering_ssl.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering_ssl.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,288 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass https://127.0.0.1:8082;
+            client_body_buffer_size 512;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass https://127.0.0.1:8082;
+            client_body_buffer_size 512;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+$t->plan(40);
+
+###############################################################################
+
+# unbuffered request body
+
+my $f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128, 'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128, 'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128, 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+    '56789many', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}('', wait => 0.2), '', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789', 'split');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body, chunked transfer-encoding
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunk');
+is($f->{upload}('01234', body_more => 1), '5' . CRLF . '01234' . CRLF,
+    'chunked - part');
+is($f->{upload}('56789'), '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+    'chunked - part 2');
+is($f->{http_end}(), 200, 'chunked - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked buffer');
+is($f->{upload}('0123' x 64, body_more => 1),
+    '100' . CRLF . '0123' x 64 . CRLF, 'chunked buffer - below');
+is($f->{upload}('4567' x 64, body_more => 1),
+    '100' . CRLF . '4567' x 64 . CRLF, 'chunked buffer - equal');
+is($f->{upload}('89AB' x 64),
+    '100' . CRLF . '89AB' x 64 . CRLF . '0' . CRLF . CRLF,
+    'chunked buffer - above');
+is($f->{http_end}(), 200, 'chunked buffer - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '9' . CRLF . '01234many' . CRLF, 'chunked many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+    '9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF,
+    'chunked many - part 2');
+is($f->{http_end}(), 200, 'chunked many - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'chunked empty - part');
+is($f->{upload}(''), '0' . CRLF . CRLF, 'chunked empty - part 2');
+is($f->{http_end}(), 200, 'chunked empty - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked split');
+is(http_content($f->{upload}('0123456789', split => [ 14 ])),
+    '0123456789', 'chunked split');
+is($f->{http_end}(), 200, 'chunked split - response');
+
+###############################################################################
+
+sub http_content {
+    my ($body) = @_;
+    my $content = '';
+
+    while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+        my $len = hex($1);
+        $content .= substr($body, pos($body), $len);
+        pos($body) += $len;
+    }
+
+    return $content;
+}
+
+sub get_body {
+    my ($url, %extra) = @_;
+    my ($server, $client, $f);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Timeout => 3,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $s = Test::Nginx::HTTP2->new();
+    my $sid = exists $extra{'content-length'}
+        ? $s->new_stream({ headers => [
+            { name => ':method', value => 'GET' },
+            { name => ':scheme', value => 'http' },
+            { name => ':path', value => $url, },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-length',
+                value => $extra{'content-length'} }],
+            body_more => 1 })
+        : $s->new_stream({ path => $url, body_more => 1 });
+
+    $client = $server->accept() or return;
+
+    log2c("(new connection $client)");
+
+    $f->{headers} = backend_read($client);
+
+    my $chunked = $f->{headers} =~ /chunked/;
+
+    $f->{upload} = sub {
+        my ($body, %extra) = @_;
+        my $len = length($body);
+        my $wait = $extra{wait};
+
+        $s->h2_body($body, { %extra });
+
+        $body = '';
+
+        for (1 .. 10) {
+            my $buf = backend_read($client, $wait) or return '';
+            $body .= $buf;
+
+            my $got = 0;
+            $got += $chunked ? hex $_ : $_ for $chunked
+                ? $body =~ /(\w+)\x0d\x0a?\w+\x0d\x0a?/g
+                : length($body);
+            next if $chunked && !$extra{body_more}
+                && $buf !~ /^0\x0d\x0a?/m;
+            last if $got >= $len;
+        }
+
+        return $body;
+    };
+    $f->{http_end} = sub {
+        $client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+        $client->close;
+
+        my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        return $frame->{headers}->{':status'};
+    };
+    return $f;
+}
+
+sub backend_read {
+    my ($s, $timo) = @_;
+    my $buf = '';
+
+    if (IO::Select->new($s)->can_read($timo || 8)) {
+        $s->sysread($buf, 16384) or return;
+        log2i($buf);
+    }
+    return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_request_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_request_buffering.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,282 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            proxy_request_buffering off;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /chunked {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8081/;
+            client_body_buffer_size 1k;
+        }
+        location /abort {
+            proxy_request_buffering off;
+            proxy_http_version 1.1;
+            proxy_pass http://127.0.0.1:8082/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(49);
+
+###############################################################################
+
+# unbuffered request body
+
+my $f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'request');
+is($f->{upload}('01234', body_more => 1), '01234', 'part');
+is($f->{upload}('56789'), '56789', 'part 2');
+is($f->{http_end}(), 200, 'response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'much');
+is($f->{upload}('0123456789', body_more => 1), '0123456789', 'much - part');
+is($f->{upload}('many'), '', 'much - part 2');
+is($f->{http_end}(), 400, 'much - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'less');
+is($f->{upload}('0123', body_more => 1), '0123', 'less - part');
+is($f->{upload}('56789'), '', 'less - part 2');
+is($f->{http_end}(), 400, 'less - response');
+
+$f = get_body('/', 'content-length' => 18);
+ok($f->{headers}, 'many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '01234many', 'many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+    '56789many', 'many - part 2');
+is($f->{http_end}(), 200, 'many - response');
+
+$f = get_body('/', 'content-length' => 0);
+ok($f->{headers}, 'empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'empty - part');
+is($f->{upload}('', wait => 0.2), '', 'empty - part 2');
+is($f->{http_end}(), 200, 'empty - response');
+
+$f = get_body('/', 'content-length' => 1536);
+ok($f->{headers}, 'buffer');
+is($f->{upload}('0123' x 128, body_more => 1), '0123' x 128,
+    'buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1), '4567' x 128,
+    'buffer - equal');
+is($f->{upload}('89AB' x 128), '89AB' x 128, 'buffer - above');
+is($f->{http_end}(), 200, 'buffer - response');
+
+$f = get_body('/', 'content-length' => 10);
+ok($f->{headers}, 'split');
+is($f->{upload}('0123456789', split => [ 14 ]), '0123456789', 'split');
+is($f->{http_end}(), 200, 'split - response');
+
+# unbuffered request body, chunked transfer-encoding
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked');
+is($f->{upload}('01234', body_more => 1), '5' . CRLF . '01234' . CRLF,
+    'chunked - part');
+is($f->{upload}('56789'), '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+    'chunked - part 2');
+is($f->{http_end}(), 200, 'chunked - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked buffer');
+is($f->{upload}('0123' x 128, body_more => 1),
+    '200' . CRLF . '0123' x 128 . CRLF, 'chunked buffer - below');
+is($f->{upload}('4567' x 128, body_more => 1),
+    '200' . CRLF . '4567' x 128 . CRLF, 'chunked buffer - equal');
+is($f->{upload}('89AB' x 128),
+    '200' . CRLF . '89AB' x 128 . CRLF . '0' . CRLF . CRLF,
+    'chunked buffer - above');
+is($f->{http_end}(), 200, 'chunked buffer - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked many');
+is($f->{upload}('01234many', body_split => [ 5 ], body_more => 1),
+    '9' . CRLF . '01234many' . CRLF, 'chunked many - part');
+is($f->{upload}('56789many', body_split => [ 5 ]),
+    '9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF,
+    'chunked many - part 2');
+is($f->{http_end}(), 200, 'chunked many - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked empty');
+is($f->{upload}('', body_more => 1, wait => 0.2), '', 'chunked empty - part');
+is($f->{upload}(''), '0' . CRLF . CRLF, 'chunked empty - part 2');
+is($f->{http_end}(), 200, 'chunked empty - response');
+
+$f = get_body('/chunked');
+ok($f->{headers}, 'chunked split');
+is(http_content($f->{upload}('0123456789', split => [ 14 ])),
+    '0123456789', 'chunked split');
+is($f->{http_end}(), 200, 'chunked split - response');
+
+# unbuffered request body, chunked transfer-encoding
+# client sends partial DATA frame and closes connection
+
+my $s = Test::Nginx::HTTP2->new();
+my $s2 = Test::Nginx::HTTP2->new();
+
+$s->new_stream({ path => '/abort', body_more => 1 });
+$s->h2_body('TEST', { split => [ 9 ], abort => 1 });
+
+close $s->{socket};
+
+$s2->h2_ping('PING');
+isnt(@{$s2->read()}, 0, 'chunked abort');
+
+###############################################################################
+
+sub http_content {
+    my ($body) = @_;
+    my $content = '';
+
+    while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+        my $len = hex($1);
+        $content .= substr($body, pos($body), $len);
+        pos($body) += $len;
+    }
+
+    return $content;
+}
+
+sub get_body {
+    my ($url, %extra) = @_;
+    my ($server, $client, $f);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Timeout => 3,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $s = Test::Nginx::HTTP2->new();
+    my $sid = exists $extra{'content-length'}
+        ? $s->new_stream({ headers => [
+            { name => ':method', value => 'GET' },
+            { name => ':scheme', value => 'http' },
+            { name => ':path', value => $url, },
+            { name => ':authority', value => 'localhost' },
+            { name => 'content-length',
+                value => $extra{'content-length'} }],
+            body_more => 1 })
+        : $s->new_stream({ path => $url, body_more => 1 });
+
+    $client = $server->accept() or return;
+
+    log2c("(new connection $client)");
+
+    $f->{headers} = backend_read($client);
+
+    my $chunked = $f->{headers} =~ /chunked/;
+
+    $f->{upload} = sub {
+        my ($body, %extra) = @_;
+        my $len = length($body);
+        my $wait = $extra{wait};
+
+        $s->h2_body($body, { %extra });
+
+        $body = '';
+
+        for (1 .. 10) {
+            my $buf = backend_read($client, $wait) or return '';
+            $body .= $buf;
+
+            my $got = 0;
+            $got += $chunked ? hex $_ : $_ for $chunked
+                ? $body =~ /(\w+)\x0d\x0a?\w+\x0d\x0a?/g
+                : length($body);
+            next if $chunked && !$extra{body_more}
+                && $buf !~ /^0\x0d\x0a?/m;
+            last if $got >= $len;
+        }
+
+        return $body;
+    };
+    $f->{http_end} = sub {
+        $client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+        $client->close;
+
+        my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+        my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+        return $frame->{headers}->{':status'};
+    };
+    return $f;
+}
+
+sub backend_read {
+    my ($s, $timo) = @_;
+    my $buf = '';
+
+    if (IO::Select->new($s)->can_read($timo || 8)) {
+        $s->sysread($buf, 16384) or return;
+        log2i($buf);
+    }
+    return $buf;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_proxy_ssl.t ../asynch_mode_nginx/test/nginx-tests/h2_proxy_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/h2_proxy_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_proxy_ssl.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy/)
+    ->has_daemon('openssl')->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / { }
+        location /proxy_ssl/ {
+            proxy_pass https://127.0.0.1:8081/;
+            %%PROXY_ASYNCH_ENABLE%%
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+# request body with an empty DATA frame proxied to ssl backend
+# "zero size buf in output" alerts seen
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy_ssl/', body_more => 1 });
+$s->h2_body('');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'empty request body');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_request_body_js.t ../asynch_mode_nginx/test/nginx-tests/h2_request_body_js.t
--- nginx-release-1.20.1/test/nginx-tests/h2_request_body_js.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_request_body_js.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,91 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 request body with njs subrequest in the body handler.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        lingering_close off;
+
+        location / {
+            js_content sr_body;
+            add_header X-Body $request_body;
+        }
+
+        location /sr { }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+function body_fwd_cb(r) {
+    r.parent.return(r.status, r.responseBody);
+}
+
+function sr_body(r) {
+    r.subrequest('/sr', body_fwd_cb);
+}
+
+EOF
+
+$t->write_file('sr', 'SEE-THIS');
+$t->try_run('no njs available')->plan(3);
+
+###############################################################################
+
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+$t->todo_alerts() unless $t->has_version('1.19.3');
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ body => 'TEST' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'status');
+is($frame->{headers}->{'x-body'}, 'TEST', 'request body');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'SEE-THIS', 'response body');
+
+$t->stop();
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_request_body_preread.t ../asynch_mode_nginx/test/nginx-tests/h2_request_body_preread.t
--- nginx-release-1.20.1/test/nginx-tests/h2_request_body_preread.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_request_body_preread.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,200 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with preread request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=20r/m;
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        http2_body_preread_size 10;
+
+        location /t { }
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+
+            location /req {
+                limit_req  zone=req burst=2;
+                proxy_pass http://127.0.0.1:8081/t;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+
+        http2_body_preread_size 0;
+
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+
+            location /req {
+                limit_req  zone=req burst=2;
+                proxy_pass http://127.0.0.1:8081/t;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8083 http2;
+        server_name  localhost;
+
+        location / {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8081/t;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+$t->run()->plan(9);
+
+###############################################################################
+
+# request body within preread size (that is, stream window)
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ body => 'TEST' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'within preread');
+
+# request body beyond preread size
+# RST_STREAM expected due stream window violation
+
+TODO: {
+local $TODO = 'not yet';
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body => 'TEST' x 10 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'beyond preread - FLOW_CONTROL_ERROR');
+
+}
+
+# within preread size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/req' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ path => '/req', body => 'TEST' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'within preread limited');
+
+# processing request body without END_STREAM in preread
+
+$sid = $s->new_stream({ path => '/req', body_more => 1, continuation => 1 });
+$s->h2_continue($sid,
+    { headers => [{ name => 'content-length', value => '8' }]});
+
+$s->h2_body('SEE', { body_more => 1 });
+$s->read(all => [{ type => 'WINDOW_UPDATE' }]);
+
+$s->h2_body('-THIS');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'SEE-THIS', 'within preread limited - more');
+
+# beyond preread size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/req', body => 'TEST' x 10 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'beyond preread limited - FLOW_CONTROL_ERROR');
+
+
+# zero preread size
+
+TODO: {
+local $TODO = 'not yet';
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'zero preread - FLOW_CONTROL_ERROR');
+
+}
+
+# zero preread size - limited
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ path => '/req', body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 3, 'zero preread limited - FLOW_CONTROL_ERROR');
+
+
+# REFUSED_STREAM on request body prior SETTINGS acknowledgement
+
+$s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 7, 'no SETTINGS ack - REFUSED_STREAM');
+
+# default preread size - no REFUSED_STREAM expected
+
+$s = Test::Nginx::HTTP2->new(port(8083), pure => 1);
+$sid = $s->new_stream({ body => 'TEST' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body'}, 'TEST', 'no SETTINGS ack - default preread');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_request_body.t ../asynch_mode_nginx/test/nginx-tests/h2_request_body.t
--- nginx-release-1.20.1/test/nginx-tests/h2_request_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_request_body.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,494 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/)->plan(45);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        error_page 400 /proxy2/t.html;
+
+        location / {
+            add_header X-Length $http_content_length;
+        }
+        location /slow {
+            limit_rate 100;
+        }
+        location /off/ {
+            proxy_pass http://127.0.0.1:8081/;
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+        }
+        location /proxy2/ {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+        location /client_max_body_size {
+            add_header X-Body $request_body;
+            add_header X-Body-File $request_body_file;
+            client_body_in_single_buffer on;
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8081/;
+            client_max_body_size 10;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('slow.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# request body (uses proxied response)
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST');
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST', 'request body');
+is($frame->{headers}->{'x-length'}, 4, 'request body - content length');
+
+# request body with padding (uses proxied response)
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+    'request body with padding');
+is($frame->{headers}->{'x-length'}, 4,
+    'request body with padding - content length');
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, '200', 'request body with padding - next');
+
+# request body sent in multiple DATA frames in a single packet
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TEST',
+    'request body in multiple frames');
+is($frame->{headers}->{'x-length'}, 4,
+    'request body in multiple frames - content length');
+
+# request body sent in multiple DATA frames, each in its own packet
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/t.html', body_more => 1 });
+$s->h2_body('TEST', { body_more => 1 });
+select undef, undef, undef, 0.1;
+$s->h2_body('MOREDATA');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTMOREDATA',
+    'request body in multiple frames separately');
+is($frame->{headers}->{'x-length'}, 12,
+    'request body in multiple frames separately - content length');
+
+# request body with an empty DATA frame
+# "zero size buf in output" alerts seen
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/', body_more => 1 });
+$s->h2_body('');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request body - empty');
+is($frame->{headers}->{'x-length'}, 0, 'request body - empty size');
+ok($frame->{headers}{'x-body-file'}, 'request body - empty body file');
+is(read_body_file($frame->{headers}{'x-body-file'}), '',
+    'request body - empty content');
+
+# it is expected to avoid adding Content-Length for requests without body
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/proxy2/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'request without body');
+is($frame->{headers}->{'x-length'}, undef,
+    'request without body - content length');
+
+# request body discarded
+# RST_STREAM with zero code received
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+is($frame->{code}, 0, 'request body discarded - zero RST_STREAM');
+
+}
+
+# malformed request body length not equal to content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/client_max_body_size', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'content-length', value => '5', mode => 1 }]});
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'request body less than content-length');
+
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/client_max_body_size', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'content-length', value => '3', mode => 1 }]});
+$s->h2_body('TEST');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'request body more than content-length');
+
+# client_max_body_size
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST12');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'client_max_body_size - body');
+
+# client_max_body_size - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST123');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size - limited');
+
+# client_max_body_size - many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST12', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size many - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'client_max_body_size many - body');
+
+# client_max_body_size - many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST123', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size many - limited');
+
+# client_max_body_size - padded DATA
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST12', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'client_max_body_size pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'client_max_body_size pad - body');
+
+# client_max_body_size - padded DATA - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST123', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413, 'client_max_body_size pad - limited');
+
+# client_max_body_size - many padded DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST12', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'client_max_body_size many pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'client_max_body_size many pad - body');
+
+# client_max_body_size - many padded DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/client_max_body_size/t.html',
+    body_more => 1 });
+$s->h2_body('TESTTEST123', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+    'client_max_body_size many pad - limited');
+
+# request body without content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'request body without content-length - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'request body without content-length - body');
+
+# request body without content-length - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123');
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+    'request body without content-length - limited');
+
+# request body without content-length - many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'request body without content-length many - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'request body without content-length many - body');
+
+# request body without content-length - many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+    'request body without content-length many - limited');
+
+# request body without content-length - padding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST12', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'request body without content-length pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST12',
+    'request body without content-length pad - body');
+
+# request body without content-length - padding - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_padding => 42 });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+    'request body without content-length pad - limited');
+
+# request body without content-length - padding with many DATA frames
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'request body without content-length many pad - status');
+is(read_body_file($frame->{headers}->{'x-body-file'}), 'TESTTEST',
+    'request body without content-length many pad - body');
+
+# request body without content-length - padding with many DATA frames - limited
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body_more => 1, headers => [
+    { name => ':method', value => 'GET', mode => 2 },
+    { name => ':scheme', value => 'http', mode => 2 },
+    { name => ':path', value => '/client_max_body_size', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$s->h2_body('TESTTEST123', { body_padding => 42, body_split => [2] });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 413,
+    'request body without content-length many pad - limited');
+
+# absent request body is not buffered with client_body_in_file_only off
+# see e02f1977846b for details
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/off/t.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-body-file'}, undef, 'no request body in file');
+
+# ticket #1384, request body corruption in recv_buffer
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/off/slow.html', body_more => 1 });
+select undef, undef, undef, 0.1;
+
+# for simplicity, DATA frame is received on its own for a known offset
+
+$s->h2_body('TEST');
+select undef, undef, undef, 0.1;
+
+# overwrite recv_buffer; since upstream response arrival is delayed,
+# this would make $request_body point to the overridden buffer space
+
+$s->h2_ping('xxxx');
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+isnt($frame->{headers}->{'x-body'}, 'xxxx', 'sync buffer');
+
+# request body after 400 errors redirected to a proxied location
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->has_version('1.19.3');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ body => "", headers => [
+    { name => ':method', value => "" }]});
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq 'DATA' } @$frames;
+is($frame->{data}, 'SEE-THIS', 'request body after 400 redirect');
+
+}
+
+###############################################################################
+
+sub read_body_file {
+    my ($path) = @_;
+    open FILE, $path or return "$!";
+    local $/;
+    my $content = <FILE>;
+    close FILE;
+    return $content;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_server_push.t ../asynch_mode_nginx/test/nginx-tests/h2_server_push.t
--- nginx-release-1.20.1/test/nginx-tests/h2_server_push.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_server_push.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,447 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 server push.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite gzip/)->plan(42)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /prio {
+            http2_push /t1;
+            http2_push /t2;
+            return 204;
+        }
+
+        location /expl {
+            http2_push /push;
+            http2_push /push2;
+
+            location /expl/off {
+                http2_push off;
+            }
+        }
+
+        location /preload {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";
+            add_header X-Link $sent_http_link;
+            return 200 SEE-THIS;
+        }
+
+        location /preload2 {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";           # valid
+            add_header Link "</push2 >; rel=preload";         # valid
+            add_header Link "</push3>; rel=preloadX";         # not
+            add_header Link '</push4>; rel="preload"';        # valid
+            add_header Link '</push5>; rel="preloadX"';       # not
+            add_header Link "</push6>; rel=preload; nopush";  # not
+            add_header Link '</push7>; rel="foo"';            # not
+            add_header Link '</push7>; rel="foo preload"';    # valid
+            return 200 SEE-THIS;
+        }
+
+        location /preload/many {
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload, </push2>; rel=preload";
+            add_header Link "</push3>, </push4>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /preload/proxy {
+            http2_push_preload on;
+            proxy_pass http://127.0.0.1:8081/proxied;
+        }
+
+        location /proxied {
+            add_header Link "</push>; rel=preload";
+            add_header Link "</push2>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /both {
+            http2_push /push;
+            http2_push_preload on;
+            add_header Link "</push>; rel=preload";
+            return 200 SEE-THIS;
+        }
+
+        location /arg {
+            http2_push $arg_push;
+            return 204;
+        }
+
+        location /push {
+            return 200 PROMISED;
+        }
+
+        location /gzip.html {
+            gzip on;
+            gzip_min_length 0;
+            return 200 PROMISED;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  max_pushes;
+
+        http2_max_concurrent_pushes 2;
+        http2_push /push;
+        http2_push /push;
+        http2_push /push;
+    }
+}
+
+EOF
+
+$t->write_file('t1', join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+$t->write_file('t2', 'SEE-THIS');
+$t->write_file('explf', join('', map { sprintf "X%06dXXX", $_ } (1 .. 6553)));
+
+$t->run();
+
+###############################################################################
+
+# 6.6.  PUSH_PROMISE
+#   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
+#   is in either the "open" or "half-closed (remote)" state.
+
+# preload & format
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/preload' });
+my $frames = $s->read(all => [{ sid => 1, fin => 1 }, { sid => 2, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'push promise');
+is($frame->{headers}->{':authority'}, 'localhost', 'authority');
+is($frame->{headers}->{':scheme'}, 'http', 'scheme');
+is($frame->{headers}->{':method'}, 'GET', 'method');
+is($frame->{headers}->{':path'}, '/push', 'path');
+is($frame->{flags}, 4, 'flags');
+is($frame->{promised}, 2, 'promised stream');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} eq 2 } @$frames;
+is($frame->{data}, 'PROMISED', 'promised stream payload');
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} eq $sid } @$frames;
+is($frame->{headers}->{'x-link'}, '</push>; rel=preload', 'sent_http_link');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 4, 'preload 2');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload/many' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 3, 'preload many');
+
+# preload proxy
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/preload/proxy' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'preload proxy');
+
+# both h2_push & preload
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/both' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'h2_push and preload');
+
+# h2_push
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'h2_push only');
+
+# h2_push off
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl/off' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push off');
+
+# h2_push $var
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/arg?push=/push' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'h2_push variable');
+
+$sid = $s->new_stream({ path => '/arg?push=' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable empty');
+
+$sid = $s->new_stream({ path => '/arg?push=off' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable off');
+
+$sid = $s->new_stream({ path => '/arg?push=foo' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'h2_push variable relative path');
+
+# SETTINGS_ENABLE_PUSH
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x2 => 0);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok(!$frame, 'push setting disabled');
+
+$s->h2_settings(0, 0x2 => 1);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" } @$frames;
+ok($frame, 'push setting enabled');
+
+$s->h2_settings(0, 0x2 => 42);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} =~ "GOAWAY" } @$frames;
+is($frame->{'code'}, 1, 'push setting invalid - GOAWAY protocol error');
+cmp_ok($frame->{'last_sid'}, '<', 5, 'push setting invalid - last sid');
+
+# SETTINGS_MAX_CONCURRENT_STREAMS
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'max pushes default');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x3 => 1);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 1, 'max pushes limited');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x3 => 0);
+$sid = $s->new_stream({ path => '/expl' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 0, 'max pushes disabled');
+
+TODO: {
+todo_skip 'long tests with aio', 6 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->read_file('nginx.conf') !~ /aio (on|threads)/;
+local $TODO = 'not yet' if $t->read_file('nginx.conf') =~ /aio (on|threads)/;
+
+# server push flow control & rst
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/explf' });
+$frames = $s->read(all => [
+    { sid => 1, fin => 1 },
+    { sid => 2, length => 5 },
+    { sid => 4, fin => 4 }]);
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 5, 'flow control - pushed stream limited');
+is($frame->{flags}, 0, 'flow control - pushed stream flags');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 4 } @$frames;
+ok(!$frame, 'flow control - no window for next stream');
+
+# window update
+
+$s->h2_window(2);
+
+$frames = $s->read(all => [{ length => 2 }]);
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 2, 'window update');
+
+# client refused stream
+
+$s->h2_rst(4, 7);
+$s->h2_window(2**16);
+
+$frames = $s->read(all => [{ sid => 2, length => 1 }]);
+push @$frames, @{ $s->read(all => [{ sid => 4, fin => 1 }], wait => 0.2) };
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+is($frame->{length}, 1, 'pushed response flow control');
+is($frame->{flags}, 1, 'pushed response END_STREAM');
+
+}
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 4 } @$frames;
+ok(!$frame, 'rst pushed stream');
+
+TODO: {
+todo_skip 'long tests with aio', 2 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->read_file('nginx.conf') !~ /aio (on|threads)/;
+local $TODO = 'not yet' if $t->read_file('nginx.conf') =~ /aio (on|threads)/;
+
+# priority
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/prio' });
+$frames = $s->read(all => [{ length => 2**16 - 1 }, { sid => 4, fin => 4 }]);
+
+$s->h2_priority(16, 2, 4);
+
+$s->h2_window(2**17, 2);
+$s->h2_window(2**17, 4);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [{ sid => 2, fin => 1 }, { sid => 4, fin => 1 }]);
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "4 2", 'priority 1');
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/prio' });
+$frames = $s->read(all => [{ length => 2**16 - 1 }, { sid => 4, fin => 4 }]);
+
+$s->h2_priority(16, 4, 2);
+
+$s->h2_window(2**17, 2);
+$s->h2_window(2**17, 4);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [{ sid => 2, fin => 1 }, { sid => 4, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(join(' ', map { $_->{sid} } @data), "2 4", 'priority 2');
+
+}
+
+# http2_max_concurrent_pushes
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'max_pushes', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 2, 'http2 max pushes lim');
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$s->h2_settings(0, 0x3 => 1);
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'max_pushes', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+is(grep({ $_->{type} eq "PUSH_PROMISE" } @$frames), 1, 'http2 max pushes 2');
+
+# missing request header ':authority'
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 400, 'incomplete headers');
+
+# gzip tests
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/arg?push=/gzip.html' },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'accept-encoding', value => 'gzip' }]});
+$frames = $s->read(all => [{ sid => 2, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{'accept-encoding'}, 'gzip', 'gzip - push promise');
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == 2 } @$frames;
+is($frame->{headers}->{'content-encoding'}, 'gzip', 'gzip - headers');
+
+($frame) = grep { $_->{type} eq "DATA" && $_->{sid} == 2 } @$frames;
+gunzip_like($frame->{data}, qr/^PROMISED\Z/, 'gzip - response');
+
+# scheme https
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'https', mode => 0 },
+    { name => ':path', value => '/preload' },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => 2, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "PUSH_PROMISE" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':scheme'}, 'https', 'scheme https');
+
+###############################################################################
+
+sub gunzip_like {
+    my ($in, $re, $name) = @_;
+
+    SKIP: {
+        eval { require IO::Uncompress::Gunzip; };
+        Test::More::skip(
+            "IO::Uncompress::Gunzip not installed", 1) if $@;
+
+        my $out;
+
+        IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+        if ($in =~ $re) {
+            fail($name);
+            return;
+        }
+
+        like($out, $re, $name);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_server_tokens.t ../asynch_mode_nginx/test/nginx-tests/h2_server_tokens.t
--- nginx-release-1.20.1/test/nginx-tests/h2_server_tokens.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_server_tokens.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,140 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with server_tokens directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /200 {
+            return 200;
+        }
+
+        location /404 {
+            return 404;
+        }
+
+        location /off {
+            server_tokens off;
+
+            location /off/200 {
+                return 200;
+            }
+
+            location /off/404 {
+                return 404;
+            }
+        }
+
+        location /on {
+            server_tokens on;
+
+            location /on/200 {
+                return 200;
+            }
+
+            location /on/404 {
+                return 404;
+            }
+        }
+
+        location /b {
+            server_tokens build;
+
+            location /b/200 {
+                return 200;
+            }
+
+            location /b/404 {
+                return 404;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(12);
+
+###############################################################################
+
+my $re = qr/nginx\/\d+\.\d+\.\d+/;
+
+like(header_server('/200'), qr/^$re$/, 'http2 tokens default 200');
+like(header_server('/404'), qr/^$re$/, 'http2 tokens default 404');
+like(body('/404'), qr/$re/, 'http2 tokens default 404 body');
+
+is(header_server('/off/200'), 'nginx', 'http2 tokens off 200');
+is(header_server('/off/404'), 'nginx', 'http2 tokens off 404');
+like(body('/off/404'), qr/nginx(?!\/)/, 'http2 tokens off 404 body');
+
+like(header_server('/on/200'), qr/^$re$/, 'http2 tokens on 200');
+like(header_server('/on/404'), qr/^$re$/, 'http2 tokens on 404');
+like(body('/on/404'), $re, 'http2 tokens on 404 body');
+
+$re = qr/$re \Q($1)\E/ if $t->{_configure_args} =~ /--build=(\S+)/;
+
+like(header_server('/b/200'), qr/^$re$/, 'http2 tokens build 200');
+like(header_server('/b/404'), qr/^$re$/, 'http2 tokens build 404');
+like(body('/b/404'), qr/$re/, 'http2 tokens build 404 body');
+
+###############################################################################
+
+sub header_server {
+    my ($path) = shift;
+
+    my $s = Test::Nginx::HTTP2->new();
+    my $sid = $s->new_stream({ path => $path });
+    my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+    my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+    return $frame->{headers}->{'server'};
+}
+
+sub body {
+    my ($path) = shift;
+
+    my $s = Test::Nginx::HTTP2->new();
+    my $sid = $s->new_stream({ path => $path });
+    my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+    my ($frame) = grep { $_->{type} eq "DATA" } @$frames;
+    return $frame->{'data'};
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_ssl_proxy_cache.t ../asynch_mode_nginx/test/nginx-tests/h2_ssl_proxy_cache.t
--- nginx-release-1.20.1/test/nginx-tests/h2_ssl_proxy_cache.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_ssl_proxy_cache.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,152 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl and http proxy cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 proxy cache/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl sndbuf=32k %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        send_timeout 1s;
+        lingering_close off;
+
+        location / {
+            proxy_pass   http://127.0.0.1:8081;
+            proxy_cache  NAME;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 sndbuf=64k;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('tbig.html',
+    join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+plan(skip_all => 'no ALPN/NPN negotiation') unless defined getconn(port(8080));
+$t->plan(1);
+
+###############################################################################
+
+# client cancels stream with a cacheable request sent to upstream causing alert
+
+my $s = getconn(port(8080));
+ok($s, 'ssl connection');
+
+my $sid = $s->new_stream();
+$s->h2_rst($sid, 8);
+
+# large response may stuck in SSL buffer and won't be sent producing alert
+
+my $s2 = getconn(port(8080));
+$sid = $s2->new_stream({ path => '/tbig.html' });
+$s2->h2_window(2**30, $sid);
+$s2->h2_window(2**30);
+
+select undef, undef, undef, 0.2;
+
+$t->stop();
+
+# "aio_write" is used to produce "open socket ... left in connection" alerts.
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+    and $t->read_file('nginx.conf') =~ /aio threads/ and $^O eq 'linux';
+
+###############################################################################
+
+sub getconn {
+    my ($port) = @_;
+    my $s;
+
+    eval {
+        my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+            alpn => 'h2');
+        $s = Test::Nginx::HTTP2->new($port, socket => $sock)
+            if $sock->alpn_selected();
+    };
+
+    return $s if defined $s;
+
+    eval {
+        my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+            npn => 'h2');
+        $s = Test::Nginx::HTTP2->new($port, socket => $sock)
+            if $sock->next_proto_negotiated();
+    };
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_ssl.t ../asynch_mode_nginx/test/nginx-tests/h2_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/h2_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_ssl.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        lingering_close off;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('tbig.html',
+    join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+plan(skip_all => 'no ALPN/NPN negotiation') unless defined getconn(port(8080));
+$t->plan(1);
+
+###############################################################################
+
+# client cancels 2nd stream after HEADERS has been created
+# while some unsent data was left in the SSL buffer
+# HEADERS frame may stuck in SSL buffer and won't be sent producing alert
+
+my $s = getconn(port(8080));
+ok($s, 'ssl connection');
+
+my $sid = $s->new_stream({ path => '/tbig.html' });
+
+select undef, undef, undef, 0.2;
+$s->h2_rst($sid, 8);
+
+$sid = $s->new_stream({ path => '/tbig.html' });
+
+select undef, undef, undef, 0.2;
+$s->h2_rst($sid, 8);
+
+$t->stop();
+
+###############################################################################
+
+sub getconn {
+    my ($port) = @_;
+    my $s;
+
+    eval {
+        my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+            alpn => 'h2');
+        $s = Test::Nginx::HTTP2->new($port, socket => $sock)
+            if $sock->alpn_selected();
+    };
+
+    return $s if defined $s;
+
+    eval {
+        my $sock = Test::Nginx::HTTP2::new_socket($port, SSL => 1,
+            npn => 'h2');
+        $s = Test::Nginx::HTTP2->new($port, socket => $sock)
+            if $sock->next_proto_negotiated();
+    };
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_ssl_variables.t ../asynch_mode_nginx/test/nginx-tests/h2_ssl_variables.t
--- nginx-release-1.20.1/test/nginx-tests/h2_ssl_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_ssl_variables.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,214 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl http_v2 rewrite/)
+    ->has_daemon('openssl')->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location /h2 {
+            return 200 $http2;
+        }
+        location /sp {
+            return 200 $server_protocol;
+        }
+        location /scheme {
+            return 200 $scheme;
+        }
+        location /https {
+            return 200 $https;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+my $has_npn = eval { Test::Nginx::HTTP2::new_socket(port(8080), SSL => 1,
+    npn => 'h2')->next_proto_negotiated() };
+my $has_alpn = eval { Test::Nginx::HTTP2::new_socket(port(8080), SSL => 1,
+    alpn => 'h2')->alpn_selected() };
+
+# SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/h2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2', 'http variable - npn');
+
+}
+
+# SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/h2' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2', 'http variable - alpn');
+
+}
+
+# $server_protocol - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable - npn');
+
+}
+
+# $server_protocol - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable - alpn');
+
+}
+
+# $scheme - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'https', 'scheme variable - npn');
+
+}
+
+# $scheme - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'https', 'scheme variable - alpn');
+
+}
+
+# $https - SSL/TLS connection, NPN
+
+SKIP: {
+skip 'OpenSSL NPN support required', 1 unless $has_npn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, npn => 'h2');
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'on', 'https variable - npn');
+
+}
+
+# $https - SSL/TLS connection, ALPN
+
+SKIP: {
+skip 'OpenSSL ALPN support required', 1 unless $has_alpn;
+
+$s = Test::Nginx::HTTP2->new(port(8080), SSL => 1, alpn => 'h2');
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'on', 'https variable - alpn');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_ssl_verify_client.t ../asynch_mode_nginx/test/nginx-tests/h2_ssl_verify_client.t
--- nginx-release-1.20.1/test/nginx-tests/h2_ssl_verify_client.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_ssl_verify_client.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,160 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with ssl, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL->can_client_sni() or die; };
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+eval { IO::Socket::SSL->can_alpn() or die; };
+plan(skip_all => 'OpenSSL ALPN support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni http_v2/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    ssl_verify_client optional_no_ca;
+
+    add_header X-Verify $ssl_client_verify;
+
+    server {
+        listen       127.0.0.1:8080 ssl http2;
+        server_name  localhost;
+
+        ssl_client_certificate client.crt;
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl http2;
+        server_name  example.com;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'client') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('t', 'SEE-THIS');
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+my $s = get_ssl_socket();
+plan(skip_all => 'no alpn') unless $s->alpn_selected();
+$t->plan(3);
+
+###############################################################################
+
+is(get('localhost')->{'x-verify'}, 'SUCCESS', 'success');
+like(get('example.com')->{'x-verify'}, qr/FAILED/, 'failed');
+is(get('localhost', 'example.com')->{':status'}, '421', 'misdirected');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($sni) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => port(8080),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_alpn_protocols => [ 'h2' ],
+            SSL_hostname => $sni,
+            SSL_cert_file => "$d/client.crt",
+            SSL_key_file => "$d/client.key",
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+sub get {
+    my ($sni, $host) = @_;
+
+    $host = $sni if !defined $host;
+
+    my $s = get_ssl_socket($sni);
+    my $sess = Test::Nginx::HTTP2->new(port(8080), socket => $s);
+    my $sid = $sess->new_stream({ headers => [
+        { name => ':method', value => 'GET', mode => 0 },
+        { name => ':scheme', value => 'http', mode => 0 },
+        { name => ':path', value => '/t', mode => 1 },
+        { name => ':authority', value => $host, mode => 1 }]});
+    my $frames = $sess->read(all => [{ sid => $sid, fin => 1 }]);
+
+    my ($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+    return $frame->{'headers'};
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2.t ../asynch_mode_nginx/test/nginx-tests/h2.t
--- nginx-release-1.20.1/test/nginx-tests/h2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,1158 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol [RFC7540].
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy rewrite charset gzip/)
+    ->plan(142);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Header X-Foo;
+            add_header X-Sent-Foo $http_x_foo;
+            add_header X-Referer $http_referer;
+            return 200 'body';
+        }
+        location /t {
+        }
+        location /gzip.html {
+            gzip on;
+            %%GZIP_MIN_LENGTH_0%%
+            %%QATZIP_ENABLE%%
+            %%QATZIP_MIN_LENGTH_0%%
+            gzip_vary on;
+            alias %%TESTDIR%%/t2.html;
+        }
+        location /frame_size {
+            http2_chunk_size 64k;
+            alias %%TESTDIR%%;
+            output_buffers 2 1m;
+        }
+        location /chunk_size {
+            http2_chunk_size 1;
+            return 200 'body';
+        }
+        location /redirect {
+            error_page 405 /;
+            return 405;
+        }
+        location /return301 {
+            return 301;
+        }
+        location /return301_absolute {
+            return 301 text;
+        }
+        location /return301_relative {
+            return 301 /;
+        }
+        location /charset {
+            charset utf-8;
+            return 200;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost;
+        return 200   first;
+    }
+
+    server {
+        listen       127.0.0.1:8082 http2;
+        server_name  localhost2;
+        return 200   second;
+    }
+
+    server {
+        listen       127.0.0.1:8083 http2;
+        server_name  localhost;
+
+        http2_max_concurrent_streams 1;
+    }
+
+    server {
+        listen       127.0.0.1:8086 http2;
+        server_name  localhost;
+
+        send_timeout 1s;
+        lingering_close off;
+    }
+
+    server {
+        listen       127.0.0.1:8087 http2;
+        server_name  localhost;
+
+        client_header_timeout 1s;
+        client_body_timeout 1s;
+        lingering_close off;
+
+        location / { }
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+# file size is slightly beyond initial window size: 2**16 + 80 bytes
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%04dXXX", $_ } (1 .. 8202)));
+$t->write_file('tbig.html',
+    join('', map { sprintf "XX%06dXX", $_ } (1 .. 500000)));
+
+$t->write_file('t2.html', 'SEE-THIS');
+
+###############################################################################
+
+# SETTINGS
+
+my $s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+my $frames = $s->read(all => [
+    { type => 'WINDOW_UPDATE' },
+    { type => 'SETTINGS'}
+]);
+
+my ($frame) = grep { $_->{type} eq 'WINDOW_UPDATE' } @$frames;
+ok($frame, 'WINDOW_UPDATE frame');
+is($frame->{flags}, 0, 'WINDOW_UPDATE zero flags');
+is($frame->{sid}, 0, 'WINDOW_UPDATE zero sid');
+is($frame->{length}, 4, 'WINDOW_UPDATE fixed length');
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'SETTINGS frame');
+is($frame->{flags}, 0, 'SETTINGS flags');
+is($frame->{sid}, 0, 'SETTINGS stream');
+
+$s->h2_settings(1);
+$s->h2_settings(0);
+
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'SETTINGS frame ack');
+is($frame->{flags}, 1, 'SETTINGS flags ack');
+
+# SETTINGS - no ack on PROTOCOL_ERROR
+
+$s = Test::Nginx::HTTP2->new(port(8080), pure => 1);
+$frames = $s->read(all => [
+    { type => 'WINDOW_UPDATE' },
+    { type => 'SETTINGS'}
+]);
+
+$s->h2_settings(1);
+$s->h2_settings(0, 0x5 => 42);
+
+$frames = $s->read(all => [
+    { type => 'SETTINGS'},
+    { type => 'GOAWAY' }
+]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+is($frame, undef, 'SETTINGS PROTOCOL_ERROR - no ack');
+
+($frame) = grep { $_->{type} eq 'GOAWAY' } @$frames;
+ok($frame, 'SETTINGS PROTOCOL_ERROR - GOAWAY');
+
+# PING
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" } @$frames;
+ok($frame, 'PING frame');
+is($frame->{value}, 'SEE-THIS', 'PING payload');
+is($frame->{flags}, 1, 'PING flags ack');
+is($frame->{sid}, 0, 'PING stream');
+
+# GOAWAY
+
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5);
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, 'foobar');
+Test::Nginx::HTTP2->new()->h2_goaway(0, 0, 5, 'foobar', split => [ 8, 8, 4 ]);
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(0, 0, 5);
+$s->h2_goaway(0, 0, 5);
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(0, 0, 5, 'foobar', len => 0);
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY invalid length - GOAWAY frame');
+is($frame->{code}, 6, 'GOAWAY invalid length - GOAWAY FRAME_SIZE_ERROR');
+
+# 6.8.  GOAWAY
+#   An endpoint MUST treat a GOAWAY frame with a stream identifier other
+#   than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_goaway(1, 0, 5, 'foobar');
+$frames = $s->read(all => [{ type => "GOAWAY" }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY invalid stream - GOAWAY frame');
+is($frame->{code}, 1, 'GOAWAY invalid stream - GOAWAY PROTOCOL_ERROR');
+
+}
+
+# client-initiated PUSH_PROMISE, just to ensure nothing went wrong
+# N.B. other implementation returns zero code, which is not anyhow regulated
+
+$s = Test::Nginx::HTTP2->new();
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C2xN", 4, 0x5, 1));
+}
+$frames = $s->read(all => [{ type => "GOAWAY" }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'client-initiated PUSH_PROMISE - GOAWAY frame');
+is($frame->{code}, 1, 'client-initiated PUSH_PROMISE - GOAWAY PROTOCOL_ERROR');
+
+# GET
+
+$s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame, 'HEADERS frame');
+is($frame->{sid}, $sid, 'HEADERS stream');
+is($frame->{headers}->{':status'}, 200, 'HEADERS status');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEADERS header');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'DATA frame');
+is($frame->{length}, length 'body', 'DATA length');
+is($frame->{data}, 'body', 'DATA payload');
+
+# GET in the new stream on same connection
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'HEADERS stream 2');
+is($frame->{headers}->{':status'}, 200, 'HEADERS status 2');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEADERS header 2');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'DATA frame 2');
+is($frame->{sid}, $sid, 'HEADERS stream 2');
+is($frame->{length}, length 'body', 'DATA length 2');
+is($frame->{data}, 'body', 'DATA payload 2');
+
+# HEAD
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ method => 'HEAD' });
+$frames = $s->read(all => [{ sid => $sid, fin => 0x4 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{sid}, $sid, 'HEAD - HEADERS');
+is($frame->{headers}->{':status'}, 200, 'HEAD - HEADERS status');
+is($frame->{headers}->{'x-header'}, 'X-Foo', 'HEAD - HEADERS header');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame, undef, 'HEAD - no body');
+
+# range filter
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/t1.html', mode => 1 },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'range', value => 'bytes=10-19', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 206, 'range - HEADERS status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{length}, 10, 'range - DATA length');
+is($frame->{data}, '002XXXX000', 'range - DATA payload');
+
+# http2_chunk_size=1
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/chunk_size' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my @data = grep { $_->{type} eq "DATA" } @$frames;
+is(@data, 4, 'chunk_size frames');
+is(join(' ', map { $_->{data} } @data), 'b o d y', 'chunk_size data');
+is(join(' ', map { $_->{flags} } @data), '0 0 0 1', 'chunk_size flags');
+
+# CONTINUATION
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => 1, headers => [
+    { name => ':method', value => 'HEAD', mode => 1 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$s->h2_continue($sid, { continuation => 1, headers => [
+    { name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$s->h2_continue($sid, { headers => [
+    { name => 'referer', value => 'foo', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame, undef, 'CONTINUATION - fragment 1');
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'x-sent-foo'}, 'X-Bar', 'CONTINUATION - fragment 2');
+is($frame->{headers}->{'x-referer'}, 'foo', 'CONTINUATION - fragment 3');
+
+# CONTINUATION - in the middle of request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => [ 2, 4, 1, 5 ], headers => [
+    { name => ':method', value => 'HEAD', mode => 1 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'CONTINUATION - in header field');
+
+# CONTINUATION on a closed stream
+
+$s->h2_continue(1, { headers => [
+    { name => 'x-foo', value => 'X-Bar', mode => 2 }]});
+$frames = $s->read(all => [{ sid => 1, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{type}, 'GOAWAY', 'GOAWAY - CONTINUATION closed stream');
+is($frame->{code}, 1, 'GOAWAY - CONTINUATION closed stream - PROTOCOL_ERROR');
+
+# frame padding
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ padding => 42, headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - HEADERS status');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - next stream');
+
+# padding followed by CONTINUATION
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ padding => 42, continuation => [ 2, 4, 1, 5 ],
+    headers => [
+    { name => ':method', value => 'GET', mode => 1 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 1 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'padding - CONTINUATION');
+
+# internal redirect
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/redirect' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 405, 'redirect - HEADERS');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+ok($frame, 'redirect - DATA');
+is($frame->{data}, 'body', 'redirect - DATA payload');
+
+# return 301 with absolute URI
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/return301_absolute' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301, 'return 301 absolute - status');
+is($frame->{headers}->{'location'}, 'text', 'return 301 absolute - location');
+
+# return 301 with relative URI
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/return301_relative' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301, 'return 301 relative - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+    'return 301 relative - location');
+
+# return 301 with relative URI and ':authority' request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/return301_relative', mode => 2 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301,
+    'return 301 relative - authority - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+    'return 301 relative - authority - location');
+
+# return 301 with relative URI and 'host' request header field
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/return301_relative', mode => 2 },
+    { name => 'host', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 301,
+    'return 301 relative - host - status');
+is($frame->{headers}->{'location'}, 'http://localhost:' . port(8080) . '/',
+    'return 301 relative - host - location');
+
+# virtual host
+
+$s = Test::Nginx::HTTP2->new(port(8082));
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => 'host', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'virtual host - host - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'first', 'virtual host - host - DATA');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'virtual host - authority - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'first', 'virtual host - authority - DATA');
+
+# virtual host - second
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => 'host', value => 'localhost2', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'virtual host 2 - host - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'second', 'virtual host 2 - host - DATA');
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/', mode => 0 },
+    { name => ':authority', value => 'localhost2', mode => 2 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200,
+    'virtual host 2 - authority - status');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'second', 'virtual host 2 - authority - DATA');
+
+# gzip tests for internal nginx version
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },
+    { name => ':scheme', value => 'http', mode => 0 },
+    { name => ':path', value => '/gzip.html' },
+    { name => ':authority', value => 'localhost', mode => 1 },
+    { name => 'accept-encoding', value => 'gzip' }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'content-encoding'}, 'gzip', 'gzip - encoding');
+is($frame->{headers}->{'vary'}, 'Accept-Encoding', 'gzip - vary');
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+gunzip_like($frame->{data}, qr/^SEE-THIS\Z/, 'gzip - DATA');
+
+# charset
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/charset' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{'content-type'}, 'text/plain; charset=utf-8', 'charset');
+
+# partial request header frame received (field split),
+# the rest of frame is received after client header timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/t2.html', split => [35],
+    split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client header timeout');
+is($frame->{code}, 1, 'client header timeout - protocol error');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client header timeout - PING');
+
+# partial request header frame received (no field split),
+# the rest of frame is received after client header timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/t2.html', split => [20], split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client header timeout 2');
+is($frame->{code}, 1, 'client header timeout 2 - protocol error');
+
+}
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client header timeout 2 - PING');
+
+# partial request body data frame received, the rest is after body timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/proxy/t2.html', body_more => 1 });
+$s->h2_body('TEST', { split => [10], split_delay => 2.1 });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "RST_STREAM" } @$frames;
+ok($frame, 'client body timeout');
+is($frame->{code}, 1, 'client body timeout - protocol error');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'client body timeout - PING');
+
+# partial request body data frame with connection close after body timeout
+
+$s = Test::Nginx::HTTP2->new(port(8087));
+$sid = $s->new_stream({ path => '/proxy/t2.html', body_more => 1 });
+$s->h2_body('TEST', { split => [ 12 ], abort => 1 });
+
+select undef, undef, undef, 1.1;
+undef $s;
+
+# proxied request with logging pristine request header field (e.g., referer)
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET' },
+    { name => ':scheme', value => 'http' },
+    { name => ':path', value => '/proxy2/' },
+    { name => ':authority', value => 'localhost' },
+    { name => 'referer', value => 'foo' }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'proxy with logging request headers');
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+ok($frame->{headers}, 'proxy with logging request headers - next');
+
+# initial window size, client side
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   When an HTTP/2 connection is first established, new streams are
+#   created with an initial flow-control window size of 65,535 octets.
+#   The connection flow-control window is also 65,535 octets.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+# with the default http2_chunk_size, data is divided into 8 data frames
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $lengths = join ' ', map { $_->{length} } @data;
+is($lengths, '8192 8192 8192 8192 8192 8192 8192 8191',
+    'iws - stream blocked on initial window size');
+
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" && $_->{flags} & 0x1 } @$frames;
+ok($frame, 'iws - PING not blocked');
+
+$s->h2_window(2**16, $sid);
+$frames = $s->read(wait => 0.2);
+is(@$frames, 0, 'iws - updated stream window');
+
+$s->h2_window(2**16);
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+my $sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'iws - updated connection window');
+
+# SETTINGS (initial window size, client side)
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   Both endpoints can adjust the initial window size for new streams by
+#   including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS
+#   frame that forms part of the connection preface.  The connection
+#   flow-control window can only be changed using WINDOW_UPDATE frames.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x4 => 2**17);
+$s->h2_window(2**17);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 + 80, 'iws - increased');
+
+# INITIAL_WINDOW_SIZE duplicate settings
+
+# 6.5.  SETTINGS
+#   Each parameter in a SETTINGS frame replaces any existing value for
+#   that parameter.  Parameters are processed in the order in which they
+#   appear, and a receiver of a SETTINGS frame does not need to maintain
+#   any state other than the current value of its parameters.  Therefore,
+#   the value of a SETTINGS parameter is the last value that is seen by a
+#   receiver.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**17);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 - 1, 'iws duplicate - default stream window');
+
+# this should effect in extra stream window octect
+# $s->h2_settings(0, 0x4 => 42, 0x4 => 2**16);
+{
+    local $SIG{PIPE} = 'IGNORE';
+    syswrite($s->{socket}, pack("x2C2x5nNnN", 12, 0x4, 4, 42, 4, 2**16));
+}
+
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 1, 'iws duplicate - updated stream window');
+
+# yet more octets to finish receiving the response
+
+$s->h2_settings(0, 0x4 => 2**16 + 80);
+
+$frames = $s->read(all => [{ sid => $sid, length => 80 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 80, 'iws duplicate - updated stream window 2');
+
+# probe for negative available space in a flow control window
+
+# 6.9.2.  Initial Flow-Control Window Size
+#   A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available
+#   space in a flow-control window to become negative.  A sender MUST
+#   track the negative flow-control window and MUST NOT send new flow-
+#   controlled frames until it receives WINDOW_UPDATE frames that cause
+#   the flow-control window to become positive.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$s->h2_window(1);
+$s->h2_settings(0, 0x4 => 42);
+$s->h2_window(1024, $sid);
+
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+ok($frame, 'negative window - SETTINGS frame ack');
+is($frame->{flags}, 1, 'negative window - SETTINGS flags ack');
+
+($frame) = grep { $_->{type} ne 'SETTINGS' } @$frames;
+is($frame, undef, 'negative window - no data');
+
+# predefined window size, minus new iws settings, minus window update
+
+$s->h2_window(2**16 - 1 - 42 - 1024, $sid);
+
+$frames = $s->read(wait => 0.2);
+is(@$frames, 0, 'zero window - no data');
+
+$s->h2_window(1, $sid);
+
+$frames = $s->read(all => [{ sid => $sid, length => 1 }]);
+is(@$frames, 1, 'positive window');
+
+SKIP: {
+skip 'failed connection', 2 unless @$frames;
+
+is(@$frames[0]->{type}, 'DATA', 'positive window - data');
+is(@$frames[0]->{length}, 1, 'positive window - data length');
+
+}
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**30);
+$s->h2_settings(0, 0x4 => 2**30);
+
+$sid = $s->new_stream({ path => '/frame_size/tbig.html' });
+
+sleep 1;
+$s->h2_settings(0, 0x5 => 2**15);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+$lengths = join ' ', map { $_->{length} } @$frames;
+unlike($lengths, qr/16384 0 16384/, 'SETTINGS ack after queued DATA');
+
+# ask write handler in sending large response
+
+SKIP: {
+skip 'unsafe socket tests', 4 unless $ENV{TEST_NGINX_UNSAFE};
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/tbig.html' });
+
+$s->h2_window(2**30, $sid);
+$s->h2_window(2**30);
+
+sleep 1;
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'large response - HEADERS');
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 5000000, 'large response - DATA');
+
+# Make sure http2 write handler doesn't break a connection.
+
+$sid = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" } @$frames;
+is($frame->{headers}->{':status'}, 200, 'new stream after large response');
+
+# write event send timeout
+
+$s = Test::Nginx::HTTP2->new(port(8086));
+$sid = $s->new_stream({ path => '/tbig.html' });
+$s->h2_window(2**30, $sid);
+$s->h2_window(2**30);
+
+select undef, undef, undef, 2.1;
+
+$s->h2_ping('SEE-THIS');
+
+$frames = $s->read(all => [{ type => 'PING' }]);
+ok(!grep ({ $_->{type} eq "PING" } @$frames), 'large response - send timeout');
+
+}
+
+# SETTINGS_MAX_FRAME_SIZE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->h2_window(2**18, 1);
+$s->h2_window(2**18);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is($data[0]->{length}, 2**14, 'max frame size - default');
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_settings(0, 0x5 => 2**15);
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->h2_window(2**18, 1);
+$s->h2_window(2**18);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is($data[0]->{length}, 2**15, 'max frame size - custom');
+
+# SETTINGS_INITIAL_WINDOW_SIZE + SETTINGS_MAX_FRAME_SIZE
+# Expanding available stream window should not result in emitting
+# new frames before remaining SETTINGS parameters were applied.
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_window(2**17);
+$s->h2_settings(0, 0x4 => 42);
+
+$sid = $s->new_stream({ path => '/frame_size/t1.html' });
+$s->read(all => [{ sid => $sid, length => 42 }]);
+
+$s->h2_settings(0, 0x4 => 2**17, 0x5 => 2**15);
+
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$lengths = join ' ', map { $_->{length} } @data;
+is($lengths, '32768 32768 38', 'multiple SETTINGS');
+
+# stream multiplexing + WINDOW_UPDATE
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 - 1, 'multiple - stream1 data');
+
+my $sid2 = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }]);
+
+@data = grep { $_->{type} eq "DATA" } @$frames;
+is(@data, 0, 'multiple - stream2 no data');
+
+$s->h2_window(2**17, $sid);
+$s->h2_window(2**17, $sid2);
+$s->h2_window(2**17);
+
+$frames = $s->read(all => [
+    { sid => $sid, fin => 1 },
+    { sid => $sid2, fin => 1 }
+]);
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'multiple - stream1 remain data');
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid2 } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 2**16 + 80, 'multiple - stream2 full data');
+
+# http2_max_concurrent_streams
+
+$s = Test::Nginx::HTTP2->new(port(8083), pure => 1);
+$frames = $s->read(all => [{ type => 'SETTINGS' }]);
+
+($frame) = grep { $_->{type} eq 'SETTINGS' } @$frames;
+is($frame->{3}, 1, 'http2_max_concurrent_streams SETTINGS');
+
+$s->h2_window(2**18);
+
+$sid = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ sid => $sid, length => 2 ** 16 - 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams');
+
+$sid2 = $s->new_stream({ path => '/t1.html' });
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid2 } @$frames;
+isnt($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams 2');
+
+($frame) = grep { $_->{type} eq "RST_STREAM" && $_->{sid} == $sid2 } @$frames;
+is($frame->{sid}, $sid2, 'http2_max_concurrent_streams RST_STREAM sid');
+is($frame->{length}, 4, 'http2_max_concurrent_streams RST_STREAM length');
+is($frame->{flags}, 0, 'http2_max_concurrent_streams RST_STREAM flags');
+is($frame->{code}, 7, 'http2_max_concurrent_streams RST_STREAM code');
+
+# properly skip header field that's not/never indexed from discarded streams
+
+$sid2 = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET' },
+    { name => ':scheme', value => 'http' },
+    { name => ':path', value => '/', mode => 6 },
+    { name => ':authority', value => 'localhost' },
+    { name => 'x-foo', value => 'Foo', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# also if split across writes
+
+$sid2 = $s->new_stream({ split => [ 22 ], headers => [
+    { name => ':method', value => 'GET' },
+    { name => ':scheme', value => 'http' },
+    { name => ':path', value => '/', mode => 6 },
+    { name => ':authority', value => 'localhost' },
+    { name => 'x-bar', value => 'Bar', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+# also if split across frames
+
+$sid2 = $s->new_stream({ continuation => [ 17 ], headers => [
+    { name => ':method', value => 'GET' },
+    { name => ':scheme', value => 'http' },
+    { name => ':path', value => '/', mode => 6 },
+    { name => ':authority', value => 'localhost' },
+    { name => 'x-baz', value => 'Baz', mode => 2 }]});
+$frames = $s->read(all => [{ type => 'RST_STREAM' }]);
+
+$s->h2_window(2**16, $sid);
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET' },
+    { name => ':scheme', value => 'http' },
+    { name => ':path', value => '/t2.html' },
+    { name => ':authority', value => 'localhost' },
+# make sure that discarded streams updated dynamic table
+    { name => 'x-foo', value => 'Foo', mode => 0 },
+    { name => 'x-bar', value => 'Bar', mode => 0 },
+    { name => 'x-baz', value => 'Baz', mode => 0 }]});
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "HEADERS" && $_->{sid} == $sid } @$frames;
+is($frame->{headers}->{':status'}, 200, 'http2_max_concurrent_streams 3');
+
+
+# some invalid cases below
+
+# invalid connection preface
+
+$s = Test::Nginx::HTTP2->new(port(8080), preface => 'x' x 16, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid preface - GOAWAY frame');
+is($frame->{code}, 1, 'invalid preface - error code');
+
+my $preface = 'PRI * HTTP/2.0' . CRLF . CRLF . 'x' x 8;
+$s = Test::Nginx::HTTP2->new(port(8080), preface => $preface, pure => 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'invalid preface 2 - GOAWAY frame');
+is($frame->{code}, 1, 'invalid preface 2 - error code');
+
+# GOAWAY on SYN_STREAM with even StreamID
+
+$s = Test::Nginx::HTTP2->new();
+$s->new_stream({ path => '/' }, 2);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'even stream - GOAWAY frame');
+is($frame->{code}, 1, 'even stream - error code');
+is($frame->{last_sid}, 0, 'even stream - last stream');
+
+# GOAWAY on SYN_STREAM with backward StreamID
+
+# 5.1.1.  Stream Identifiers
+#   The first use of a new stream identifier implicitly closes all
+#   streams in the "idle" state <..> with a lower-valued stream identifier.
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' }, 3);
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid2 = $s->new_stream({ path => '/' }, 1);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'backward stream - GOAWAY frame');
+is($frame->{code}, 1, 'backward stream - error code');
+is($frame->{last_sid}, $sid, 'backward stream - last stream');
+
+# GOAWAY on the second SYN_STREAM with same StreamID
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' });
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+$sid2 = $s->new_stream({ path => '/' }, $sid);
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'dup stream - GOAWAY frame');
+is($frame->{code}, 1, 'dup stream - error code');
+is($frame->{last_sid}, $sid, 'dup stream - last stream');
+
+# aborted stream with zero HEADERS payload followed by client connection close
+
+Test::Nginx::HTTP2->new()->new_stream({ split => [ 9 ], abort => 1 });
+
+# unknown frame type
+
+$s = Test::Nginx::HTTP2->new();
+$s->h2_unknown('payload');
+$s->h2_ping('SEE-THIS');
+$frames = $s->read(all => [{ type => 'PING' }]);
+
+($frame) = grep { $_->{type} eq "PING" } @$frames;
+is($frame->{value}, 'SEE-THIS', 'unknown frame type');
+
+# graceful shutdown with stream waiting on HEADERS payload
+
+my $grace = Test::Nginx::HTTP2->new(port(8087));
+$grace->new_stream({ split => [ 9 ], abort => 1 });
+
+# graceful shutdown waiting on incomplete request body DATA frames
+
+my $grace3 = Test::Nginx::HTTP2->new(port(8087));
+$sid = $grace3->new_stream({ path => '/proxy/t2.html', body_more => 1 });
+$grace3->h2_body('TEST', { body_more => 1 });
+
+# GOAWAY without awaiting active streams, further streams ignored
+
+$s = Test::Nginx::HTTP2->new(port(8080));
+$sid = $s->new_stream({ path => '/t1.html' });
+$s->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$t->reload();
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+is($frame->{last_sid}, $sid, 'GOAWAY with active stream - last sid');
+
+$sid2 = $s->new_stream();
+$frames = $s->read(all => [{ sid => $sid2, fin => 0x4 }], wait => 0.5);
+
+($frame) = grep { $_->{type} eq 'HEADERS' } @$frames;
+is($frame, undef, 'GOAWAY with active stream - no new stream');
+
+$s->h2_window(100, $sid);
+$s->h2_window(100);
+$frames = $s->read(all => [{ sid => $sid, fin => 0x1 }]);
+
+@data = grep { $_->{type} eq "DATA" && $_->{sid} == $sid } @$frames;
+$sum = eval join '+', map { $_->{length} } @data;
+is($sum, 81, 'GOAWAY with active stream - active stream DATA after GOAWAY');
+
+# GOAWAY - force closing a connection by server with idle or active streams
+
+$s = Test::Nginx::HTTP2->new(port(8086));
+$sid = $s->new_stream();
+$s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my $active = Test::Nginx::HTTP2->new(port(8086));
+$sid = $active->new_stream({ path => '/t1.html' });
+$active->read(all => [{ sid => $sid, length => 2**16 - 1 }]);
+
+$t->stop();
+
+$frames = $s->read(all => [{ type => 'GOAWAY' }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY on connection close - idle stream');
+
+$frames = $active->read(all => [{ type => 'GOAWAY' }]);
+($frame) = grep { $_->{type} eq "GOAWAY" } @$frames;
+ok($frame, 'GOAWAY on connection close - active stream');
+
+###############################################################################
+
+sub gunzip_like {
+    my ($in, $re, $name) = @_;
+
+    SKIP: {
+        eval { require IO::Uncompress::Gunzip; };
+        Test::More::skip(
+            "IO::Uncompress::Gunzip not installed", 1) if $@;
+
+        my $out;
+
+        IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+        like($out, $re, $name);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_trailers.t ../asynch_mode_nginx/test/nginx-tests/h2_trailers.t
--- nginx-release-1.20.1/test/nginx-tests/h2_trailers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_trailers.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,132 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 trailers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2/)->plan(22)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            add_trailer X-Var $host;
+        }
+
+        location /continuation {
+            # many trailers to send in parts
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+            add_trailer X-LongHeader $arg_h;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('empty', '');
+$t->write_file('continuation', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my ($s, $sid, $frames, $frame);
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@$frames = grep { $_->{type} =~ "HEADERS|DATA" } @$frames;
+
+is(@$frames, 3, 'frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'header');
+is($frame->{headers}->{'x-var'}, undef, 'header not trailer');
+is($frame->{flags}, 4, 'header flags');
+
+$frame = shift @$frames;
+is($frame->{data}, 'SEE-THIS', 'data');
+is($frame->{flags}, 0, 'data flags');
+
+$frame = shift @$frames;
+is($frame->{headers}->{'x-var'}, 'localhost', 'trailer');
+is($frame->{flags}, 5, 'trailer flags');
+
+# with zero content-length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/empty' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+@$frames = grep { $_->{type} =~ "HEADERS|DATA" } @$frames;
+
+is(@$frames, 2, 'no data - frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'no data - header');
+is($frame->{flags}, 4, 'no data - header flags');
+
+$frame = shift @$frames;
+is($frame->{headers}->{'x-var'}, 'localhost', 'no data - trailer');
+is($frame->{flags}, 5, 'no data - trailer flags');
+
+# CONTINUATION in response trailers
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/continuation?h=' . 'x' x 4000 });
+$frames = $s->read(all => [{ sid => $sid, type => 'CONTINUATION' }]);
+@$frames = grep { $_->{type} =~ "HEADERS|CONTINUATION|DATA" } @$frames;
+
+is(@$frames, 4, 'continuation - frames');
+
+$frame = shift @$frames;
+is($frame->{headers}->{':status'}, 200, 'continuation - header');
+is($frame->{flags}, 4, 'continuation - header flags');
+
+$frame = shift @$frames;
+is($frame->{data}, 'SEE-THIS', 'continuation - data');
+is($frame->{flags}, 0, 'continuation - data flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'HEADERS', 'continuation - trailer');
+is($frame->{flags}, 1, 'continuation - trailer flags');
+
+$frame = shift @$frames;
+is($frame->{type}, 'CONTINUATION', 'continuation - trailer continuation');
+is($frame->{flags}, 4, 'continuation - trailer continuation flags');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/h2_variables.t ../asynch_mode_nginx/test/nginx-tests/h2_variables.t
--- nginx-release-1.20.1/test/nginx-tests/h2_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/h2_variables.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for HTTP/2 protocol with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 rewrite/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location /h2 {
+            return 200 $http2;
+        }
+        location /sp {
+            return 200 $server_protocol;
+        }
+        location /scheme {
+            return 200 $scheme;
+        }
+        location /https {
+            return 200 "body $https";
+        }
+        location /rl {
+            return 200 $request_length;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# $http2
+
+my $s = Test::Nginx::HTTP2->new();
+my $sid = $s->new_stream({ path => '/h2' });
+my $frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+my ($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'h2c', 'http variable - h2c');
+
+# $server_protocol
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/sp' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'HTTP/2.0', 'server_protocol variable');
+
+# $scheme
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/scheme' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'http', 'scheme variable');
+
+# $https
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ path => '/https' });
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, 'body ', 'https variable');
+
+# $request_length, HEADERS payload length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ headers => [
+    { name => ':method', value => 'GET', mode => 0 },        # 1
+    { name => ':scheme', value => 'http', mode => 0 },        # 1
+    { name => ':authority', value => 'localhost', mode => 1 },    # 1+1+9
+    { name => ':path', value => '/rl', mode => 1 }]});        # 1+1+3
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, '18', 'request length');
+
+# $request_length, HEADERS+CONTINUATION payload length
+
+$s = Test::Nginx::HTTP2->new();
+$sid = $s->new_stream({ continuation => 1, headers => [
+    { name => ':method', value => 'GET', mode => 0 },        # 1
+    { name => ':authority', value => 'localhost', mode => 1 },    # 1+1+9
+    { name => ':path', value => '/rl', mode => 1 }]});        # 1+1+3
+$s->h2_continue($sid, { headers => [
+    { name => ':scheme', value => 'http', mode => 0 }]});        # 1
+$frames = $s->read(all => [{ sid => $sid, fin => 1 }]);
+
+($frame) = grep { $_->{type} eq "DATA" } @$frames;
+is($frame->{data}, '18', 'request length');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/headers.t ../asynch_mode_nginx/test/nginx-tests/headers.t
--- nginx-release-1.20.1/test/nginx-tests/headers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/headers.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for headers module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(28)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header   X-URI $uri;
+        add_header   X-Always $uri always;
+        add_header   ETag foo always;
+        add_header   ETag '' always;
+        expires      epoch;
+
+        location /t1 {
+        }
+
+        location /nx {
+        }
+
+        location /epoch {
+            expires epoch;
+        }
+
+        location /max {
+            expires max;
+        }
+
+        location /off {
+            expires off;
+        }
+
+        location /access {
+            expires 2048;
+
+            location /access_inner {
+                # inherited from outer
+            }
+        }
+
+        location /negative {
+            expires -2048;
+        }
+
+        location /daily {
+            expires @15h30m33s;
+        }
+
+        location /modified {
+            expires modified 2048;
+
+            location /modified/proxy {
+                proxy_pass http://127.0.0.1:8081/modified;
+            }
+        }
+
+        location /var {
+            expires $arg_e;
+
+            location /var_inner {
+                # inherited from outer
+            }
+
+            location /var_modified {
+                expires modified $arg_e;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        add_header   Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+    }
+}
+
+EOF
+
+$t->write_file('t1', '');
+$t->write_file('epoch', '');
+$t->write_file('max', '');
+$t->write_file('off', '');
+$t->write_file('access', '');
+$t->write_file('access_inner', '');
+$t->write_file('negative', '');
+$t->write_file('daily', '');
+$t->write_file('modified', '');
+$t->write_file('var', '');
+$t->write_file('var_inner', '');
+$t->write_file('var_modified', '');
+
+$t->run();
+
+###############################################################################
+
+my $r;
+
+# test for header field presence
+
+$r = http_get('/t1');
+like($r, qr/Cache-Control/, 'good expires');
+like($r, qr/X-URI/, 'good add_header');
+like($r, qr/X-Always/, 'good add_header always');
+unlike($r, qr/ETag/, 'good add_header always empty');
+
+$r = http_get('/nx');
+unlike($r, qr/Cache-Control/, 'bad expires');
+unlike($r, qr/X-URI/, 'bad add_header');
+like($r, qr/X-Always/, 'bad add_header always');
+unlike($r, qr/ETag/, 'bad add_header always empty');
+
+# various expires variants
+
+like(http_get('/epoch'), qr/Expires:.*1970/, 'expires epoch');
+like(http_get('/max'), qr/Expires:.*2037/, 'expires max');
+unlike(http_get('/off'), qr/Expires:/, 'expires off');
+like(http_get('/access'), qr/max-age=2048/, 'expires access');
+like(http_get('/access_inner'), qr/max-age=2048/, 'expires inner');
+like(http_get('/negative'), qr/no-cache/, 'expires negative');
+like(http_get('/daily'), qr/Expires:.*:33 GMT/, 'expires daily');
+like(http_get('/modified'), qr/max-age=204./, 'expires modified');
+
+# "expires modified" with proxy
+
+like(http_get('/modified/proxy'), qr/Expires: Mon, 28 Sep 1970 06:34:08 GMT/,
+    'expires modified proxy');
+
+# expires with variables
+
+like(http_get('/var?e=epoch'), qr/Expires:.*1970/, 'expires var epoch');
+like(http_get('/var?e=max'), qr/Expires:.*2037/, 'expires var max');
+unlike(http_get('/var?e=off'), qr/Expires:/, 'expires var off');
+like(http_get('/var?e=2048'), qr/max-age=2048/, 'expires var access');
+like(http_get('/var_inner?e=2048'), qr/max-age=2048/, 'expires var inner');
+like(http_get('/var?e=-2048'), qr/no-cache/, 'expires var negative');
+like(http_get('/var?e=@33s'), qr/Expires:.*:33 GMT/, 'expires var daily');
+like(http_get('/var_modified?e=2048'), qr/max-age=204./,
+    'expires var modified');
+
+# some invalid cases
+
+unlike(http_get('/var'), qr/Expires/, 'expires var empty');
+unlike(http_get('/var?e=bad'), qr/Expires/, 'expires var bad');
+unlike(http_get('/var_modified?e=epoch'), qr/Expires/,
+    'expires var modified epoch');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_absolute_redirect.t ../asynch_mode_nginx/test/nginx-tests/http_absolute_redirect.t
--- nginx-release-1.20.1/test/nginx-tests/http_absolute_redirect.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_absolute_redirect.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,174 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for absolute_redirect directive and Location escaping.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    absolute_redirect off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  on;
+
+        absolute_redirect on;
+
+        location / { }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location "/auto sp/" {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location /return301 {
+            return 301 /redirect;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  off;
+
+        location / { }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location "/auto sp/" {
+            proxy_pass http://127.0.0.1:8080;
+        }
+
+        location /return301 {
+            return 301 /redirect;
+        }
+
+        location /i/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/dir');
+mkdir($t->testdir() . '/dir sp');
+
+$t->run()->plan(18);
+
+###############################################################################
+
+my $p = port(8080);
+
+like(get('on', '/dir'), qr!Location: http://on:$p/dir/\x0d?$!m, 'directory');
+like(get('on', '/i/dir'), qr!Location: http://on:$p/i/dir/\x0d?$!m,
+    'directory alias');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+like(get('on', '/dir%20sp'), qr!Location: http://on:$p/dir%20sp/\x0d?$!m,
+    'directory escaped');
+like(get('on', '/dir%20sp?a=b'),
+    qr!Location: http://on:$p/dir%20sp/\?a=b\x0d?$!m,
+    'directory escaped args');
+
+}
+
+like(get('on', '/auto'), qr!Location: http://on:$p/auto/\x0d?$!m, 'auto');
+like(get('on', '/auto?a=b'), qr!Location: http://on:$p/auto/\?a=b\x0d?$!m,
+    'auto args');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+like(get('on', '/auto%20sp'), qr!Location: http://on:$p/auto%20sp/\x0d?$!m,
+    'auto escaped');
+like(get('on', '/auto%20sp?a=b'),
+    qr!Location: http://on:$p/auto%20sp/\?a=b\x0d?$!m,
+    'auto escaped args');
+
+}
+
+like(get('on', '/return301'), qr!Location: http://on:$p/redirect\x0d?$!m,
+    'return');
+
+like(get('off', '/dir'), qr!Location: /dir/\x0d?$!m, 'off directory');
+like(get('off', '/i/dir'), qr!Location: /i/dir/\x0d?$!m, 'off directory alias');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+like(get('off', '/dir%20sp'), qr!Location: /dir%20sp/\x0d?$!m,
+    'off directory escaped');
+like(get('off', '/dir%20sp?a=b'), qr!Location: /dir%20sp/\?a=b\x0d?$!m,
+    'off directory escaped args');
+
+}
+
+like(get('off', '/auto'), qr!Location: /auto/\x0d?$!m, 'off auto');
+like(get('off', '/auto?a=b'), qr!Location: /auto/\?a=b\x0d?$!m,
+    'off auto args');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+like(get('off', '/auto%20sp'), qr!Location: /auto%20sp/\x0d?$!m,
+    'auto escaped');
+like(get('off', '/auto%20sp?a=b'), qr!Location: /auto%20sp/\?a=b\x0d?$!m,
+    'auto escaped args');
+
+}
+
+like(get('off', '/return301'), qr!Location: /redirect\x0d?$!m, 'off return');
+
+###############################################################################
+
+sub get {
+    my ($host, $uri) = @_;
+    http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_disable_symlinks.t ../asynch_mode_nginx/test/nginx-tests/http_disable_symlinks.t
--- nginx-release-1.20.1/test/nginx-tests/http_disable_symlinks.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_disable_symlinks.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,289 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Belov
+
+# Tests for disable_symlinks directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use POSIX;
+use Cwd qw/ realpath /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite symlink/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  s1;
+
+        location /on/ {
+            disable_symlinks on;
+        }
+
+        location /not_owner/ {
+            disable_symlinks if_not_owner;
+        }
+
+        location /try_on/ {
+            disable_symlinks on;
+            try_files $uri $uri.html =404;
+        }
+
+        location /try_not_owner/ {
+            disable_symlinks if_not_owner;
+            try_files $uri $uri.txt =404;
+        }
+
+        location /if_on/ {
+            disable_symlinks on;
+            if (-f $request_filename) {
+                return 204;
+            }
+        }
+
+        location /if_not_owner/ {
+            disable_symlinks if_not_owner;
+            if (-f $request_filename) {
+                return 204;
+            }
+        }
+
+        location /complex/1/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/./cached/../;
+        }
+
+        location /complex/2/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%//./cached/..//;
+        }
+
+        location /complex/3/ {
+            disable_symlinks on;
+            alias ///%%TESTDIR%%//./cached/..//;
+        }
+
+        location ~ (.+/)tail$ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location ~ (.+/)tailowner$ {
+            disable_symlinks if_not_owner;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location ~ (.+/)tailoff$ {
+            disable_symlinks off;
+            alias %%TESTDIR%%/$1;
+        }
+
+        location /dir {
+            disable_symlinks on;
+            try_files $uri/ =404;
+        }
+
+        location /from {
+            disable_symlinks on from=$document_root;
+
+            location /from/wo_slash {
+                alias %%TESTDIR%%/dirlink;
+            }
+            location /from/with_slash/ {
+                alias %%TESTDIR%%/dirlink/;
+            }
+            location ~ ^/from/exact/(.+)$ {
+                alias %%TESTDIR%%/$1;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  s2;
+
+        open_file_cache max=16 inactive=60s;
+        open_file_cache_valid 30s;
+        open_file_cache_min_uses 1;
+        open_file_cache_errors on;
+
+        location /cached-off/ {
+            disable_symlinks off;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location /cached-on/ {
+            disable_symlinks on;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location /cached-if-not-owner/ {
+            disable_symlinks if_not_owner;
+            alias %%TESTDIR%%/cached/;
+        }
+
+        location / {
+            disable_symlinks off;
+        }
+    }
+}
+
+EOF
+
+my $uid = getuid();
+my ($extfile) = grep { -f && !-l && $uid != (stat())[4] }
+    ('/etc/resolv.conf', '/etc/protocols', '/etc/host.conf');
+
+plan(skip_all => 'no external file found')
+    if !defined $extfile;
+
+$t->try_run('no disable_symlinks')->plan(28);
+
+my $d = $t->testdir();
+
+mkdir("$d/on");
+mkdir("$d/not_owner");
+mkdir("$d/try_on");
+mkdir("$d/try_not_owner");
+mkdir("$d/if_on");
+mkdir("$d/if_not_owner");
+mkdir("$d/cached");
+
+$t->write_file("empty.html", "");
+symlink("empty.html", "$d/link");
+symlink($extfile, "$d/link2");
+
+$t->write_file("on/empty.html", "");
+symlink("empty.html", "$d/on/link");
+symlink($extfile, "$d/on/link2");
+
+$t->write_file("not_owner/empty.html", "");
+symlink("empty.html", "$d/not_owner/link");
+symlink($extfile, "$d/not_owner/link2");
+
+$t->write_file("try_on/try.html", "LOCAL TRY");
+symlink($extfile, "$d/try_on/try");
+
+$t->write_file("try_not_owner/try.html", "LOCAL TRY");
+symlink($extfile, "$d/try_not_owner/try");
+symlink("try.html", "$d/try_not_owner/try.txt");
+
+$t->write_file("if_on/empty.html", "");
+symlink("empty.html", "$d/if_on/link");
+symlink($extfile, "$d/if_on/link2");
+
+$t->write_file("if_not_owner/empty.html", "");
+symlink("empty.html", "$d/if_not_owner/link");
+symlink($extfile, "$d/if_not_owner/link2");
+
+mkdir("$d/dir");
+$t->write_file("dir/empty.html", "");
+symlink("dir", "$d/dirlink");
+
+symlink($extfile, "$d/cached/link");
+
+###############################################################################
+
+SKIP: {
+skip 'cannot test under symlink', 25 if $d ne realpath($d) or $^O eq 'netbsd';
+
+like(http_get_host('s1', '/link'), qr!200 OK!, 'static (off, same uid)');
+like(http_get_host('s1', '/link2'), qr!200 OK!, 'static (off, other uid)');
+
+like(http_get_host('s1', '/on/link'), qr!403 Forbidden!,
+    'static (on, same uid)');
+like(http_get_host('s1', '/on/link2'), qr!403 Forbidden!,
+    'static (on, other uid)');
+
+like(http_get_host('s1', '/not_owner/link'), qr!200 OK!,
+    'static (if_not_owner, same uid)');
+like(http_get_host('s1', '/not_owner/link2'), qr!403 Forbidden!,
+    'static (if_not_owner, other uid)');
+
+like(http_get_host('s1', '/try_on/try'), qr/LOCAL TRY/,
+    'try_files (on)');
+like(http_get_host('s1', '/try_not_owner/try'), qr/LOCAL TRY/,
+    'try_files (if_not_owner)');
+
+like(http_get_host('s1', '/if_on/link'), qr!403 Forbidden!,
+    'if (on, same uid)');
+like(http_get_host('s1', '/if_on/link2'), qr!403 Forbidden!,
+    'if (on, other uid)');
+
+like(http_get_host('s1', '/if_not_owner/link'), qr!204 No Content!,
+    'if (if_not_owner, same uid)');
+like(http_get_host('s1', '/if_not_owner/link2'), qr!403 Forbidden!,
+    'if (if_not_owner, other uid)');
+
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+    'open_file_cache (pass 1)');
+like(http_get_host('s2', '/cached-on/link'), qr!403 Forbidden!,
+    'open_file_cache (pass 2)');
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+    'open_file_cache (pass 3)');
+like(http_get_host('s2', '/cached-if-not-owner/link'), qr!403 Forbidden!,
+    'open_file_cache (pass 4)');
+like(http_get_host('s2', '/cached-off/link'), qr!200 OK!,
+    'open_file_cache (pass 5)');
+
+like(http_get('/complex/1/empty.html'), qr!200 OK!, 'complex root 1');
+like(http_get('/complex/2/empty.html'), qr!200 OK!, 'complex root 2');
+like(http_get('/complex/3/empty.html'), qr!200 OK!, 'complex root 3');
+
+# workaround for freebsd 8: we use O_EXEC instead of O_SEARCH (since there
+# is no O_SEARCH), and O_DIRECTORY does nothing.  setting the 'x' bit
+# tests to pass as openat() will correctly fail with ENOTDIR
+
+chmod(0700, "$d/link");
+my $rc = $^O eq 'darwin' ? 200 : 404;
+
+like(http_get('/link/tail'), qr!40[34] !, 'file with trailing /, on');
+like(http_get('/link/tailowner'), qr!404 !, 'file with trailing /, owner');
+like(http_get('/link/tailoff'), qr!$rc !, 'file with trailing /, off');
+
+like(http_get('/dirlink'), qr!404 !, 'directory without /');
+like(http_get('/dirlink/'), qr!404 !, 'directory with trailing /');
+
+} # SKIP: cannot test under symlink
+
+like(http_get('/from/wo_slash/empty.html'), qr!200 OK!, '"from=" without /');
+like(http_get('/from/with_slash/empty.html'), qr!200 OK!, '"from=" with /');
+like(http_get('/from/exact/link'), qr!200 OK!, '"from=" exact match');
+
+###############################################################################
+
+sub http_get_host {
+    my ($host, $url) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_error_page.t ../asynch_mode_nginx/test/nginx-tests/http_error_page.t
--- nginx-release-1.20.1/test/nginx-tests/http_error_page.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_error_page.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for error_page directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /redirect200 {
+            error_page 404 =200 http://example.com/;
+            return 404;
+        }
+
+        location /redirect497 {
+            # 497 implies implicit status code change
+            error_page 497 https://example.com/;
+            return 497;
+        }
+
+        location /error302redirect {
+            error_page 302 http://example.com/;
+            return 302 "first";
+        }
+
+        location /error302return302text {
+            error_page 302 /return302text;
+            return 302 "first";
+        }
+
+        location /return302text {
+            return 302 "http://example.com/";
+        }
+
+        location /error302return302args {
+            error_page 302 /return302args?1;
+            return 302 "first";
+        }
+
+        location /error302return302varargs {
+            error_page 302 /return302args?$arg_a;
+            return 302 "first";
+        }
+
+        location /return302args {
+            return 302 "http://example.com/$args";
+        }
+
+        location /error302rewrite {
+            error_page 302 /rewrite;
+            return 302 "first";
+        }
+
+        location /rewrite {
+            rewrite ^ http://example.com/;
+        }
+
+        location /error302directory {
+            error_page 302 /directory;
+            return 302 "first";
+        }
+
+        location /directory {
+        }
+
+        location /error302auto {
+            error_page 302 /auto;
+            return 302 "first";
+        }
+
+        location /auto/ {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+# tests for error_page status code change for redirects. problems
+# introduced in 0.8.53 and fixed in 0.9.5.
+
+like(http_get('/redirect200'), qr!HTTP!, 'redirect 200');
+like(http_get('/redirect497'), qr!HTTP/1.1 302!, 'redirect 497');
+
+# various tests to see if old location cleared if we happen to redirect
+# again in error_page 302
+
+like(http_get('/error302redirect'),
+    qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+    'error 302 redirect - old location cleared');
+
+like(http_get('/error302return302text'),
+    qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+    'error 302 return 302 text - old location cleared');
+
+like(http_get('/error302return302args'),
+    qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/1}ms,
+    'error 302 return 302 args - old location cleared');
+
+like(http_get('/error302return302varargs?a=2'),
+    qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/2}ms,
+    'error 302 return 302 var args - old location cleared');
+
+like(http_get('/error302rewrite'),
+    qr{HTTP/1.1 302(?!.*Location: first).*Location: http://example.com/}ms,
+    'error 302 rewrite - old location cleared');
+
+like(http_get('/error302directory'),
+    qr{HTTP/1.1 301(?!.*Location: first).*Location: http://}ms,
+    'error 302 directory redirect - old location cleared');
+
+like(http_get('/error302auto'),
+    qr{HTTP/1.1 301(?!.*Location: first).*Location: http://}ms,
+    'error 302 auto redirect - old location cleared');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_expect_100_continue.t ../asynch_mode_nginx/test/nginx-tests/http_expect_100_continue.t
--- nginx-release-1.20.1/test/nginx-tests/http_expect_100_continue.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_expect_100_continue.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for Expect: 100-continue support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            proxy_pass http://127.0.0.1:8080/local;
+        }
+        location /local {
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_100_request('/', '1.1'), qr/ 100 /, 'expect 100 continue');
+
+# Comparison of expectation values is case-insensitive for unquoted tokens.
+
+like(http_100_request('/', '1.1', '100-Continue'), qr/ 100 /,
+    'expect 100 continue case-insensitive');
+
+# From RFC 2616, 8.2.3 Use of the 100 (Continue) Status:
+#
+#      - An origin server SHOULD NOT send a 100 (Continue) response if
+#        the request message does not include an Expect request-header
+#        field with the "100-continue" expectation, and MUST NOT send a
+#        100 (Continue) response if such a request comes from an HTTP/1.0
+#        (or earlier) client.
+
+unlike(http_100_request('/', '1.0'), qr/ 100 /, 'no 100 continue via http 1.0');
+
+# From RFC 2616, 14.20 Expect:
+#
+#    A server that does not understand or is unable to comply with any of
+#    the expectation values in the Expect field of a request MUST respond
+#    with appropriate error status. The server MUST respond with a 417
+#    (Expectation Failed) status if any of the expectations cannot be met.
+#
+#    <..> If a server receives a request containing an
+#    Expect field that includes an expectation-extension that it does not
+#    support, it MUST respond with a 417 (Expectation Failed) status.
+
+TODO: {
+local $TODO = 'not yet';
+
+like(http_100_request('/', '1.1', 'unknown'), qr/ 417 /, 'unknown expectation');
+like(http_100_request('/', '1.1', 'token=param'), qr/ 417 /,
+    'unsupported expectation extension');
+
+}
+
+###############################################################################
+
+sub http_100_request {
+    my ($url, $version, $value) = @_;
+    $value = '100-continue' unless defined $value;
+    http(<<EOF);
+POST $url HTTP/$version
+Host: localhost
+Expect: $value
+Content-Length: 0
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_header_buffers.t ../asynch_mode_nginx/test/nginx-tests/http_header_buffers.t
--- nginx-release-1.20.1/test/nginx-tests/http_header_buffers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_header_buffers.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,249 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for large_client_header_buffers directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(10)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    connection_pool_size 128;
+    client_header_buffer_size 128;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  five;
+
+        large_client_header_buffers 5 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ten;
+
+        large_client_header_buffers 10 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  one;
+
+        large_client_header_buffers 1 256;
+
+        return 204;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  foo;
+
+        large_client_header_buffers 5 256;
+
+        add_header X-URI $uri;
+        add_header X-Foo $http_x_foo;
+        return 204;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+TODO: {
+todo_skip 'overflow', 2 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if hc->busy is allocated before the virtual server is selected,
+# and then additional buffers are allocated in a virtual server with larger
+# number of buffers configured, hc->busy will be overflowed
+
+like(http(
+    "GET / HTTP/1.0" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "Host: ten" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF
+), qr/204|400/, 'additional buffers in virtual server');
+
+# for pipelined requests large header buffers are saved to hc->free;
+# it sized for number of buffers in the current virtual server, but
+# saves previously allocated buffers, and there may be more buffers if
+# allocatad before the virtual server was selected
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "Host: one" . CRLF .
+    CRLF .
+    "GET / HTTP/1.1" . CRLF .
+    "Host: one" . CRLF .
+    "Connection: close" . CRLF .
+    CRLF
+), qr/204/, 'pipelined with too many buffers');
+
+}
+
+# check if long header and long request lines are correctly returned
+# when nginx allocates a long header buffer
+
+like(http(
+    "GET / HTTP/1.0" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+    CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header');
+
+like(http(
+    "GET /foo" . ("1234567890" x 20) . "bar HTTP/1.0" . CRLF .
+    "Host: foo" . CRLF .
+    CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line');
+
+# the same as the above, but with pipelining, so there is a buffer
+# allocated in the previous request
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF .
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    "X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+    CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after pipelining');
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF .
+    "GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after pipelining');
+
+# the same as the above, but with keepalive; this ensures that previously
+# allocated buffers are properly cleaned up when we set keepalive handler
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF,
+sleep => 0.1, body =>
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    "X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+    CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after keepalive');
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF,
+sleep => 0.1, body =>
+    "GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after keepalive');
+
+# the same as the above, but with pipelining and then keepalive;
+# this ensures that previously allocated buffers are properly cleaned
+# up when we set keepalive handler, including hc->free
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF .
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF,
+sleep => 0.1, body =>
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    "X-Foo: foo" . ("1234567890" x 20) . "bar" . CRLF .
+    CRLF
+), qr/X-Foo: foo(1234567890){20}bar/, 'long header after both');
+
+like(http(
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF .
+    "GET / HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "X-Foo: " . ("1234567890" x 20) . CRLF .
+    CRLF,
+sleep => 0.1, body =>
+    "GET /foo" . ("1234567890" x 20) . "bar HTTP/1.1" . CRLF .
+    "Host: foo" . CRLF .
+    "Connection: close" . CRLF .
+    CRLF
+), qr!X-URI: /foo(1234567890){20}bar!, 'long request line after both');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_host.t ../asynch_mode_nginx/test/nginx-tests/http_host.t
--- nginx-release-1.20.1/test/nginx-tests/http_host.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_host.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,202 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for host parsing in requests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_content /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(36);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen  127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            return  200  $host;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+is(http_host_header('www.abcd-ef.g02.xyz'), 'www.abcd-ef.g02.xyz',
+    'domain w/o port (host header)');
+is(http_host_header('abcd-ef.g02.xyz:' . port(8080)), 'abcd-ef.g02.xyz',
+    'domain w/port (host header)');
+
+is(http_absolute_path('abcd-ef.g02.xyz'), 'abcd-ef.g02.xyz',
+    'domain w/o port (absolute request)');
+is(http_absolute_path('www.abcd-ef.g02.xyz:10'), 'www.abcd-ef.g02.xyz',
+    'domain w/port (absolute request)');
+
+
+is(http_host_header('www.abcd-ef.g02.xyz.'), 'www.abcd-ef.g02.xyz',
+    'domain w/ ending dot w/o port (host header)');
+
+is(http_host_header('abcd-ef.g02.xyz.:88'), 'abcd-ef.g02.xyz',
+    'domain w/ ending dot w/port (host header)');
+
+is(http_absolute_path('www.abcd-ef.g02.xyz.'), 'www.abcd-ef.g02.xyz',
+    'domain w/ ending dot w/o port (absolute request)');
+is(http_absolute_path('abcd-ef.g02.xyz.:2'), 'abcd-ef.g02.xyz',
+    'domain w/ ending dot w/port (absolute request)');
+
+
+is(http_absolute_path('AbC-d93.0.34ZhGt-s.nk.Ru'), 'abc-d93.0.34zhgt-s.nk.ru',
+    'mixed case domain w/o port (absolute request)');
+is(http_host_header('AbC-d93.0.34ZhGt-s.nk.Ru:88'), 'abc-d93.0.34zhgt-s.nk.ru',
+    'mixed case domain w/port (host header)');
+
+
+is(http_host_header('123.40.56.78'), '123.40.56.78',
+    'ipv4 w/o port (host header)');
+is(http_host_header('123.49.0.78:987'), '123.49.0.78',
+    'ipv4 w/port (host header)');
+
+is(http_absolute_path('123.49.0.78'), '123.49.0.78',
+    'ipv4 w/o port (absolute request)');
+is(http_absolute_path('123.40.56.78:123'), '123.40.56.78',
+    'ipv4 w/port (absolute request)');
+
+is(http_host_header('[abcd::ef98:0:7654:321]'), '[abcd::ef98:0:7654:321]',
+    'ipv6 literal w/o port (host header)');
+is(http_host_header('[abcd::ef98:0:7654:321]:80'), '[abcd::ef98:0:7654:321]',
+    'ipv6 literal w/port (host header)');
+
+is(http_absolute_path('[abcd::ef98:0:7654:321]'), '[abcd::ef98:0:7654:321]',
+    'ipv6 literal w/o port (absolute request)');
+is(http_absolute_path('[abcd::ef98:0:7654:321]:5'), '[abcd::ef98:0:7654:321]',
+    'ipv6 literal w/port (absolute request)');
+
+is(http_host_header('[::ffff:12.30.67.89]'), '[::ffff:12.30.67.89]',
+    'ipv4-mapped ipv6 w/o port (host header)');
+is(http_host_header('[::123.45.67.89]:4321'), '[::123.45.67.89]',
+    'ipv4-mapped ipv6 w/port (host header)');
+
+is(http_absolute_path('[::123.45.67.89]'), '[::123.45.67.89]',
+    'ipv4-mapped ipv6 w/o port (absolute request)');
+is(http_absolute_path('[::ffff:12.30.67.89]:4321'), '[::ffff:12.30.67.89]',
+    'ipv4-mapped ipv6 w/port (absolute request)');
+
+like(http_host_header('example.com/\:552', 1), qr/ 400 /,
+    'domain w/ path separators (host header)');
+like(http_absolute_path('\e/xample.com', 1), qr/ 400 /,
+    'domain w/ path separators (absolute request)');
+
+like(http_host_header('..examp-LE.com', 1), qr/ 400 /,
+    'domain w/ double dot (host header)');
+like(http_absolute_path('com.exa-m.45..:', 1), qr/ 400 /,
+    'domain w/ double dot (absolute request)');
+
+
+like(http_host_header('[abcd::e\f98:0/:7654:321]', 1), qr/ 400 /,
+    'ipv6 literal w/ path separators (host header)');
+like(http_absolute_path('[abcd\::ef98:0:7654:321/]:12', 1), qr/ 400 /,
+    'ipv6 literal w/ path separators (absolute request)');
+
+like(http_host_header('[abcd::ef98:0:7654:321]..:98', 1), qr/ 400 /,
+    'ipv6 literal w/ double dot (host header)');
+like(http_absolute_path('[ab..cd::ef98:0:7654:321]', 1), qr/ 400 /,
+    'ipv6 literal w/ double dot (absolute request)');
+
+
+like(http_host_header('[abcd::ef98:0:7654:321]..:98', 1), qr/ 400 /,
+    'ipv6 literal w/ double dot (host header)');
+like(http_absolute_path('[ab..cd::ef98:0:7654:321]', 1), qr/ 400 /,
+    'ipv6 literal w/ double dot (absolute request)');
+
+
+# As per RFC 3986,
+# http://tools.ietf.org/html/rfc3986#section-3.2.2
+#
+# IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
+#
+# IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+#
+# sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+#               / "*" / "+" / "," / ";" / "="
+#
+# unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
+#
+
+is(http_host_header(
+    '[v0123456789aBcDeF.!$&\'()*+,;=-._~AbCdEfGhIjKlMnOpQrStUvWxYz'
+    . '0123456789:]'),
+    '[v0123456789abcdef.!$&\'()*+,;=-._~abcdefghijklmnopqrstuvwxyz'
+    . '0123456789:]',
+    'IPvFuture all symbols (host header)');
+
+is(http_absolute_path(
+    '[v0123456789aBcDeF.!$&\'()*+,;=-._~AbCdEfGhIjKlMnOpQrStUvWxYz'
+    . '0123456789:]'),
+    '[v0123456789abcdef.!$&\'()*+,;=-._~abcdefghijklmnopqrstuvwxyz'
+    . '0123456789:]',
+    'IPvFuture all symbols (absolute request)');
+
+is(http_host_header('123.40.56.78:9000:80'), '123.40.56.78',
+    'double port hack');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_host_header("localhost\nHost: again", 1), qr/ 400 /, 'host repeat');
+
+}
+
+###############################################################################
+
+sub http_host_header {
+    my ($host, $all) = @_;
+    my ($r) = http(<<EOF);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+    return ($all ? $r : http_content($r));
+}
+
+sub http_absolute_path {
+    my ($host, $all) = @_;
+    my ($r) = http(<<EOF);
+GET http://$host/ HTTP/1.0
+Host: localhost
+
+EOF
+    return ($all ? $r : http_content($r));
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_include.t ../asynch_mode_nginx/test/nginx-tests/http_include.t
--- nginx-release-1.20.1/test/nginx-tests/http_include.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_include.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for include directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy access/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        include ups.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        if ($arg_s) {
+            include sif.conf;
+        }
+
+        location / {
+            if ($arg_l) {
+                include lif.conf;
+            }
+        }
+
+        location /lmt {
+            limit_except GET {
+                include lmt.conf;
+            }
+        }
+
+        location /proxy {
+            add_header X-IP $upstream_addr always;
+            proxy_pass http://u/backend;
+        }
+
+        location /backend { }
+    }
+}
+
+EOF
+
+my $p = port(8080);
+
+$t->write_file('sif.conf', 'return 200 SIF;');
+$t->write_file('lif.conf', 'return 200 LIF;');
+$t->write_file('lmt.conf', 'deny all;');
+$t->write_file('ups.conf', "server 127.0.0.1:$p;");
+
+$t->try_run('no include in any context')->plan(5);
+
+###############################################################################
+
+like(http_get('/?s=1'), qr/SIF/, 'include in server if');
+like(http_get('/?l=1'), qr/LIF/, 'include in location if');
+like(http_post('/lmt'), qr/ 403 /, 'include in limit_except');
+like(http_get('/proxy'), qr/X-IP: 127.0.0.1:$p/, 'include in upstream');
+
+unlike(http_get('/'), qr/ 200 /, 'no include');
+
+###############################################################################
+
+sub http_post {
+    my ($uri) = @_;
+    http(<<EOF);
+POST $uri HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_keepalive.t ../asynch_mode_nginx/test/nginx-tests/http_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/http_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_keepalive.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,216 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http keepalive directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test1 $sent_http_connection;
+    log_format test2 $sent_http_keep_alive;
+    access_log %%TESTDIR%%/test1.log test1 if=$arg_l;
+    access_log %%TESTDIR%%/test2.log test2 if=$arg_l;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        keepalive_requests  2;
+        keepalive_timeout   1 9;
+
+        add_header X-Conn $connection_requests:$connection_time;
+
+        location / { }
+        location /r {
+            keepalive_requests  4;
+            keepalive_timeout   30s;
+        }
+
+        location /time {
+            keepalive_requests  100;
+            keepalive_timeout   75s;
+            keepalive_time      1s;
+        }
+
+        location /safari {
+            keepalive_disable  safari;
+        }
+
+        location /none {
+            keepalive_disable  none;
+        }
+
+        location /zero {
+            keepalive_timeout  0;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('r', '');
+$t->write_file('time', '');
+$t->write_file('safari', '');
+$t->write_file('none', '');
+$t->write_file('zero', '');
+$t->try_run('no keepalive_time')->plan(21);
+
+###############################################################################
+
+# keepalive_requests
+
+like(http_keepalive('/'), qr/Connection: keep-alive/, 'keepalive request');
+is(count_keepalive(http_keepalive('/?l=ok', req => 2)), 1, 'keepalive limit');
+is(count_keepalive(http_keepalive('/r', req => 3)), 3, 'keepalive merge');
+is(count_keepalive(http_keepalive('/r', req => 5)), 3, 'keepalive merge limit');
+
+# keepalive_disable
+
+like(http_keepalive('/', method => 'POST', ua => "MSIE 5.0"),
+    qr/Connection: close/, 'keepalive disable msie6');
+like(http_keepalive('/', ua => "MSIE 5.0"), qr/Connection: keep-alive/,
+    'keepalive disable msie6 GET');
+like(http_keepalive('/', method => 'POST', ua => "MSIE 7.0"),
+    qr/Connection: keep-alive/, 'keepalive disable msie6 modern');
+like(http_keepalive('/', ua => "Mac OS X Safari/7534.48.3"),
+    qr/Connection: keep-alive/, 'keepalive disable msie6 safari');
+like(http_keepalive('/safari', ua => "Mac OS X Safari/7534.48.3"),
+    qr/Connection: close/, 'keepalive disable safari');
+like(http_keepalive('/none', method => 'POST', ua => "MSIE 5.0"),
+    qr/Connection: keep-alive/, 'keepalive disable none');
+
+# keepalive_timeout
+
+my $r = http_keepalive('/', req => 2, sleep => 2.1);
+is(count_keepalive($r), 1, 'keepalive timeout request');
+like($r, qr/Keep-Alive: timeout=9/, 'keepalive timeout header');
+
+like(http_keepalive('/zero'), qr/Connection: close/, 'keepalive timeout 0');
+
+# keepalive_time
+
+$r = http_keepalive('/time', req => 3);
+is(() = $r =~ /(200 OK)/g, 3, 'keepalive time requests');
+unlike($r, qr/Connection: close/, 'keepalive time connection');
+
+$r = http_keepalive('/time', req => 3, sleep => 1.2);
+is(() = $r =~ /(200 OK)/g, 2, 'keepalive time limit requests');
+like($r, qr/Connection: close/, 'keepalive time limit connection');
+
+like($r, qr/X-Conn: 1:0.*X-Conn: 2:[^0]/s, 'keepalive time limit variables');
+
+# cancel keepalive on EOF while discarding body
+
+my $s = http(<<EOF, start => 1);
+POST /r HTTP/1.1
+Host: localhost
+Content-Length: 10
+
+EOF
+
+read_keepalive($s);
+shutdown($s, 1);
+
+TODO: {
+local $TODO = 'not yet' unless ($^O eq 'MSWin32' or $^O eq 'solaris')
+    or $t->has_version('1.19.9');
+
+ok(IO::Select->new($s)->can_read(3), 'EOF in discard body');
+
+}
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet';
+
+is($t->read_file('test1.log'), "keep-alive\nclose\n", 'sent_http_connection');
+is($t->read_file('test2.log'), "timeout=9\n-\n", 'sent_http_keep_alive');
+
+}
+
+###############################################################################
+
+sub http_keepalive {
+    my ($url, %opts) = @_;
+    my $total = '';
+
+    $opts{ua} = $opts{ua} || '';
+    $opts{req} = $opts{req} || 1;
+    $opts{sleep} = $opts{sleep} || 0;
+    $opts{method} = $opts{method} || 'GET';
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my $s = http('', start => 1);
+
+    for my $i (1 .. $opts{req}) {
+
+        my $sleep = ($i == 1 ? $opts{sleep} : 0);
+
+        http(<<EOF, socket => $s, start => 1, sleep => $sleep);
+$opts{method} $url HTTP/1.1
+Host: localhost
+User-Agent: $opts{ua}
+
+EOF
+
+        $total .= read_keepalive($s);
+    }
+
+    return $total;
+}
+
+sub read_keepalive {
+    my ($s) = @_;
+    my $data = '';
+
+    while (IO::Select->new($s)->can_read(3)) {
+        sysread($s, my $buffer, 4096) or last;
+        $data .= $buffer;
+        last if $data =~ /^\x0d\x0a/ms;
+    }
+
+    log_in($data);
+    return $data;
+}
+
+sub count_keepalive {
+    my ($str) = @_;
+    return $str =~ s/Connection: keep-alive//g;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_listen.t ../asynch_mode_nginx/test/nginx-tests/http_listen.t
--- nginx-release-1.20.1/test/nginx-tests/http_listen.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_listen.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for listen port ranges.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       127.0.0.1:%%PORT_8082%%-%%PORT_8083%%;
+        listen       %%PORT_8085%%-%%PORT_8086%%;
+        listen       [::1]:%%PORT_8085%%-%%PORT_8086%%;
+        server_name  localhost;
+
+        location / {
+            proxy_pass  http://$arg_b/t;
+        }
+
+        location /t {
+            return  200  $server_addr:$server_port;
+        }
+    }
+
+    # catch out of range
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8084;
+        listen       127.0.0.1:8087;
+        listen       [::1]:%%PORT_8084%%;
+        listen       [::1]:%%PORT_8087%%;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+my $p0 = port(8080); my $p3 = port(8083); my $p6 = port(8086);
+my $p1 = port(8081); my $p4 = port(8084); my $p7 = port(8087);
+my $p2 = port(8082); my $p5 = port(8085);
+
+plan(skip_all => 'listen on wildcard address')
+    unless $ENV{TEST_NGINX_UNSAFE};
+
+plan(skip_all => 'no requested ranges')
+    if "$p0$p1$p2$p3$p4$p5$p6$p7" ne "80808081808280838084808580868087";
+
+$t->run()->plan(12);
+
+###############################################################################
+
+like(http_get("/?b=127.0.0.1:$p0"), qr/127.0.0.1:$p0/, 'single');
+unlike(http_get("/?b=127.0.0.1:$p1"), qr/127.0.0.1:$p1/, 'out of range 1');
+like(http_get("/?b=127.0.0.1:$p2"), qr/127.0.0.1:$p2/, 'range 1');
+like(http_get("/?b=127.0.0.1:$p3"), qr/127.0.0.1:$p3/, 'range 2');
+unlike(http_get("/?b=127.0.0.1:$p4"), qr/127.0.0.$p4/, 'out of range 2');
+like(http_get("/?b=127.0.0.1:$p5"), qr/127.0.0.1:$p5/, 'wildcard range 1');
+like(http_get("/?b=127.0.0.1:$p6"), qr/127.0.0.1:$p6/, 'wildcard range 2');
+unlike(http_get("/?b=127.0.0.1:$p7"), qr/127.0.0.1:$p7/, 'out of range 3');
+
+unlike(http_get("/?b=[::1]:$p4"), qr/::1:$p4/, 'out of range 4');
+like(http_get("/?b=[::1]:$p5"), qr/::1:$p5/, 'ipv6 range 1');
+like(http_get("/?b=[::1]:$p6"), qr/::1:$p6/, 'ipv6 range 2');
+unlike(http_get("/?b=[::1]:$p7"), qr/::1:$p7/, 'out of range 5');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_location_auto.t ../asynch_mode_nginx/test/nginx-tests/http_location_auto.t
--- nginx-release-1.20.1/test/nginx-tests/http_location_auto.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_location_auto.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,74 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for location selection, an auto_redirect edge case.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_hide_header X-Location;
+        add_header X-Location unset;
+
+        # As of nginx 1.5.4, this results in the following
+        # location tree:
+        #
+        #         "/a-b"
+        # "/a-a"          "/a/"
+        #
+        # A request to "/a" is expected to match "/a/" with auto_redirect,
+        # but with such a tree it tests locations "/a-b", "/a-a" and then
+        # falls back to null location.
+        #
+        # Key factor is that "-" is less than "/".
+
+        location /a/  { proxy_pass http://127.0.0.1:8080/a-a; }
+        location /a-a { add_header X-Location a-a; return 204; }
+        location /a-b { add_header X-Location a-b; return 204; }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/a'), qr/301 Moved/, 'auto redirect');
+like(http_get('/a/'), qr/X-Location: unset/, 'match a');
+like(http_get('/a-a'), qr/X-Location: a-a/, 'match a-a');
+like(http_get('/a-b'), qr/X-Location: a-b/, 'match a-b');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_location.t ../asynch_mode_nginx/test/nginx-tests/http_location.t
--- nginx-release-1.20.1/test/nginx-tests/http_location.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_location.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for location selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(14)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = / {
+            add_header X-Location exactlyroot;
+            return 204;
+        }
+
+        location / {
+            add_header X-Location root;
+            return 204;
+        }
+
+        location ^~ /images/ {
+            add_header X-Location images;
+            return 204;
+        }
+
+        location ~* \.(gif|jpg|jpeg)$ {
+            add_header X-Location regex;
+            return 204;
+        }
+
+        location ~ casefull {
+            add_header X-Location casefull;
+            return 204;
+        }
+
+        location = /foo {
+            add_header X-Location "/foo exact";
+            return 204;
+        }
+
+        location /foo {
+            add_header X-Location "/foo prefix";
+            return 204;
+        }
+
+        location = /foo/ {
+            add_header X-Location "/foo/ exact";
+            return 204;
+        }
+
+        location /foo/ {
+            add_header X-Location "/foo/ prefix";
+            return 204;
+        }
+
+        location /lowercase {
+            add_header X-Location lowercase;
+            return 204;
+        }
+
+        location /UPPERCASE {
+            add_header X-Location uppercase;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Location: exactlyroot/, 'exactlyroot');
+like(http_get('/x'), qr/X-Location: root/, 'root');
+like(http_get('/images/t.gif'), qr/X-Location: images/, 'images');
+like(http_get('/t.gif'), qr/X-Location: regex/, 'regex');
+like(http_get('/t.GIF'), qr/X-Location: regex/, 'regex with mungled case');
+like(http_get('/casefull/t.gif'), qr/X-Location: regex/, 'first regex wins');
+like(http_get('/casefull/'), qr/X-Location: casefull/, 'casefull regex');
+
+like(http_get('/foo'), qr!X-Location: /foo exact!, '/foo exact');
+like(http_get('/foobar'), qr!X-Location: /foo prefix!, '/foo prefix');
+like(http_get('/foo/'), qr!X-Location: /foo/ exact!, '/foo/ exact');
+like(http_get('/foo/bar'), qr!X-Location: /foo/ prefix!, '/foo/ prefix');
+
+SKIP: {
+    skip 'caseless os', 1
+        if $^O eq 'MSWin32' or $^O eq 'darwin';
+
+    like(http_get('/CASEFULL/'), qr/X-Location: root/,
+        'casefull regex do not match wrong case');
+}
+
+# on case-insensitive systems a request to "/UPPERCASE" might fail,
+# if location search tree is incorrectly sorted and uppercase
+# characters are used in location directives (ticket #90)
+
+like(http_get('/lowercase'), qr/X-Location: lowercase/, 'lowercase');
+like(http_get('/UPPERCASE'), qr/X-Location: uppercase/, 'uppercase');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_location_win32.t ../asynch_mode_nginx/test/nginx-tests/http_location_win32.t
--- nginx-release-1.20.1/test/nginx-tests/http_location_win32.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_location_win32.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,119 @@
+#!/usr/bin/env perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for location selection on win32.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'not win32')
+    if $^O ne 'MSWin32' && $^O ne 'msys';
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(19)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon         off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Location root;
+            return 204;
+        }
+
+        location /directory/ {
+            add_header X-Location directory;
+            return 204;
+        }
+
+        location /direct~1 {
+        }
+
+        location = /file {
+            add_header X-Location file;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+my $d = $t->testdir();
+mkdir("$d/directory");
+
+$t->write_file('directory/file', 'SEE-THIS');
+
+###############################################################################
+
+like(http_get('/x'), qr/X-Location: root/, 'root');
+
+# these all are mapped to "/directory/"
+
+like(http_get('/directory/'), qr/X-Location: directory/, 'directory');
+like(http_get('/Directory/'), qr/X-Location: directory/, 'directory caseless');
+like(http_get('/directory./'), qr/X-Location: directory/, 'directory dot');
+like(http_get('/directory.%2ffile'), qr/X-Location: directory/,
+    'directory dot encoded slash');
+like(http_get('/directory::$index_allocation/'),
+    qr/X-Location: directory|400 Bad/,
+    'directory stream');
+like(http_get('/directory::$index_allocation./'),
+    qr/X-Location: directory|400 Bad/,
+    'directory stream dot');
+like(http_get('/directory:$i30:$index_allocation./'),
+    qr/X-Location: directory|400 Bad/,
+    'directory i30 stream dot');
+
+# these looks similar, but shouldn't be mapped to "/directory/"
+
+like(http_get('/directory../'), qr/X-Location: root/, 'directory dot dot');
+like(http_get('/directory.::$index_allocation/'), qr/X-Location: root|400 Bad/,
+    'directory dot stream');
+
+# short name, should be rejected
+
+unlike(http_get('/direct~1/file'), qr/SEE-THIS/, 'short name');
+unlike(http_get('/direct~1./file'), qr/SEE-THIS/, 'short name dot');
+unlike(http_get('/direct~1::$index_allocation./file'), qr/SEE-THIS/,
+    'short name stream dot');
+unlike(http_get('/direct~1.::$index_allocation/file'), qr/SEE-THIS/,
+    'short name dot stream');
+
+# these should be mapped to /file
+
+like(http_get('/file'), qr/X-Location: file/, 'file');
+like(http_get('/file.'), qr/X-Location: file/, 'file dot');
+like(http_get('/file..'), qr/X-Location: file/, 'file dot dot');
+like(http_get('/file%20.%20.'), qr/X-Location: file/, 'file dots and spaces');
+like(http_get('/file::$data..'), qr/X-Location: file|400 Bad/,
+    'file stream dot dot');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_resolver_aaaa.t ../asynch_mode_nginx/test/nginx-tests/http_resolver_aaaa.t
--- nginx-release-1.20.1/test/nginx-tests/http_resolver_aaaa.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_resolver_aaaa.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,629 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for AAAA capable http resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+
+            proxy_next_upstream http_504 timeout error;
+            proxy_intercept_errors on;
+            proxy_connect_timeout 50ms;
+            error_page 504 502 /50x;
+            add_header X-Host $upstream_addr;
+        }
+        location /two {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+
+        location /backend {
+            return 200;
+        }
+        location /50x {
+            return 200 $upstream_addr;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(72);
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+my (@n, $response);
+
+my $p0 = port(8080);
+
+like(http_host_header('aaaa.example.net', '/'), qr/\[fe80::1\]/, 'AAAA');
+like(http_host_header('cname.example.net', '/'), qr/\[fe80::1\]/, 'CNAME');
+like(http_host_header('cname.example.net', '/'), qr/\[fe80::1\]/,
+    'CNAME cached');
+
+# CNAME + AAAA combined answer
+# demonstrates the name in answer section different from what is asked
+
+like(http_host_header('cname_a.example.net', '/'), qr/\[::1\]/, 'CNAME + AAAA');
+
+# many AAAA records in round robin
+# nonexisting IPs enumerated with proxy_next_upstream
+
+like(http_host_header('many.example.net', '/'),
+    qr/^\[fe80::(1\]:$p0, \[fe80::2\]:$p0|2\]:$p0, \[fe80::1\]:$p0)$/m,
+    'AAAA many');
+
+like(http_host_header('many.example.net', '/'),
+    qr/^\[fe80::(1\]:$p0, \[fe80::2\]:$p0|2\]:$p0, \[fe80::1\]:$p0)$/m,
+    'AAAA many cached');
+
+# tests for several resolvers specified in directive
+# query bad ns, make sure that error responses are not cached
+
+like(http_host_header('2.example.net', '/two'), qr/502 Bad/, 'two ns bad');
+
+# now get correct response
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns good');
+
+# response is cached, actual request would get error
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns cached');
+
+# various ipv4/ipv6 combinations
+
+$response = http_host_header('z_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'zero zero responses');
+like($response, qr/502 Bad/, 'zero zero');
+
+like(http_host_header('z_n.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+    'zero AAAA');
+
+$response = http_host_header('z_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'zero CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'zero CNAME 1');
+like($response, qr/\[fe80::1\]:$p0/, 'zero CNAME 2');
+
+$response = http_host_header('z_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'zero CNAME+AAAA responses');
+like($response, qr/\[fe80::1\]:$p0/, 'zero CNAME+AAAA 1');
+like($response, qr/\[fe80::2\]:$p0/, 'zero CNAME+AAAA 2');
+
+$response = http_host_header('z_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'zero error responses');
+like($response, qr/502 Bad/, 'zero error');
+
+like(http_host_header('n_z.example.net', '/'), qr/^127.0.0.201:$p0$/ms,
+    'A zero');
+
+$response = http_host_header('n_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'A AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'A AAAA 1');
+like($response, qr/\[fe80::1\]:$p0/, 'A AAAA 2');
+
+like(http_host_header('n_c.example.net', '/'), qr/^127.0.0.201:$p0$/ms,
+    'A CNAME');
+
+$response = http_host_header('n_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'A CNAME+AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'A CNAME+AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'A CNAME+AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'A CNAME+AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'A CNAME+AAAA 4');
+
+$response = http_host_header('n_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'A error responses');
+like($response, qr/502 Bad/, 'A error');
+
+$response = http_host_header('c_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME zero responses');
+like($response, qr/502 Bad/, 'CNAME zero');
+
+like(http_host_header('c_n.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+    'CNAME AAAA');
+
+$response = http_host_header('c_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME CNAME 1');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME CNAME 2');
+
+like(http_host_header('c1_c2.example.net', '/'), qr/^\[fe80::1\]:$p0$/ms,
+    'CNAME1 CNAME2');
+
+$response = http_host_header('c_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME CNAME+AAAA responses');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME CNAME+AAAA 1');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME CNAME+AAAA 1');
+
+$response = http_host_header('c_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME error responses');
+like($response, qr/502 Bad/, 'CNAME error');
+
+$response = http_host_header('cn_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME+A zero responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A zero 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A zero 2');
+
+$response = http_host_header('cn_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'CNAME+A AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME+A AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME+A AAAA 4');
+
+$response = http_host_header('cn_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 2, 'CNAME+A CNAME responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A CNAME 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A CNAME 2');
+
+$response = http_host_header('cn_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 4, 'CNAME+A CNAME+AAAA responses');
+like($response, qr/127.0.0.201:$p0/, 'CNAME+A CNAME+AAAA 1');
+like($response, qr/127.0.0.202:$p0/, 'CNAME+A CNAME+AAAA 2');
+like($response, qr/\[fe80::1\]:$p0/, 'CNAME+A CNAME+AAAA 3');
+like($response, qr/\[fe80::2\]:$p0/, 'CNAME+A CNAME+AAAA 4');
+
+$response = http_host_header('cn_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'CNAME+A error responses');
+like($response, qr/502 Bad/, 'CNAME+A error');
+
+$response = http_host_header('e_z.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error zero responses');
+like($response, qr/502 Bad/, 'error zero');
+
+$response = http_host_header('e_n.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error AAAA responses');
+like($response, qr/502 Bad/, 'error AAAA');
+
+$response = http_host_header('e_c.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error CNAME responses');
+like($response, qr/502 Bad/, 'error CNAME');
+
+$response = http_host_header('e_cn.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error CNAME+AAAA responses');
+like($response, qr/502 Bad/, 'error CNAME+AAAA');
+
+$response = http_host_header('e_e.example.net', '/');
+is(@n = $response =~ /$p0/g, 0, 'error error responses');
+like($response, qr/502 Bad/, 'error error');
+
+###############################################################################
+
+sub http_host_header {
+    my ($host, $uri) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data, $port, $state) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant SERVFAIL    => 2;
+    use constant NXDOMAIN    => 3;
+
+    use constant A        => 1;
+    use constant CNAME    => 5;
+    use constant AAAA    => 28;
+    use constant DNAME    => 39;
+
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if (($name eq 'aaaa.example.net') || ($name eq 'alias.example.net')) {
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, "fe80::1");
+        }
+
+    } elsif ($name eq 'alias2.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, "fe80::1");
+        }
+
+    } elsif ($name eq 'alias4.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+
+    } elsif ($name eq 'alias6.example.net') {
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, "fe80::1");
+        }
+
+    } elsif (($name eq 'many.example.net') && $type == AAAA) {
+        $state->{manycnt}++;
+        if ($state->{manycnt} > 1) {
+            $rcode = SERVFAIL;
+        }
+
+        push @rdata, rd_addr6($ttl, 'fe80::1');
+        push @rdata, rd_addr6($ttl, 'fe80::2');
+
+    } elsif ($name eq 'cname.example.net') {
+        $state->{cnamecnt}++;
+        if ($state->{cnamecnt} > 2) {
+            $rcode = SERVFAIL;
+        }
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, 'alias', 0xc012);
+
+    } elsif ($name eq 'cname_a.example.net') {
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, 'alias', 0xc014);
+
+        # points to "alias" set in previous rdata
+
+        if ($type == AAAA) {
+            push @rdata, pack('n3N nn8', 0xc031, AAAA, IN, $ttl,
+                16, expand_ip6("::1"));
+        }
+
+    } elsif ($name eq '2.example.net') {
+        if ($port == port(8981)) {
+            $state->{twocnt}++;
+        }
+        if ($state->{twocnt} & 1) {
+            $rcode = SERVFAIL;
+        }
+
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, '::1');
+        }
+
+    } elsif ($name eq 'z_z.example.net') {
+        # assume no answers given
+
+    } elsif ($name eq 'z_n.example.net') {
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, 'fe80::1');
+        }
+
+    } elsif ($name eq 'z_c.example.net') {
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc010);
+        }
+
+    } elsif ($name eq 'z_cn.example.net') {
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+                8, 5, 'alias', 0xc011);
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'z_e.example.net') {
+        if ($type == AAAA) {
+            $rcode = SERVFAIL;
+        }
+
+    } elsif ($name eq 'n_z.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+
+    } elsif ($name eq 'n_n.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, 'fe80::1');
+        }
+
+    } elsif ($name eq 'n_c.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc010);
+        }
+
+    } elsif ($name eq 'n_cn.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+            push @rdata, rd_addr($ttl, '127.0.0.202');
+        }
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+                8, 5, 'alias', 0xc011);
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'n_e.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.201');
+        }
+        if ($type == AAAA) {
+            $rcode = SERVFAIL;
+        }
+
+    } elsif ($name eq 'c_z.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+                8, 5, 'alias', 0xc010);
+        }
+
+    } elsif ($name eq 'c_n.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+                8, 5, 'alias', 0xc010);
+        }
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, "fe80::1");
+        }
+
+    } elsif ($name eq 'c_c.example.net') {
+        push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+            9, 6, 'alias2', 0xc010);
+
+    } elsif ($name eq 'c1_c2.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias4', 0xc012);
+        }
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias6', 0xc012);
+        }
+
+    } elsif ($name eq 'c_cn.example.net') {
+        push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+            9, 6, 'alias2', 0xc011);
+
+        if ($type == AAAA) {
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'cn_z.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc011);
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.201'));
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.202'));
+        }
+
+    } elsif ($name eq 'cn_n.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc011);
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.201'));
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.202'));
+        }
+        if ($type == AAAA) {
+            push @rdata, pack('n3N nn8', 0xc00c, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc00c, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'cn_c.example.net') {
+        push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+            9, 6, 'alias2', 0xc011);
+        if ($type == A) {
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.201'));
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.202'));
+        }
+
+    } elsif ($name eq 'cn_cn.example.net') {
+        push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+            9, 6, 'alias2', 0xc012);
+
+        if ($type == A) {
+            push @rdata, pack("n3N nC4", 0xc02f, A, IN, $ttl,
+                4, split('\.', '127.0.0.201'));
+            push @rdata, pack("n3N nC4", 0xc02f, A, IN, $ttl,
+                4, split('\.', '127.0.0.202'));
+        }
+        if ($type == AAAA) {
+            push @rdata, pack('n3N nn8', 0xc02f, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc02f, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'cn_e.example.net') {
+        if ($type == A) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc011);
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.201'));
+            push @rdata, pack("n3N nC4", 0xc02e, A, IN, $ttl,
+                4, split('\.', '127.0.0.202'));
+        }
+        if ($type == AAAA) {
+            $rcode = SERVFAIL;
+        }
+
+
+    } elsif ($name eq 'e_z.example.net') {
+        if ($type == A) {
+            $rcode = SERVFAIL;
+        }
+
+    } elsif ($name eq 'e_n.example.net') {
+        if ($type == A) {
+            $rcode = SERVFAIL;
+        }
+        if ($type == AAAA) {
+            push @rdata, rd_addr6($ttl, 'fe80::1');
+        }
+
+    } elsif ($name eq 'e_c.example.net') {
+        if ($type == A) {
+            $rcode = SERVFAIL;
+        }
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa6n", 0xc00c, CNAME, IN, $ttl,
+                9, 6, 'alias2', 0xc010);
+        }
+
+    } elsif ($name eq 'e_cn.example.net') {
+        if ($type == A) {
+            $rcode = SERVFAIL;
+        }
+        if ($type == AAAA) {
+            push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+                8, 5, 'alias', 0xc011);
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::1"));
+            push @rdata, pack('n3N nn8', 0xc02e, AAAA, IN, $ttl,
+                16, expand_ip6("fe80::2"));
+        }
+
+    } elsif ($name eq 'e_e.example.net') {
+        if ($type == A) {
+            $rcode = SERVFAIL;
+        }
+        if ($type == AAAA) {
+            $rcode = NXDOMAIN;
+        }
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub expand_ip6 {
+    my ($addr) = @_;
+
+    substr ($addr, index($addr, "::"), 2) =
+        join "0", map { ":" } (0 .. 8 - (split /:/, $addr) + 1);
+    map { hex "0" x (4 - length $_) . "$_" } split /:/, $addr;
+}
+
+sub rd_addr6 {
+    my ($ttl, $addr) = @_;
+
+    pack 'n3N nn8', 0xc00c, AAAA, IN, $ttl, 16, expand_ip6($addr);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # track number of relevant queries
+
+    my %state = (
+        cnamecnt    => 0,
+        twocnt        => 0,
+        manycnt        => 0,
+    );
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data, $port, \%state);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_resolver_cleanup.t ../asynch_mode_nginx/test/nginx-tests/http_resolver_cleanup.t
--- nginx-release-1.20.1/test/nginx-tests/http_resolver_cleanup.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_resolver_cleanup.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,105 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver, worker process termination.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/);
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(1);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            resolver 127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass http://example.net/$args;
+        }
+
+        location /pid {
+            add_header X-Pid $pid always;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, $t);
+$t->run()->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+# truncated UDP response, no response over TCP
+
+my $s = http_get('/', start => 1);
+
+pass('request');
+
+sleep 1;
+
+# retrasmission timer wasn't removed during resolver cleanup,
+# while the event memory was freed, resulting in use-after-free
+# when later removing timer in TCP connection
+
+http_get('/pid') =~ qr/X-Pid: (\d+)/;
+kill 'TERM', $1;
+
+###############################################################################
+
+sub dns_daemon {
+    my ($t) = @_;
+    my ($data);
+
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => port(8981),
+        Proto => 'udp',
+    )
+        or die "Can't create UDP socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . port(8981);
+    close $fh;
+
+    while (1) {
+        $socket->recv($data, 65536);
+        # truncation bit set
+        $data |= pack("n2", 0, 0x8380);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_resolver_cname.t ../asynch_mode_nginx/test/nginx-tests/http_resolver_cname.t
--- nginx-release-1.20.1/test/nginx-tests/http_resolver_cname.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_resolver_cname.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,283 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver with CNAME.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(11);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /short {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 2s;
+
+            proxy_pass  http://$host:%%PORT_8080%%/t;
+        }
+
+        location /long {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 5s;
+
+            proxy_pass  http://$host:%%PORT_8080%%/t;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+
+$t->write_file('t', '');
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+# CNAME pointing to name which times out
+
+like(http_host('cn01.example.net', '/short'), qr/502 Bad/, 'CNAME timeout');
+
+# several requests on CNAME pointing to invalid name
+
+my @s;
+
+push @s, http_host('cn03.example.net', '/long', start => 1);
+push @s, http_host('cn03.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'invalid CNAME - first');
+like(http_end(pop @s), qr/502 Bad/, 'invalid CNAME - last');
+
+# several requests on CNAME pointing to cached name
+
+@s = ();
+
+http_host('a.example.net', '/long');
+
+push @s, http_host('cn04.example.net', '/long', start => 1);
+push @s, http_host('cn04.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/200 OK/, 'cached CNAME - first');
+like(http_end(pop @s), qr/200 OK/, 'cached CNAME - last');
+
+# several requests on CNAME pointing to name being resolved
+
+@s = ();
+
+my $s = http_host('cn06.example.net', '/long', start => 1);
+
+sleep 1;
+
+push @s, http_host('cn05.example.net', '/long', start => 1);
+push @s, http_host('cn05.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'CNAME in progress - first');
+like(http_end(pop @s), qr/502 Bad/, 'CNAME in progress - last');
+
+# several requests on CNAME pointing to name which times out
+# 1st request receives CNAME with short ttl
+# 2nd request replaces expired CNAME
+
+@s = ();
+
+push @s, http_host('cn07.example.net', '/long', start => 1);
+
+sleep 2;
+
+push @s, http_host('cn07.example.net', '/long', start => 1);
+
+like(http_end(pop @s), qr/502 Bad/, 'CNAME ttl - first');
+like(http_end(pop @s), qr/502 Bad/, 'CNAME ttl - last');
+
+# several requests on CNAME pointing to name
+# 1st request aborts before name is resolved
+# 2nd request finishes with name resolved
+
+@s = ();
+
+push @s, http_host('cn09.example.net', '/long', start => 1);
+push @s, http_host('cn09.example.net', '/long', start => 1);
+
+select undef, undef, undef, 0.4;    # let resolver hang on CNAME
+
+close(shift @s);
+
+like(http_end(pop @s), qr/200 OK/, 'abort on CNAME');
+
+like(http_host('cn001.example.net', '/short'), qr/502 Bad/, 'recurse uncached');
+
+###############################################################################
+
+sub http_host {
+    my ($host, $uri, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+
+    use constant A        => 1;
+    use constant CNAME    => 5;
+
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if ($name eq 'a.example.net' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'b.example.net' && $type == A) {
+        sleep 2;
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'cn01.example.net') {
+        $ttl = 1;
+        push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+            7, 4, "cn02", 0xc011);
+
+    } elsif ($name =~ /cn0[268].example.net/) {
+        # resolver timeout
+
+        return;
+
+    } elsif ($name eq 'cn03.example.net') {
+        select undef, undef, undef, 1.1;
+        push @rdata, pack("n3N nC", 0xc00c, CNAME, IN, $ttl, 0);
+
+    } elsif ($name eq 'cn04.example.net') {
+        select undef, undef, undef, 1.1;
+        push @rdata, pack("n3N nCa1n", 0xc00c, CNAME, IN, $ttl,
+            4, 1, "a", 0xc011);
+
+    } elsif ($name eq 'cn05.example.net') {
+        select undef, undef, undef, 1.1;
+        push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+            7, 4, "cn06", 0xc011);
+
+    } elsif ($name eq 'cn07.example.net') {
+        $ttl = 1;
+        push @rdata, pack("n3N nCa4n", 0xc00c, CNAME, IN, $ttl,
+            7, 4, "cn08", 0xc011);
+
+    } elsif ($name eq 'cn09.example.net') {
+        if ($type == A) {
+            # await both HTTP requests
+            select undef, undef, undef, 0.2;
+        }
+        push @rdata, pack("n3N nCa1n", 0xc00c, CNAME, IN, $ttl,
+            4, 1, "b", 0xc011);
+
+    } elsif ($name eq 'cn052.example.net') {
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.1');
+        }
+
+    } elsif ($name =~ /cn0\d+.example.net/) {
+        my ($id) = $name =~ /cn(\d+)/;
+        $id++;
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, "cn$id", 0xc012);
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_resolver.t ../asynch_mode_nginx/test/nginx-tests/http_resolver.t
--- nginx-release-1.20.1/test/nginx-tests/http_resolver.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_resolver.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,596 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+
+            proxy_next_upstream http_504 timeout error;
+            proxy_intercept_errors on;
+            proxy_connect_timeout 1s;
+            error_page 504 502 /50x;
+        }
+        location /two {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /valid {
+            resolver    127.0.0.1:%%PORT_8981_UDP%% valid=5s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /case {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            proxy_pass  http://$http_x_name:%%PORT_8080%%/backend;
+        }
+        location /invalid {
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /long {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 4s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /resend {
+            resolver    127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 8s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /bad {
+            resolver    127.0.0.1:%%PORT_8984_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+        }
+        location /tcp {
+            resolver    127.0.0.1:%%PORT_8983_UDP%% 127.0.0.1:%%PORT_8982_UDP%%;
+            resolver_timeout 1s;
+            proxy_pass  http://$host:%%PORT_8080%%/backend;
+            proxy_connect_timeout 1s;
+            add_header X-IP $upstream_addr;
+            error_page 504 502 /50x;
+
+            location /tcp2 {
+                resolver_timeout 8s;
+                proxy_pass  http://$host:%%PORT_8080%%/backend;
+            }
+        }
+
+        location /backend {
+            return 200;
+        }
+        location /50x {
+            return 200 $upstream_addr;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+
+$t->run_daemon(\&dns_daemon, port(8983), $t, tcp => 1);
+$t->waitforfile($t->testdir . '/' . port(8983));
+port(8983, socket => 1)->close();
+
+$t->run_daemon(\&dns_daemon, port(8984), $t);
+
+$t->run()->plan(38);
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+$t->waitforfile($t->testdir . '/' . port(8984));
+
+###############################################################################
+
+my $p0 = port(8080);
+
+# schedule resend test, which takes about 5 seconds to complete
+
+my $s = http_host_header('id.example.net', '/resend', start => 1);
+my $fe = http_host_header('fe.example.net', '/resend', start => 1);
+
+like(http_host_header('a.example.net', '/'), qr/200 OK/, 'A');
+
+# ensure that resolver serves queries from cache in a case-insensitive manner
+# we check this by marking 2nd and subsequent queries on backend with SERVFAIL
+
+http_x_name_header('case.example.net', '/case');
+like(http_x_name_header('CASE.example.net', '/case'), qr/200 OK/,
+    'A case-insensitive');
+
+like(http_host_header('awide.example.net', '/'), qr/200 OK/, 'A uncompressed');
+like(http_host_header('short.example.net', '/'), qr/502 Bad/,
+    'A short dns response');
+
+like(http_host_header('nx.example.net', '/'), qr/502 Bad/, 'NXDOMAIN');
+like(http_host_header('cname.example.net', '/'), qr/200 OK/, 'CNAME');
+like(http_host_header('cname.example.net', '/'), qr/200 OK/,
+    'CNAME cached');
+
+# CNAME + A combined answer
+# demonstrates the name in answer section different from what is asked
+
+like(http_host_header('cname_a.example.net', '/'), qr/200 OK/, 'CNAME + A');
+
+# CNAME refers to non-existing A
+
+like(http_host_header('cname2.example.net', '/'), qr/502 Bad/, 'CNAME bad');
+like(http_host_header('long.example.net', '/'), qr/200 OK/, 'long label');
+like(http_host_header('long2.example.net', '/'), qr/200 OK/, 'long name');
+
+# take into account DNAME
+
+like(http_host_header('alias.example.com', '/'), qr/200 OK/, 'DNAME');
+
+# many A records in round robin
+# nonexisting IPs enumerated with proxy_next_upstream
+
+like(http_host_header('many.example.net', '/'),
+    qr/^127.0.0.20(1:$p0, 127.0.0.202:$p0|2:$p0, 127.0.0.201:$p0)$/m,
+    'A many');
+
+like(http_host_header('many.example.net', '/'),
+    qr/^127.0.0.20(1:$p0, 127.0.0.202:$p0|2:$p0, 127.0.0.201:$p0)$/m,
+    'A many cached');
+
+# tests for several resolvers specified in directive
+# query bad ns, make sure that error responses are not cached
+
+like(http_host_header('2.example.net', '/two'), qr/502 Bad/, 'two ns bad');
+
+# now get correct response
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns good');
+
+# response is cached, actual request would get error
+
+like(http_host_header('2.example.net', '/two'), qr/200 OK/, 'two ns cached');
+
+# ttl tested with 1st req good and 2nd req bad
+# send 1st request and cache its good response
+
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl');
+
+# response is cached, actual request would get error
+
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl cached 1');
+like(http_host_header('ttl.example.net', '/'), qr/200 OK/, 'ttl cached 2');
+
+sleep 2;
+
+# expired ttl causes nginx to make actual query
+
+like(http_host_header('ttl.example.net', '/'), qr/502 Bad/, 'ttl expired');
+
+# zero ttl prohibits response caching
+
+like(http_host_header('ttl0.example.net', '/'), qr/200 OK/, 'zero ttl');
+
+TODO: {
+local $TODO = 'support for zero ttl';
+
+like(http_host_header('ttl0.example.net', '/'), qr/502 Bad/,
+    'zero ttl not cached');
+
+}
+
+# "valid" parameter tested with 1st req good and 2nd req bad
+# send 1st request and cache its good response
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/, 'valid');
+
+# response is cached, actual request would get error
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+    'valid cached 1');
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+    'valid cached 2');
+
+sleep 2;
+
+# expired ttl is overridden with "valid" parameter
+# response is taken from cache
+
+like(http_host_header('ttl.example.net', '/valid'), qr/200 OK/,
+    'valid overrides ttl');
+
+sleep 4;
+
+# expired "valid" value causes nginx to make actual query
+
+like(http_host_header('ttl.example.net', '/valid'), qr/502 Bad/,
+    'valid expired');
+
+# Ensure that resolver respects expired CNAME in CNAME + A combined response.
+# When ttl in CNAME is expired, the answer should not be served from cache.
+# Catch this by returning SERVFAIL on the 2nd and subsequent queries.
+
+http_host_header('cname_a_ttl2.example.net', '/');
+
+sleep 2;
+
+like(http_host_header('cname_a_ttl2.example.net', '/'), qr/502 Bad/,
+    'CNAME + A with expired CNAME ttl');
+
+like(http_host_header('example.net', '/invalid'), qr/502 Bad/, 'no resolver');
+
+like(http_end($s), qr/200 OK/, 'resend after malformed response');
+like(http_end($fe), qr/200 OK/, 'resend after format error');
+
+$s = http_get('/bad', start => 1);
+my $s2 = http_get('/bad', start => 1);
+
+http_end($s);
+ok(http_end($s2), 'timeout handler on 2nd request');
+
+like(http_host_header('fe_id.example.net', '/'), qr/502 Bad/, 'format error');
+
+# several requests waiting on same name query
+# 1st request aborts before name is resolved
+# 2nd request completes on resolver timeout
+
+$s = http_host_header('timeout.example.net', '/long', start => 1);
+$s2 = http_host_header('timeout.example.net', '/long', start => 1);
+
+select undef, undef, undef, 1.1;
+
+close $s;
+
+like(http_end($s2), qr/502 Bad/, 'timeout after aborted request');
+
+# resend DNS query over TCP once UDP response came truncated
+
+unlike(http_host_header('tcp.example.net', '/tcp'), qr/127.0.0.201/, 'tc');
+like(http_host_header('tcp.example.net', '/tcp'), qr/X-IP: 127.0.0.1/, 'tcp');
+like(http_host_header('tcp2.example.net', '/tcp2'), qr/X-IP: 127.0.0.1/,
+    'tcp with resend');
+
+###############################################################################
+
+sub http_host_header {
+    my ($host, $uri, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $uri HTTP/1.0
+Host: $host
+
+EOF
+}
+
+sub http_x_name_header {
+    my ($host, $uri) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+X-Name: $host
+
+EOF
+}
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data, $port, $state, %extra) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant FORMERR    => 1;
+    use constant SERVFAIL    => 2;
+    use constant NXDOMAIN    => 3;
+
+    use constant A        => 1;
+    use constant CNAME    => 5;
+    use constant DNAME    => 39;
+
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if (($name eq 'a.example.net') || ($name eq 'alias.example.net')) {
+        if ($type == A || $type == CNAME) {
+            push @rdata, rd_addr($ttl, '127.0.0.1');
+        }
+
+    } elsif ($name eq 'fe.example.net' && $type == A) {
+        if (++$state->{fecnt} > 1) {
+            $rcode = FORMERR;
+        }
+
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'fe_id.example.net' && $type == A) {
+        $id = 42;
+        $rcode = FORMERR;
+
+    } elsif ($name eq 'case.example.net' && $type == A) {
+        if (++$state->{casecnt} > 1) {
+            $rcode = SERVFAIL;
+        }
+
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'id.example.net' && $type == A) {
+        if (++$state->{idcnt} == 1) {
+            $id++;
+        }
+
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'awide.example.net' && $type == A) {
+        push @rdata, pack '(C/a*)3x n2N nC4',
+            ('awide', 'example', 'net'), A, IN, $ttl,
+            4, (127, 0, 0, 1);
+
+    } elsif (($name eq 'many.example.net') && $type == A) {
+        $state->{manycnt}++;
+        if ($state->{manycnt} > 1) {
+            $rcode = SERVFAIL;
+        }
+
+        push @rdata, rd_addr($ttl, '127.0.0.201');
+        push @rdata, rd_addr($ttl, '127.0.0.202');
+
+
+    } elsif (($name eq 'short.example.net')) {
+        # zero length RDATA in DNS response
+
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '');
+        }
+
+    } elsif (($name eq 'alias.example.com')) {
+        # example.com.       3600 IN DNAME example.net.
+
+        my @dname = ('example', 'net');
+        my $rdlen = length(join '', @dname) + @dname + 1;
+        push @rdata, pack("n3N n(C/a*)* x", 0xc012, DNAME, IN, $ttl,
+            $rdlen, @dname);
+
+        # alias.example.com. 3600 IN CNAME alias.example.net.
+
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, 'alias', 0xc02f);
+
+    } elsif ($name eq 'cname.example.net') {
+        $state->{cnamecnt}++;
+        if ($state->{cnamecnt} > 2) {
+            $rcode = SERVFAIL;
+        }
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, 'alias', 0xc012);
+
+    } elsif ($name eq 'timeout.example.net') {
+        select undef, undef, undef, 2.1;
+        return;
+
+    } elsif ($name eq 'cname_a.example.net') {
+        push @rdata, pack("n3N nCa5n", 0xc00c, CNAME, IN, $ttl,
+            8, 5, 'alias', 0xc014);
+
+        # points to "alias" set in previous rdata
+
+        if ($type == A) {
+            push @rdata, pack('n3N nC4', 0xc031, A, IN, $ttl,
+                4, split(/\./, '127.0.0.1'));
+        }
+
+    } elsif ($name eq 'cname_a_ttl2.example.net' && $type == A) {
+        push @rdata, pack("n3N nCa18n", 0xc00c, CNAME, IN, 1,
+            21, 18, 'cname_a_ttl2_alias', 0xc019);
+        if (++$state->{cttl2cnt} >= 2) {
+            $rcode = SERVFAIL;
+        }
+        push @rdata, pack('n3N nC4', 0xc036, A, IN, $ttl,
+            4, split(/\./, '127.0.0.1'));
+
+    } elsif ($name eq 'cname_a_ttl_alias.example.net' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'cname2.example.net') {
+        # points to non-existing A
+
+        push @rdata, pack("n3N nCa2n", 0xc00c, CNAME, IN, $ttl,
+            5, 2, 'nx', 0xc02f);
+
+    } elsif ($name eq 'long.example.net') {
+        push @rdata, pack("n3N nCA63x", 0xc00c, CNAME, IN, $ttl,
+            65, 63, 'a' x 63);
+
+    } elsif (($name eq 'a' x 63) && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'long2.example.net') {
+        push @rdata, pack("n3N n(CA63)4x", 0xc00c, CNAME, IN, $ttl, 257,
+            63, 'a' x 63, 63, 'a' x 63, 63, 'a' x 63, 63, 'a' x 63);
+
+    } elsif (($name eq 'a' x 63 . '.' . 'a' x 63 . '.' . 'a' x 63 . '.'
+            . 'a' x 63) && $type == A)
+    {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'ttl.example.net' && $type == A) {
+        $state->{ttlcnt}++;
+        if ($state->{ttlcnt} == 2 || $state->{ttlcnt} == 4) {
+            $rcode = SERVFAIL;
+        }
+
+        push @rdata, rd_addr(1, '127.0.0.1');
+
+    } elsif ($name eq 'ttl0.example.net' && $type == A) {
+        $state->{ttl0cnt}++;
+        if ($state->{ttl0cnt} == 2) {
+            $rcode = SERVFAIL;
+        }
+
+        push @rdata, rd_addr(0, '127.0.0.1');
+
+    } elsif ($name eq '2.example.net') {
+        if ($port == port(8981)) {
+            $state->{twocnt}++;
+        }
+        if ($state->{twocnt} & 1) {
+            $rcode = SERVFAIL;
+        }
+
+        if ($type == A) {
+            push @rdata, rd_addr($ttl, '127.0.0.1');
+        }
+
+    } elsif ($name =~ /tcp2?.example.net/) {
+        $rcode = FORMERR if $port == port(8982);
+        $hdr |= 0x0300 unless $extra{tcp};
+        push @rdata, rd_addr($ttl, $extra{tcp}
+            ? '127.0.0.1' : '127.0.0.201') if $type == A;
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t, %extra) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($socket);
+    my $tcp = 0;
+
+    if ($extra{tcp}) {
+        $tcp = port(8983, socket => 1);
+        $sel->add($tcp);
+    }
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    # track number of relevant queries
+
+    my %state = (
+        cnamecnt    => 0,
+        twocnt        => 0,
+        ttlcnt        => 0,
+        ttl0cnt        => 0,
+        cttlcnt        => 0,
+        cttl2cnt    => 0,
+        manycnt        => 0,
+        casecnt        => 0,
+        idcnt        => 0,
+        fecnt        => 0,
+    );
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($tcp == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif ($socket == $fh) {
+                $fh->recv($recv_data, 65536);
+                $data = reply_handler($recv_data, $port,
+                    \%state);
+                $fh->send($data);
+
+            } else {
+                $fh->recv($recv_data, 65536);
+                unless (length $recv_data) {
+                    $sel->remove($fh);
+                    $fh->close;
+                    next;
+                }
+
+again:
+                my $len = unpack("n", $recv_data);
+                $data = substr $recv_data, 2, $len;
+                $data = reply_handler($data, $port, \%state,
+                    tcp => 1);
+                $data = pack("n", length $data) . $data;
+                $fh->send($data);
+                $recv_data = substr $recv_data, 2 + $len;
+                goto again if length $recv_data;
+            }
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_server_name.t ../asynch_mode_nginx/test/nginx-tests/http_server_name.t
--- nginx-release-1.20.1/test/nginx-tests/http_server_name.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_server_name.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,233 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for server_name selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(20)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server_names_hash_bucket_size 64;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  "";
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  www.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ~^EXAMPLE\.COM$;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  ~^(?P<name>.+)\Q.example.com\E$;
+
+        location / {
+            add_header X-Server $server_name;
+            add_header X-Match  $name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  "~^(?P<name>www\p{N}+)\.example\.com$";
+
+        location / {
+            add_header X-Server $server_name;
+            add_header X-Match  $name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  many.example.com many2.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  many3.example.com;
+        server_name  many4.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  *.wc.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  *.pref.wc.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  wc2.example.*;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  wc2.example.com.*;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  .dot.example.com;
+
+        location / {
+            add_header X-Server $server_name;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_server('xxx'), qr/X-Server: localhost/, 'default');
+unlike(http_server(), qr/X-Server/, 'empty');
+
+like(http_server('www.example.com'), qr/\QX-Server: www.example.com/,
+    'www.example.com');
+like(http_server('WWW.EXAMPLE.COM'), qr/\QX-Server: www.example.com/,
+    'www.example.com uppercase');
+
+like(http_server('example.com'), qr/\QX-Server: ~^EXAMPLE\.COM$/,
+    'example.com regex');
+like(http_server('EXAMPLE.COM'), qr/\QX-Server: ~^EXAMPLE\.COM$/,
+    'example.com regex uppercase');
+
+like(http_server('blah.example.com'), qr/X-Match: blah/,
+    '(P<name>.*).example.com named capture');
+like(http_server('BLAH.EXAMPLE.COM'), qr/X-Match: blah/,
+    '(P<name>.*).example.com named capture uppercase');
+
+like(http_server('www01.example.com'), qr/X-Match: www01/,
+    '\p{N} in named capture');
+like(http_server('WWW01.EXAMPLE.COM'), qr/X-Match: www01/,
+    '\p{N} in named capture uppercase');
+
+like(http_server('many.example.com'), qr/\QX-Server: many.example.com/,
+    'name row - first');
+like(http_server('many2.example.com'), qr/\QX-Server: many.example.com/,
+    'name row - second');
+
+like(http_server('many3.example.com'), qr/\QX-Server: many3.example.com/,
+    'name list - first');
+like(http_server('many4.example.com'), qr/\QX-Server: many3.example.com/,
+    'name list - second');
+
+like(http_server('www.wc.example.com'),
+    qr/\QX-Server: *.wc.example.com/, 'wildcard first');
+like(http_server('www.pref.wc.example.com'),
+    qr/\QX-Server: *.pref.wc.example.com/, 'wildcard first most specific');
+like(http_server('wc2.example.net'),
+    qr/\QX-Server: wc2.example.*/, 'wildcard last');
+like(http_server('wc2.example.com.pref'),
+    qr/\QX-Server: wc2.example.com.*/, 'wildcard last most specific');
+
+like(http_server('www.dot.example.com'), qr/\QX-Server: dot.example.com/,
+    'wildcard dot');
+like(http_server('dot.example.com'), qr/\QX-Server: dot.example.com/,
+    'wildcard dot empty');
+
+###############################################################################
+
+sub http_server {
+    my ($host) = @_;
+
+    my $str = 'GET / HTTP/1.0' . CRLF .
+        (defined $host ? "Host: $host" . CRLF : '') .
+        CRLF;
+
+    return http($str);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_try_files.t ../asynch_mode_nginx/test/nginx-tests/http_try_files.t
--- nginx-release-1.20.1/test/nginx-tests/http_try_files.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_try_files.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,124 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for try_files directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(10)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            try_files $uri /fallback;
+        }
+
+        location /nouri/ {
+            try_files $uri /fallback-nouri;
+        }
+
+        location /short/ {
+            try_files /short $uri =404;
+        }
+
+        location /file-file/ {
+            try_files /found.html =404;
+        }
+
+        location /file-dir/ {
+            try_files /found.html/ =404;
+        }
+
+        location /dir-dir/ {
+            try_files /directory/ =404;
+        }
+
+        location /dir-file/ {
+            try_files /directory =404;
+        }
+
+        location ~ /alias-re.html {
+            alias %%TESTDIR%%/directory;
+            try_files $uri =404;
+        }
+
+        location /alias-nested/ {
+            alias %%TESTDIR%%/;
+            location ~ html {
+                try_files $uri =404;
+            }
+        }
+
+        location /fallback {
+            proxy_pass http://127.0.0.1:8081/fallback;
+        }
+        location /fallback-nouri {
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-URI $request_uri;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+$t->write_file('directory/alias-re.html', 'SEE THIS');
+$t->write_file('found.html', 'SEE THIS');
+$t->run();
+
+###############################################################################
+
+like(http_get('/found.html'), qr!SEE THIS!, 'found');
+like(http_get('/uri/notfound'), qr!X-URI: /fallback!, 'not found uri');
+like(http_get('/nouri/notfound'), qr!X-URI: /fallback!, 'not found nouri');
+like(http_get('/short/long'), qr!404 Not!, 'short uri in try_files');
+
+like(http_get('/file-file/'), qr!SEE THIS!, 'file matches file');
+like(http_get('/file-dir/'), qr!404 Not!, 'file does not match dir');
+like(http_get('/dir-dir/'), qr!301 Moved Permanently!, 'dir matches dir');
+like(http_get('/dir-file/'), qr!404 Not!, 'dir does not match file');
+
+like(http_get('/alias-re.html'), qr!SEE THIS!, 'alias in regex location');
+like(http_get('/alias-nested/found.html'), qr!SEE THIS!,
+    'alias with nested location');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_uri.t ../asynch_mode_nginx/test/nginx-tests/http_uri.t
--- nginx-release-1.20.1/test/nginx-tests/http_uri.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_uri.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for URI normalization.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(17)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header  X-URI          "x $uri x";
+            add_header  X-Args         "y $args y";
+            add_header  X-Request-URI  "z $request_uri z";
+            return      204;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+like(http_get('/foo/bar%'), qr/400 Bad/, 'percent');
+like(http_get('/foo/bar%1'), qr/400 Bad/, 'percent digit');
+
+like(http_get('/foo/bar/.?args'), qr!x /foo/bar/ x!, 'dot args');
+like(http_get('/foo/bar/.#frag'), qr!x /foo/bar/ x!, 'dot frag');
+like(http_get('/foo/bar/..?args'), qr!x /foo/ x!, 'dot dot args');
+like(http_get('/foo/bar/..#frag'), qr!x /foo/ x!, 'dot dot frag');
+like(http_get('/foo/bar/.'), qr!x /foo/bar/ x!, 'trailing dot');
+like(http_get('/foo/bar/..'), qr!x /foo/ x!, 'trailing dot dot');
+
+like(http_get('http://localhost'), qr!x / x!, 'absolute');
+like(http_get('http://localhost/'), qr!x / x!, 'absolute slash');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.6');
+
+like(http_get('http://localhost?args'), qr!x / x.*y args y!ms,
+    'absolute args');
+like(http_get('http://localhost?args#frag'), qr!x / x.*y args y!ms,
+    'absolute args and frag');
+
+}
+
+like(http_get('http://localhost:8080'), qr!x / x!, 'port');
+like(http_get('http://localhost:8080/'), qr!x / x!, 'port slash');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.6');
+
+like(http_get('http://localhost:8080?args'), qr!x / x.*y args y!ms,
+    'port args');
+like(http_get('http://localhost:8080?args#frag'), qr!x / x.*y args y!ms,
+    'port args and frag');
+
+}
+
+like(http_get('/ /'), qr!x / / x!, 'space');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/http_variables.t ../asynch_mode_nginx/test/nginx-tests/http_variables.t
--- nginx-release-1.20.1/test/nginx-tests/http_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/http_variables.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for http variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(7);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format cc "$uri: $sent_http_cache_control";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        access_log %%TESTDIR%%/cc.log cc;
+
+        location / {
+            return 200 OK;
+        }
+
+        location /arg {
+            return 200 $arg_l:$arg_;
+        }
+
+        location /set {
+            add_header Cache-Control max-age=3600;
+            add_header Cache-Control private;
+            add_header Cache-Control must-revalidate;
+            return 200 OK;
+        }
+
+        location /redefine {
+            expires epoch;
+            proxy_pass http://127.0.0.1:8080/set;
+        }
+
+        location /limit_rate {
+            set $limit_rate $arg_l;
+            add_header X-Rate $limit_rate;
+            return 200 OK;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/');
+http_get('/../bad_uri');
+http_get('/redefine');
+
+TODO: {
+todo_skip 'overflow', 1 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->has_version('1.19.0');
+
+like(http_get('/arg?l=42'), qr/42:$/, 'arg');
+
+}
+
+# $limit_rate is a special variable that has its own set_handler / get_handler
+
+like(http_get('/limit_rate?l=40k'), qr/X-Rate: 40960/, 'limit_rate handlers');
+like(http_get('/limit_rate'), qr/X-Rate: 0/, 'limit_rate invalid');
+
+$t->stop();
+
+my $log = $t->read_file('cc.log');
+like($log, qr!^: -$!m, 'no uri');
+like($log, qr!^/: -$!m, 'no header');
+like($log, qr!^/set: max-age=3600, private, must-revalidate$!m,
+    'multi headers');
+
+like($log, qr!^/redefine: no-cache$!m, 'ignoring headers with (hash == 0)');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ignore_invalid_headers.t ../asynch_mode_nginx/test/nginx-tests/ignore_invalid_headers.t
--- nginx-release-1.20.1/test/nginx-tests/ignore_invalid_headers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ignore_invalid_headers.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,172 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for ignore_invalid_headers, underscores_in_headers directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+use MIME::Base64 qw/ encode_base64 decode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ignore_invalid_headers off;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+
+        location /v {
+            add_header X-Cookie $http_cookie;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        underscores_in_headers on;
+
+        location / {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('v', '');
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my $us = 'GET / HTTP/1.0' . CRLF
+    . 'x_foo: x-bar' . CRLF . CRLF;
+my $us2 = 'GET / HTTP/1.0' . CRLF
+    . '_foo: x-bar' . CRLF . CRLF;
+my $bad = 'GET / HTTP/1.0' . CRLF
+    . 'x.foo: x-bar' . CRLF . CRLF;
+my $bad2 = 'GET / HTTP/1.0' . CRLF
+    . '.foo: x-bar' . CRLF . CRLF;
+
+# ignore_invalid_headers off;
+
+like(get($us, 8080), qr/x-bar/, 'off - underscore');
+like(get($us2, 8080), qr/x-bar/, 'off - underscore first');
+like(get($bad, 8080), qr/x-bar/, 'off - bad');
+like(get($bad2, 8080), qr/x-bar/, 'off - bad first');
+
+# ignore_invalid_headers off; headers parsing post 8f55cb5c7e79
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.5');
+
+unlike(http('GET /v HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'coo: foo' . CRLF
+    . '</kie>: x-bar' . CRLF . CRLF), qr/x-bar/, 'off - several');
+
+}
+
+# ignore_invalid_headers on;
+
+unlike(get($us, 8081), qr/x-bar/, 'on - underscore');
+unlike(get($us2, 8081), qr/x-bar/, 'on - underscore first');
+
+# ignore_invalid_headers on; underscores_in_headers on;
+
+like(get($us, 8082), qr/x-bar/, 'underscores_in_headers');
+like(get($us2, 8082), qr/x-bar/, 'underscores_in_headers - first');
+
+###############################################################################
+
+sub get {
+    my ($msg, $port) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port)) or die;
+    my ($headers) = http($msg, socket => $s) =~ /X-Headers: (\w+)/;
+    decode_base64($headers);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my $once = 1;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8085),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $headers = encode_base64($headers, "");
+
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Headers: $headers
+
+EOF
+
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/image_filter_finalize.t ../asynch_mode_nginx/test/nginx-tests/image_filter_finalize.t
--- nginx-release-1.20.1/test/nginx-tests/image_filter_finalize.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/image_filter_finalize.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,152 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http filter finalize code.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache image_filter limit_req/)
+    ->has(qw/rewrite/)->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=cache:1m;
+
+    limit_req_zone $binary_remote_addr zone=limit:1m rate=25r/m;
+
+    log_format time "$request_uri:$status:$upstream_response_time";
+    access_log time.log time;
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8080;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # this used to cause a segmentation fault before 07f028df3879 (1.3.1)
+        # http://nginx.org/pipermail/nginx/2011-January/024703.html
+
+        location /t1 {
+            proxy_pass http://127.0.0.1:8080/bad;
+            proxy_cache cache;
+            proxy_cache_valid any 1h;
+
+            image_filter   resize  150 100;
+            error_page     415   = /empty;
+        }
+
+        location /empty {
+            return 204;
+        }
+
+        location /bad {
+            return 404;
+        }
+
+        # another segfault, introduced in 204b780a89de (1.3.0),
+        # fixed in 07f028df3879 (1.3.1)
+
+        location /t2 {
+            proxy_pass http://127.0.0.1:8080/big;
+            proxy_store on;
+
+            image_filter_buffer 10m;
+            image_filter   resize  150 100;
+            error_page     415   = /empty;
+        }
+
+        location /big {
+            # big enough static file
+        }
+
+        # filter finalization may cause duplicate upstream finalization,
+        # resulting in wrong $upstream_response_time,
+        # http://nginx.org/pipermail/nginx-devel/2015-February/006539.html
+
+        # note that we'll need upstream response time to be at least 1 second,
+        # and at least 4 failed requests to make sure r->upstream_states will
+        # not be reallocated
+
+        location /t3 {
+            proxy_pass http://u/slow;
+            proxy_buffering off;
+
+            image_filter   resize  150 100;
+            error_page     415   = /upstream;
+        }
+
+        location /slow {
+            limit_req zone=limit burst=5;
+        }
+
+        location /upstream {
+            proxy_pass http://127.0.0.1:8080/empty;
+        }
+
+        location /time.log {
+            # access to log
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+        return 444;
+    }
+}
+
+EOF
+
+$t->write_file('big', "x" x 10240000);
+$t->write_file('slow', "x");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1'), qr/HTTP/, 'image filter and cache');
+like(http_get('/t2'), qr/HTTP/, 'image filter and store');
+
+http_get('/slow');
+http_get('/t3');
+like(http_get('/time.log'), qr!/t3:.*, [1-9]\.!, 'upstream response time');
+
+# "aio_write" is used to produce the following alert on some platforms:
+# "readv() failed (9: Bad file descriptor) while reading upstream"
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+    and $t->read_file('nginx.conf') =~ /aio threads/;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/image_filter.t ../asynch_mode_nginx/test/nginx-tests/image_filter.t
--- nginx-release-1.20.1/test/nginx-tests/image_filter.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/image_filter.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,344 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for image filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/CRLF/;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require GD; };
+plan(skip_all => 'GD not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy map image_filter/)->plan(39)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $arg_w $w {
+        "" '-';
+        default $arg_w;
+    }
+    map $arg_h $h {
+        "" '-';
+        default $arg_h;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /size {
+            image_filter size;
+            alias %%TESTDIR%%/;
+        }
+
+        location /test {
+            image_filter test;
+            alias %%TESTDIR%%/;
+
+            location /test/off {
+                image_filter off;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /resize {
+            image_filter resize 10 12;
+            alias %%TESTDIR%%/;
+        }
+        location /resize1 {
+            image_filter resize 10 -;
+            alias %%TESTDIR%%/;
+        }
+        location /resize2 {
+            image_filter resize - 12;
+            alias %%TESTDIR%%/;
+        }
+        location /resize_var {
+            image_filter resize $w $h;
+            alias %%TESTDIR%%/;
+        }
+
+        location /rotate {
+            image_filter rotate 90;
+            alias %%TESTDIR%%/;
+        }
+        location /rotate_var {
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crop {
+            image_filter crop 60 80;
+            alias %%TESTDIR%%/;
+        }
+        location /crop_var {
+            image_filter crop $arg_w $arg_h;
+            alias %%TESTDIR%%/;
+        }
+        location /crop_rotate {
+            image_filter crop $arg_w $arg_h;
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+        }
+        location /resize_rotate {
+            image_filter resize $w $h;
+            image_filter rotate $arg_r;
+            alias %%TESTDIR%%/;
+
+            location /resize_rotate/resize {
+                image_filter resize 10 12;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /interlaced {
+            image_filter resize 10 12;
+            image_filter_interlace on;
+            alias %%TESTDIR%%/;
+        }
+
+        location /nontransparent {
+            image_filter resize 10 12;
+            image_filter_transparency off;
+            alias %%TESTDIR%%/;
+        }
+
+        location /quality {
+            image_filter resize 10 12;
+            image_filter_jpeg_quality 50;
+            alias %%TESTDIR%%/;
+        }
+        location /quality_var {
+            image_filter resize 10 12;
+            image_filter_jpeg_quality $arg_q;
+            alias %%TESTDIR%%/;
+
+            location /quality_var/quality {
+                image_filter_jpeg_quality 60;
+                alias %%TESTDIR%%/;
+            }
+        }
+
+        location /buffer {
+            image_filter test;
+            image_filter_buffer 1k;
+            alias %%TESTDIR%%/;
+        }
+        location /proxy_buffer {
+            image_filter rotate 90;
+            image_filter_buffer 20;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+            proxy_buffer_size 512;
+        }
+    }
+}
+
+EOF
+
+
+my $im = new GD::Image(100, 120);
+my $white = $im->colorAllocate(255, 255, 255);
+my $black = $im->colorAllocate(0, 0, 0);
+
+$im->transparent($white);
+$im->rectangle(0, 0, 99, 99, $black);
+
+$t->write_file('jpeg', $im->jpeg);
+$t->write_file('gif', $im->gif);
+$t->write_file('png', $im->png);
+$t->write_file('txt', 'SEE-THIS');
+
+$t->run_daemon(\&http_daemon, $t);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_head('/test/gif'), qr/200 OK/, 'test');
+like(http_head('/test/gif'), qr!Content-Type: image/gif!, 'test content-type');
+like(http_get('/test/txt'), qr/415 Unsupported/, 'test fail');
+like(http_get('/test/off/txt'), qr/SEE-THIS/, 'off');
+
+is(http_get_body('/size/txt'), '{}' . CRLF, 'size wrong type');
+like(http_head('/size/txt'), qr!Content-Type: application/json!,
+    'size content-type');
+like(http_get('/size/jpeg'), qr/"width": 100/, 'size width');
+like(http_get('/size/jpeg'), qr/"height": 120/, 'size height');
+like(http_get('/size/jpeg'), qr/"type": "jpeg"/, 'size jpeg');
+like(http_get('/size/gif'), qr/"type": "gif"/, 'size gif');
+like(http_get('/size/png'), qr/"type": "png"/, 'size png');
+
+is(gif_size('/resize/gif'), '10 12', 'resize');
+is(gif_size('/resize1/gif'), '10 12', 'resize 1');
+is(gif_size('/resize2/gif'), '10 12', 'resize 2');
+
+is(gif_size('/resize_var/gif?w=10&h=12'), '10 12', 'resize var');
+is(gif_size('/resize_var/gif?w=10'), '10 12', 'resize var 1');
+is(gif_size('/resize_var/gif?h=12'), '10 12', 'resize var 2');
+
+is(gif_size('/rotate/gif?r=90'), '120 100', 'rotate');
+is(gif_size('/rotate_var/gif?r=180'), '100 120', 'rotate var 1');
+is(gif_size('/rotate_var/gif?r=270'), '120 100', 'rotate var 2');
+
+$im = GD::Image->newFromGifData(http_get_body('/gif'));
+is($im->interlaced, 0, 'gif interlaced off');
+is($im->transparent, 0, 'gif transparent white');
+
+SKIP: {
+skip 'broken/unknown libgd', 1
+    unless has_gdversion('2.1.0') or $ENV{TEST_NGINX_UNSAFE};
+
+$im = GD::Image->newFromGifData(http_get_body('/interlaced/gif'));
+is($im->interlaced, 1, 'gif interlaced on');
+
+}
+
+$im = GD::Image->newFromGifData(http_get_body('/nontransparent/gif'));
+is($im->transparent, -1, 'gif transparent loss');
+
+$im = GD::Image->newFromPngData(http_get_body('/png'));
+is($im->interlaced, 0, 'png interlaced off');
+is($im->transparent, 0, 'png transparent white');
+
+# this test produces libpng warning on STDERR:
+# "Interlace handling should be turned on when using png_read_image"
+
+SKIP: {
+skip 'can wedge nginx with SIGPIPE', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+$im = GD::Image->newFromPngData(http_get_body('/interlaced/png'));
+is($im->interlaced, 1, 'png interlaced on');
+
+}
+
+$im = GD::Image->newFromPngData(http_get_body('/nontransparent/png'));
+is($im->transparent, -1, 'png transparent loss');
+
+like(http_get('/resize/jpeg'), qr/quality = 75/, 'quality default');
+like(http_get('/quality/jpeg'), qr/quality = 50/, 'quality');
+like(http_get('/quality_var/jpeg?q=40'), qr/quality = 40/, 'quality var');
+like(http_get('/quality_var/quality/jpeg?q=40'), qr/quality = 60/,
+    'quality nested');
+
+is(gif_size('/crop/gif'), '60 80', 'crop');
+is(gif_size('/crop_var/gif?w=10&h=20'), '10 20', 'crop var');
+is(gif_size('/crop_rotate/gif?w=5&h=6&r=90'), '5 5', 'rotate before crop');
+is(gif_size('/resize_rotate/gif?w=5&h=6&r=90'), '6 5', 'rotate after resize');
+is(gif_size('/resize_rotate/resize/gif??w=5&h=6&r=90'), '10 12',
+    'resize rotate nested');
+
+like(http_get('/buffer/jpeg'), qr/415 Unsupported/, 'small buffer');
+isnt(http_get('/proxy_buffer/jpeg'), undef, 'small buffer proxy');
+
+###############################################################################
+
+sub gif_size {
+    join ' ', unpack("x6v2", http_get_body(@_));
+}
+
+sub http_get_body {
+    my ($uri) = @_;
+
+    return undef if !defined $uri;
+
+    my $text = http_get($uri);
+
+    if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+        return undef;
+    }
+
+    return $2;
+}
+
+sub has_gdversion {
+    my ($need) = @_;
+
+    my $v_str = `gdlib-config --version 2>&1`
+        || eval { GD::VERSION_STRING() } or return 0;
+    ($v_str) = $v_str =~ m!^([0-9.]+)!m or return 0;
+    my @v = split(/\./, $v_str);
+    my ($n, $v);
+
+    for $n (split(/\./, $need)) {
+        $v = shift @v || 0;
+        return 0 if $n > $v;
+        return 1 if $v > $n;
+    }
+
+    return 1;
+}
+
+###############################################################################
+
+# serve static files without Content-Length
+
+sub http_daemon {
+    my ($t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        next if $headers eq '';
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+        my $data = $t->read_file($uri);
+
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+$data
+EOF
+
+    } continue {
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/image_filter_webp.t ../asynch_mode_nginx/test/nginx-tests/image_filter_webp.t
--- nginx-release-1.20.1/test/nginx-tests/image_filter_webp.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/image_filter_webp.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for image filter module, WebP support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http image_filter/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /size {
+            image_filter size;
+            alias %%TESTDIR%%/;
+        }
+
+        location /test {
+            image_filter test;
+            alias %%TESTDIR%%/;
+        }
+
+        location /resize {
+            image_filter resize 1 1;
+            alias %%TESTDIR%%/;
+        }
+
+        location /quality {
+            image_filter rotate 90;
+            image_filter_webp_quality 50;
+            alias %%TESTDIR%%/;
+        }
+        location /quality_var {
+            image_filter rotate 90;
+            image_filter_webp_quality $arg_q;
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(18);
+
+$t->write_file('webp', pack("A4LA8", "RIFF", 0x22, "WEBPVP8 ") .
+    pack("N4", 0x16000000, 0x3001009d, 0x012a0100, 0x01000ec0) .
+    pack("N2n", 0xfe25a400, 0x03700000, 0x0000));
+$t->write_file('webpl', pack("A4LA8", "RIFF", 0x1a, "WEBPVP8L") .
+    pack("N4n", 0x0d000000, 0x2f000000, 0x10071011, 0x118888fe, 0x0700));
+$t->write_file('webpx', pack("A4LA8", "RIFF", 0x4a, "WEBPVP8X") .
+    pack("N4", 0x0a000000, 0x10000000, 0x00000000, 0x0000414c) .
+    pack("N4", 0x50480c00, 0x00001107, 0x1011fd0f, 0x4444ff03) .
+    pack("N4", 0x00005650, 0x38201800, 0x00001401, 0x009d012a) .
+    pack("N4n", 0x01000100, 0x0000fe00, 0x000dc000, 0xfee6b500, 0x0000));
+
+$t->write_file('webperr', pack("A4LA8", "RIFF", 0x22, "WEBPERR ") .
+    pack("N4", 0x16000000, 0x3001009d, 0x012a0100, 0x01000ec0) .
+    pack("N2n", 0xfe25a400, 0x03700000, 0x0000));
+$t->write_file('webptrunc', substr $t->read_file('webp'), 0, 29);
+
+###############################################################################
+
+my $r = http_get('/test/webp');
+like($r, qr!Content-Type: image/webp!, 'content-type');
+like($r, qr/RIFF/, 'content');
+
+$r = http_get('/size/webp');
+like($r, qr/"type": "webp"/, 'size type');
+like($r, qr/"width": 1/, 'size width');
+like($r, qr/"height": 1/, 'size height');
+
+# lossless
+
+$r = http_get('/size/webpl');
+like($r, qr/"type": "webp"/, 'lossless type');
+like($r, qr/"width": 1/, 'lossless width');
+like($r, qr/"height": 1/, 'lossless height');
+
+# extended
+
+$r = http_get('/size/webpx');
+like($r, qr/"type": "webp"/, 'extended type');
+like($r, qr/"width": 1/, 'extended width');
+like($r, qr/"height": 1/, 'extended height');
+
+# transforms, libgd may have no WebP support
+
+like(http_get('/quality/webp'), qr/RIFF|415/, 'quality');
+like(http_get('/quality_var/webp?q=40'), qr/RIFF|415/, 'quality var');
+like(http_get('/resize/webp'), qr/RIFF/, 'resize as is');
+
+# generic error handling
+
+like(http_get('/quality/webperr'), qr/415 Unsupported/, 'bad header');
+like(http_get('/quality/webptrunc'), qr/415 Unsupported/, 'truncated');
+
+like(http_get('/size/webperr'), qr/{}/, 'size - bad header');
+like(http_get('/size/webptrunc'), qr/{}/, 'size - truncated');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/index.t ../asynch_mode_nginx/test/nginx-tests/index.t
--- nginx-release-1.20.1/test/nginx-tests/index.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/index.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for index module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)->plan(14)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        add_header   X-URI $uri;
+
+        location / {
+            # index index.html by default
+        }
+
+        location /redirect/ {
+            index /re.html;
+        }
+
+        location /loop/ {
+            index /loop/;
+        }
+
+        location /no_index/ {
+            alias %%TESTDIR%%/;
+            index nonexisting.html;
+        }
+
+        location /many/ {
+            alias %%TESTDIR%%/;
+            index nonexisting.html many.html;
+        }
+
+        location /var/ {
+            alias %%TESTDIR%%/;
+            index $server_name.html;
+        }
+
+        location /va2/ {
+            alias %%TESTDIR%%/;
+            # before 1.13.8, the token produced emerg:
+            # directive "index" is not terminated by ";"
+            index ${server_name}.html;
+        }
+
+        location /var_redirect/ {
+            index /$server_name.html;
+        }
+
+        location /not_found/ {
+            error_log %%TESTDIR%%/log_not_found.log;
+
+            location /not_found/off/ {
+                error_log %%TESTDIR%%/off.log;
+                log_not_found off;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'body');
+$t->write_file('many.html', 'manybody');
+$t->write_file('re.html', 'rebody');
+$t->write_file('localhost.html', 'varbody');
+
+my $d = $t->testdir();
+mkdir("$d/forbidden");
+chmod(0000, "$d/forbidden");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-URI: \/index.html.*body/ms, 'default index');
+like(http_get('/no_index/'), qr/403 Forbidden/, 'no index');
+like(http_get('/redirect/'), qr/X-URI: \/re.html.*rebody/ms, 'redirect');
+like(http_get('/loop/'), qr/500 Internal/, 'redirect loop');
+like(http_get('/many/'), qr/X-URI: \/many\/many.html.*manybody/ms, 'many');
+like(http_get('/var/'), qr/X-URI: \/var\/localhost.html.*varbody/ms, 'var');
+like(http_get('/va2/'), qr/X-URI: \/va2\/localhost.html.*varbody/ms, 'var 2');
+like(http_get('/var_redirect/'), qr/X-URI: \/localhost.html.*varbody/ms,
+    'var with redirect');
+
+like(http_get('/not_found/'), qr/404 Not Found/, 'not found');
+like(http_get('/not_found/off/'), qr/404 Not Found/, 'not found log off');
+like(http_get('/forbidden/'), qr/403 Forbidden/, 'directory access denied');
+like(http_get('/index.html/'), qr/404 Not Found/, 'not a directory');
+
+$t->stop();
+
+like($t->read_file('log_not_found.log'), qr/error/, 'log_not_found');
+unlike($t->read_file('off.log'), qr/error/, 'log_not_found off');
+
+chmod(0700, "$d/forbidden");
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_async.t ../asynch_mode_nginx/test/nginx-tests/js_async.t
--- nginx-release-1.20.1/test/nginx-tests/js_async.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_async.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,184 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Async tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_async      set_timeout;
+    js_set $context_var     context_var;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /async_var {
+            return 200 $test_async;
+        }
+
+        location /shared_ctx {
+            add_header H $context_var;
+            js_content shared_ctx;
+        }
+
+        location /set_timeout {
+            js_content set_timeout;
+        }
+
+        location /set_timeout_many {
+            js_content set_timeout_many;
+        }
+
+        location /set_timeout_data {
+            postpone_output 0;
+            js_content set_timeout_data;
+        }
+
+        location /limit_rate {
+            postpone_output 0;
+            sendfile_max_chunk 5;
+            js_content limit_rate;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function set_timeout(r) {
+        var timerId = setTimeout(timeout_cb_r, 5, r, 0);
+        clearTimeout(timerId);
+        setTimeout(timeout_cb_r, 5, r, 0)
+    }
+
+    function set_timeout_data(r) {
+        setTimeout(timeout_cb_data, 5, r, 0);
+    }
+
+    function set_timeout_many(r) {
+        for (var i = 0; i < 5; i++) {
+            setTimeout(timeout_cb_empty, 5, r, i);
+        }
+
+        setTimeout(timeout_cb_reply, 10, r);
+    }
+
+    function timeout_cb_r(r, cnt) {
+        if (cnt == 10) {
+            r.status = 200;
+            r.headersOut['Content-Type'] = 'foo';
+            r.sendHeader();
+            r.finish();
+
+        } else {
+            setTimeout(timeout_cb_r, 5, r, ++cnt);
+        }
+    }
+
+    function timeout_cb_empty(r, arg) {
+        r.log("timeout_cb_empty" + arg);
+    }
+
+    function timeout_cb_reply(r) {
+        r.status = 200;
+        r.headersOut['Content-Type'] = 'reply';
+        r.sendHeader();
+        r.finish();
+    }
+
+    function timeout_cb_data(r, counter) {
+        if (counter == 0) {
+            r.log("timeout_cb_data: init");
+            r.status = 200;
+            r.sendHeader();
+            setTimeout(timeout_cb_data, 5, r, ++counter);
+
+        } else if (counter == 10) {
+            r.log("timeout_cb_data: finish");
+            r.finish();
+
+        } else {
+            r.send("" + counter);
+            setTimeout(timeout_cb_data, 5, r, ++counter);
+        }
+    }
+
+    var js_;
+    function context_var() {
+        return js_;
+    }
+
+    function shared_ctx(r) {
+        js_ = r.variables.arg_a;
+
+        r.status = 200;
+        r.sendHeader();
+        r.finish();
+    }
+
+    function limit_rate_cb(r) {
+        r.finish();
+    }
+
+    function limit_rate(r) {
+        r.status = 200;
+        r.sendHeader();
+        r.send("AAAAA".repeat(10))
+        setTimeout(limit_rate_cb, 1000, r);
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(7);
+
+###############################################################################
+
+like(http_get('/set_timeout'), qr/Content-Type: foo/, 'setTimeout');
+like(http_get('/set_timeout_many'), qr/Content-Type: reply/, 'setTimeout many');
+like(http_get('/set_timeout_data'), qr/123456789/, 'setTimeout data');
+like(http_get('/shared_ctx?a=xxx'), qr/H: xxx/, 'shared context');
+like(http_get('/limit_rate'), qr/A{50}/, 'limit_rate');
+
+http_get('/async_var');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'pending events') > 0,
+   'pending js events');
+ok(index($t->read_file('error.log'), 'async operation inside') > 0,
+   'async op in var handler');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_body_filter.t ../asynch_mode_nginx/test/nginx-tests/js_body_filter.t
--- nginx-release-1.20.1/test/nginx-tests/js_body_filter.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_body_filter.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, body filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /append {
+            js_body_filter test.append;
+            proxy_pass http://127.0.0.1:8081/source;
+        }
+
+        location /buffer_type {
+            js_body_filter test.buffer_type buffer_type=buffer;
+            proxy_pass http://127.0.0.1:8081/source;
+        }
+
+        location /forward {
+            js_body_filter test.forward buffer_type=string;
+            proxy_pass http://127.0.0.1:8081/source;
+        }
+
+        location /filter {
+            proxy_buffering off;
+            js_body_filter test.filter;
+            proxy_pass http://127.0.0.1:8081/source;
+        }
+
+        location /prepend {
+            js_body_filter test.prepend;
+            proxy_pass http://127.0.0.1:8081/source;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /source {
+            postpone_output 1;
+            js_content test.source;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function append(r, data, flags) {
+        r.sendBuffer(data, {last:false});
+
+        if (flags.last) {
+            r.sendBuffer("XXX", flags);
+        }
+    }
+
+    var collect = Buffer.from([]);
+    function buffer_type(r, data, flags) {
+        collect = Buffer.concat([collect, data]);
+
+        if (flags.last) {
+            r.sendBuffer(collect, flags);
+        }
+    }
+
+    function chain(chunks, i) {
+        if (i < chunks.length) {
+            chunks.r.send(chunks[i++]);
+            setTimeout(chunks.chain, chunks.delay, chunks, i);
+
+        } else {
+            chunks.r.finish();
+        }
+    }
+
+    function source(r) {
+        var chunks = ['AAA', 'BB', 'C', 'DDDD'];
+        chunks.delay = 5;
+        chunks.r = r;
+        chunks.chain = chain;
+
+        r.status = 200;
+        r.sendHeader();
+        chain(chunks, 0);
+    }
+
+    function filter(r, data, flags) {
+        if (flags.last || data.length >= Number(r.args.len)) {
+            r.sendBuffer(`\${data}|`, flags);
+
+            if (r.args.dup && !flags.last) {
+                r.sendBuffer(data, flags);
+            }
+        }
+    }
+
+    function forward(r, data, flags) {
+        r.sendBuffer(data, flags);
+    }
+
+    function prepend(r, data, flags) {
+        r.sendBuffer("XXX");
+        r.sendBuffer(data, flags);
+        r.done();
+    }
+
+    export default {njs: test_njs, append, buffer_type, filter, forward,
+                    prepend, source};
+
+EOF
+
+$t->try_run('no njs body filter')->plan(6);
+
+###############################################################################
+
+like(http_get('/append'), qr/AAABBCDDDDXXX/, 'append');
+like(http_get('/buffer_type'), qr/AAABBCDDDD/, 'buffer type');
+like(http_get('/forward'), qr/AAABBCDDDD/, 'forward');
+like(http_get('/filter?len=3'), qr/AAA|DDDD|/, 'filter 3');
+like(http_get('/filter?len=2&dup=1'), qr/AAA|AAABB|BBDDDD|DDDD/,
+    'filter 2 dup');
+like(http_get('/prepend'), qr/XXXAAABBCDDDD/, 'prepend');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_buffer.t ../asynch_mode_nginx/test/nginx-tests/js_buffer.t
--- nginx-release-1.20.1/test/nginx-tests/js_buffer.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_buffer.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,191 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, buffer properties.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require JSON::PP; };
+plan(skip_all => "JSON::PP not installed") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /return {
+            js_content test.return;
+        }
+
+        location /req_body {
+            js_content test.req_body;
+        }
+
+        location /res_body {
+            js_content test.res_body;
+        }
+
+        location /res_text {
+            js_content test.res_text;
+        }
+
+        location /binary_var {
+            js_content test.binary_var;
+        }
+
+        location /p/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /sub1 {
+            return 200 '{"a": {"b": 1}}';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_return(r) {
+        var body = Buffer.from("body: ");
+        body = Buffer.concat([body, Buffer.from(r.args.text)]);
+        r.return(200, body);
+    }
+
+    function req_body(r) {
+        var body = r.requestBuffer;
+        var view = new DataView(body.buffer);
+        view.setInt8(2, 'c'.charCodeAt(0));
+        r.return(200, JSON.parse(body).c.b);
+    }
+
+    function type(v) {return Buffer.isBuffer(v) ? 'buffer' : (typeof v);}
+
+    function res_body(r) {
+        r.subrequest('/p/sub1')
+        .then(reply => {
+            var body = reply.responseBuffer;
+            var view = new DataView(body.buffer);
+            view.setInt8(2, 'c'.charCodeAt(0));
+            body = JSON.parse(body);
+            body.type = type(reply.responseBuffer);
+            r.return(200, JSON.stringify(body));
+        })
+    }
+
+    function res_text(r) {
+        r.subrequest('/p/sub1')
+        .then(reply => {
+            var body = JSON.parse(reply.responseText);
+            body.type = type(reply.responseText);
+            r.return(200, JSON.stringify(body));
+        })
+    }
+
+    function binary_var(r) {
+        var test = r.rawVariables.binary_remote_addr
+                   .equals(Buffer.from([127,0,0,1]));
+        r.return(200, test);
+    }
+
+    export default {njs: test_njs, return: test_return, req_body, res_body,
+                    res_text, binary_var};
+
+EOF
+
+$t->try_run('no njs buffer')->plan(5);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+like(http_get('/return?text=FOO'), qr/200 OK.*body: FOO$/s,
+    'return buffer');
+like(http_post('/req_body'), qr/200 OK.*BAR$/s, 'request buffer');
+is(get_json('/res_body'), '{"c":{"b":1},"type":"buffer"}', 'response buffer');
+is(get_json('/res_text'), '{"a":{"b":1},"type":"string"}', 'response text');
+like(http_get('/binary_var'), qr/200 OK.*true$/s,
+    'binary var');
+
+}
+
+###############################################################################
+
+sub recode {
+    my $json;
+    eval { $json = JSON::PP::decode_json(shift) };
+
+    if ($@) {
+        return "<failed to parse JSON>";
+    }
+
+    JSON::PP->new()->canonical()->encode($json);
+}
+
+sub get_json {
+    http_get(shift) =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+    recode($1);
+}
+
+sub http_post {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 17" . CRLF .
+        CRLF .
+        "{\"a\":{\"b\":\"BAR\"}}";
+
+    return http($p, %extra);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_dump.t ../asynch_mode_nginx/test/nginx-tests/js_dump.t
--- nginx-release-1.20.1/test/nginx-tests/js_dump.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_dump.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, request object dump.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /dump {
+            js_content test_dump;
+        }
+
+        location /stringify {
+            js_content test_stringify;
+        }
+
+        location /stringify_subrequest {
+            js_content test_stringify_subrequest;
+        }
+
+        location /js_sub {
+            return 201 '{$request_method}';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_dump(r) {
+        r.headersOut.baz = 'bar';
+        r.return(200, njs.dump(r));
+    }
+
+    function test_stringify(r) {
+        r.headersOut.baz = 'bar';
+        var obj = JSON.parse(JSON.stringify(r));
+        r.return(200, JSON.stringify(obj));
+    }
+
+    function test_stringify_subrequest(r) {
+        r.subrequest('/js_sub', reply => {
+            r.return(200, JSON.stringify(reply))
+        });
+    }
+
+EOF
+
+$t->try_run('no njs dump')->plan(3);
+
+###############################################################################
+
+like(http(
+    'GET /dump?v=1&t=x HTTP/1.0' . CRLF
+    . 'Foo: bar' . CRLF
+    . 'Foo2: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/method:'GET'/, 'njs.dump(r)');
+
+like(http(
+    'GET /stringify?v=1&t=x HTTP/1.0' . CRLF
+    . 'Foo: bar' . CRLF
+    . 'Foo2: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/headersOut":\{"baz":"bar"}/, 'JSON.stringify(r)');
+
+like(http(
+    'GET /stringify_subrequest HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/"status":201/, 'JSON.stringify(reply)');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_fetch_resolver.t ../asynch_mode_nginx/test/nginx-tests/js_fetch_resolver.t
--- nginx-release-1.20.1/test/nginx-tests/js_fetch_resolver.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_fetch_resolver.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,235 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, fetch method, dns support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /dns {
+            js_content test.dns;
+
+            resolver   127.0.0.1:%%PORT_8981_UDP%%;
+            resolver_timeout 1s;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  aaa;
+
+        location /loc {
+            js_content test.loc;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  many;
+
+        location /loc {
+            js_content test.loc;
+        }
+    }
+}
+
+EOF
+
+my $p0 = port(8080);
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function dns(r) {
+        var url = `http://\${r.args.domain}:$p0/loc`;
+
+        ngx.fetch(url)
+        .then(reply => reply.text())
+        .then(body => r.return(200, body))
+        .catch(e => r.return(501, e.message))
+    }
+
+    function str(v) { return v ? v : ''};
+
+    function loc(r) {
+        var v = r.variables;
+        var body = str(r.requestText);
+        var foo = str(r.headersIn.foo);
+        var bar = str(r.headersIn.bar);
+        var c = r.headersIn.code ? Number(r.headersIn.code) : 200;
+        r.return(c, `\${v.host}:\${v.request_method}:\${foo}:\${bar}:\${body}`);
+    }
+
+     export default {njs: test_njs, dns, loc};
+EOF
+
+$t->try_run('no njs.fetch')->plan(3);
+
+$t->run_daemon(\&dns_daemon, port(8981), $t);
+$t->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.1';
+
+like(http_get('/dns?domain=aaa'), qr/aaa:GET:::$/s, 'fetch dns aaa');
+like(http_get('/dns?domain=many'), qr/many:GET:::$/s, 'fetch dns many');
+like(http_get('/dns?domain=unknown'), qr/"unknown" could not be resolved/s,
+    'fetch dns unknown');
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data, $port, %extra) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant FORMERR    => 1;
+    use constant SERVFAIL    => 2;
+    use constant NXDOMAIN    => 3;
+
+    use constant A        => 1;
+
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+
+    if ($name eq 'aaa' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq 'many' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.2');
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t, %extra) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($socket);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($socket == $fh) {
+                $fh->recv($recv_data, 65536);
+                $data = reply_handler($recv_data, $port);
+                $fh->send($data);
+
+            } else {
+                $fh->recv($recv_data, 65536);
+                unless (length $recv_data) {
+                    $sel->remove($fh);
+                    $fh->close;
+                    next;
+                }
+
+again:
+                my $len = unpack("n", $recv_data);
+                $data = substr $recv_data, 2, $len;
+                $data = reply_handler($data, $port, tcp => 1);
+                $data = pack("n", length $data) . $data;
+                $fh->send($data);
+                $recv_data = substr $recv_data, 2 + $len;
+                goto again if length $recv_data;
+            }
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_fetch.t ../asynch_mode_nginx/test/nginx-tests/js_fetch.t
--- nginx-release-1.20.1/test/nginx-tests/js_fetch.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_fetch.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,562 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, fetch method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require JSON::PP; };
+plan(skip_all => "JSON::PP not installed") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /broken {
+            js_content test.broken;
+        }
+
+        location /broken_response {
+            js_content test.broken_response;
+        }
+
+        location /body {
+            js_content test.body;
+        }
+
+        location /chain {
+            js_content test.chain;
+        }
+
+        location /chunked {
+            js_content test.chunked;
+        }
+
+        location /header {
+            js_content test.header;
+        }
+
+        location /multi {
+            js_content test.multi;
+        }
+
+        location /property {
+            js_content test.property;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  aaa;
+
+        location /loc {
+            js_content test.loc;
+        }
+
+        location /json { }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  bbb;
+
+        location /loc {
+            js_content test.loc;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  ccc;
+
+        location /loc {
+            js_content test.loc;
+        }
+    }
+}
+
+EOF
+
+my $p0 = port(8080);
+my $p1 = port(8081);
+my $p2 = port(8082);
+
+$t->write_file('json', '{"a":[1,2], "b":{"c":"FIELD"}}');
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function body(r) {
+        var loc = r.args.loc;
+        var getter = r.args.getter;
+
+        function query(obj) {
+            var path = r.args.path;
+            var retval = (getter == 'arrayBuffer') ? Buffer.from(obj).toString()
+                                                   : obj;
+
+            if (path) {
+                retval = path.split('.').reduce((a, v) => a[v], obj);
+            }
+
+            return JSON.stringify(retval);
+        }
+
+        ngx.fetch(`http://127.0.0.1:$p0/\${loc}`, {headers: {Host: 'aaa'}})
+        .then(reply => reply[getter]())
+        .then(data => r.return(200, query(data)))
+        .catch(e => r.return(501, e.message))
+    }
+
+    function property(r) {
+        var opts = {headers:{Host: 'aaa'}};
+
+        if (r.args.code) {
+            opts.headers.code = r.args.code;
+        }
+
+        var p = ngx.fetch('http://127.0.0.1:$p0/loc', opts)
+
+        if (r.args.readBody) {
+            p = p.then(rep =>
+                 rep.text().then(body => {rep.text = body; return rep;}))
+        }
+
+        p.then(reply => r.return(200, reply[r.args.pr]))
+        .catch(e => r.return(501, e.message))
+    }
+
+    function process_errors(r, tests) {
+        var results = [];
+
+        tests.forEach(args => {
+            ngx.fetch.apply(r, args)
+            .then(reply => {
+                r.return(400, '["unexpected then"]');
+            })
+            .catch(e => {
+                results.push(e.message);
+
+                if (results.length == tests.length) {
+                    results.sort();
+                    r.return(200, JSON.stringify(results));
+                }
+            })
+        })
+    }
+
+    function broken(r) {
+        var tests = [
+            ['http://127.0.0.1:1/loc'],
+            ['http://127.0.0.1:80800/loc'],
+            [Symbol.toStringTag],
+            ['https://127.0.0.1:$p0/loc'],
+        ];
+
+        return process_errors(r, tests);
+    }
+
+    function broken_response(r) {
+        var tests = [
+            ['http://127.0.0.1:$p2/status_line'],
+            ['http://127.0.0.1:$p2/length'],
+            ['http://127.0.0.1:$p2/header'],
+            ['http://127.0.0.1:$p2/headers'],
+            ['http://127.0.0.1:$p2/content_length'],
+        ];
+
+        return process_errors(r, tests);
+    }
+
+    function chain(r) {
+        var results = [];
+        var reqs = [
+             ['http://127.0.0.1:$p0/loc', {headers: {Host:'aaa'}}],
+             ['http://127.0.0.1:$p0/loc', {headers: {Host:'bbb'}}],
+           ];
+
+           function next(reply) {
+              if (reqs.length == 0) {
+                 r.return(200, "SUCCESS");
+                 return;
+              }
+
+              ngx.fetch.apply(r, reqs.pop())
+              .then(next)
+              .catch(e => r.return(400, e.message))
+           }
+
+           next();
+    }
+
+    function chunked(r) {
+        var results = [];
+        var tests = [
+            ['http://127.0.0.1:$p2/big', {max_response_body_size:128000}],
+            ['http://127.0.0.1:$p2/big/ok', {max_response_body_size:128000}],
+            ['http://127.0.0.1:$p2/chunked'],
+            ['http://127.0.0.1:$p2/chunked/ok'],
+            ['http://127.0.0.1:$p2/chunked/big', {max_response_body_size:128}],
+            ['http://127.0.0.1:$p2/chunked/big'],
+        ];
+
+        function collect(v) {
+            results.push(v);
+
+            if (results.length == tests.length) {
+                results.sort();
+                r.return(200, JSON.stringify(results));
+            }
+        }
+
+        tests.forEach(args => {
+            ngx.fetch.apply(r, args)
+            .then(reply => reply.text())
+            .then(body => collect(body.length))
+            .catch(e => collect(e.message))
+        })
+    }
+
+    function header(r) {
+        var url = `http://127.0.0.1:$p2/\${r.args.loc}`;
+        var method = r.args.method ? r.args.method : 'get';
+
+        var p = ngx.fetch(url)
+
+        if (r.args.readBody) {
+            p = p.then(rep =>
+                 rep.text().then(body => {rep.text = body; return rep;}))
+        }
+
+        p.then(reply => {
+            var h = reply.headers[method](r.args.h);
+            r.return(200, njs.dump(h));
+        })
+        .catch(e => r.return(501, e.message))
+    }
+
+    function multi(r) {
+        var results = [];
+        var tests = [
+             [
+              'http://127.0.0.1:$p0/loc',
+               { headers: {Code: 201, Host: 'aaa'}},
+             ],
+             [
+              'http://127.0.0.1:$p0/loc',
+               { method:'POST', headers: {Code: 401, Host: 'bbb'}, body: 'OK'},
+             ],
+             [
+              'http://127.0.0.1:$p1/loc',
+               { method:'PATCH',
+                 headers: {foo:undefined, bar:'xxx', Host: 'ccc'}},
+             ],
+           ];
+
+        function cmp(a,b) {
+            if (a.b > b.b) {return 1;}
+            if (a.b < b.b) {return -1;}
+            return 0
+        }
+
+        tests.forEach(args => {
+            ngx.fetch.apply(r, args)
+            .then(rep =>
+                 rep.text().then(body => {rep.text = body; return rep;}))
+            .then(rep => {
+                results.push({b:rep.text,
+                              c:rep.status,
+                              u:rep.url});
+
+                if (results.length == tests.length) {
+                    results.sort(cmp);
+                    r.return(200, JSON.stringify(results));
+                }
+            })
+            .catch(e => {
+                r.return(400, `["\${e.message}"]`);
+                throw e;
+            })
+        })
+
+        if (r.args.throw) {
+            throw 'Oops';
+        }
+    }
+
+    function str(v) { return v ? v : ''};
+
+    function loc(r) {
+        var v = r.variables;
+        var body = str(r.requestText);
+        var foo = str(r.headersIn.foo);
+        var bar = str(r.headersIn.bar);
+        var c = r.headersIn.code ? Number(r.headersIn.code) : 200;
+        r.return(c, `\${v.host}:\${v.request_method}:\${foo}:\${bar}:\${body}`);
+    }
+
+     export default {njs: test_njs, body, broken, broken_response,
+                     chain, chunked, header, multi, loc, property};
+EOF
+
+$t->try_run('no njs.fetch')->plan(27);
+
+$t->run_daemon(\&http_daemon, port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.1';
+
+like(http_get('/body?getter=arrayBuffer&loc=loc'), qr/200 OK.*"aaa:GET:::"$/s,
+    'fetch body arrayBuffer');
+like(http_get('/body?getter=text&loc=loc'), qr/200 OK.*"aaa:GET:::"$/s,
+    'fetch body text');
+like(http_get('/body?getter=json&loc=json&path=b.c'),
+    qr/200 OK.*"FIELD"$/s, 'fetch body json');
+like(http_get('/body?getter=json&loc=loc'), qr/501/s,
+    'fetch body json invalid');
+like(http_get('/property?pr=bodyUsed'), qr/false$/s,
+    'fetch bodyUsed false');
+like(http_get('/property?pr=bodyUsed&readBody=1'), qr/true$/s,
+    'fetch bodyUsed true');
+like(http_get('/property?pr=ok'), qr/200 OK.*true$/s,
+    'fetch ok true');
+like(http_get('/property?pr=ok&code=401'), qr/200 OK.*false$/s,
+    'fetch ok false');
+like(http_get('/property?pr=redirected'), qr/200 OK.*false$/s,
+    'fetch redirected false');
+like(http_get('/property?pr=statusText'), qr/200 OK.*OK$/s,
+    'fetch statusText OK');
+like(http_get('/property?pr=statusText&code=403'), qr/200 OK.*Forbidden$/s,
+    'fetch statusText Forbidden');
+like(http_get('/property?pr=type'), qr/200 OK.*basic$/s,
+    'fetch type');
+like(http_get('/header?loc=duplicate_header&h=BAR'), qr/200 OK.*c$/s,
+    'fetch header');
+like(http_get('/header?loc=duplicate_header&h=BARR'), qr/200 OK.*null$/s,
+    'fetch no header');
+like(http_get('/header?loc=duplicate_header&h=foo'), qr/200 OK.*a,b$/s,
+    'fetch header duplicate');
+like(http_get('/header?loc=duplicate_header&h=BAR&method=getAll'),
+    qr/200 OK.*\['c']$/s, 'fetch getAll header');
+like(http_get('/header?loc=duplicate_header&h=BARR&method=getAll'),
+    qr/200 OK.*\[]$/s, 'fetch getAll no header');
+like(http_get('/header?loc=duplicate_header&h=FOO&method=getAll'),
+    qr/200 OK.*\['a','b']$/s, 'fetch getAll duplicate');
+like(http_get('/header?loc=duplicate_header&h=bar&method=has'),
+    qr/200 OK.*true$/s, 'fetch header has');
+like(http_get('/header?loc=duplicate_header&h=buz&method=has'),
+    qr/200 OK.*false$/s, 'fetch header does not have');
+like(http_get('/header?loc=chunked/big&h=BAR&readBody=1'), qr/200 OK.*xxx$/s,
+    'fetch chunked header');
+is(get_json('/multi'),
+    '[{"b":"aaa:GET:::","c":201,"u":"http://127.0.0.1:'.$p0.'/loc"},' .
+    '{"b":"bbb:POST:::OK","c":401,"u":"http://127.0.0.1:'.$p0.'/loc"},' .
+    '{"b":"ccc:PATCH::xxx:","c":200,"u":"http://127.0.0.1:'.$p1.'/loc"}]',
+    'fetch multi');
+like(http_get('/multi?throw=1'), qr/500/s, 'fetch destructor');
+is(get_json('/broken'),
+    '[' .
+    '"connect failed",' .
+    '"failed to convert url arg",' .
+    '"invalid url",' .
+    '"unsupported URL prefix"]', 'fetch broken');
+is(get_json('/broken_response'),
+    '["invalid fetch content length",' .
+    '"invalid fetch header",' .
+    '"invalid fetch status line",' .
+    '"prematurely closed connection",' .
+    '"prematurely closed connection"]', 'fetch broken response');
+is(get_json('/chunked'),
+    '[10,100010,25500,' .
+    '"invalid fetch chunked response",' .
+    '"prematurely closed connection",' .
+    '"very large fetch chunked response"]', 'fetch chunked');
+like(http_get('/chain'), qr/200 OK.*SUCCESS$/s, 'fetch chain');
+
+###############################################################################
+
+sub recode {
+    my $json;
+    eval { $json = JSON::PP::decode_json(shift) };
+
+    if ($@) {
+        return "<failed to parse JSON>";
+    }
+
+    JSON::PP->new()->canonical()->encode($json);
+}
+
+sub get_json {
+    http_get(shift) =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+    recode($1);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my $port = shift;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . $port,
+        Listen => 5,
+        Reuse => 1
+    ) or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/status_line') {
+            print $client
+                "HTTP/1.1 2A";
+
+        } elsif ($uri eq '/content_length') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: " . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+
+        } elsif ($uri eq '/header') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "@#" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+
+        } elsif ($uri eq '/duplicate_header') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Foo: a" . CRLF .
+                "bar: c" . CRLF .
+                "Foo: b" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+
+        } elsif ($uri eq '/headers') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Connection: close" . CRLF;
+
+        } elsif ($uri eq '/length') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 100" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "unfinished" . CRLF;
+
+        } elsif ($uri eq '/big') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 100100" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+            for (1 .. 1000) {
+                print $client ("X" x 98) . CRLF;
+            }
+            print $client "unfinished" . CRLF;
+
+        } elsif ($uri eq '/big/ok') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 100010" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+            for (1 .. 1000) {
+                print $client ("X" x 98) . CRLF;
+            }
+            print $client "finished" . CRLF;
+
+        } elsif ($uri eq '/chunked') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "ff" . CRLF .
+                "unfinished" . CRLF;
+
+        } elsif ($uri eq '/chunked/ok') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "a" . CRLF .
+                "finished" . CRLF .
+                CRLF . "0" . CRLF . CRLF;
+        } elsif ($uri eq '/chunked/big') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Bar: xxx" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+
+            for (1 .. 100) {
+                print $client "ff" . CRLF . ("X" x 255) . CRLF;
+            }
+
+            print $client  "0" . CRLF . CRLF;
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_header_filter.t ../asynch_mode_nginx/test/nginx-tests/js_header_filter.t
--- nginx-release-1.20.1/test/nginx-tests/js_header_filter.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_header_filter.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, header filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /filter/ {
+            js_header_filter test.filter;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Set-Cookie "BB";
+            add_header Set-Cookie "CCCC";
+
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function filter(r) {
+        var cookies = r.headersOut['Set-Cookie'];
+        var len = r.args.len ? Number(r.args.len) : 0;
+        r.headersOut['Set-Cookie'] = cookies.filter(v=>v.length > len);
+    }
+
+    export default {njs: test_njs, filter};
+
+EOF
+
+$t->try_run('no njs header filter')->plan(2);
+
+###############################################################################
+
+like(http_get('/filter/?len=1'), qr/Set-Cookie: BB.*Set-Cookie: CCCC.*/ms,
+    'all');;
+unlike(http_get('/filter/?len=3'), qr/Set-Cookie: BB/,
+    'filter');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_headers.t ../asynch_mode_nginx/test/nginx-tests/js_headers.t
--- nginx-release-1.20.1/test/nginx-tests/js_headers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_headers.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,465 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, working with headers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_foo_in   test_foo_in;
+    js_set $test_ifoo_in  test_ifoo_in;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /content_length {
+            js_content content_length;
+        }
+
+        location /content_length_arr {
+            js_content content_length_arr;
+        }
+
+        location /content_length_keys {
+            js_content content_length_keys;
+        }
+
+        location /content_type {
+            charset windows-1251;
+
+            default_type text/plain;
+            js_content content_type;
+        }
+
+        location /content_type_arr {
+            charset windows-1251;
+
+            default_type text/plain;
+            js_content content_type_arr;
+        }
+
+        location /content_encoding {
+            js_content content_encoding;
+        }
+
+        location /content_encoding_arr {
+            js_content content_encoding_arr;
+        }
+
+        location /headers_list {
+            js_content headers_list;
+        }
+
+        location /foo_in {
+            return 200 $test_foo_in;
+        }
+
+        location /ifoo_in {
+            return 200 $test_ifoo_in;
+        }
+
+        location /hdr_in {
+            js_content hdr_in;
+        }
+
+        location /raw_hdr_in {
+            js_content raw_hdr_in;
+        }
+
+        location /hdr_out {
+            js_content hdr_out;
+        }
+
+        location /raw_hdr_out {
+            js_content raw_hdr_out;
+        }
+
+        location /hdr_out_array {
+            js_content hdr_out_array;
+        }
+
+        location /hdr_out_set_cookie {
+            js_content hdr_out_set_cookie;
+        }
+
+        location /hdr_out_single {
+            js_content hdr_out_single;
+        }
+
+        location /ihdr_out {
+            js_content ihdr_out;
+        }
+
+        location /hdr_sorted_keys {
+            js_content hdr_sorted_keys;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function content_length(r) {
+        r.headersOut['Content-Length'] = '';
+        r.headersOut['Content-Length'] = 3;
+        delete r.headersOut['Content-Length'];
+        r.headersOut['Content-Length'] = 3;
+        r.sendHeader();
+        r.send('XXX');
+        r.finish();
+    }
+
+    function content_length_arr(r) {
+        r.headersOut['Content-Length'] = [5];
+        r.headersOut['Content-Length'] = [];
+        r.headersOut['Content-Length'] = [4,3];
+        r.sendHeader();
+        r.send('XXX');
+        r.finish();
+    }
+
+    function content_length_keys(r) {
+        r.headersOut['Content-Length'] = 3;
+        var in_keys = Object.keys(r.headersOut).some(v=>v=='Content-Length');
+        r.return(200, `B:\${in_keys}`);
+    }
+
+    function content_type(r) {
+        r.headersOut['Content-Type'] = 'text/xml';
+        r.headersOut['Content-Type'] = '';
+        r.headersOut['Content-Type'] = 'text/xml; charset=';
+        delete r.headersOut['Content-Type'];
+        r.headersOut['Content-Type'] = 'text/xml; charset=utf-8';
+        r.headersOut['Content-Type'] = 'text/xml; charset="utf-8"';
+        var in_keys = Object.keys(r.headersOut).some(v=>v=='Content-Type');
+        r.return(200, `B:\${in_keys}`);
+    }
+
+    function content_type_arr(r) {
+        r.headersOut['Content-Type'] = ['text/html'];
+        r.headersOut['Content-Type'] = [];
+        r.headersOut['Content-Type'] = [ 'text/xml', 'text/html'];
+        r.return(200);
+    }
+
+    function content_encoding(r) {
+        r.headersOut['Content-Encoding'] = '';
+        r.headersOut['Content-Encoding'] = 'test';
+        delete r.headersOut['Content-Encoding'];
+        r.headersOut['Content-Encoding'] = 'gzip';
+        r.return(200);
+    }
+
+    function content_encoding_arr(r) {
+        r.headersOut['Content-Encoding'] = 'test';
+        r.headersOut['Content-Encoding'] = [];
+        r.headersOut['Content-Encoding'] = ['test', 'gzip'];
+        r.return(200);
+    }
+
+    function headers_list(r) {
+        for (var h in {a:1, b:2, c:3}) {
+            r.headersOut[h] = h;
+        }
+
+        delete r.headersOut.b;
+        r.headersOut.d = 'd';
+
+        var out = "";
+        for (var h in r.headersOut) {
+            out += h + ":";
+        }
+
+        r.return(200, out);
+    }
+
+    function hdr_in(r) {
+        var s = '', h;
+        for (h in r.headersIn) {
+            s += `\${h.toLowerCase()}: \${r.headersIn[h]}\n`;
+        }
+
+        r.return(200, s);
+    }
+
+    function raw_hdr_in(r) {
+        var filtered = r.rawHeadersIn
+                       .filter(v=>v[0].toLowerCase() == r.args.filter);
+        r.return(200, 'raw:' + filtered.map(v=>v[1]).join('|'));
+    }
+
+    function hdr_sorted_keys(r) {
+        var s = '';
+        var hdr = r.args.in ? r.headersIn : r.headersOut;
+
+        if (!r.args.in) {
+            r.headersOut.b = 'b';
+            r.headersOut.c = 'c';
+            r.headersOut.a = 'a';
+        }
+
+        r.return(200, Object.keys(hdr).sort());
+    }
+
+    function test_foo_in(r) {
+        return 'hdr=' + r.headersIn.foo;
+    }
+
+    function test_ifoo_in(r) {
+        var s = '', h;
+        for (h in r.headersIn) {
+            if (h.substr(0, 3) == 'foo') {
+                s += r.headersIn[h];
+            }
+        }
+        return s;
+    }
+
+    function hdr_out(r) {
+        r.status = 200;
+        r.headersOut['Foo'] = r.args.fOO;
+
+        if (r.args.bar) {
+            r.headersOut['Bar'] =
+                r.headersOut[(r.args.bar == 'empty' ? 'Baz' :'Foo')]
+        }
+
+        r.sendHeader();
+        r.finish();
+    }
+
+    function raw_hdr_out(r) {
+        r.headersOut.a = ['foo', 'bar'];
+        r.headersOut.b = 'b';
+
+        var filtered = r.rawHeadersOut
+                       .filter(v=>v[0].toLowerCase() == r.args.filter);
+        r.return(200, 'raw:' + filtered.map(v=>v[1]).join('|'));
+    }
+
+    function hdr_out_array(r) {
+        if (!r.args.hidden) {
+            r.headersOut['Foo'] = [r.args.fOO];
+            r.headersOut['Foo'] = [];
+            r.headersOut['Foo'] = ['bar', r.args.fOO];
+        }
+
+        if (r.args.scalar_set) {
+            r.headersOut['Foo'] = 'xxx';
+        }
+
+        r.return(200, `B:\${njs.dump(r.headersOut.foo)}`);
+    }
+
+    function hdr_out_single(r) {
+        r.headersOut.ETag = ['a', 'b'];
+        r.return(200, `B:\${njs.dump(r.headersOut.etag)}`);
+    }
+
+    function hdr_out_set_cookie(r) {
+        r.headersOut['Set-Cookie'] = [];
+        r.headersOut['Set-Cookie'] = ['a', 'b'];
+        delete r.headersOut['Set-Cookie'];
+        r.headersOut['Set-Cookie'] = 'e';
+        r.headersOut['Set-Cookie'] = ['c', '', null, 'd', 'f'];
+
+        r.return(200, `B:\${njs.dump(r.headersOut['Set-Cookie'])}`);
+    }
+
+    function ihdr_out(r) {
+        r.status = 200;
+        r.headersOut['a'] = r.args.a;
+        r.headersOut['b'] = r.args.b;
+
+        var s = '', h;
+        for (h in r.headersOut) {
+            s += r.headersOut[h];
+        }
+
+        r.sendHeader();
+        r.send(s);
+        r.finish();
+    }
+
+
+EOF
+
+$t->try_run('no njs')->plan(39);
+
+###############################################################################
+
+like(http_get('/content_length'), qr/Content-Length: 3/,
+    'set Content-Length');
+like(http_get('/content_type'), qr/Content-Type: text\/xml; charset="utf-8"\r/,
+    'set Content-Type');
+unlike(http_get('/content_type'), qr/Content-Type: text\/plain/,
+    'set Content-Type 2');
+like(http_get('/content_encoding'), qr/Content-Encoding: gzip/,
+    'set Content-Encoding');
+like(http_get('/headers_list'), qr/a:c:d/, 'headers list');
+
+like(http_get('/ihdr_out?a=12&b=34'), qr/^1234$/m, 'r.headersOut iteration');
+like(http_get('/ihdr_out'), qr/\x0d\x0a?\x0d\x0a?$/m, 'r.send zero');
+like(http_get('/hdr_out?foo=12345'), qr/Foo: 12345/, 'r.headersOut');
+like(http_get('/hdr_out?foo=123&bar=copy'), qr/Bar: 123/, 'r.headersOut get');
+unlike(http_get('/hdr_out?bar=empty'), qr/Bar:/, 'r.headersOut empty');
+unlike(http_get('/hdr_out?foo='), qr/Foo:/, 'r.headersOut no value');
+unlike(http_get('/hdr_out?foo'), qr/Foo:/, 'r.headersOut no value 2');
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.0';
+
+like(http_get('/content_length_keys'), qr/B:true/, 'Content-Length in keys');
+like(http_get('/content_length_arr'), qr/Content-Length: 3/,
+    'set Content-Length arr');
+
+like(http_get('/content_type'), qr/B:true/, 'Content-Type in keys');
+like(http_get('/content_type_arr'), qr/Content-Type: text\/html/,
+    'set Content-Type arr');
+like(http_get('/content_encoding_arr'), qr/Content-Encoding: gzip/,
+    'set Content-Encoding arr');
+
+like(http_get('/hdr_out_array?foo=12345'), qr/Foo: bar\r\nFoo: 12345/,
+    'r.headersOut arr');
+like(http_get('/hdr_out_array'), qr/Foo: bar/,
+    'r.headersOut arr last is empty');
+like(http_get('/hdr_out_array?foo=abc'), qr/B:bar,abc/,
+    'r.headersOut get');
+like(http_get('/hdr_out_array'), qr/B:bar/, 'r.headersOut get2');
+like(http_get('/hdr_out_array?hidden=1'), qr/B:undefined/,
+    'r.headersOut get3');
+like(http_get('/hdr_out_array?scalar_set=1'), qr/B:xxx/,
+    'r.headersOut scalar set');
+like(http_get('/hdr_out_single'), qr/ETag: a\r\nETag: b/,
+    'r.headersOut single');
+like(http_get('/hdr_out_single'), qr/B:a/,
+    'r.headersOut single get');
+like(http_get('/hdr_out_set_cookie'), qr/Set-Cookie: c\r\nSet-Cookie: d/,
+    'set_cookie');
+like(http_get('/hdr_out_set_cookie'), qr/B:\['c','d','f']/,
+    'set_cookie2');
+unlike(http_get('/hdr_out_set_cookie'), qr/Set-Cookie: [abe]/,
+    'set_cookie3');
+
+}
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'Cookie: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo/, 'r.headersIn cookie');
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'X-Forwarded-For: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/x-forwarded-for: foo/, 'r.headersIn xff');
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'Cookie: foo1' . CRLF
+    . 'Cookie: foo2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo1;\s?foo2/, 'r.headersIn cookie2');
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'X-Forwarded-For: foo1' . CRLF
+    . 'X-Forwarded-For: foo2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/x-forwarded-for: foo1,\s?foo2/, 'r.headersIn xff2');
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'ETag: bar1' . CRLF
+    . 'ETag: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/etag: bar1(?!,\s?bar2)/, 'r.headersIn duplicate single');
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'Content-Type: bar1' . CRLF
+    . 'Content-Type: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/content-type: bar1(?!,\s?bar2)/, 'r.headersIn duplicate single 2');
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.4.1';
+
+like(http(
+    'GET /hdr_in HTTP/1.0' . CRLF
+    . 'Foo: bar1' . CRLF
+    . 'Foo: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/foo: bar1,bar2/, 'r.headersIn duplicate generic');
+
+like(http(
+    'GET /raw_hdr_in?filter=foo HTTP/1.0' . CRLF
+    . 'foo: bar1' . CRLF
+    . 'Foo: bar2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/raw: bar1|bar2/, 'r.rawHeadersIn');
+
+like(http_get('/raw_hdr_out?filter=a'), qr/raw: foo|bar/, 'r.rawHeadersOut');
+
+}
+
+like(http(
+    'GET /hdr_sorted_keys?in=1 HTTP/1.0' . CRLF
+    . 'Cookie: foo1' . CRLF
+    . 'Accept: */*' . CRLF
+    . 'Cookie: foo2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/Accept,Cookie,Host/, 'r.headersIn sorted keys');
+
+like(http(
+    'GET /hdr_sorted_keys HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/a,b,c/, 'r.headersOut sorted keys');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_import.t ../asynch_mode_nginx/test/nginx-tests/js_import.t
--- nginx-release-1.20.1/test/nginx-tests/js_import.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_import.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (c) Nginx, Inc.
+
+# Tests for http njs module, js_import directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test foo.bar.p;
+
+    js_import lib.js;
+    js_import fun.js;
+    js_import foo from ./main.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content foo.version;
+        }
+
+        location /test_foo {
+            js_content foo.test;
+        }
+
+        location /test_lib {
+            js_content lib.test;
+        }
+
+        location /test_fun {
+            js_content fun;
+        }
+
+        location /test_var {
+            return 200 $test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('lib.js', <<EOF);
+    function test(r) {
+        r.return(200, "LIB-TEST");
+    }
+
+    export default {test};
+
+EOF
+
+$t->write_file('fun.js', <<EOF);
+    export default function (r) {r.return(200, "FUN-TEST")};
+
+EOF
+
+$t->write_file('main.js', <<EOF);
+    function version(r) {
+        r.return(200, njs.version);
+    }
+
+    function test(r) {
+        r.return(200, "MAIN-TEST");
+    }
+
+    export default {version, test, bar: {p(r) {return "P-TEST"}}};
+
+EOF
+
+$t->try_run('no njs available')->plan(4);
+
+###############################################################################
+
+like(http_get('/test_foo'), qr/MAIN-TEST/s, 'foo.test');
+like(http_get('/test_lib'), qr/LIB-TEST/s, 'lib.test');
+like(http_get('/test_fun'), qr/FUN-TEST/s, 'fun');
+like(http_get('/test_var'), qr/P-TEST/s, 'foo.bar.p');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_internal_redirect.t ../asynch_mode_nginx/test/nginx-tests/js_internal_redirect.t
--- nginx-release-1.20.1/test/nginx-tests/js_internal_redirect.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_internal_redirect.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, internalRedirect method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /test {
+            js_content test_redirect;
+        }
+
+        location /redirect {
+            internal;
+            return 200 redirect$arg_b;
+        }
+
+        location @named {
+            return 200 named;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_redirect(r) {
+        if (r.variables.arg_dest == 'named') {
+            r.internalRedirect('\@named');
+
+        } else {
+            if (r.variables.arg_a) {
+                r.internalRedirect('/redirect?b=' + r.variables.arg_a);
+
+            } else {
+                r.internalRedirect('/redirect');
+            }
+        }
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(3);
+
+###############################################################################
+
+like(http_get('/test'), qr/redirect/s, 'redirect');
+like(http_get('/test?a=A'), qr/redirectA/s, 'redirect with args');
+like(http_get('/test?dest=named'), qr/named/s, 'redirect to named location');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_modules.t ../asynch_mode_nginx/test/nginx-tests/js_modules.t
--- nginx-release-1.20.1/test/nginx-tests/js_modules.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_modules.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, ES6 import, export.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /test {
+            js_content test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    import m from 'module.js';
+
+    function test(r) {
+        r.return(200, m[r.args.fun](r.args.a, r.args.b));
+    }
+
+EOF
+
+$t->write_file('module.js', <<EOF);
+    function sum(a, b) {
+        return Number(a) + Number(b);
+    }
+
+    function prod(a, b) {
+        return Number(a) * Number(b);
+    }
+
+    export default {sum, prod};
+
+EOF
+
+
+$t->try_run('no njs modules')->plan(2);
+
+###############################################################################
+
+like(http_get('/test?fun=sum&a=3&b=4'), qr/7/s, 'test sum');
+like(http_get('/test?fun=prod&a=3&b=4'), qr/12/s, 'test prod');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_ngx.t ../asynch_mode_nginx/test/nginx-tests/js_ngx.t
--- nginx-release-1.20.1/test/nginx-tests/js_ngx.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_ngx.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,101 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, ngx object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /log {
+            js_content test.log;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function level(r) {
+        switch (r.args.level) {
+        case 'INFO': return ngx.INFO;
+        case 'WARN': return ngx.WARN;
+        case 'ERR': return ngx.ERR;
+        default:
+            throw Error(`Unknown log level:"\${r.args.level}"`);
+        }
+    }
+
+    function log(r) {
+        ngx.log(level(r), `ngx.log:\${r.args.text}`);
+        r.return(200);
+    }
+
+    export default {njs: test_njs, log};
+
+EOF
+
+$t->try_run('no njs ngx')->plan(3);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+http_get('/log?level=INFO&text=FOO');
+http_get('/log?level=WARN&text=BAR');
+http_get('/log?level=ERR&text=BAZ');
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/\[info\].*ngx.log:FOO/, 'ngx.log info');
+like($t->read_file('error.log'), qr/\[warn\].*ngx.log:BAR/, 'ngx.log warn');
+like($t->read_file('error.log'), qr/\[error\].*ngx.log:BAZ/, 'ngx.log err');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_object.t ../asynch_mode_nginx/test/nginx-tests/js_object.t
--- nginx-release-1.20.1/test/nginx-tests/js_object.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_object.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,135 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, request object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /to_string {
+            js_content to_string;
+        }
+
+        location /define_prop {
+            js_content define_prop;
+        }
+
+        location /in_operator {
+            js_content in_operator;
+        }
+
+        location /redefine_bind {
+            js_content redefine_bind;
+        }
+
+        location /redefine_proxy {
+            js_content redefine_proxy;
+        }
+
+        location /redefine_proto {
+            js_content redefine_proto;
+        }
+
+        location /get_own_prop_descs {
+            js_content get_own_prop_descs;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function to_string(r) {
+        r.return(200, r.toString());
+    }
+
+    function define_prop(r) {
+        Object.defineProperty(r.headersOut, 'Foo', {value:'bar'});
+        r.return(200);
+    }
+
+    function in_operator(r) {
+        r.return(200, ['Foo', 'Bar'].map(v=>v in r.headersIn)
+                      .toString() === 'true,false');
+    }
+
+    function redefine_bind(r) {
+        r.return = r.return.bind(r, 200);
+        r.return('redefine_bind');
+    }
+
+    function redefine_proxy(r) {
+        r.return_orig = r.return;
+        r.return = function (body) { this.return_orig(200, body);}
+        r.return('redefine_proxy');
+    }
+
+    function redefine_proto(r) {
+        r[0] = 'a';
+        r[1] = 'b';
+        r.length = 2;
+        Object.setPrototypeOf(r, Array.prototype);
+        r.return(200, r.join('|'));
+    }
+
+    function get_own_prop_descs(r) {
+        r.return(200,
+                 Object.getOwnPropertyDescriptors(r)['log'].value === r.log);
+    }
+
+EOF
+
+$t->try_run('no njs request object')->plan(7);
+
+###############################################################################
+
+like(http_get('/to_string'), qr/\[object Request\]/, 'toString');
+like(http_get('/define_prop'), qr/Foo: bar/, 'define_prop');
+like(http(
+    'GET /in_operator HTTP/1.0' . CRLF
+    . 'Foo: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/true/, 'in_operator');
+like(http_get('/redefine_bind'), qr/redefine_bind/, 'redefine_bind');
+like(http_get('/redefine_proxy'), qr/redefine_proxy/, 'redefine_proxy');
+like(http_get('/redefine_proto'), qr/a|b/, 'redefine_proto');
+like(http_get('/get_own_prop_descs'), qr/true/, 'get_own_prop_descs');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_paths.t ../asynch_mode_nginx/test/nginx-tests/js_paths.t
--- nginx-release-1.20.1/test/nginx-tests/js_paths.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_paths.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, js_path directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_path "%%TESTDIR%%/lib1";
+    js_path "lib2";
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /test {
+            js_content test;
+        }
+
+        location /test2 {
+            js_content test2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    import m1 from 'module1.js';
+    import m2 from 'module2.js';
+    import m3 from 'lib1/module1.js';
+
+    function test(r) {
+        r.return(200, m1[r.args.fun](r.args.a, r.args.b));
+    }
+
+    function test2(r) {
+        r.return(200, m2.sum(r.args.a, r.args.b));
+    }
+
+    function test3(r) {
+        r.return(200, m3.sum(r.args.a, r.args.b));
+    }
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/lib1");
+mkdir("$d/lib2");
+
+$t->write_file('lib1/module1.js', <<EOF);
+    function sum(a, b) { return Number(a) + Number(b); }
+    function prod(a, b) { return Number(a) * Number(b); }
+
+    export default {sum, prod};
+
+EOF
+
+$t->write_file('lib2/module2.js', <<EOF);
+    function sum(a, b) { return a + b; }
+
+    export default {sum};
+
+EOF
+
+
+$t->try_run('no njs available')->plan(4);
+
+###############################################################################
+
+like(http_get('/test?fun=sum&a=3&b=4'), qr/7/s, 'test sum');
+like(http_get('/test?fun=prod&a=3&b=4'), qr/12/s, 'test prod');
+like(http_get('/test2?a=3&b=4'), qr/34/s, 'test2');
+like(http_get('/test2?a=A&b=B'), qr/AB/s, 'test2 relative');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_promise.t ../asynch_mode_nginx/test/nginx-tests/js_promise.t
--- nginx-release-1.20.1/test/nginx-tests/js_promise.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_promise.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,207 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Promise tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /promise {
+            js_content promise;
+        }
+
+        location /promise_throw {
+            js_content promise_throw;
+        }
+
+        location /promise_pure {
+            js_content promise_pure;
+        }
+
+        location /timeout {
+            js_content timeout;
+        }
+
+        location /sub_token {
+            js_content sub_token;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    var global_token = '';
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function promise(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=a')
+        .then(reply => {
+            var data = JSON.parse(reply.responseBody);
+
+            if (data['token'] !== "a") {
+                throw new Error('token is not "a"');
+            }
+
+            return data['token'];
+        })
+        .then(token => {
+            promisified_subrequest(r, '/sub_token', 'code=200&token=b')
+            .then(reply => {
+                var data = JSON.parse(reply.responseBody);
+
+                r.return(200, '{"token": "' + data['token'] + '"}');
+            })
+            .catch(() => {
+                throw new Error("failed promise() test");
+            });
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function promise_throw(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=x')
+        .then(reply => {
+            var data = JSON.parse(reply.responseBody);
+
+            if (data['token'] !== "a") {
+                throw data['token'];
+            }
+
+            return data['token'];
+        })
+        .then(() => {
+            r.return(500);
+        })
+        .catch(token => {
+            r.return(200, '{"token": "' + token + '"}');
+        });
+    }
+
+    function promise_pure(r) {
+        var count = 0;
+
+        Promise.resolve(true)
+        .then(() => count++)
+        .then(() => not_exist_ref)
+        .finally(() => count++)
+        .catch(() => {
+            r.return((count != 2) ? 500 : 200);
+        });
+    }
+
+    function timeout(r) {
+        promisified_subrequest(r, '/sub_token', 'code=200&token=R')
+        .then(reply => JSON.parse(reply.responseBody))
+        .then(data => {
+            setTimeout(timeout_cb, 50, r, '/sub_token', 'code=200&token=T');
+            return data;
+        })
+        .then(data => {
+            setTimeout(timeout_cb, 1, r, '/sub_token', 'code=200&token='
+                                                        + data['token']);
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function timeout_cb(r, url, args) {
+        promisified_subrequest(r, url, args)
+        .then(reply => {
+            if (global_token == '') {
+                var data = JSON.parse(reply.responseBody);
+
+                global_token = data['token'];
+
+                r.return(200, '{"token": "' + data['token'] + '"}');
+            }
+        })
+        .catch(() => {
+            r.return(500);
+        });
+    }
+
+    function promisified_subrequest(r, uri, args) {
+        return new Promise((resolve, reject) => {
+            r.subrequest(uri, args, (reply) => {
+                if (reply.status < 400) {
+                    resolve(reply);
+                } else {
+                    reject(reply);
+                }
+            });
+        })
+    }
+
+    function sub_token(r) {
+        var code = r.variables.arg_code;
+        var token = r.variables.arg_token;
+
+        r.return(parseInt(code), '{"token": "'+ token +'"}');
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(4);
+
+###############################################################################
+
+like(http_get('/promise'), qr/{"token": "b"}/, "Promise");
+like(http_get('/promise_throw'), qr/{"token": "x"}/, "Promise throw and catch");
+like(http_get('/timeout'), qr/{"token": "R"}/, "Promise with timeout");
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+like(http_get('/promise_pure'), qr/200 OK/, "events handling");
+}
+
+$t->todo_alerts() unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_request_body.t ../asynch_mode_nginx/test/nginx-tests/js_request_body.t
--- nginx-release-1.20.1/test/nginx-tests/js_request_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_request_body.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, r.requestBody method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /body {
+            js_content test_body;
+        }
+
+        location /in_file {
+            client_body_in_file_only on;
+            js_content test_body;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_body(r) {
+        try {
+            var body = r.requestBody;
+            r.return(200, body);
+
+        } catch (e) {
+            r.return(500, e.message);
+        }
+    }
+
+EOF
+
+$t->try_run('no njs request body')->plan(3);
+
+###############################################################################
+
+like(http_post('/body'), qr/REQ-BODY/, 'request body');
+like(http_post('/in_file'), qr/request body is in a file/,
+    'request body in file');
+like(http_post_big('/body'), qr/200.*^(1234567890){1024}$/ms,
+        'request body big');
+
+###############################################################################
+
+sub http_post {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 8" . CRLF .
+        CRLF .
+        "REQ-BODY";
+
+    return http($p, %extra);
+}
+
+sub http_post_big {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10240" . CRLF .
+        CRLF .
+        ("1234567890" x 1024);
+
+    return http($p, %extra);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_return.t ../asynch_mode_nginx/test/nginx-tests/js_return.t
--- nginx-release-1.20.1/test/nginx-tests/js_return.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_return.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http njs module, return method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Config;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            js_content test_return;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_return(r) {
+        r.return(Number(r.args.c), r.args.t);
+    }
+
+EOF
+
+$t->try_run('no njs return')->plan(5);
+
+###############################################################################
+
+like(http_get('/?c=200'), qr/200 OK.*\x0d\x0a?\x0d\x0a?$/s, 'return code');
+like(http_get('/?c=200&t=SEE-THIS'), qr/200 OK.*^SEE-THIS$/ms, 'return text');
+like(http_get('/?c=301&t=path'), qr/ 301 .*Location: path/s, 'return redirect');
+like(http_get('/?c=404'), qr/404 Not.*html/s, 'return error page');
+like(http_get('/?c=inv'), qr/ 500 /, 'return invalid');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_subrequests.t ../asynch_mode_nginx/test/nginx-tests/js_subrequests.t
--- nginx-release-1.20.1/test/nginx-tests/js_subrequests.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_subrequests.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,645 @@
+#!/usr/bin/perl
+#
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev.
+# (C) Nginx, Inc.
+
+# Tests for subrequests in http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require JSON::PP; };
+plan(skip_all => "JSON::PP not installed") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy cache/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1
+                       keys_zone=ON:1m      use_temp_path=on;
+
+    js_include test.js;
+
+    js_set $async_var       async_var;
+    js_set $subrequest_var  subrequest_var;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /sr {
+            js_content sr;
+        }
+
+        location /sr_pr {
+            js_content sr_pr;
+        }
+
+        location /sr_args {
+            js_content sr_args;
+        }
+
+        location /sr_options_args {
+            js_content sr_options_args;
+        }
+
+        location /sr_options_args_pr {
+            js_content sr_options_args_pr;
+        }
+
+        location /sr_options_method {
+            js_content sr_options_method;
+        }
+
+        location /sr_options_method_pr {
+            js_content sr_options_method_pr;
+        }
+
+        location /sr_options_body {
+            js_content sr_options_body;
+        }
+
+        location /sr_options_method_head {
+            js_content sr_options_method_head;
+        }
+
+        location /sr_body {
+            js_content sr_body;
+        }
+
+        location /sr_body_pr {
+            js_content sr_body_pr;
+        }
+
+        location /sr_body_special {
+            js_content sr_body_special;
+        }
+
+        location /sr_in_variable_handler {
+            set $_ $async_var;
+            js_content sr_in_variable_handler;
+        }
+
+        location /sr_detached_in_variable_handler {
+            return 200 $subrequest_var;
+        }
+
+        location /sr_async_var {
+            set $_ $async_var;
+            error_page 404 /return;
+            return 404;
+        }
+
+        location /sr_error_page {
+            js_content sr_error_page;
+        }
+
+        location /sr_js_in_subrequest {
+            js_content sr_js_in_subrequest;
+        }
+
+        location /sr_js_in_subrequest_pr {
+            js_content sr_js_in_subrequest_pr;
+        }
+
+        location /sr_file {
+            js_content sr_file;
+        }
+
+        location /sr_cache {
+            js_content sr_cache;
+        }
+
+
+        location /sr_unavail {
+            js_content sr_unavail;
+        }
+
+        location /sr_unavail_pr {
+            js_content sr_unavail_pr;
+        }
+
+        location /sr_broken {
+            js_content sr_broken;
+        }
+
+        location /sr_too_large {
+            js_content sr_too_large;
+        }
+
+        location /sr_out_of_order {
+            js_content sr_out_of_order;
+        }
+
+        location /sr_except_not_a_func {
+            js_content sr_except_not_a_func;
+        }
+
+        location /sr_except_failed_to_convert_options_arg {
+            js_content sr_except_failed_to_convert_options_arg;
+        }
+
+        location /sr_except_invalid_options_header_only {
+            js_content sr_except_invalid_options_header_only;
+        }
+
+        location /sr_in_sr_callback {
+            js_content sr_in_sr_callback;
+        }
+
+        location /sr_uri_except {
+            js_content sr_uri_except;
+        }
+
+
+        location /file/ {
+            alias %%TESTDIR%%/;
+        }
+
+        location /p/ {
+            proxy_cache $arg_c;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /daemon/ {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+
+        location /too_large/ {
+            subrequest_output_buffer_size 3;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        location /sr_in_sr {
+            js_content sr_in_sr;
+        }
+
+        location /unavail {
+            proxy_pass http://127.0.0.1:8084/;
+        }
+
+        location /sr_parent {
+             js_content sr_parent;
+        }
+
+        location /js_sub {
+            js_content js_sub;
+        }
+
+        location /return {
+            return 200 '["$request_method"]';
+        }
+
+        location /error_page_404 {
+            return 404;
+
+            error_page 404 /404.html;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /sub1 {
+            add_header H $arg_h;
+            return 206 '{"a": {"b": 1}}';
+        }
+
+        location /sub2 {
+            return 404 '{"e": "msg"}';
+        }
+
+        location /method {
+            return 200 '["$request_method"]';
+        }
+
+        location /body {
+            js_content body;
+        }
+
+        location /detached {
+            js_content detached;
+        }
+
+        location /delayed {
+            js_content delayed;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        return 444;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    this.Failed = {get toConvert() { return {toString(){return {};}}}};
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function sr(r) {
+        subrequest_fn(r, ['/p/sub2'], ['uri', 'status'])
+    }
+
+    function sr_pr(r) {
+        r.subrequest('/p/sub1', 'h=xxx')
+        .then(reply => r.return(200, JSON.stringify({h:reply.headersOut.h})))
+    }
+
+    function sr_args(r) {
+        r.subrequest('/p/sub1', 'h=xxx', reply => {
+            r.return(200, JSON.stringify({h:reply.headersOut.h}));
+        });
+    }
+
+    function sr_options_args(r) {
+        r.subrequest('/p/sub1', {args:'h=xxx'}, reply => {
+            r.return(200, JSON.stringify({h:reply.headersOut.h}));
+        });
+    }
+
+    function sr_options_args_pr(r) {
+        r.subrequest('/p/sub1', {args:'h=xxx'})
+        .then(reply => r.return(200, JSON.stringify({h:reply.headersOut.h})))
+    }
+
+    function sr_options_method(r) {
+        r.subrequest('/p/method', {method:r.args.m}, body_fwd_cb);
+    }
+
+    function sr_options_method_pr(r) {
+        r.subrequest('/p/method', {method:r.args.m})
+        .then(body_fwd_cb);
+    }
+
+    function sr_options_body(r) {
+        r.subrequest('/p/body', {method:'POST', body:'["REQ-BODY"]'},
+                     body_fwd_cb);
+    }
+
+    function sr_options_method_head(r) {
+        r.subrequest('/p/method', {method:'HEAD'}, reply => {
+            r.return(200, JSON.stringify({c:reply.status}));
+        });
+    }
+
+    function sr_body(r) {
+        r.subrequest('/p/sub1', body_fwd_cb);
+    }
+
+    function sr_body_pr(r) {
+        r.subrequest('/p/sub1')
+        .then(body_fwd_cb);
+    }
+
+    function sr_body_special(r) {
+        r.subrequest('/p/sub2', body_fwd_cb);
+    }
+
+    function body(r) {
+        r.return(200, r.variables.request_body);
+    }
+
+    function delayed(r) {
+        setTimeout(r => r.return(200), 100, r);
+    }
+
+    function detached(r) {
+        var method = r.variables.request_method;
+        r.log(`DETACHED: \${method} args: \${r.variables.args}`);
+
+        r.return(200);
+    }
+
+    function sr_in_variable_handler(r) {
+    }
+
+    function async_var(r) {
+        r.subrequest('/p/delayed', reply => {
+            r.return(200, JSON.stringify(["CB-VAR"]));
+        });
+
+        return "";
+    }
+
+    function sr_error_page(r) {
+         r.subrequest('/error_page_404')
+         .then(reply => {r.return(200, `reply.status:\${reply.status}`)});
+    }
+
+    function subrequest_var(r) {
+        r.subrequest('/p/detached',  {detached:true});
+        r.subrequest('/p/detached',  {detached:true, args:'a=yyy',
+                                      method:'POST'});
+
+        return "subrequest_var";
+    }
+
+    function sr_file(r) {
+        r.subrequest('/file/t', body_fwd_cb);
+    }
+
+    function sr_cache(r) {
+        r.subrequest('/p/t', body_fwd_cb);
+    }
+
+    function sr_unavail(req) {
+        subrequest_fn(req, ['/unavail'], ['uri', 'status']);
+    }
+
+    function sr_unavail_pr(req) {
+        subrequest_fn_pr(req, ['/unavail'], ['uri', 'status']);
+    }
+
+    function sr_broken(r) {
+        r.subrequest('/daemon/unfinished', reply => {
+            r.return(200, JSON.stringify({code:reply.status}));
+        });
+    }
+
+    function sr_too_large(r) {
+        r.subrequest('/too_large/t', body_fwd_cb);
+    }
+
+    function sr_in_sr(r) {
+        r.subrequest('/sr', body_fwd_cb);
+    }
+
+    function sr_js_in_subrequest(r) {
+        r.subrequest('/js_sub', body_fwd_cb);
+    }
+
+    function sr_js_in_subrequest_pr(r) {
+        r.subrequest('/js_sub')
+        .then(body_fwd_cb);
+    }
+
+    function sr_in_sr_callback(r) {
+        r.subrequest('/return', function (reply) {
+                try {
+                    reply.subrequest('/return');
+
+                } catch (err) {
+                    r.return(200, JSON.stringify({e:err.message}));
+                    return;
+                }
+
+                r.return(200);
+            });
+    }
+
+    function sr_parent(r) {
+        try {
+            var parent = r.parent;
+
+        } catch (err) {
+            r.return(200, JSON.stringify({e:err.message}));
+            return;
+        }
+
+        r.return(200);
+    }
+
+    function sr_out_of_order(r) {
+        subrequest_fn(r, ['/p/delayed', '/p/sub1', '/unknown'],
+                      ['uri', 'status']);
+    }
+
+    function collect(replies, props, total, reply) {
+        reply.log(`subrequest handler: \${reply.uri} status: \${reply.status}`)
+
+        var rep = {};
+        props.forEach(p => {rep[p] = reply[p]});
+
+        replies.push(rep);
+
+        if (replies.length == total) {
+            reply.parent.return(200, JSON.stringify(replies));
+        }
+    }
+
+    function subrequest_fn(r, subs, props) {
+        var replies = [];
+
+        subs.forEach(sr =>
+                     r.subrequest(sr, collect.bind(null, replies,
+                                                   props, subs.length)));
+    }
+
+    function subrequest_fn_pr(r, subs, props) {
+        var replies = [];
+
+        subs.forEach(sr => r.subrequest(sr)
+            .then(collect.bind(null, replies, props, subs.length)));
+    }
+
+    function sr_except_not_a_func(r) {
+        r.subrequest('/sub1', 'a=1', 'b');
+    }
+
+    function sr_except_failed_to_convert_options_arg(r) {
+        r.subrequest('/sub1', {args:Failed.toConvert}, ()=>{});
+    }
+
+    function sr_uri_except(r) {
+        r.subrequest(Failed.toConvert, 'a=1', 'b');
+    }
+
+    function body_fwd_cb(r) {
+        r.parent.return(200, JSON.stringify(JSON.parse(r.responseBody)));
+    }
+
+    function js_sub(r) {
+        r.return(200, '["JS-SUB"]');
+    }
+
+EOF
+
+$t->write_file('t', '["SEE-THIS"]');
+
+$t->try_run('no njs available')->plan(32);
+$t->run_daemon(\&http_daemon);
+
+###############################################################################
+
+is(get_json('/sr'), '[{"status":404,"uri":"/p/sub2"}]', 'sr');
+is(get_json('/sr_args'), '{"h":"xxx"}', 'sr_args');
+is(get_json('/sr_options_args'), '{"h":"xxx"}', 'sr_options_args');
+is(get_json('/sr_options_method?m=POST'), '["POST"]', 'sr method POST');
+is(get_json('/sr_options_method?m=PURGE'), '["PURGE"]', 'sr method PURGE');
+is(get_json('/sr_options_body'), '["REQ-BODY"]', 'sr_options_body');
+is(get_json('/sr_options_method_head'), '{"c":200}', 'sr_options_method_head');
+is(get_json('/sr_body'), '{"a":{"b":1}}', 'sr_body');
+is(get_json('/sr_body_special'), '{"e":"msg"}', 'sr_body_special');
+is(get_json('/sr_in_variable_handler'), '["CB-VAR"]', 'sr_in_variable_handler');
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio (on|threads)/
+    and !$t->has_version('1.17.9');
+
+TODO: {
+local $TODO = 'header already sent' if $t->read_file('nginx.conf') =~ /aio on/
+    and !$t->has_version('1.17.9');
+local $TODO = 'open socket left' if $t->read_file('nginx.conf') =~ /aio thread/
+    and !$t->has_version('1.17.9');
+
+is(get_json('/sr_file'), '["SEE-THIS"]', 'sr_file');
+
+}
+
+is(get_json('/sr_cache?c=1'), '["SEE-THIS"]', 'sr_cache');
+is(get_json('/sr_cache?c=1'), '["SEE-THIS"]', 'sr_cached');
+is(get_json('/sr_js_in_subrequest'), '["JS-SUB"]', 'sr_js_in_subrequest');
+is(get_json('/sr_unavail'), '[{"status":502,"uri":"/unavail"}]',
+    'sr_unavail');
+is(get_json('/sr_out_of_order'),
+    '[{"status":404,"uri":"/unknown"},' .
+    '{"status":206,"uri":"/p/sub1"},' .
+    '{"status":200,"uri":"/p/delayed"}]',
+    'sr_multi');
+
+is(get_json('/sr_pr'), '{"h":"xxx"}', 'sr_promise');
+is(get_json('/sr_options_args_pr'), '{"h":"xxx"}', 'sr_options_args_pr');
+is(get_json('/sr_options_method_pr?m=PUT'), '["PUT"]', 'sr method PUT');
+is(get_json('/sr_body_pr'), '{"a":{"b":1}}', 'sr_body_pr');
+is(get_json('/sr_js_in_subrequest_pr'), '["JS-SUB"]', 'sr_js_in_subrequest_pr');
+is(get_json('/sr_unavail_pr'), '[{"status":502,"uri":"/unavail"}]',
+    'sr_unavail_pr');
+
+like(http_get('/sr_detached_in_variable_handler'), qr/subrequest_var/,
+     'sr_detached_in_variable_handler');
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+    or http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+like(http_get('/sr_error_page'), qr/reply\.status:404/,
+     'sr_error_page');
+
+}
+
+http_get('/sr_broken');
+http_get('/sr_in_sr');
+http_get('/sr_in_variable_handler');
+http_get('/sr_async_var');
+http_get('/sr_too_large');
+http_get('/sr_except_not_a_func');
+http_get('/sr_except_failed_to_convert_options_arg');
+http_get('/sr_uri_except');
+
+is(get_json('/sr_in_sr_callback'),
+    '{"e":"subrequest can only be created for the primary request"}',
+    'subrequest for non-primary request');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'callback is not a function') > 0,
+    'subrequest cb exception');
+ok(index($t->read_file('error.log'), 'failed to convert uri arg') > 0,
+    'subrequest uri exception');
+ok(index($t->read_file('error.log'), 'failed to convert options.args') > 0,
+    'subrequest invalid args exception');
+ok(index($t->read_file('error.log'), 'too big subrequest response') > 0,
+    'subrequest too large body');
+ok(index($t->read_file('error.log'), 'subrequest creation failed') > 0,
+    'subrequest creation failed');
+ok(index($t->read_file('error.log'),
+        'js subrequest: failed to get the parent context') > 0,
+    'zero parent ctx');
+
+ok(index($t->read_file('error.log'), 'DETACHED') > 0,
+    'detached subrequest');
+
+###############################################################################
+
+sub recode {
+    my $json;
+    eval { $json = JSON::PP::decode_json(shift) };
+
+    if ($@) {
+        return "<failed to parse JSON>";
+    }
+
+    JSON::PP->new()->canonical()->encode($json);
+}
+
+sub get_json {
+    http_get(shift) =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+    recode($1);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8082),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/unfinished') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Content-Length: 100" . CRLF .
+                CRLF .
+                "unfinished" . CRLF;
+            close($client);
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js.t ../asynch_mode_nginx/test/nginx-tests/js.t
--- nginx-release-1.20.1/test/nginx-tests/js.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js.t	2022-03-15 13:23:40.576403156 -0500
@@ -0,0 +1,391 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Roman Arutyunyan
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_method   test_method;
+    js_set $test_version  test_version;
+    js_set $test_addr     test_addr;
+    js_set $test_uri      test_uri;
+    js_set $test_arg      test_arg;
+    js_set $test_iarg     test_iarg;
+    js_set $test_var      test_var;
+    js_set $test_type     test_type;
+    js_set $test_global   test_global;
+    js_set $test_log      test_log;
+    js_set $test_except   test_except;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /method {
+            return 200 $test_method;
+        }
+
+        location /version {
+            return 200 $test_version;
+        }
+
+        location /addr {
+            return 200 $test_addr;
+        }
+
+        location /uri {
+            return 200 $test_uri;
+        }
+
+        location /arg {
+            return 200 $test_arg;
+        }
+
+        location /iarg {
+            return 200 $test_iarg;
+        }
+
+        location /var {
+            return 200 $test_var;
+        }
+
+        location /global {
+            return 200 $test_global;
+        }
+
+        location /body {
+            js_content request_body;
+        }
+
+        location /in_file {
+            client_body_in_file_only on;
+            js_content request_body;
+        }
+
+        location /status {
+            js_content status;
+        }
+
+        location /request_body {
+            js_content request_body;
+        }
+
+        location /request_body_cache {
+            js_content request_body_cache;
+        }
+
+        location /send {
+            js_content send;
+        }
+
+        location /return_method {
+            js_content return_method;
+        }
+
+        location /arg_keys {
+            js_content arg_keys;
+        }
+
+        location /type {
+            js_content test_type;
+        }
+
+        location /log {
+            return 200 $test_log;
+        }
+
+        location /except {
+            return 200 $test_except;
+        }
+
+        location /content_except {
+            js_content content_except;
+        }
+
+        location /content_empty {
+            js_content content_empty;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    var global = ['n', 'j', 's'].join("");
+
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function test_method(r) {
+        return 'method=' + r.method;
+    }
+
+    function test_version(r) {
+        return 'version=' + r.httpVersion;
+    }
+
+    function test_addr(r) {
+        return 'addr=' + r.remoteAddress;
+    }
+
+    function test_uri(r) {
+        return 'uri=' + r.uri;
+    }
+
+    function test_arg(r) {
+        return 'arg=' + r.args.foo;
+    }
+
+    function test_iarg(r) {
+        var s = '', a;
+        for (a in r.args) {
+            if (a.substr(0, 3) == 'foo') {
+                s += r.args[a];
+            }
+        }
+        return s;
+    }
+
+    function test_var(r) {
+        return 'variable=' + r.variables.remote_addr;
+    }
+
+    function test_global(r) {
+        return 'global=' + global;
+    }
+
+    function status(r) {
+        r.status = 204;
+        r.sendHeader();
+        r.finish();
+    }
+
+    function request_body(r) {
+        try {
+            var body = r.requestBody;
+            r.return(200, body);
+
+        } catch (e) {
+            r.return(500, e.message);
+        }
+    }
+
+    function request_body_cache(r) {
+        function t(v) {return Buffer.isBuffer(v) ? 'buffer' : (typeof v);}
+        r.return(200,
+      `requestText:\${t(r.requestText)} requestBuffer:\${t(r.requestBuffer)}`);
+    }
+
+    function send(r) {
+        var a, s;
+        r.status = 200;
+        r.sendHeader();
+        for (a in r.args) {
+            if (a.substr(0, 3) == 'foo') {
+                s = r.args[a];
+                r.send('n=' + a + ', v=' + s.substr(0, 2) + ' ');
+            }
+        }
+        r.finish();
+    }
+
+    function return_method(r) {
+        r.return(Number(r.args.c), r.args.t);
+    }
+
+    function arg_keys(r) {
+        r.return(200, Object.keys(r.args).sort());
+    }
+
+    function test_type(r) {
+        var p = r.args.path.split('.').reduce((a, v) => a[v], r);
+
+        var type = Buffer.isBuffer(p) ? 'buffer' : (typeof p);
+        r.return(200, `type: \${type}`);
+    }
+
+    function test_log(r) {
+        r.log('SEE-LOG');
+    }
+
+    function test_except(r) {
+        var fs = require('fs');
+        fs.readFileSync();
+    }
+
+
+    function content_except(r) {
+        JSON.parse({}.a.a);
+    }
+
+    function content_empty(r) {
+    }
+
+EOF
+
+$t->try_run('no njs available')->plan(33);
+
+###############################################################################
+
+like(http_get('/method'), qr/method=GET/, 'r.method');
+like(http_get('/version'), qr/version=1.0/, 'r.httpVersion');
+like(http_get('/addr'), qr/addr=127.0.0.1/, 'r.remoteAddress');
+like(http_get('/uri'), qr/uri=\/uri/, 'r.uri');
+like(http_get('/arg?foO=12345'), qr/arg=12345/, 'r.args');
+like(http_get('/iarg?foo=12345&foo2=bar&nn=22&foo-3=z'), qr/12345barz/,
+    'r.args iteration');
+
+like(http_get('/iarg?foo=123&foo2=&foo3&foo4=456'), qr/123undefined456/,
+    'r.args iteration 2');
+like(http_get('/iarg?foo=123&foo2=&foo3'), qr/123/, 'r.args iteration 3');
+like(http_get('/iarg?foo=123&foo2='), qr/123/, 'r.args iteration 4');
+
+like(http_get('/status'), qr/204 No Content/, 'r.status');
+
+like(http_post('/body'), qr/REQ-BODY/, 'request body');
+like(http_post('/in_file'), qr/request body is in a file/,
+    'request body in file');
+like(http_post_big('/body'), qr/200.*^(1234567890){1024}$/ms,
+    'request body big');
+
+like(http_get('/send?foo=12345&n=11&foo-2=bar&ndd=&foo-3=z'),
+    qr/n=foo, v=12 n=foo-2, v=ba n=foo-3, v=z/, 'r.send');
+
+like(http_get('/return_method?c=200'), qr/200 OK.*\x0d\x0a?\x0d\x0a?$/s,
+    'return code');
+like(http_get('/return_method?c=200&t=SEE-THIS'), qr/200 OK.*^SEE-THIS$/ms,
+    'return text');
+like(http_get('/return_method?c=301&t=path'), qr/ 301 .*Location: path/s,
+    'return redirect');
+like(http_get('/return_method?c=404'), qr/404 Not.*html/s, 'return error page');
+like(http_get('/return_method?c=inv'), qr/ 500 /, 'return invalid');
+
+like(http_get('/arg_keys?b=1&c=2&a=5'), qr/a,b,c/m, 'r.args sorted keys');
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+like(http_get('/type?path=variables.host'), qr/200 OK.*type: string$/s,
+    'variables type');
+like(http_get('/type?path=rawVariables.host'), qr/200 OK.*type: buffer$/s,
+    'rawVariables type');
+
+like(http_post('/type?path=requestBody'), qr/200 OK.*type: string$/s,
+    'requestBody type');
+like(http_post('/type?path=requestText'), qr/200 OK.*type: string$/s,
+    'requestText type');
+like(http_post('/type?path=requestBuffer'), qr/200 OK.*type: buffer$/s,
+    'requestBuffer type');
+like(http_post('/request_body_cache'),
+    qr/requestText:string requestBuffer:buffer$/s, 'request body cache');
+
+}
+
+like(http_get('/var'), qr/variable=127.0.0.1/, 'r.variables');
+like(http_get('/global'), qr/global=njs/, 'global code');
+like(http_get('/log'), qr/200 OK/, 'r.log');
+
+http_get('/except');
+http_get('/content_except');
+
+like(http_get('/content_empty'), qr/500 Internal Server Error/,
+    'empty handler');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'SEE-LOG') > 0, 'log js');
+ok(index($t->read_file('error.log'), 'at fs.readFileSync') > 0,
+    'js_set backtrace');
+ok(index($t->read_file('error.log'), 'at JSON.parse') > 0,
+    'js_content backtrace');
+
+###############################################################################
+
+sub http_get_hdr {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+FoO: 12345
+
+EOF
+}
+
+sub http_get_ihdr {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+foo: 12345
+Host: localhost
+foo2: bar
+X-xxx: more
+foo-3: z
+
+EOF
+}
+
+sub http_post {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 8" . CRLF .
+        CRLF .
+        "REQ-BODY";
+
+    return http($p, %extra);
+}
+
+sub http_post_big {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10240" . CRLF .
+        CRLF .
+        ("1234567890" x 1024);
+
+    return http($p, %extra);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_variables.t ../asynch_mode_nginx/test/nginx-tests/js_variables.t
--- nginx-release-1.20.1/test/nginx-tests/js_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_variables.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, setting nginx variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_set $test_var   test_var;
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set $foo       foo_orig;
+
+        location /var_set {
+            return 200 $test_var$foo;
+        }
+
+        location /content_set {
+            js_content content_set;
+        }
+
+        location /not_found_set {
+            js_content not_found_set;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_var(r) {
+        r.variables.foo = r.variables.arg_a;
+        return 'test_var';
+    }
+
+    function content_set(r) {
+        r.variables.foo = r.variables.arg_a;
+        r.return(200, r.variables.foo);
+    }
+
+    function not_found_set(r) {
+        try {
+            r.variables.unknown = 1;
+        } catch (e) {
+            r.return(500, e);
+        }
+    }
+
+EOF
+
+$t->try_run('no njs')->plan(3);
+
+###############################################################################
+
+like(http_get('/var_set?a=bar'), qr/test_varbar/, 'var set');
+like(http_get('/content_set?a=bar'), qr/bar/, 'content set');
+like(http_get('/not_found_set'), qr/variable not found/, 'not found exception');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/js_var.t ../asynch_mode_nginx/test/nginx-tests/js_var.t
--- nginx-release-1.20.1/test/nginx-tests/js_var.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/js_var.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,91 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for http njs module, js_var directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    js_var $foo;
+    js_var $bar a:$arg_a;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /test {
+            js_content test.test;
+        }
+
+        location /sub {
+            return 200 DONE;
+        }
+
+        location /dest {
+            return 200 $bar;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test(r) {
+        if (r.args.sub) {
+            r.subrequest('/sub')
+            .then(reply => {
+                r.variables.bar = reply.responseText;
+                r.internalRedirect('/dest');
+            });
+
+            return;
+        }
+
+        r.return(200, `V:\${r.variables[r.args.var]}`);
+    }
+
+    export default {test};
+
+EOF
+
+$t->try_run('no njs js_var')->plan(3);
+
+###############################################################################
+
+like(http_get('/test?var=bar&a=qq'), qr/200 OK.*V:a:qq$/s, 'default value');
+like(http_get('/test?var=foo'), qr/200 OK.*V:$/s, 'default empty value');
+like(http_get('/test?sub=1&var=bar&a=qq'), qr/200 OK.*DONE$/s, 'value set');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/HTTP2.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/HTTP2.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/HTTP2.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/HTTP2.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,1135 @@
+package Test::Nginx::HTTP2;
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Module for nginx HTTP/2 tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+use Data::Dumper;
+
+use Test::Nginx;
+
+my %cframe = (
+	0 => { name => 'DATA', value => \&data },
+	1 => { name => 'HEADERS', value => \&headers },
+#	2 => { name => 'PRIORITY', value => \&priority },
+	3 => { name => 'RST_STREAM', value => \&rst_stream },
+	4 => { name => 'SETTINGS', value => \&settings },
+	5 => { name => 'PUSH_PROMISE', value => \&push_promise },
+	6 => { name => 'PING', value => \&ping },
+	7 => { name => 'GOAWAY', value => \&goaway },
+	8 => { name => 'WINDOW_UPDATE', value => \&window_update },
+	9 => { name => 'CONTINUATION', value => \&continuation },
+);
+
+sub new {
+	my $class = shift;
+	my ($port, %extra) = @_;
+
+	my $s = $extra{socket} || new_socket($port, %extra);
+	my $preface = defined $extra{preface} ? $extra{preface}
+		: 'PRI * HTTP/2.0' . CRLF . CRLF . 'SM' . CRLF . CRLF;
+
+	my $self = bless {
+		socket => $s, last_stream => -1,
+		dynamic_encode => [ static_table() ],
+		dynamic_decode => [ static_table() ],
+		static_table_size => scalar @{[static_table()]},
+		iws => 65535, conn_window => 65535, streams => {}
+	}, $class;
+
+	if ($extra{proxy}) {
+		$self->raw_write($extra{proxy});
+	}
+
+	# preface
+
+	$self->raw_write($preface);
+
+	return $self if $extra{pure};
+
+	# update windows, if any
+
+	my $frames = $self->read(all => [
+		{ type => 'WINDOW_UPDATE' },
+		{ type => 'SETTINGS'}
+	]);
+
+	# 6.5.3.  Settings Synchronization
+
+	if (grep { $_->{type} eq "SETTINGS" && $_->{flags} == 0 } @$frames) {
+		$self->h2_settings(1);
+	}
+
+	return $self;
+}
+
+sub h2_ping {
+	my ($self, $payload) = @_;
+
+	$self->raw_write(pack("x2C2x5a8", 8, 0x6, $payload));
+}
+
+sub h2_rst {
+	my ($self, $stream, $error) = @_;
+
+	$self->raw_write(pack("x2C2xNN", 4, 0x3, $stream, $error));
+}
+
+sub h2_goaway {
+	my ($self, $stream, $lstream, $err, $debug, %extra) = @_;
+	$debug = '' unless defined $debug;
+	my $len = defined $extra{len} ? $extra{len} : 8 + length($debug);
+	my $buf = pack("x2C2xN3A*", $len, 0x7, $stream, $lstream, $err, $debug);
+
+	my @bufs = map {
+		$self->raw_write(substr $buf, 0, $_, "");
+		select undef, undef, undef, 0.2;
+	} @{$extra{split}};
+
+	$self->raw_write($buf);
+}
+
+sub h2_priority {
+	my ($self, $w, $stream, $dep, %extra) = @_;
+
+	$stream = 0 unless defined $stream;
+	$dep = 0 unless defined $dep;
+	$dep |= $extra{excl} << 31 if exists $extra{excl};
+	$self->raw_write(pack("x2C2xNNC", 5, 0x2, $stream, $dep, $w));
+}
+
+sub h2_window {
+	my ($self, $win, $stream) = @_;
+
+	$stream = 0 unless defined $stream;
+	$self->raw_write(pack("x2C2xNN", 4, 0x8, $stream, $win));
+}
+
+sub h2_settings {
+	my ($self, $ack, @pairs) = @_;
+
+	my $len = 6 * @pairs / 2;
+	my $buf = pack_length($len) . pack "CCx4", 0x4, $ack ? 0x1 : 0x0;
+	$buf .= pack "nN", splice @pairs, 0, 2 while @pairs;
+	$self->raw_write($buf);
+}
+
+sub h2_unknown {
+	my ($self, $payload) = @_;
+
+	my $buf = pack_length(length($payload)) . pack("Cx5a*", 0xa, $payload);
+	$self->raw_write($buf);
+}
+
+sub h2_continue {
+	my ($ctx, $stream, $uri) = @_;
+
+	$uri->{h2_continue} = 1;
+	return new_stream($ctx, $uri, $stream);
+}
+
+sub h2_body {
+	my ($self, $body, $extra) = @_;
+	$extra = {} unless defined $extra;
+
+	my $len = length $body;
+	my $sid = $self->{last_stream};
+
+	if ($len > $self->{conn_window} || $len > $self->{streams}{$sid}) {
+		$self->read(all => [{ type => 'WINDOW_UPDATE' }]);
+	}
+
+	if ($len > $self->{conn_window} || $len > $self->{streams}{$sid}) {
+		return;
+	}
+
+	$self->{conn_window} -= $len;
+	$self->{streams}{$sid} -= $len;
+
+	my $buf;
+
+	my $split = ref $extra->{body_split} && $extra->{body_split} || [];
+	for (@$split) {
+		$buf .= pack_body($self, substr($body, 0, $_, ""), 0x0, $extra);
+	}
+
+	$buf .= pack_body($self, $body, 0x1, $extra) if defined $body;
+
+	$split = ref $extra->{split} && $extra->{split} || [];
+	for (@$split) {
+		$self->raw_write(substr($buf, 0, $_, ""));
+		return if $extra->{abort};
+		select undef, undef, undef, ($extra->{split_delay} || 0.2);
+	}
+
+	$self->raw_write($buf);
+}
+
+sub new_stream {
+	my ($self, $uri, $stream) = @_;
+	my ($input, $buf);
+	my ($d, $status);
+
+	$self->{headers} = '';
+
+	my $host = $uri->{host} || 'localhost';
+	my $method = $uri->{method} || 'GET';
+	my $scheme = $uri->{scheme} || 'http';
+	my $path = $uri->{path} || '/';
+	my $headers = $uri->{headers};
+	my $body = $uri->{body};
+	my $prio = $uri->{prio};
+	my $dep = $uri->{dep};
+
+	my $pad = defined $uri->{padding} ? $uri->{padding} : 0;
+	my $padlen = defined $uri->{padding} ? 1 : 0;
+
+	my $type = defined $uri->{h2_continue} ? 0x9 : 0x1;
+	my $flags = defined $uri->{continuation} ? 0x0 : 0x4;
+	$flags |= 0x1 unless defined $body || defined $uri->{body_more}
+		|| defined $uri->{h2_continue};
+	$flags |= 0x8 if $padlen;
+	$flags |= 0x20 if defined $dep || defined $prio;
+
+	if ($stream) {
+		$self->{last_stream} = $stream;
+	} else {
+		$self->{last_stream} += 2;
+	}
+	$self->{streams}{$self->{last_stream}} = $self->{iws};
+
+	$buf = pack("xxx");				# Length stub
+	$buf .= pack("CC", $type, $flags);		# END_HEADERS
+	$buf .= pack("N", $self->{last_stream});	# Stream-ID
+
+	$dep = 0 if defined $prio and not defined $dep;
+	$prio = 16 if defined $dep and not defined $prio;
+
+	unless ($headers) {
+		$input = hpack($self, ":method", $method);
+		$input .= hpack($self, ":scheme", $scheme);
+		$input .= hpack($self, ":path", $path);
+		$input .= hpack($self, ":authority", $host);
+		$input .= hpack($self, "content-length", length($body))
+			if $body;
+
+	} else {
+		$input = join '', map {
+			hpack($self, $_->{name}, $_->{value},
+			mode => $_->{mode}, huff => $_->{huff})
+		} @$headers if $headers;
+	}
+
+	$input = pack("B*", '001' . ipack(5, $uri->{table_size})) . $input
+		if defined $uri->{table_size};
+
+	my $split = ref $uri->{continuation} && $uri->{continuation} || [];
+	my @input = map { substr $input, 0, $_, "" } @$split;
+	push @input, $input;
+
+	# set length, attach headers, padding, priority
+
+	my $hlen = length($input[0]) + $pad + $padlen;
+	$hlen += 5 if $flags & 0x20;
+	$buf |= pack_length($hlen);
+
+	$buf .= pack 'C', $pad if $padlen;		# Pad Length?
+	$buf .= pack 'NC', $dep, $prio if $flags & 0x20;
+	$buf .= $input[0];
+	$buf .= (pack 'C', 0) x $pad if $padlen;	# Padding
+
+	shift @input;
+
+	while (@input) {
+		$input = shift @input;
+		$flags = @input ? 0x0 : 0x4;
+		$buf .= pack_length(length($input));
+		$buf .= pack("CC", 0x9, $flags);
+		$buf .= pack("N", $self->{last_stream});
+		$buf .= $input;
+	}
+
+	$split = ref $uri->{body_split} && $uri->{body_split} || [];
+	for (@$split) {
+		$buf .= pack_body($self, substr($body, 0, $_, ""), 0x0, $uri);
+	}
+
+	$buf .= pack_body($self, $body, 0x1, $uri) if defined $body;
+
+	$split = ref $uri->{split} && $uri->{split} || [];
+	for (@$split) {
+		$self->raw_write(substr($buf, 0, $_, ""));
+		goto done if $uri->{abort};
+		select undef, undef, undef, ($uri->{split_delay} || 0.2);
+	}
+
+	$self->raw_write($buf);
+done:
+	return $self->{last_stream};
+}
+
+sub read {
+	my ($self, %extra) = @_;
+	my (@got);
+	my $s = $self->{socket};
+	my $buf = '';
+	my $wait = $extra{wait};
+
+	local $Data::Dumper::Terse = 1;
+
+	while (1) {
+		$buf = $self->raw_read($buf, 9, $wait);
+		last if length $buf < 9;
+
+		my $length = unpack_length($buf);
+		my $type = unpack('x3C', $buf);
+		my $flags = unpack('x4C', $buf);
+
+		my $stream = unpack "x5 B32", $buf;
+		substr($stream, 0, 1) = 0;
+		$stream = unpack("N", pack("B32", $stream));
+
+		$buf = $self->raw_read($buf, $length + 9, $wait);
+		last if length($buf) < $length + 9;
+
+		$buf = substr($buf, 9);
+
+		my $frame = $cframe{$type}{value}($self, $buf, $length, $flags,
+			$stream);
+		$frame->{length} = $length;
+		$frame->{type} = $cframe{$type}{name};
+		$frame->{flags} = $flags;
+		$frame->{sid} = $stream;
+		push @got, $frame;
+
+		Test::Nginx::log_core('||', $_) for split "\n", Dumper $frame;
+
+		$buf = substr($buf, $length);
+
+		last unless $extra{all} && test_fin($got[-1], $extra{all});
+	};
+	return \@got;
+}
+
+sub raw_read {
+	my ($self, $buf, $len, $timo) = @_;
+	$timo = 8 unless $timo;
+	my $got = '';
+	my $s = $self->{socket};
+
+	while (length($buf) < $len && IO::Select->new($s)->can_read($timo)) {
+		$s->sysread($got, 16384) or last;
+		log_in($got);
+		$buf .= $got;
+	}
+	return $buf;
+}
+
+sub raw_write {
+	my ($self, $message) = @_;
+
+	if ($self->{chaining}) {
+		return add_chain($self, $message);
+	}
+
+	my $s = $self->{socket};
+
+	local $SIG{PIPE} = 'IGNORE';
+
+	while (IO::Select->new($s)->can_write(0.4)) {
+		log_out($message);
+		my $n = $s->syswrite($message);
+		last unless $n;
+		$message = substr($message, $n);
+		last unless length $message;
+	}
+}
+
+sub start_chain {
+	my ($self) = @_;
+
+	$self->{chaining} = 1;
+}
+
+sub add_chain {
+	my ($self, $buf) = @_;
+
+	if ($self->{chained_buf}) {
+		$self->{chained_buf} .= $buf;
+	} else {
+		$self->{chained_buf} = $buf;
+	}
+}
+
+sub send_chain {
+	my ($self) = @_;
+
+	undef $self->{chaining};
+	$self->raw_write($self->{chained_buf}) if $self->{chained_buf};
+	undef $self->{chained_buf};
+}
+
+###############################################################################
+
+sub pack_body {
+	my ($ctx, $body, $flags, $extra) = @_;
+
+	my $pad = defined $extra->{body_padding} ? $extra->{body_padding} : 0;
+	my $padlen = defined $extra->{body_padding} ? 1 : 0;
+
+	my $buf = pack_length(length($body) + $pad + $padlen);
+	$flags |= 0x8 if $padlen;
+	vec($flags, 0, 1) = 0 if $extra->{body_more};
+	$buf .= pack 'CC', 0x0, $flags;		# DATA, END_STREAM
+	$buf .= pack 'N', $ctx->{last_stream};
+	$buf .= pack 'C', $pad if $padlen;	# DATA Pad Length?
+	$buf .= $body;
+	$buf .= pack "x$pad" if $padlen;	# DATA Padding
+	return $buf;
+}
+
+sub test_fin {
+	my ($frame, $all) = @_;
+	my @test = @{$all};
+
+	# wait for the specified DATA length
+
+	for (@test) {
+		if ($_->{length} && $frame->{type} eq 'DATA') {
+			# check also for StreamID if needed
+
+			if (!$_->{sid} || $_->{sid} == $frame->{sid}) {
+				$_->{length} -= $frame->{length};
+			}
+		}
+	}
+	@test = grep { !(defined $_->{length} && $_->{length} == 0) } @test;
+
+	# wait for the fin flag
+
+	@test = grep { !(defined $_->{fin}
+		&& (!defined $_->{sid} || $_->{sid} == $frame->{sid})
+		&& $_->{fin} & $frame->{flags})
+	} @test if defined $frame->{flags};
+
+	# wait for the specified frame
+
+	@test = grep { !($_->{type} && $_->{type} eq $frame->{type}) } @test;
+
+	@{$all} = @test;
+}
+
+sub headers {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$ctx->{headers} = substr($buf, 0, $len);
+	return unless $flags & 0x4;
+	{ headers => hunpack($ctx, $buf, $len) };
+}
+
+sub continuation {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$ctx->{headers} .= substr($buf, 0, $len);
+	return unless $flags & 0x4;
+	{ headers => hunpack($ctx, $ctx->{headers}, length($ctx->{headers})) };
+}
+
+sub data {
+	my ($ctx, $buf, $len) = @_;
+	return { data => substr($buf, 0, $len) };
+}
+
+sub settings {
+	my ($ctx, $buf, $len) = @_;
+	my %payload;
+	my $skip = 0;
+
+	for (1 .. $len / 6) {
+		my $id = hex unpack "\@$skip n", $buf; $skip += 2;
+		$payload{$id} = unpack "\@$skip N", $buf; $skip += 4;
+
+		$ctx->{iws} = $payload{$id} if $id == 4;
+	}
+	return \%payload;
+}
+
+sub push_promise {
+	my ($ctx, $buf, $len, $flags) = @_;
+	$len -= 4;
+
+	{ promised => unpack("N", $buf),
+	  headers => hunpack($ctx, substr($buf, 4, $len), $len) };
+}
+
+sub ping {
+	my ($ctx, $buf, $len) = @_;
+	return { value => unpack "A$len", $buf };
+}
+
+sub rst_stream {
+	my ($ctx, $buf, $len) = @_;
+	return { code => unpack "N", $buf };
+}
+
+sub goaway {
+	my ($ctx, $buf, $len) = @_;
+	my %payload;
+
+	my $stream = unpack "B32", $buf;
+	substr($stream, 0, 1) = 0;
+	$stream = unpack("N", pack("B32", $stream));
+	$payload{last_sid} = $stream;
+
+	$len -= 4;
+	$payload{code} = unpack "x4 N", $buf;
+	$payload{debug} = unpack "x8 A$len", $buf;
+	return \%payload;
+}
+
+sub window_update {
+	my ($ctx, $buf, $len, $flags, $sid) = @_;
+	my $value = unpack "B32", $buf;
+	substr($value, 0, 1) = 0;
+	$value = unpack("N", pack("B32", $value));
+
+	unless ($sid) {
+		$ctx->{conn_window} += $value;
+
+	} else {
+		$ctx->{streams}{$sid} = $ctx->{iws}
+			unless defined $ctx->{streams}{$sid};
+		$ctx->{streams}{$sid} += $value;
+	}
+
+	return { wdelta => $value };
+}
+
+sub pack_length {
+	pack 'c3', unpack 'xc3', pack 'N', $_[0];
+}
+
+sub unpack_length {
+	unpack 'N', pack 'xc3', unpack 'c3', $_[0];
+}
+
+sub new_socket {
+	my ($port, %extra) = @_;
+	my $npn = $extra{'npn'};
+	my $alpn = $extra{'alpn'};
+	my $s;
+
+	$port ||= port(8080);
+
+	eval {
+		local $SIG{ALRM} = sub { die "timeout\n" };
+		local $SIG{PIPE} = sub { die "sigpipe\n" };
+		alarm(8);
+		$s = IO::Socket::INET->new(
+			Proto => 'tcp',
+			PeerAddr => "127.0.0.1:$port",
+		);
+		require IO::Socket::SSL if $extra{'SSL'};
+		IO::Socket::SSL->start_SSL($s,
+			SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+			SSL_npn_protocols => $npn ? [ $npn ] : undef,
+			SSL_alpn_protocols => $alpn ? [ $alpn ] : undef,
+			SSL_error_trap => sub { die $_[1] }
+		) if $extra{'SSL'};
+		alarm(0);
+	};
+	alarm(0);
+
+	if ($@) {
+		log_in("died: $@");
+		return undef;
+	}
+
+	return $s;
+}
+
+sub static_table {
+	[ '',			''		], # unused
+	[ ':authority',		''		],
+	[ ':method',		'GET'		],
+	[ ':method',		'POST'		],
+	[ ':path',		'/'		],
+	[ ':path',		'/index.html'	],
+	[ ':scheme',		'http'		],
+	[ ':scheme',		'https'		],
+	[ ':status',		'200'		],
+	[ ':status',		'204'		],
+	[ ':status',		'206'		],
+	[ ':status',		'304'		],
+	[ ':status',		'400'		],
+	[ ':status',		'404'		],
+	[ ':status',		'500'		],
+	[ 'accept-charset',	''		],
+	[ 'accept-encoding',	'gzip, deflate'	],
+	[ 'accept-language',	''		],
+	[ 'accept-ranges',	''		],
+	[ 'accept',		''		],
+	[ 'access-control-allow-origin',
+				''		],
+	[ 'age',		''		],
+	[ 'allow',		''		],
+	[ 'authorization',	''		],
+	[ 'cache-control',	''		],
+	[ 'content-disposition',
+				''		],
+	[ 'content-encoding',	''		],
+	[ 'content-language',	''		],
+	[ 'content-length',	''		],
+	[ 'content-location',	''		],
+	[ 'content-range',	''		],
+	[ 'content-type',	''		],
+	[ 'cookie',		''		],
+	[ 'date',		''		],
+	[ 'etag',		''		],
+	[ 'expect',		''		],
+	[ 'expires',		''		],
+	[ 'from',		''		],
+	[ 'host',		''		],
+	[ 'if-match',		''		],
+	[ 'if-modified-since',	''		],
+	[ 'if-none-match',	''		],
+	[ 'if-range',		''		],
+	[ 'if-unmodified-since',
+				''		],
+	[ 'last-modified',	''		],
+	[ 'link',		''		],
+	[ 'location',		''		],
+	[ 'max-forwards',	''		],
+	[ 'proxy-authenticate',	''		],
+	[ 'proxy-authorization',
+				''		],
+	[ 'range',		''		],
+	[ 'referer',		''		],
+	[ 'refresh',		''		],
+	[ 'retry-after',	''		],
+	[ 'server',		''		],
+	[ 'set-cookie',		''		],
+	[ 'strict-transport-security',
+				''		],
+	[ 'transfer-encoding',	''		],
+	[ 'user-agent',		''		],
+	[ 'vary',		''		],
+	[ 'via',		''		],
+	[ 'www-authenticate',	''		],
+}
+
+# RFC 7541, 5.1.  Integer Representation
+
+sub ipack {
+	my ($base, $d) = @_;
+	return sprintf("%.*b", $base, $d) if $d < 2**$base - 1;
+
+	my $o = sprintf("%${base}b", 2**$base - 1);
+	$d -= 2**$base - 1;
+	while ($d >= 128) {
+		$o .= sprintf("%8b", $d % 128 + 128);
+		$d /= 128;
+	}
+	$o .= sprintf("%08b", $d);
+	return $o;
+}
+
+sub iunpack {
+	my ($base, $b, $s) = @_;
+
+	my $len = unpack("\@$s B8", $b); $s++;
+	my $prefix = substr($len, 0, 8 - $base);
+	$len = '0' x (8 - $base) . substr($len, 8 - $base);
+	$len = unpack("C", pack("B8", $len));
+
+	return ($len, $s, $prefix) if $len < 2**$base - 1;
+
+	my $m = 0;
+	my $d;
+
+	do {
+		$d = unpack("\@$s C", $b); $s++;
+		$len += ($d & 127) * 2**$m;
+		$m += $base;
+	} while (($d & 128) == 128);
+
+	return ($len, $s, $prefix);
+}
+
+sub hpack {
+	my ($ctx, $name, $value, %extra) = @_;
+	my $table = $ctx->{dynamic_encode};
+	my $mode = defined $extra{mode} ? $extra{mode} : 1;
+	my $huff = $extra{huff};
+
+	my ($index, $buf) = 0;
+
+	# 6.1.  Indexed Header Field Representation
+
+	if ($mode == 0) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name
+			and $table->[$index][1] eq $value;
+		$buf = pack('B*', '1' . ipack(7, $index));
+	}
+
+	# 6.2.1.  Literal Header Field with Incremental Indexing
+
+	if ($mode == 1) {
+		splice @$table, $ctx->{static_table_size}, 0, [ $name, $value ];
+
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '01' . ipack(6, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.1.  Literal Header Field with Incremental Indexing -- New Name
+
+	if ($mode == 2) {
+		splice @$table, $ctx->{static_table_size}, 0, [ $name, $value ];
+
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '01000000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.2.  Literal Header Field without Indexing
+
+	if ($mode == 3) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '0000' . ipack(4, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.2.  Literal Header Field without Indexing -- New Name
+
+	if ($mode == 4) {
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '00000000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.3.  Literal Header Field Never Indexed
+
+	if ($mode == 5) {
+		++$index until $index > $#$table
+			or $table->[$index][0] eq $name;
+		my $value = $huff ? huff($value) : $value;
+
+		$buf = pack('B*', '0001' . ipack(4, $index)
+			. ($huff ? '1' : '0') . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	# 6.2.3.  Literal Header Field Never Indexed -- New Name
+
+	if ($mode == 6) {
+		my $name = $huff ? huff($name) : $name;
+		my $value = $huff ? huff($value) : $value;
+		my $hbit = ($huff ? '1' : '0');
+
+		$buf = pack('B*', '00010000');
+		$buf .= pack('B*', $hbit . ipack(7, length($name)));
+		$buf .= $name;
+		$buf .= pack('B*', $hbit . ipack(7, length($value)));
+		$buf .= $value;
+	}
+
+	return $buf;
+}
+
+sub hunpack {
+	my ($ctx, $data, $length) = @_;
+	my $table = $ctx->{dynamic_decode};
+	my %headers;
+	my $skip = 0;
+	my ($index, $name, $value, $size);
+
+	my $field = sub {
+		my ($b) = @_;
+		my ($len, $s, $huff) = iunpack(7, @_);
+
+		my $field = substr($b, $s, $len);
+		$field = $huff ? dehuff($field) : $field;
+		$s += $len;
+		return ($field, $s);
+	};
+
+	my $add = sub {
+		my ($h, $n, $v) = @_;
+		return $h->{$n} = $v unless exists $h->{$n};
+		$h->{$n} = [ $h->{$n} ] unless ref $h->{$n};
+		push @{$h->{$n}}, $v;
+	};
+
+	while ($skip < $length) {
+		my $ib = unpack("\@$skip B8", $data);
+
+		if (substr($ib, 0, 1) eq '1') {
+			($index, $skip) = iunpack(7, $data, $skip);
+			$add->(\%headers,
+				$table->[$index][0], $table->[$index][1]);
+			next;
+		}
+
+		if (substr($ib, 0, 2) eq '01') {
+			($index, $skip) = iunpack(6, $data, $skip);
+			$name = $table->[$index][0];
+
+			($name, $skip) = $field->($data, $skip) unless $name;
+			($value, $skip) = $field->($data, $skip);
+
+			splice @$table,
+				$ctx->{static_table_size}, 0, [ $name, $value ];
+			$add->(\%headers, $name, $value);
+			next;
+		}
+
+		if (substr($ib, 0, 4) eq '0000') {
+			($index, $skip) = iunpack(4, $data, $skip);
+			$name = $table->[$index][0];
+
+			($name, $skip) = $field->($data, $skip) unless $name;
+			($value, $skip) = $field->($data, $skip);
+
+			$add->(\%headers, $name, $value);
+			next;
+		}
+
+		if (substr($ib, 0, 3) eq '001') {
+			($size, $skip) = iunpack(5, $data, $skip);
+
+			# TODO: handle dynamic table size update
+
+			next;
+		}
+
+		last;
+	}
+
+	return \%headers;
+}
+
+sub huff_code { scalar {
+	pack('C', 0)	=> '1111111111000',
+	pack('C', 1)	=> '11111111111111111011000',
+	pack('C', 2)	=> '1111111111111111111111100010',
+	pack('C', 3)	=> '1111111111111111111111100011',
+	pack('C', 4)	=> '1111111111111111111111100100',
+	pack('C', 5)	=> '1111111111111111111111100101',
+	pack('C', 6)	=> '1111111111111111111111100110',
+	pack('C', 7)	=> '1111111111111111111111100111',
+	pack('C', 8)	=> '1111111111111111111111101000',
+	pack('C', 9)	=> '111111111111111111101010',
+	pack('C', 10)	=> '111111111111111111111111111100',
+	pack('C', 11)	=> '1111111111111111111111101001',
+	pack('C', 12)	=> '1111111111111111111111101010',
+	pack('C', 13)	=> '111111111111111111111111111101',
+	pack('C', 14)	=> '1111111111111111111111101011',
+	pack('C', 15)	=> '1111111111111111111111101100',
+	pack('C', 16)	=> '1111111111111111111111101101',
+	pack('C', 17)	=> '1111111111111111111111101110',
+	pack('C', 18)	=> '1111111111111111111111101111',
+	pack('C', 19)	=> '1111111111111111111111110000',
+	pack('C', 20)	=> '1111111111111111111111110001',
+	pack('C', 21)	=> '1111111111111111111111110010',
+	pack('C', 22)	=> '111111111111111111111111111110',
+	pack('C', 23)	=> '1111111111111111111111110011',
+	pack('C', 24)	=> '1111111111111111111111110100',
+	pack('C', 25)	=> '1111111111111111111111110101',
+	pack('C', 26)	=> '1111111111111111111111110110',
+	pack('C', 27)	=> '1111111111111111111111110111',
+	pack('C', 28)	=> '1111111111111111111111111000',
+	pack('C', 29)	=> '1111111111111111111111111001',
+	pack('C', 30)	=> '1111111111111111111111111010',
+	pack('C', 31)	=> '1111111111111111111111111011',
+	pack('C', 32)	=> '010100',
+	pack('C', 33)	=> '1111111000',
+	pack('C', 34)	=> '1111111001',
+	pack('C', 35)	=> '111111111010',
+	pack('C', 36)	=> '1111111111001',
+	pack('C', 37)	=> '010101',
+	pack('C', 38)	=> '11111000',
+	pack('C', 39)	=> '11111111010',
+	pack('C', 40)	=> '1111111010',
+	pack('C', 41)	=> '1111111011',
+	pack('C', 42)	=> '11111001',
+	pack('C', 43)	=> '11111111011',
+	pack('C', 44)	=> '11111010',
+	pack('C', 45)	=> '010110',
+	pack('C', 46)	=> '010111',
+	pack('C', 47)	=> '011000',
+	pack('C', 48)	=> '00000',
+	pack('C', 49)	=> '00001',
+	pack('C', 50)	=> '00010',
+	pack('C', 51)	=> '011001',
+	pack('C', 52)	=> '011010',
+	pack('C', 53)	=> '011011',
+	pack('C', 54)	=> '011100',
+	pack('C', 55)	=> '011101',
+	pack('C', 56)	=> '011110',
+	pack('C', 57)	=> '011111',
+	pack('C', 58)	=> '1011100',
+	pack('C', 59)	=> '11111011',
+	pack('C', 60)	=> '111111111111100',
+	pack('C', 61)	=> '100000',
+	pack('C', 62)	=> '111111111011',
+	pack('C', 63)	=> '1111111100',
+	pack('C', 64)	=> '1111111111010',
+	pack('C', 65)	=> '100001',
+	pack('C', 66)	=> '1011101',
+	pack('C', 67)	=> '1011110',
+	pack('C', 68)	=> '1011111',
+	pack('C', 69)	=> '1100000',
+	pack('C', 70)	=> '1100001',
+	pack('C', 71)	=> '1100010',
+	pack('C', 72)	=> '1100011',
+	pack('C', 73)	=> '1100100',
+	pack('C', 74)	=> '1100101',
+	pack('C', 75)	=> '1100110',
+	pack('C', 76)	=> '1100111',
+	pack('C', 77)	=> '1101000',
+	pack('C', 78)	=> '1101001',
+	pack('C', 79)	=> '1101010',
+	pack('C', 80)	=> '1101011',
+	pack('C', 81)	=> '1101100',
+	pack('C', 82)	=> '1101101',
+	pack('C', 83)	=> '1101110',
+	pack('C', 84)	=> '1101111',
+	pack('C', 85)	=> '1110000',
+	pack('C', 86)	=> '1110001',
+	pack('C', 87)	=> '1110010',
+	pack('C', 88)	=> '11111100',
+	pack('C', 89)	=> '1110011',
+	pack('C', 90)	=> '11111101',
+	pack('C', 91)	=> '1111111111011',
+	pack('C', 92)	=> '1111111111111110000',
+	pack('C', 93)	=> '1111111111100',
+	pack('C', 94)	=> '11111111111100',
+	pack('C', 95)	=> '100010',
+	pack('C', 96)	=> '111111111111101',
+	pack('C', 97)	=> '00011',
+	pack('C', 98)	=> '100011',
+	pack('C', 99)	=> '00100',
+	pack('C', 100)	=> '100100',
+	pack('C', 101)	=> '00101',
+	pack('C', 102)	=> '100101',
+	pack('C', 103)	=> '100110',
+	pack('C', 104)	=> '100111',
+	pack('C', 105)	=> '00110',
+	pack('C', 106)	=> '1110100',
+	pack('C', 107)	=> '1110101',
+	pack('C', 108)	=> '101000',
+	pack('C', 109)	=> '101001',
+	pack('C', 110)	=> '101010',
+	pack('C', 111)	=> '00111',
+	pack('C', 112)	=> '101011',
+	pack('C', 113)	=> '1110110',
+	pack('C', 114)	=> '101100',
+	pack('C', 115)	=> '01000',
+	pack('C', 116)	=> '01001',
+	pack('C', 117)	=> '101101',
+	pack('C', 118)	=> '1110111',
+	pack('C', 119)	=> '1111000',
+	pack('C', 120)	=> '1111001',
+	pack('C', 121)	=> '1111010',
+	pack('C', 122)	=> '1111011',
+	pack('C', 123)	=> '111111111111110',
+	pack('C', 124)	=> '11111111100',
+	pack('C', 125)	=> '11111111111101',
+	pack('C', 126)	=> '1111111111101',
+	pack('C', 127)	=> '1111111111111111111111111100',
+	pack('C', 128)	=> '11111111111111100110',
+	pack('C', 129)	=> '1111111111111111010010',
+	pack('C', 130)	=> '11111111111111100111',
+	pack('C', 131)	=> '11111111111111101000',
+	pack('C', 132)	=> '1111111111111111010011',
+	pack('C', 133)	=> '1111111111111111010100',
+	pack('C', 134)	=> '1111111111111111010101',
+	pack('C', 135)	=> '11111111111111111011001',
+	pack('C', 136)	=> '1111111111111111010110',
+	pack('C', 137)	=> '11111111111111111011010',
+	pack('C', 138)	=> '11111111111111111011011',
+	pack('C', 139)	=> '11111111111111111011100',
+	pack('C', 140)	=> '11111111111111111011101',
+	pack('C', 141)	=> '11111111111111111011110',
+	pack('C', 142)	=> '111111111111111111101011',
+	pack('C', 143)	=> '11111111111111111011111',
+	pack('C', 144)	=> '111111111111111111101100',
+	pack('C', 145)	=> '111111111111111111101101',
+	pack('C', 146)	=> '1111111111111111010111',
+	pack('C', 147)	=> '11111111111111111100000',
+	pack('C', 148)	=> '111111111111111111101110',
+	pack('C', 149)	=> '11111111111111111100001',
+	pack('C', 150)	=> '11111111111111111100010',
+	pack('C', 151)	=> '11111111111111111100011',
+	pack('C', 152)	=> '11111111111111111100100',
+	pack('C', 153)	=> '111111111111111011100',
+	pack('C', 154)	=> '1111111111111111011000',
+	pack('C', 155)	=> '11111111111111111100101',
+	pack('C', 156)	=> '1111111111111111011001',
+	pack('C', 157)	=> '11111111111111111100110',
+	pack('C', 158)	=> '11111111111111111100111',
+	pack('C', 159)	=> '111111111111111111101111',
+	pack('C', 160)	=> '1111111111111111011010',
+	pack('C', 161)	=> '111111111111111011101',
+	pack('C', 162)	=> '11111111111111101001',
+	pack('C', 163)	=> '1111111111111111011011',
+	pack('C', 164)	=> '1111111111111111011100',
+	pack('C', 165)	=> '11111111111111111101000',
+	pack('C', 166)	=> '11111111111111111101001',
+	pack('C', 167)	=> '111111111111111011110',
+	pack('C', 168)	=> '11111111111111111101010',
+	pack('C', 169)	=> '1111111111111111011101',
+	pack('C', 170)	=> '1111111111111111011110',
+	pack('C', 171)	=> '111111111111111111110000',
+	pack('C', 172)	=> '111111111111111011111',
+	pack('C', 173)	=> '1111111111111111011111',
+	pack('C', 174)	=> '11111111111111111101011',
+	pack('C', 175)	=> '11111111111111111101100',
+	pack('C', 176)	=> '111111111111111100000',
+	pack('C', 177)	=> '111111111111111100001',
+	pack('C', 178)	=> '1111111111111111100000',
+	pack('C', 179)	=> '111111111111111100010',
+	pack('C', 180)	=> '11111111111111111101101',
+	pack('C', 181)	=> '1111111111111111100001',
+	pack('C', 182)	=> '11111111111111111101110',
+	pack('C', 183)	=> '11111111111111111101111',
+	pack('C', 184)	=> '11111111111111101010',
+	pack('C', 185)	=> '1111111111111111100010',
+	pack('C', 186)	=> '1111111111111111100011',
+	pack('C', 187)	=> '1111111111111111100100',
+	pack('C', 188)	=> '11111111111111111110000',
+	pack('C', 189)	=> '1111111111111111100101',
+	pack('C', 190)	=> '1111111111111111100110',
+	pack('C', 191)	=> '11111111111111111110001',
+	pack('C', 192)	=> '11111111111111111111100000',
+	pack('C', 193)	=> '11111111111111111111100001',
+	pack('C', 194)	=> '11111111111111101011',
+	pack('C', 195)	=> '1111111111111110001',
+	pack('C', 196)	=> '1111111111111111100111',
+	pack('C', 197)	=> '11111111111111111110010',
+	pack('C', 198)	=> '1111111111111111101000',
+	pack('C', 199)	=> '1111111111111111111101100',
+	pack('C', 200)	=> '11111111111111111111100010',
+	pack('C', 201)	=> '11111111111111111111100011',
+	pack('C', 202)	=> '11111111111111111111100100',
+	pack('C', 203)	=> '111111111111111111111011110',
+	pack('C', 204)	=> '111111111111111111111011111',
+	pack('C', 205)	=> '11111111111111111111100101',
+	pack('C', 206)	=> '111111111111111111110001',
+	pack('C', 207)	=> '1111111111111111111101101',
+	pack('C', 208)	=> '1111111111111110010',
+	pack('C', 209)	=> '111111111111111100011',
+	pack('C', 210)	=> '11111111111111111111100110',
+	pack('C', 211)	=> '111111111111111111111100000',
+	pack('C', 212)	=> '111111111111111111111100001',
+	pack('C', 213)	=> '11111111111111111111100111',
+	pack('C', 214)	=> '111111111111111111111100010',
+	pack('C', 215)	=> '111111111111111111110010',
+	pack('C', 216)	=> '111111111111111100100',
+	pack('C', 217)	=> '111111111111111100101',
+	pack('C', 218)	=> '11111111111111111111101000',
+	pack('C', 219)	=> '11111111111111111111101001',
+	pack('C', 220)	=> '1111111111111111111111111101',
+	pack('C', 221)	=> '111111111111111111111100011',
+	pack('C', 222)	=> '111111111111111111111100100',
+	pack('C', 223)	=> '111111111111111111111100101',
+	pack('C', 224)	=> '11111111111111101100',
+	pack('C', 225)	=> '111111111111111111110011',
+	pack('C', 226)	=> '11111111111111101101',
+	pack('C', 227)	=> '111111111111111100110',
+	pack('C', 228)	=> '1111111111111111101001',
+	pack('C', 229)	=> '111111111111111100111',
+	pack('C', 230)	=> '111111111111111101000',
+	pack('C', 231)	=> '11111111111111111110011',
+	pack('C', 232)	=> '1111111111111111101010',
+	pack('C', 233)	=> '1111111111111111101011',
+	pack('C', 234)	=> '1111111111111111111101110',
+	pack('C', 235)	=> '1111111111111111111101111',
+	pack('C', 236)	=> '111111111111111111110100',
+	pack('C', 237)	=> '111111111111111111110101',
+	pack('C', 238)	=> '11111111111111111111101010',
+	pack('C', 239)	=> '11111111111111111110100',
+	pack('C', 240)	=> '11111111111111111111101011',
+	pack('C', 241)	=> '111111111111111111111100110',
+	pack('C', 242)	=> '11111111111111111111101100',
+	pack('C', 243)	=> '11111111111111111111101101',
+	pack('C', 244)	=> '111111111111111111111100111',
+	pack('C', 245)	=> '111111111111111111111101000',
+	pack('C', 246)	=> '111111111111111111111101001',
+	pack('C', 247)	=> '111111111111111111111101010',
+	pack('C', 248)	=> '111111111111111111111101011',
+	pack('C', 249)	=> '1111111111111111111111111110',
+	pack('C', 250)	=> '111111111111111111111101100',
+	pack('C', 251)	=> '111111111111111111111101101',
+	pack('C', 252)	=> '111111111111111111111101110',
+	pack('C', 253)	=> '111111111111111111111101111',
+	pack('C', 254)	=> '111111111111111111111110000',
+	pack('C', 255)	=> '11111111111111111111101110',
+	'_eos'		=> '111111111111111111111111111111',
+}};
+
+sub huff {
+	my ($string) = @_;
+	my $code = &huff_code;
+
+	my $ret = join '', map { $code->{$_} } (split //, $string);
+	my $len = length($ret) + (8 - length($ret) % 8);
+	$ret .= $code->{_eos};
+
+	return pack("B$len", $ret);
+}
+
+sub dehuff {
+	my ($string) = @_;
+	my $code = &huff_code;
+	my %decode = reverse %$code;
+
+	my $ret = ''; my $c = '';
+	for (split //, unpack('B*', $string)) {
+		$c .= $_;
+		next unless exists $decode{$c};
+		last if $decode{$c} eq '_eos';
+
+		$ret .= $decode{$c};
+		$c = '';
+	}
+
+	return $ret;
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/IMAP.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/IMAP.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/IMAP.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/IMAP.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,161 @@
+package Test::Nginx::IMAP;
+
+# (C) Maxim Dounin
+# Copyright (C) Intel, Inc.
+# Module for nginx imap tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => "127.0.0.1:" . port(8143),
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+	$self->{_read_buffer} = '';
+
+	return $self;
+}
+
+sub eof {
+	my $self = shift;
+	return $self->{_socket}->eof();
+}
+
+sub print {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd);
+}
+
+sub send {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd . CRLF);
+}
+
+sub getline {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+
+	if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+		$self->{_read_buffer} = $2;
+		return $1;
+	}
+
+	while (IO::Select->new($socket)->can_read(8)) {
+	        $socket->blocking(0);
+		my $n = $socket->sysread(my $buf, 1024);
+	        $socket->blocking(1);
+		last unless $n;
+
+		$self->{_read_buffer} .= $buf;
+
+		if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+			$self->{_read_buffer} = $2;
+			return $1;
+		}
+	};
+}
+
+sub read {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+
+	while (defined($_ = $self->getline())) {
+		log_in($_);
+		last;
+	}
+
+	return $_;
+}
+
+sub check {
+	my ($self, $regex, $name) = @_;
+	Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^\S+ OK/, @_);
+}
+
+sub can_read {
+	my ($self, $timo) = @_;
+	IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub imap_test_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . ($port || port(8144)),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		print $client "* OK fake imap server ready" . CRLF;
+
+		while (<$client>) {
+			Test::Nginx::log_core('||', $_);
+
+			while (m/{(\d+)}\x0d?$/) {
+				print $client '+ ' . CRLF;
+				$client->sysread(my $buf, $1);
+				Test::Nginx::log_core('||', $buf);
+				$buf = <$client>;
+				Test::Nginx::log_core('||', $buf);
+				$_ .= $buf;
+			}
+
+			my $tag = '';
+
+			$tag = $1 if m/^(\S+)/;
+			s/^(\S+)\s+//;
+
+			if (/^logout/i) {
+				print $client $tag . ' OK logout ok' . CRLF;
+			} elsif (/^login /i) {
+				print $client $tag . ' OK login ok' . CRLF;
+			} else {
+				print $client $tag . ' ERR unknown command' . CRLF;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/POP3.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/POP3.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/POP3.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/POP3.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,147 @@
+package Test::Nginx::POP3;
+
+# (C) Maxim Dounin
+# Copyright (C) Intel, Inc.
+# Module for nginx pop3 tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+	my $self = {};
+	bless $self, shift @_;
+
+	$self->{_socket} = IO::Socket::INET->new(
+		Proto => "tcp",
+		PeerAddr => "127.0.0.1:" . port(8110),
+		@_
+	)
+		or die "Can't connect to nginx: $!\n";
+
+	if ({@_}->{'SSL'}) {
+		require IO::Socket::SSL;
+		IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+			or die $IO::Socket::SSL::SSL_ERROR . "\n";
+	}
+
+	$self->{_socket}->autoflush(1);
+	$self->{_read_buffer} = '';
+
+	return $self;
+}
+
+sub eof {
+	my $self = shift;
+	return $self->{_socket}->eof();
+}
+
+sub print {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd);
+}
+
+sub send {
+	my ($self, $cmd) = @_;
+	log_out($cmd);
+	$self->{_socket}->print($cmd . CRLF);
+}
+
+sub getline {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+
+	if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+		$self->{_read_buffer} = $2;
+		return $1;
+	}
+
+	while (IO::Select->new($socket)->can_read(8)) {
+		$socket->blocking(0);
+		my $n = $socket->sysread(my $buf, 1024);
+		$socket->blocking(1);
+		last unless $n;
+
+		$self->{_read_buffer} .= $buf;
+
+		if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+			$self->{_read_buffer} = $2;
+			return $1;
+		}
+	};
+}
+
+sub read {
+	my ($self) = @_;
+	my $socket = $self->{_socket};
+
+	while (defined($_ = $self->getline())) {
+		log_in($_);
+		last;
+	}
+
+	return $_;
+}
+
+sub check {
+	my ($self, $regex, $name) = @_;
+	Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+	my $self = shift;
+	Test::More->builder->like($self->read(), qr/^\+OK/, @_);
+}
+
+sub can_read {
+	my ($self, $timo) = @_;
+	IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub pop3_test_daemon {
+	my ($port) = @_;
+
+	my $server = IO::Socket::INET->new(
+		Proto => 'tcp',
+		LocalAddr => '127.0.0.1:' . ($port || port(8111)),
+		Listen => 5,
+		Reuse => 1
+	)
+		or die "Can't create listening socket: $!\n";
+
+	while (my $client = $server->accept()) {
+		$client->autoflush(1);
+		print $client "+OK fake pop3 server ready" . CRLF;
+
+		while (<$client>) {
+			if (/^quit/i) {
+				print $client '+OK quit ok' . CRLF;
+			} elsif (/^user test\@example.com/i) {
+				print $client '+OK user ok' . CRLF;
+			} elsif (/^pass secret/i) {
+				print $client '+OK pass ok' . CRLF;
+			} else {
+				print $client "-ERR unknown command" . CRLF;
+			}
+		}
+
+		close $client;
+	}
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/SMTP.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/SMTP.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/SMTP.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/SMTP.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,174 @@
+package Test::Nginx::SMTP;
+
+# (C) Maxim Dounin
+# Copyright (C) Intel, Inc.
+# Module for nginx smtp tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+use Socket qw/ CRLF /;
+
+use Test::Nginx;
+
+sub new {
+    my $self = {};
+    bless $self, shift @_;
+
+    $self->{_socket} = IO::Socket::INET->new(
+        Proto => "tcp",
+        PeerAddr => "127.0.0.1:" . port(8025),
+        @_
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    if ({@_}->{'SSL'}) {
+        require IO::Socket::SSL;
+        IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+            or die $IO::Socket::SSL::SSL_ERROR . "\n";
+    }
+
+    $self->{_socket}->autoflush(1);
+    $self->{_read_buffer} = '';
+
+    return $self;
+}
+
+sub eof {
+    my $self = shift;
+    return $self->{_socket}->eof();
+}
+
+sub print {
+    my ($self, $cmd) = @_;
+    log_out($cmd);
+    $self->{_socket}->print($cmd);
+}
+
+sub send {
+    my ($self, $cmd) = @_;
+    log_out($cmd);
+    $self->{_socket}->print($cmd . CRLF);
+}
+
+sub getline {
+    my ($self) = @_;
+    my $socket = $self->{_socket};
+
+    if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+        $self->{_read_buffer} = $2;
+        return $1;
+    }
+
+    while (IO::Select->new($socket)->can_read(8)) {
+        $socket->blocking(0);
+        my $n = $socket->sysread(my $buf, 1024);
+        $socket->blocking(1);
+        last unless $n;
+
+        $self->{_read_buffer} .= $buf;
+
+        if ($self->{_read_buffer} =~ /^(.*?\x0a)(.*)/ms) {
+            $self->{_read_buffer} = $2;
+            return $1;
+        }
+    };
+}
+
+sub read {
+    my ($self) = @_;
+    my $socket = $self->{_socket};
+
+    while (defined($_ = $self->getline())) {
+        log_in($_);
+        next if m/^\d\d\d-/;
+        last;
+    }
+
+    return $_;
+}
+
+sub check {
+    my ($self, $regex, $name) = @_;
+    Test::More->builder->like($self->read(), $regex, $name);
+}
+
+sub ok {
+    my $self = shift;
+    Test::More->builder->like($self->read(), qr/^2\d\d /, @_);
+}
+
+sub authok {
+    my $self = shift;
+    Test::More->builder->like($self->read(), qr/^235 /, @_);
+}
+
+sub can_read {
+    my ($self, $timo) = @_;
+    IO::Select->new($self->{_socket})->can_read($timo || 3);
+}
+
+###############################################################################
+
+sub smtp_test_daemon {
+    my ($port) = @_;
+    my $proxy_protocol;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . ($port || port(8026)),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+        print $client "220 fake esmtp server ready" . CRLF;
+
+        $proxy_protocol = '';
+
+        while (<$client>) {
+            Test::Nginx::log_core('||', $_);
+
+            if (/^quit/i) {
+                print $client '221 quit ok' . CRLF;
+            } elsif (/^(ehlo|helo)/i) {
+                print $client '250 hello ok' . CRLF;
+            } elsif (/^rset/i) {
+                print $client '250 rset ok' . CRLF;
+            } elsif (/^auth plain/i) {
+                print $client '235 auth ok' . CRLF;
+            } elsif (/^mail from:[^@]+$/i) {
+                print $client '500 mail from error' . CRLF;
+            } elsif (/^mail from:/i) {
+                print $client '250 mail from ok' . CRLF;
+            } elsif (/^rcpt to:[^@]+$/i) {
+                print $client '500 rcpt to error' . CRLF;
+            } elsif (/^rcpt to:/i) {
+                print $client '250 rcpt to ok' . CRLF;
+            } elsif (/^xclient/i) {
+                print $client '220 xclient ok' . CRLF;
+            } elsif (/^proxy/i) {
+                $proxy_protocol = $_;
+            } elsif (/^xproxy/i) {
+                print $client '211 ' . $proxy_protocol . CRLF;
+            } else {
+                print $client "500 unknown command" . CRLF;
+            }
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/Stream.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/Stream.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx/Stream.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx/Stream.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,140 @@
+package Test::Nginx::Stream;
+
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.
+# Module for nginx stream tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use base qw/ Exporter /;
+our @EXPORT_OK = qw/ stream dgram /;
+
+use Test::More qw//;
+use IO::Select;
+use IO::Socket;
+
+use Test::Nginx;
+
+sub stream {
+    return Test::Nginx::Stream->new(@_);
+}
+
+sub dgram {
+    unshift(@_, "PeerAddr") if @_ == 1;
+
+    return Test::Nginx::Stream->new(
+        Proto => "udp",
+        @_
+    );
+}
+
+sub new {
+    my $self = {};
+    bless $self, shift @_;
+
+    unshift(@_, "PeerAddr") if @_ == 1;
+
+    $self->{_socket} = IO::Socket::INET->new(
+        Proto => "tcp",
+        PeerAddr => '127.0.0.1',
+        @_
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    if ({@_}->{'SSL'}) {
+        require IO::Socket::SSL;
+        IO::Socket::SSL->start_SSL($self->{_socket}, @_)
+            or die $IO::Socket::SSL::SSL_ERROR . "\n";
+    }
+
+    $self->{_socket}->autoflush(1);
+
+    return $self;
+}
+
+sub write {
+    my ($self, $message, %extra) = @_;
+    my $s = $self->{_socket};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_write($extra{write_timeout} || 1.5)) {
+        my $n = $s->syswrite($message);
+        log_out(substr($message, 0, $n));
+        last unless $n;
+
+        $message = substr($message, $n);
+        last unless length $message;
+    }
+
+    if (length $message) {
+        $s->close();
+    }
+}
+
+sub read {
+    my ($self, %extra) = @_;
+    my ($s, $buf);
+
+    $s = $self->{_socket};
+
+    $s->blocking(0);
+    if (IO::Select->new($s)->can_read($extra{read_timeout} || 8)) {
+        $s->sysread($buf, 1024);
+    };
+
+    log_in($buf);
+    return $buf;
+}
+
+sub io {
+    my $self = shift;
+
+    my ($data, %extra) = @_;
+    my $length = $extra{length};
+    my $read = $extra{read};
+
+    $read = 1 if !defined $read
+        && $self->{_socket}->socktype() == &SOCK_DGRAM;
+
+    $self->write($data, %extra);
+
+    $data = '';
+    while (1) {
+        last if defined $read && --$read < 0;
+
+        my $buf = $self->read(%extra);
+        last unless defined $buf and length($buf);
+
+        $data .= $buf;
+        last if defined $length && length($data) >= $length;
+    }
+
+    return $data;
+}
+
+sub sockaddr {
+    my $self = shift;
+    return $self->{_socket}->sockaddr();
+}
+
+sub sockhost {
+    my $self = shift;
+    return $self->{_socket}->sockhost();
+}
+
+sub sockport {
+    my $self = shift;
+    return $self->{_socket}->sockport();
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx.pm ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx.pm
--- nginx-release-1.20.1/test/nginx-tests/lib/Test/Nginx.pm	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/lib/Test/Nginx.pm	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,1115 @@
+package Test::Nginx;
+
+# (C) Maxim Dounin
+# Copyright (C) Intel, Inc
+# Generic module for nginx tests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use base qw/ Exporter /;
+
+our @EXPORT = qw/ log_in log_out http http_get http_head port /;
+our @EXPORT_OK = qw/
+    http_gzip_request http_gzip_like http_start http_end http_content
+/;
+our %EXPORT_TAGS = (
+    gzip => [ qw/ http_gzip_request http_gzip_like / ]
+);
+
+###############################################################################
+
+use File::Path qw/ rmtree /;
+use File::Spec qw//;
+use File::Temp qw/ tempdir /;
+use IO::Socket;
+use POSIX qw/ waitpid WNOHANG /;
+use Socket qw/ CRLF /;
+use Test::More qw//;
+
+###############################################################################
+
+our $NGINX = defined $ENV{TEST_NGINX_BINARY} ? $ENV{TEST_NGINX_BINARY}
+    : '../nginx/objs/nginx';
+our %ports = ();
+
+sub new {
+    my $self = {};
+    bless $self;
+
+    $self->{_pid} = $$;
+    $self->{_alerts} = 1;
+
+    $self->{_testdir} = tempdir(
+        'nginx-test-XXXXXXXXXX',
+        TMPDIR => 1
+    )
+        or die "Can't create temp directory: $!\n";
+    $self->{_testdir} =~ s!\\!/!g if $^O eq 'MSWin32';
+    mkdir "$self->{_testdir}/logs"
+        or die "Can't create logs directory: $!\n";
+
+    Test::More::BAIL_OUT("no $NGINX binary found")
+        unless -x $NGINX;
+
+    return $self;
+}
+
+sub DESTROY {
+    my ($self) = @_;
+    local $?;
+
+    return if $self->{_pid} != $$;
+
+    $self->stop();
+    $self->stop_daemons();
+
+    if (Test::More->builder->expected_tests) {
+        local $Test::Nginx::TODO = 'alerts' unless $self->{_alerts};
+
+        my @alerts = $self->read_file('error.log') =~ /.+\[alert\].+/gm;
+
+        if ($^O eq 'solaris') {
+            $Test::Nginx::TODO = 'alerts' if @alerts
+                && ! grep { $_ !~ /phantom event/ } @alerts;
+        }
+        if ($^O eq 'MSWin32') {
+            my $re = qr/CloseHandle|TerminateProcess/;
+            $Test::Nginx::TODO = 'alerts' if @alerts
+                && ! grep { $_ !~ $re } @alerts;
+        }
+
+        Test::More::is(join("\n", @alerts), '', 'no alerts');
+    }
+
+    if (Test::More->builder->expected_tests) {
+        local $Test::Nginx::TODO;
+        my $errors = $self->read_file('error.log');
+        $errors = join "\n", $errors =~ /.+Sanitizer.+/gm;
+        Test::More::is($errors, '', 'no sanitizer errors');
+    }
+
+    if ($ENV{TEST_NGINX_CATLOG}) {
+        system("cat $self->{_testdir}/error.log");
+    }
+    if (not $ENV{TEST_NGINX_LEAVE}) {
+        eval { rmtree($self->{_testdir}); };
+    }
+}
+
+sub has($;) {
+    my ($self, @features) = @_;
+
+    foreach my $feature (@features) {
+        Test::More::plan(skip_all => "no $feature available")
+            unless $self->has_module($feature)
+            or $self->has_feature($feature);
+    }
+
+    return $self;
+}
+
+sub has_module($) {
+    my ($self, $feature) = @_;
+
+    my %regex = (
+        sni    => 'TLS SNI support enabled',
+        mail    => '--with-mail((?!\S)|=dynamic)',
+        flv    => '--with-http_flv_module',
+        perl    => '--with-http_perl_module',
+        auth_request
+            => '--with-http_auth_request_module',
+        realip    => '--with-http_realip_module',
+        sub    => '--with-http_sub_module',
+        charset    => '(?s)^(?!.*--without-http_charset_module)',
+        gzip    => '(?s)^(?!.*--without-http_gzip_module)',
+        ssi    => '(?s)^(?!.*--without-http_ssi_module)',
+        mirror    => '(?s)^(?!.*--without-http_mirror_module)',
+        userid    => '(?s)^(?!.*--without-http_userid_module)',
+        access    => '(?s)^(?!.*--without-http_access_module)',
+        auth_basic
+            => '(?s)^(?!.*--without-http_auth_basic_module)',
+        autoindex
+            => '(?s)^(?!.*--without-http_autoindex_module)',
+        geo    => '(?s)^(?!.*--without-http_geo_module)',
+        map    => '(?s)^(?!.*--without-http_map_module)',
+        referer    => '(?s)^(?!.*--without-http_referer_module)',
+        rewrite    => '(?s)^(?!.*--without-http_rewrite_module)',
+        proxy    => '(?s)^(?!.*--without-http_proxy_module)',
+        fastcgi    => '(?s)^(?!.*--without-http_fastcgi_module)',
+        uwsgi    => '(?s)^(?!.*--without-http_uwsgi_module)',
+        scgi    => '(?s)^(?!.*--without-http_scgi_module)',
+        grpc    => '(?s)^(?!.*--without-http_grpc_module)',
+        memcached
+            => '(?s)^(?!.*--without-http_memcached_module)',
+        limit_conn
+            => '(?s)^(?!.*--without-http_limit_conn_module)',
+        limit_req
+            => '(?s)^(?!.*--without-http_limit_req_module)',
+        empty_gif
+            => '(?s)^(?!.*--without-http_empty_gif_module)',
+        browser    => '(?s)^(?!.*--without-http_browser_module)',
+        upstream_hash
+            => '(?s)^(?!.*--without-http_upstream_hash_module)',
+        upstream_ip_hash
+            => '(?s)^(?!.*--without-http_upstream_ip_hash_module)',
+        upstream_least_conn
+            => '(?s)^(?!.*--without-http_upstream_least_conn_mod)',
+        upstream_random
+            => '(?s)^(?!.*--without-http_upstream_random_module)',
+        upstream_keepalive
+            => '(?s)^(?!.*--without-http_upstream_keepalive_modu)',
+        upstream_zone
+            => '(?s)^(?!.*--without-http_upstream_zone_module)',
+        http    => '(?s)^(?!.*--without-http(?!\S))',
+        cache    => '(?s)^(?!.*--without-http-cache)',
+        pop3    => '(?s)^(?!.*--without-mail_pop3_module)',
+        imap    => '(?s)^(?!.*--without-mail_imap_module)',
+        smtp    => '(?s)^(?!.*--without-mail_smtp_module)',
+        pcre    => '(?s)^(?!.*--without-pcre)',
+        split_clients
+            => '(?s)^(?!.*--without-http_split_clients_module)',
+        stream    => '--with-stream((?!\S)|=dynamic)',
+        stream_access
+            => '(?s)^(?!.*--without-stream_access_module)',
+        stream_geo
+            => '(?s)^(?!.*--without-stream_geo_module)',
+        stream_limit_conn
+            => '(?s)^(?!.*--without-stream_limit_conn_module)',
+        stream_map
+            => '(?s)^(?!.*--without-stream_map_module)',
+        stream_return
+            => '(?s)^(?!.*--without-stream_return_module)',
+        stream_set
+            => '(?s)^(?!.*--without-stream_set_module)',
+        stream_split_clients
+            => '(?s)^(?!.*--without-stream_split_clients_module)',
+        stream_ssl
+            => '--with-stream_ssl_module',
+        stream_upstream_hash
+            => '(?s)^(?!.*--without-stream_upstream_hash_module)',
+        stream_upstream_least_conn
+            => '(?s)^(?!.*--without-stream_upstream_least_conn_m)',
+        stream_upstream_random
+            => '(?s)^(?!.*--without-stream_upstream_random_modul)',
+        stream_upstream_zone
+            => '(?s)^(?!.*--without-stream_upstream_zone_module)',
+    );
+
+    my $re = $regex{$feature};
+    $re = $feature if !defined $re;
+
+    $self->{_configure_args} = `$NGINX -V 2>&1`
+        if !defined $self->{_configure_args};
+
+    return 1 if $self->{_configure_args} =~ $re;
+
+    my %modules = (
+        http_geoip
+            => 'ngx_http_geoip_module',
+        image_filter
+            => 'ngx_http_image_filter_module',
+        perl    => 'ngx_http_perl_module',
+        xslt    => 'ngx_http_xslt_filter_module',
+        mail    => 'ngx_mail_module',
+        stream    => 'ngx_stream_module',
+        stream_geoip
+            => 'ngx_stream_geoip_module',
+    );
+
+    my $module = $modules{$feature};
+    if (defined $module && defined $ENV{TEST_NGINX_GLOBALS}) {
+        $re = qr/load_module\s+[^;]*\Q$module\E[-\w]*\.so\s*;/;
+        return 1 if $ENV{TEST_NGINX_GLOBALS} =~ $re;
+    }
+
+    return 0;
+}
+
+sub has_feature($) {
+    my ($self, $feature) = @_;
+
+    if ($feature eq 'symlink') {
+        return $^O ne 'MSWin32';
+    }
+
+    if ($feature eq 'unix') {
+        return $^O ne 'MSWin32';
+    }
+
+    if ($feature eq 'udp') {
+        return $^O ne 'MSWin32';
+    }
+
+    return 0;
+}
+
+sub has_version($) {
+    my ($self, $need) = @_;
+
+    $self->{_configure_args} = `$NGINX -V 2>&1`
+        if !defined $self->{_configure_args};
+
+    $self->{_configure_args} =~ m!nginx version: nginx/([0-9.]+)!;
+
+    my @v = split(/\./, $1);
+    my ($n, $v);
+
+    for $n (split(/\./, $need)) {
+        $v = shift @v || 0;
+        return 0 if $n > $v;
+        return 1 if $v > $n;
+    }
+
+    return 1;
+}
+
+sub has_daemon($) {
+    my ($self, $daemon) = @_;
+
+    if ($^O eq 'MSWin32') {
+        `for %i in ($daemon.exe) do \@echo | set /p x=%~\$PATH:i`
+            or Test::More::plan(skip_all => "$daemon not found");
+        return $self;
+    }
+
+    if ($^O eq 'solaris') {
+        Test::More::plan(skip_all => "$daemon not found")
+            unless `command -v $daemon`;
+        return $self;
+    }
+
+    Test::More::plan(skip_all => "$daemon not found")
+        unless `which $daemon`;
+
+    return $self;
+}
+
+sub try_run($$) {
+    my ($self, $message) = @_;
+
+    eval {
+        open OLDERR, ">&", \*STDERR;
+        open NEWERR, ">", $self->{_testdir} . '/stderr'
+            or die "Can't open stderr: $!";
+        close STDERR;
+        open STDERR, ">&", \*NEWERR;
+        close NEWERR;
+
+        $self->run();
+
+        close STDERR;
+        open STDERR, ">&", \*OLDERR;
+    };
+
+    return $self unless $@;
+
+    if ($ENV{TEST_NGINX_VERBOSE}) {
+        open F, '<', $self->{_testdir} . '/stderr'
+            or die "Can't open stderr: $!";
+        log_core($_) while (<F>);
+        close F;
+    }
+
+    Test::More::plan(skip_all => $message);
+    return $self;
+}
+
+sub plan($) {
+    my ($self, $plan) = @_;
+
+    Test::More::plan(tests => $plan + 2);
+
+    return $self;
+}
+
+sub todo_alerts() {
+    my ($self) = @_;
+
+    $self->{_alerts} = 0;
+
+    return $self;
+}
+
+sub run(;$) {
+    my ($self, $conf) = @_;
+
+    my $testdir = $self->{_testdir};
+
+    if (defined $conf) {
+        my $c = `cat $conf`;
+        $self->write_file_expand('nginx.conf', $c);
+    }
+
+    my $pid = fork();
+    die "Unable to fork(): $!\n" unless defined $pid;
+
+    if ($pid == 0) {
+        my @globals = $self->{_test_globals} ?
+            () : ('-g', "pid $testdir/nginx.pid; "
+            . "error_log $testdir/error.log debug;");
+        my @error = $self->has_version('1.19.5') ?
+            ('-e', 'error.log') : ();
+        exec($NGINX, '-p', "$testdir/", '-c', 'nginx.conf',
+            @error, @globals)
+            or die "Unable to exec(): $!\n";
+    }
+
+    # wait for nginx to start
+
+    $self->waitforfile("$testdir/nginx.pid", $pid)
+        or die "Can't start nginx";
+
+    for (1 .. 50) {
+        last if $^O ne 'MSWin32';
+        last if $self->read_file('error.log') =~ /create thread/;
+        select undef, undef, undef, 0.1;
+    }
+
+    $self->{_started} = 1;
+    return $self;
+}
+
+sub port {
+    my ($num, %opts) = @_;
+    my ($sock, $lock, $port);
+
+    goto done if defined $ports{$num};
+
+    my $socket = sub {
+        IO::Socket::INET->new(
+            Proto => 'tcp',
+            LocalAddr => '127.0.0.1:' . shift,
+            Listen => 1,
+            Reuse => ($^O ne 'MSWin32'),
+        );
+    };
+
+    my $socketl = sub {
+        IO::Socket::INET->new(
+            Proto => 'udp',
+            LocalAddr => '127.0.0.1:' . shift,
+        );
+    };
+
+    ($socket, $socketl) = ($socketl, $socket) if $opts{udp};
+
+    $port = $num;
+
+    for (1 .. 10) {
+        $port = int($port / 500) * 500 + int(rand(500)) unless $_ == 1;
+
+        $lock = $socketl->($port) or next;
+        $sock = $socket->($port) and last;
+    }
+
+    die "Port limit exceeded" unless defined $lock and defined $sock;
+
+    $ports{$num} = {
+        port => $port,
+        socket => $lock
+    };
+
+done:
+    return $ports{$num}{socket} if $opts{socket};
+    return $ports{$num}{port};
+}
+
+sub dump_config() {
+    my ($self) = @_;
+
+    my $testdir = $self->{_testdir};
+
+    my @globals = $self->{_test_globals} ?
+        () : ('-g', "pid $testdir/nginx.pid; "
+        . "error_log $testdir/error.log debug;");
+    my @error = $self->has_version('1.19.5') ?
+        ('-e', 'error.log') : ();
+    my $command = "$NGINX -T -p $testdir/ -c nginx.conf "
+        . join(' ', @error, @globals);
+
+    return qx/$command 2>&1/;
+}
+
+sub waitforfile($;$) {
+    my ($self, $file, $pid) = @_;
+    my $exited;
+
+    # wait for file to appear
+    # or specified process to exit
+
+    for (1 .. 50) {
+        return 1 if -e $file;
+        return 0 if $exited;
+        $exited = waitpid($pid, WNOHANG) != 0 if $pid;
+        select undef, undef, undef, 0.1;
+    }
+
+    return undef;
+}
+
+sub waitforsocket($) {
+    my ($self, $peer) = @_;
+
+    # wait for socket to accept connections
+
+    for (1 .. 50) {
+        my $s = IO::Socket::INET->new(
+            Proto => 'tcp',
+            PeerAddr => $peer
+        );
+
+        return 1 if defined $s;
+
+        select undef, undef, undef, 0.1;
+    }
+
+    return undef;
+}
+
+sub reload() {
+    my ($self) = @_;
+
+    return $self unless $self->{_started};
+
+    my $pid = $self->read_file('nginx.pid');
+
+    if ($^O eq 'MSWin32') {
+        my $testdir = $self->{_testdir};
+        my @globals = $self->{_test_globals} ?
+            () : ('-g', "pid $testdir/nginx.pid; "
+            . "error_log $testdir/error.log debug;");
+        my @error = $self->has_version('1.19.5') ?
+            ('-e', 'error.log') : ();
+        system($NGINX, '-p', $testdir, '-c', "nginx.conf",
+            '-s', 'reload', @error, @globals) == 0
+            or die "system() failed: $?\n";
+
+    } else {
+        kill 'HUP', $pid;
+    }
+
+    return $self;
+}
+
+sub stop() {
+    my ($self) = @_;
+
+    return $self unless $self->{_started};
+
+    my $pid = $self->read_file('nginx.pid');
+
+    if ($^O eq 'MSWin32') {
+        my $testdir = $self->{_testdir};
+        my @globals = $self->{_test_globals} ?
+            () : ('-g', "pid $testdir/nginx.pid; "
+            . "error_log $testdir/error.log debug;");
+        my @error = $self->has_version('1.19.5') ?
+            ('-e', 'error.log') : ();
+        system($NGINX, '-p', $testdir, '-c', "nginx.conf",
+            '-s', 'quit', @error, @globals) == 0
+            or die "system() failed: $?\n";
+
+    } else {
+        kill 'QUIT', $pid;
+    }
+
+    my $exited;
+
+    for (1 .. 900) {
+        $exited = waitpid($pid, WNOHANG) != 0;
+        last if $exited;
+        select undef, undef, undef, 0.1;
+    }
+
+    if (!$exited) {
+        if ($^O eq 'MSWin32') {
+            my $testdir = $self->{_testdir};
+            my @globals = $self->{_test_globals} ?
+                () : ('-g', "pid $testdir/nginx.pid; "
+                . "error_log $testdir/error.log debug;");
+            my @error = $self->has_version('1.19.5') ?
+                ('-e', 'error.log') : ();
+            system($NGINX, '-p', $testdir, '-c', "nginx.conf",
+                '-s', 'stop', @error, @globals) == 0
+                or die "system() failed: $?\n";
+
+        } else {
+            kill 'TERM', $pid;
+        }
+
+        waitpid($pid, 0);
+    }
+
+    $self->{_started} = 0;
+
+    return $self;
+}
+
+sub stop_daemons() {
+    my ($self) = @_;
+
+    while ($self->{_daemons} && scalar @{$self->{_daemons}}) {
+        my $p = shift @{$self->{_daemons}};
+        kill $^O eq 'MSWin32' ? 9 : 'TERM', $p;
+        waitpid($p, 0);
+    }
+
+    return $self;
+}
+
+sub read_file($) {
+    my ($self, $name) = @_;
+    local $/;
+
+    open F, '<', $self->{_testdir} . '/' . $name
+        or die "Can't open $name: $!";
+    my $content = <F>;
+    close F;
+
+    return $content;
+}
+
+sub write_file($$) {
+    my ($self, $name, $content) = @_;
+
+    open F, '>' . $self->{_testdir} . '/' . $name
+        or die "Can't create $name: $!";
+    binmode F;
+    print F $content;
+    close F;
+
+    return $self;
+}
+
+sub write_file_expand($$) {
+    my ($self, $name, $content) = @_;
+
+    $content =~ s/%%TEST_GLOBALS%%/$self->test_globals()/gmse;
+    $content =~ s/%%TEST_GLOBALS_HTTP%%/$self->test_globals_http()/gmse;
+    $content =~ s/%%TEST_GLOBALS_STREAM%%/$self->test_globals_stream()/gmse;
+    $content =~ s/%%TEST_GLOBALS_HTTPS%%/$self->test_globals_https()/gmse;
+    $content =~ s/%%GZIP_DISABLE%%/$self->test_globals_gzip_disable()/gmse;
+    $content =~ s/%%GZIP_ENABLE%%/$self->test_globals_gzip_enable()/gmse;
+    $content =~ s/%%GZIP_TYPES%%/$self->test_globals_gzip_types()/gmse;
+    $content =~ s/%%GZIP_MIN_LENGTH_0%%/$self->test_globals_gzip_min_length_0()/gmse;
+    $content =~ s/%%QATZIP_ENABLE%%/$self->test_globals_qatzip_enable()/gmse;
+    $content =~ s/%%QATZIP_DISABLE%%/$self->test_globals_qatzip_disable()/gmse;
+    $content =~ s/%%QATZIP_TYPES%%/$self->test_globals_qatzip_types()/gmse;
+    $content =~ s/%%QATZIP_MIN_LENGTH_0%%/$self->test_globals_qatzip_min_length_0()/gmse;
+    $content =~ s/%%PROXY_ASYNCH_ENABLE%%/$self->test_globals_proxy_asynch_enable()/gmse;
+    $content =~ s/%%PROXY_ASYNCH_DISABLE%%/$self->test_globals_proxy_asynch_disable()/gmse;
+    $content =~ s/%%GRPC_ASYNCH_ENABLE%%/$self->test_globals_grpc_asynch_enable()/gmse;
+    $content =~ s/%%SSL_ASYNCH%%/$self->test_globals_ssl_asynch()/gmse;
+    $content =~ s/%%TEST_NGINX_GLOBALS_HTTPS%%/$self->test_globals_https()/gmse;
+    $content =~ s/%%TESTDIR%%/$self->{_testdir}/gms;
+
+    $content =~ s/127\.0\.0\.1:(8\d\d\d)/'127.0.0.1:' . port($1)/gmse;
+
+    $content =~ s/%%PORT_(\d+)%%/port($1)/gmse;
+    $content =~ s/%%PORT_(\d+)_UDP%%/port($1, udp => 1)/gmse;
+
+    return $self->write_file($name, $content);
+}
+
+sub run_daemon($;@) {
+    my ($self, $code, @args) = @_;
+
+    my $pid = fork();
+    die "Can't fork daemon: $!\n" unless defined $pid;
+
+    if ($pid == 0) {
+        if (ref($code) eq 'CODE') {
+            $code->(@args);
+            exit 0;
+        } else {
+            exec($code, @args);
+            exit 0;
+        }
+    }
+
+    $self->{_daemons} = [] unless defined $self->{_daemons};
+    push @{$self->{_daemons}}, $pid;
+
+    return $self;
+}
+
+sub testdir() {
+    my ($self) = @_;
+    return $self->{_testdir};
+}
+
+sub test_globals() {
+    my ($self) = @_;
+
+    return $self->{_test_globals}
+        if defined $self->{_test_globals};
+
+    my $s = '';
+
+    $s .= "pid $self->{_testdir}/nginx.pid;\n";
+    $s .= "error_log $self->{_testdir}/error.log debug;\n";
+
+    $s .= $ENV{TEST_NGINX_GLOBALS}
+        if $ENV{TEST_NGINX_GLOBALS};
+
+    $s .= $self->test_globals_modules();
+    $s .= $self->test_globals_perl5lib() if $s !~ /env PERL5LIB/;
+
+    $self->{_test_globals} = $s;
+}
+
+sub test_globals_modules() {
+    my ($self) = @_;
+
+    my $modules = $ENV{TEST_NGINX_MODULES};
+
+    if (!defined $modules) {
+        my ($volume, $dir) = File::Spec->splitpath($NGINX);
+        $modules = File::Spec->catpath($volume, $dir, '');
+    }
+
+    $modules = File::Spec->rel2abs($modules);
+    $modules =~ s!\\!/!g if $^O eq 'MSWin32';
+
+    my $s = '';
+
+    $s .= "load_module $modules/ngx_http_geoip_module.so;\n"
+        if $self->has_module('http_geoip\S+=dynamic');
+
+    $s .= "load_module $modules/ngx_http_image_filter_module.so;\n"
+        if $self->has_module('image_filter\S+=dynamic');
+
+    $s .= "load_module $modules/ngx_http_perl_module.so;\n"
+        if $self->has_module('perl\S+=dynamic');
+
+    $s .= "load_module $modules/ngx_http_xslt_filter_module.so;\n"
+        if $self->has_module('xslt\S+=dynamic');
+
+    $s .= "load_module $modules/ngx_mail_module.so;\n"
+        if $self->has_module('mail=dynamic');
+
+    $s .= "load_module $modules/ngx_stream_module.so;\n"
+        if $self->has_module('stream=dynamic');
+
+    $s .= "load_module $modules/ngx_stream_geoip_module.so;\n"
+        if $self->has_module('stream_geoip\S+=dynamic');
+
+    return $s;
+}
+
+sub test_globals_perl5lib() {
+    my ($self) = @_;
+
+    return '' unless $self->has_module('perl');
+
+    my ($volume, $dir) = File::Spec->splitpath($NGINX);
+    my $objs = File::Spec->catpath($volume, $dir, '');
+
+    $objs = File::Spec->rel2abs($objs);
+    $objs =~ s!\\!/!g if $^O eq 'MSWin32';
+
+    return "env PERL5LIB=$objs/src/http/modules/perl:"
+        . "$objs/src/http/modules/perl/blib/arch;\n";
+}
+
+sub test_globals_http() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_http}
+        if defined $self->{_test_globals_http};
+
+    my $s = '';
+
+    $s .= "root $self->{_testdir};\n";
+    $s .= "access_log $self->{_testdir}/access.log;\n";
+    $s .= "client_body_temp_path $self->{_testdir}/client_body_temp;\n";
+
+    $s .= "fastcgi_temp_path $self->{_testdir}/fastcgi_temp;\n"
+        if $self->has_module('fastcgi');
+
+    $s .= "proxy_temp_path $self->{_testdir}/proxy_temp;\n"
+        if $self->has_module('proxy');
+
+    $s .= "uwsgi_temp_path $self->{_testdir}/uwsgi_temp;\n"
+        if $self->has_module('uwsgi');
+
+    $s .= "scgi_temp_path $self->{_testdir}/scgi_temp;\n"
+        if $self->has_module('scgi');
+
+    $s .= $ENV{TEST_NGINX_GLOBALS_HTTP}
+        if $ENV{TEST_NGINX_GLOBALS_HTTP};
+
+    $self->{_test_globals_http} = $s;
+}
+
+sub test_globals_stream() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_stream}
+        if defined $self->{_test_globals_stream};
+
+    my $s = '';
+
+    $s .= $ENV{TEST_NGINX_GLOBALS_STREAM}
+        if $ENV{TEST_NGINX_GLOBALS_STREAM};
+
+    $self->{_test_globals_stream} = $s;
+}
+
+sub test_globals_https() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_https}
+        if defined $self->{_test_globals_https};
+
+    my $s = '';
+    $s .= $ENV{TEST_NGINX_GLOBALS_HTTPS}
+        if $ENV{TEST_NGINX_GLOBALS_HTTPS};
+
+    $self->{_test_globals_https} = $s;
+}
+
+sub test_globals_gzip_disable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_gzip_disable}
+        if defined $self->{_test_globals_gzip_disable};
+
+    my $s = '';
+    $s .= $ENV{GZIP_DISABLE}
+        if $ENV{GZIP_DISABLE};
+
+    $self->{_test_globals_gzip_disable} = $s;
+}
+
+sub test_globals_gzip_enable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_gzip_enable}
+        if defined $self->{_test_globals_gzip_enable};
+
+    my $s = '';
+    $s .= $ENV{GZIP_ENABLE}
+        if $ENV{GZIP_ENABLE};
+
+    $self->{_test_globals_gzip_enable} = $s;
+}
+
+sub test_globals_gzip_types() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_gzip_types}
+        if defined $self->{_test_globals_gzip_types};
+
+    my $s = '';
+    $s .= $ENV{GZIP_TYPES}
+        if $ENV{GZIP_TYPES};
+
+    $self->{_test_globals_gzip_types} = $s;
+}
+
+sub test_globals_gzip_min_length_0() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_gzip_min_length_0}
+        if defined $self->{_test_globals_gzip_min_length_0};
+
+    my $s = '';
+    $s .= $ENV{GZIP_MIN_LENGTH_0}
+        if $ENV{GZIP_MIN_LENGTH_0};
+
+    $self->{_test_globals_gzip_min_length_0} = $s;
+}
+
+sub test_globals_qatzip_enable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_qatzip_enable}
+        if defined $self->{_test_globals_qatzip_enable};
+
+    my $s = '';
+    $s .= $ENV{QATZIP_ENABLE}
+        if $ENV{QATZIP_ENABLE};
+
+    $self->{_test_globals_qatzip_enable} = $s;
+}
+
+sub test_globals_qatzip_disable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_qatzip_disable}
+        if defined $self->{_test_globals_qatzip_disable};
+
+    my $s = '';
+    $s .= $ENV{QATZIP_DISABLE}
+        if $ENV{QATZIP_DISABLE};
+
+    $self->{_test_globals_qatzip_disable} = $s;
+}
+
+sub test_globals_qatzip_types() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_qatzip_types}
+        if defined $self->{_test_globals_qatzip_types};
+
+    my $s = '';
+    $s .= $ENV{QATZIP_TYPES}
+        if $ENV{QATZIP_TYPES};
+
+    $self->{_test_globals_qatzip_types} = $s;
+}
+
+sub test_globals_qatzip_min_length_0() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_qatzip_min_length_0}
+        if defined $self->{_test_globals_qatzip_min_length_0};
+
+    my $s = '';
+    $s .= $ENV{QATZIP_MIN_LENGTH_0}
+        if $ENV{QATZIP_MIN_LENGTH_0};
+
+    $self->{_test_globals_qatzip_min_length_0} = $s;
+}
+
+sub test_globals_proxy_asynch_enable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_proxy_asynch_enable}
+        if defined $self->{_test_globals_proxy_asynch_enable};
+
+    my $s = '';
+    $s .= $ENV{PROXY_ASYNCH_ENABLE}
+        if $ENV{PROXY_ASYNCH_ENABLE};
+
+    $self->{_test_globals_proxy_asynch_enable} = $s;
+}
+
+sub test_globals_proxy_asynch_disable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_proxy_asynch_disable}
+        if defined $self->{_test_globals_proxy_asynch_disable};
+
+    my $s = '';
+    $s .= $ENV{PROXY_ASYNCH_DISABLE}
+        if $ENV{PROXY_ASYNCH_DISABLE};
+
+    $self->{_test_globals_proxy_asynch_disable} = $s;
+}
+
+sub test_globals_grpc_asynch_enable() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_grpc_asynch_enable}
+        if defined $self->{_test_globals_grpc_asynch_enable};
+
+    my $s = '';
+    $s .= $ENV{GRPC_ASYNCH_ENABLE}
+        if $ENV{GRPC_ASYNCH_ENABLE};
+
+    $self->{_test_globals_grpc_asynch_enable} = $s;
+}
+
+sub test_globals_ssl_asynch() {
+    my ($self) = @_;
+
+    return $self->{_test_globals_ssl_asynch}
+        if defined $self->{_test_globals_ssl_asynch};
+
+    my $s = '';
+    $s .= $ENV{SSL_ASYNCH}
+        if $ENV{SSL_ASYNCH};
+
+    $self->{_test_globals_ssl_asynch} = $s;
+}
+
+
+###############################################################################
+
+sub log_core {
+    return unless $ENV{TEST_NGINX_VERBOSE};
+    my ($prefix, $msg) = @_;
+    ($prefix, $msg) = ('', $prefix) unless defined $msg;
+    $prefix .= ' ' if length($prefix) > 0;
+
+    if (length($msg) > 2048) {
+        $msg = substr($msg, 0, 2048)
+            . "(...logged only 2048 of " . length($msg)
+            . " bytes)";
+    }
+
+    $msg =~ s/^/# $prefix/gm;
+    $msg =~ s/([^\x20-\x7e])/sprintf('\\x%02x', ord($1)) . (($1 eq "\n") ? "\n" : '')/gmxe;
+    $msg .= "\n" unless $msg =~ /\n\Z/;
+    print $msg;
+}
+
+sub log_out {
+    log_core('>>', @_);
+}
+
+sub log_in {
+    log_core('<<', @_);
+}
+
+###############################################################################
+
+sub http_get($;%) {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub http_head($;%) {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+HEAD $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub http($;%) {
+    my ($request, %extra) = @_;
+
+    my $s = http_start($request, %extra);
+
+    return $s if $extra{start} or !defined $s;
+    return http_end($s);
+}
+
+sub http_start($;%) {
+    my ($request, %extra) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+
+        $s = $extra{socket} || IO::Socket::INET->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1:' . port(8080)
+        )
+            or die "Can't connect to nginx: $!\n";
+
+        log_out($request);
+        $s->print($request);
+
+        select undef, undef, undef, $extra{sleep} if $extra{sleep};
+        return '' if $extra{aborted};
+
+        if ($extra{body}) {
+            log_out($extra{body});
+            $s->print($extra{body});
+        }
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+sub http_end($;%) {
+    my ($s) = @_;
+    my $reply;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+
+        local $/;
+        $reply = $s->getline();
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    log_in($reply);
+    return $reply;
+}
+
+###############################################################################
+
+sub http_gzip_request {
+    my ($url) = @_;
+    my $r = http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: gzip
+
+EOF
+}
+
+sub http_content {
+    my ($text) = @_;
+
+    return undef if !defined $text;
+
+    if ($text !~ /(.*?)\x0d\x0a?\x0d\x0a?(.*)/ms) {
+        return undef;
+    }
+
+    my ($headers, $body) = ($1, $2);
+
+    if ($headers !~ /Transfer-Encoding: chunked/i) {
+        return $body;
+    }
+
+    my $content = '';
+    my $len = -1;
+
+    while ($body =~ /\G\x0d?\x0a?([0-9a-f]+)\x0d\x0a?/gcmsi) {
+        $len = hex($1);
+        $content .= substr($body, pos($body), $len);
+        pos($body) += $len;
+    }
+
+    if ($len != 0) {
+        $content .= '[no-last-chunk]';
+    }
+
+    return $content;
+}
+
+sub http_gzip_like {
+    my ($text, $re, $name) = @_;
+
+    SKIP: {
+        eval { require IO::Uncompress::Gunzip; };
+        Test::More::skip(
+            "IO::Uncompress::Gunzip not installed", 1) if $@;
+
+        my $in = http_content($text);
+        my $out;
+
+        IO::Uncompress::Gunzip::gunzip(\$in => \$out);
+
+        Test::More->builder->like($out, $re, $name);
+    }
+}
+
+###############################################################################
+
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/LICENSE ../asynch_mode_nginx/test/nginx-tests/LICENSE
--- nginx-release-1.20.1/test/nginx-tests/LICENSE	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/LICENSE	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,31 @@
+/*
+ * BSD LICENSE
+ *
+ * Copyright (C) 2008-2011 Maxim Dounin
+ * Copyright (C) 2014-2021 Intel, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_conn_complex.t ../asynch_mode_nginx/test/nginx-tests/limit_conn_complex.t
--- nginx-release-1.20.1/test/nginx-tests/limit_conn_complex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_conn_complex.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,100 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# limit_req based tests for limit_conn module with complex keys.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/)
+    ->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr$arg_r  zone=req:1m rate=1r/m;
+    limit_req_zone   $binary_remote_addr        zone=re2:1m rate=1r/m;
+    limit_conn_zone  $binary_remote_addr$arg_c  zone=conn:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_conn conn 1;
+        }
+
+        location /w {
+            limit_conn conn 1;
+            proxy_pass http://127.0.0.1:8080/req2;
+        }
+
+        location /req {
+            limit_req  zone=req burst=2;
+        }
+
+        location /req2 {
+            limit_req  zone=re2 burst=2;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('req', '');
+$t->run();
+
+###############################################################################
+
+my $s;
+
+# charge limit_req
+
+http_get('/req');
+
+# limit_req tests
+
+$s = http_get('/req', start => 1);
+ok(!IO::Select->new($s)->can_read(1), 'limit_req same key');
+
+like(http_get('/req?r=2'), qr/200 OK/, 'limit_req different key');
+
+# limit_conn tests
+
+http_get('/req2');
+
+$s = http_get('/w', start => 1);
+select undef, undef, undef, 0.2;
+
+like(http_get('/'), qr/^HTTP\/1.. 503 /, 'limit_conn same key');
+unlike(http_get('/?c=2'), qr/^HTTP\/1.. 503 /, 'limit_conn different key');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_conn_dry_run.t ../asynch_mode_nginx/test/nginx-tests/limit_conn_dry_run.t
--- nginx-release-1.20.1/test/nginx-tests/limit_conn_dry_run.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_conn_dry_run.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_conn_dry_run directive, limit_conn_status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=30r/m;
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    log_format test $uri:$limit_conn_status;
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /w {
+            limit_req  zone=req burst=10;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Status $limit_conn_status always;
+        access_log %%TESTDIR%%/test.log test;
+
+        location /reject {
+            proxy_pass http://127.0.0.1:8081/w;
+            limit_conn zone 1;
+        }
+
+        location /dry {
+            limit_conn zone 1;
+            limit_conn_dry_run on;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('w', '');
+$t->try_run('no limit_conn_dry_run/limit_conn_status')->plan(6);
+
+###############################################################################
+
+like(http_get('/reject'), qr/ 200 .*PASSED/s, 'passed');
+
+my $s = http_get('/reject', start => 1);
+like(http_get('/reject'), qr/ 503 .*REJECTED(?!_)/s, 'rejected');
+like(http_get('/dry'), qr/ 404 .*REJECTED_DRY_RUN/s, 'rejected dry run');
+unlike(http_get('/'), qr/X-Status/, 'no limit');
+
+close $s;
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/limiting connections, dry/, 'log dry run');
+like($t->read_file('test.log'), qr|^/:-|m, 'log not found');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_conn.t ../asynch_mode_nginx/test/nginx-tests/limit_conn.t
--- nginx-release-1.20.1/test/nginx-tests/limit_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_conn.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+
+# limit_req based tests for nginx limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy limit_conn limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(8);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone   $binary_remote_addr  zone=req:1m rate=30r/m;
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+    limit_conn_zone  $binary_remote_addr  zone=custom:1m;
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location /w {
+            limit_req  zone=req burst=10;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            limit_conn zone 1;
+        }
+
+        location /1 {
+            limit_conn zone 1;
+        }
+
+        location /zone {
+            limit_conn zone2 1;
+        }
+
+        location /unlim {
+            limit_conn zone 5;
+        }
+
+        location /custom {
+            proxy_pass http://127.0.0.1:8081/;
+            limit_conn_log_level info;
+            limit_conn_status 501;
+            limit_conn custom 1;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# charge limit_req
+
+http_get('/w');
+
+# same and other zones in different locations
+
+my $s = http_get('/w', start => 1);
+like(http_get('/'), qr/^HTTP\/1.. 503 /, 'rejected');
+like(http_get('/1'), qr/^HTTP\/1.. 503 /, 'rejected different location');
+unlike(http_get('/zone'), qr/^HTTP\/1.. 503 /, 'passed different zone');
+
+close $s;
+unlike(http_get('/1'), qr/^HTTP\/1.. 503 /, 'passed');
+
+# custom error code and log level
+
+$s = http_get('/custom/w', start => 1);
+like(http_get('/custom'), qr/^HTTP\/1.. 501 /, 'limit_conn_status');
+
+like($t->read_file('error.log'),
+    qr/\[info\].*limiting connections by zone "custom"/,
+    'limit_conn_log_level');
+
+# limited after unlimited
+
+$s = http_get('/w', start => 1);
+like(http_get('/unlim'), qr/404 Not Found/, 'unlimited passed');
+like(http_get('/'), qr/503 Service/, 'limited rejected');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_rate.t ../asynch_mode_nginx/test/nginx-tests/limit_rate.t
--- nginx-release-1.20.1/test/nginx-tests/limit_rate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_rate.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_rate and limit_rate_after directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test escape=none $uri:$arg_a$arg_xal:$upstream_response_time;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            access_log %%TESTDIR%%/test.log test;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        limit_rate 12k;
+        limit_rate_after 256;
+
+        location /data {
+            add_header X-Accel-Redirect $arg_xar;
+            add_header X-Accel-Limit-Rate $arg_xal;
+        }
+
+        location /redirect {
+            limit_rate 0;
+            alias %%TESTDIR%%/data;
+        }
+
+        location /var {
+            alias %%TESTDIR%%/data;
+            limit_rate $arg_l;
+            limit_rate_after $arg_a;
+        }
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('data', 'X' x 30000);
+$t->try_run('no limit_rate variables')->plan(7);
+
+###############################################################################
+
+# NB: response time may be 1s less, if timer is scheduled on upper half second
+
+like(http_get('/data'), qr/^(XXXXXXXXXX){3000}\x0d?\x0a?$/m, 'response body');
+like($t->read_file('test.log'), qr/data::[12]/, 'limit_rate');
+
+# /proxy -> /redirect
+# before 1.17.0, limit was set once in ngx_http_update_location_config()
+
+http_get('/proxy/data?xar=/redirect');
+like($t->read_file('test.log'), qr!proxy/data::0!, 'X-Accel-Redirect');
+
+# X-Accel-Limit-Rate has higher precedence
+
+http_get('/proxy/data?xar=/redirect&xal=13000');
+like($t->read_file('test.log'), qr!roxy/data:13000:[12]!, 'X-Accel-Limit-Rate');
+
+http_get('/var?l=12k&a=256');
+like($t->read_file('test.log'), qr/var:256:[12]/, 'variable');
+
+http_get('/var?l=12k&a=40k');
+like($t->read_file('test.log'), qr/var:40k:0/, 'variable after');
+
+http_get('/var');
+like($t->read_file('test.log'), qr/var::0/, 'variables unset');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_req2.t ../asynch_mode_nginx/test/nginx-tests/limit_req2.t
--- nginx-release-1.20.1/test/nginx-tests/limit_req2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_req2.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, multiple limits.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(14);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $arg_a  zone=slow:1m   rate=1r/m;
+    limit_req_zone  $arg_b  zone=fast:1m   rate=1000r/s;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_req    zone=fast;
+            limit_req    zone=slow;
+        }
+
+        location /t2.html {
+            limit_req    zone=fast  nodelay;
+            limit_req    zone=slow  nodelay;
+
+            alias %%TESTDIR%%/t1.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html?b=1'), qr/^HTTP\/1.. 200 /m, 'fast');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?b=1'), qr/^HTTP\/1.. 200 /m, 'fast - passed');
+
+like(http_get('/t1.html?a=1'), qr/^HTTP\/1.. 200 /m, 'slow');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?a=1'), qr/^HTTP\/1.. 503 /m, 'slow - rejected');
+
+like(http_get('/t1.html?a=2&b=2'), qr/^HTTP\/1.. 200 /m, 'both');
+select undef, undef, undef, 0.1;
+like(http_get('/t1.html?a=2&b=2'), qr/^HTTP\/1.. 503 /m, 'both - rejected');
+
+like(http_get('/t1.html'), qr/^HTTP\/1.. 200 /m, 'no key');
+like(http_get('/t1.html'), qr/^HTTP\/1.. 200 /m, 'no key - passed');
+
+# nodelay
+
+like(http_get('/t2.html?b=3'), qr/^HTTP\/1.. 200 /m, 'nodelay fast');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?b=3'), qr/^HTTP\/1.. 200 /m, 'nodelay fast - passed');
+
+like(http_get('/t2.html?a=3'), qr/^HTTP\/1.. 200 /m, 'nodelay slow');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?a=3'), qr/^HTTP\/1.. 503 /m, 'nodelay slow - rejected');
+
+like(http_get('/t2.html?a=4&b=4'), qr/^HTTP\/1.. 200 /m, 'nodelay both');
+select undef, undef, undef, 0.1;
+like(http_get('/t2.html?a=4&b=4'), qr/^HTTP\/1.. 503 /m,
+    'nodelay both - rejected');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_req_delay.t ../asynch_mode_nginx/test/nginx-tests/limit_req_delay.t
--- nginx-release-1.20.1/test/nginx-tests/limit_req_delay.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_req_delay.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,66 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, delay parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=30r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            limit_req zone=one delay=1 burst=2;
+            add_header X-Time $request_time;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('delay.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/delay.html'), qr/^HTTP\/1.. 200 /m, 'request');
+like(http_get('/delay.html'), qr/X-Time: 0.000/, 'not yet delayed');
+my $s = http_get('/delay.html', start => 1, sleep => 0.2);
+like(http_get('/delay.html'), qr/^HTTP\/1.. 503 /m, 'rejected');
+like(http_end($s), qr/^HTTP\/1.. 200 .*X-Time: (?!0.000)/ms, 'delayed');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_req_dry_run.t ../asynch_mode_nginx/test/nginx-tests/limit_req_dry_run.t
--- nginx-release-1.20.1/test/nginx-tests/limit_req_dry_run.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_req_dry_run.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx limit_req module, limit_req_dry_run directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m   rate=1r/m;
+
+    log_format test $uri:$limit_req_status;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        limit_req_dry_run  on;
+        add_header X-Status $limit_req_status always;
+        access_log %%TESTDIR%%/test.log test;
+
+        location /delay {
+            limit_req    zone=one  burst=2;
+        }
+
+        location /reject {
+            limit_req    zone=one;
+        }
+
+        location /reject/off {
+            limit_req    zone=one;
+
+            limit_req_dry_run off;
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('delay', 'SEE-THIS');
+$t->write_file('reject', 'SEE-THIS');
+$t->try_run('no limit_req_dry_run/limit_req_status')->plan(8);
+
+###############################################################################
+
+like(http_get('/delay'), qr/ 200 .*PASSED/ms, 'dry run - passed');
+like(http_get('/delay'), qr/ 200 .*DELAYED_DRY_RUN/ms, 'dry run - delayed');
+like(http_get('/reject'), qr/ 200 .*REJECTED_DRY_RUN/ms, 'dry run - rejected');
+
+like(http_get('/reject/off'), qr/ 503 .*REJECTED/ms, 'dry run off - rejected');
+
+unlike(http_get('/'), qr/X-Status/, 'no limit');
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/delaying request, dry/, 'log - delay');
+like($t->read_file('error.log'), qr/limiting requests, dry/, 'log - reject');
+
+like($t->read_file('test.log'), qr|^/:-|m, 'log - not found');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/limit_req.t ../asynch_mode_nginx/test/nginx-tests/limit_req.t
--- nginx-release-1.20.1/test/nginx-tests/limit_req.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/limit_req.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx limit_req module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m   rate=2r/s;
+    limit_req_zone  $binary_remote_addr  zone=long:1m  rate=2r/s;
+    limit_req_zone  $binary_remote_addr  zone=fast:1m  rate=1000r/s;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            limit_req    zone=one  burst=1  nodelay;
+        }
+        location /status {
+            limit_req    zone=one  burst=1  nodelay;
+
+            limit_req_status  501;
+        }
+        location /long {
+            limit_req    zone=long  burst=5;
+        }
+        location /fast {
+            limit_req    zone=fast  burst=1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test1.html', 'XtestX');
+$t->write_file('long.html', "1234567890\n" x (1 << 16));
+$t->write_file('fast.html', 'XtestX');
+$t->run();
+
+###############################################################################
+
+like(http_get('/test1.html'), qr/^HTTP\/1.. 200 /m, 'request');
+http_get('/test1.html');
+like(http_get('/test1.html'), qr/^HTTP\/1.. 503 /m, 'request rejected');
+like(http_get('/status.html'), qr/^HTTP\/1.. 501 /m, 'request rejected status');
+http_get('/test1.html');
+http_get('/test1.html');
+
+# Second request will be delayed by limit_req, make sure it isn't truncated.
+# The bug only manifests itself if buffer will be filled, so sleep for a while
+# before reading response.
+
+my $l1 = length(http_get('/long.html'));
+my $l2 = length(http_get('/long.html', sleep => 0.6));
+is($l2, $l1, 'delayed big request not truncated');
+
+# make sure rejected requests are not counted, and access is again allowed
+# after 1/rate seconds
+
+like(http_get('/test1.html'), qr/^HTTP\/1.. 200 /m, 'rejects not counted');
+
+# make sure negative excess values are handled properly
+
+http_get('/fast.html');
+select undef, undef, undef, 0.1;
+like(http_get('/fast.html'), qr/^HTTP\/1.. 200 /m, 'negative excess');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_capability.t ../asynch_mode_nginx/test/nginx-tests/mail_capability.t
--- nginx-release-1.20.1/test/nginx-tests/mail_capability.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_capability.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,229 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for imap/pop3/smtp capabilities.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+use Test::Nginx::POP3;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap pop3 smtp/)
+    ->has_daemon('openssl')->plan(17);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    auth_http  http://127.0.0.1:8080; # unused
+
+    pop3_auth  plain apop cram-md5;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+        imap_capabilities SEE-THIS;
+    }
+
+    server {
+        listen     127.0.0.1:8144;
+        protocol   imap;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8145;
+        protocol   imap;
+        starttls   only;
+    }
+
+    server {
+        listen     127.0.0.1:8110;
+        protocol   pop3;
+    }
+
+    server {
+        listen     127.0.0.1:8111;
+        protocol   pop3;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8112;
+        protocol   pop3;
+        starttls   only;
+    }
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        starttls   off;
+    }
+
+    server {
+        listen     127.0.0.1:8026;
+        protocol   smtp;
+        starttls   on;
+    }
+
+    server {
+        listen     127.0.0.1:8027;
+        protocol   smtp;
+        starttls   only;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+# imap, custom capabilities
+
+my $s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY SEE-THIS AUTH=PLAIN/, 'imap capability');
+$s->ok('imap capability completed');
+
+# imap starttls
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8144));
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY IMAP4 IMAP4rev1 UIDPLUS AUTH=PLAIN STARTTLS/,
+    'imap capability starttls');
+
+# imap starttls only
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145));
+$s->read();
+
+$s->send('1 CAPABILITY');
+$s->check(qr/^\* CAPABILITY IMAP4 IMAP4rev1 UIDPLUS STARTTLS LOGINDISABLED/,
+    'imap capability starttls only');
+
+# pop3
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8110));
+$s->read();
+
+$s->send('CAPA');
+$s->ok('pop3 capa');
+
+my $caps = get_auth_caps($s);
+like($caps, qr/USER/, 'pop3 - user');
+like($caps, qr/SASL (PLAIN LOGIN|LOGIN PLAIN) CRAM-MD5/, 'pop3 - methods');
+unlike($caps, qr/STLS/, 'pop3 - no stls');
+
+# pop3 starttls
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8111));
+$s->read();
+
+$s->send('CAPA');
+
+$caps = get_auth_caps($s);
+like($caps, qr/USER/, 'pop3 starttls - user');
+like($caps, qr/SASL (PLAIN LOGIN|LOGIN PLAIN) CRAM-MD5/,
+    'pop3 starttls - methods');
+like($caps, qr/STLS/, 'pop3 startls - stls');
+
+# pop3 starttls only
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8112));
+$s->read();
+
+$s->send('CAPA');
+
+$caps = get_auth_caps($s);
+unlike($caps, qr/USER/, 'pop3 starttls only - no user');
+unlike($caps, qr/SASL/, 'pop3 starttls only - no methods');
+like($caps, qr/STLS/, 'pop3 startls only - stls');
+
+# smtp
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8025));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 AUTH PLAIN LOGIN\x0d\x0a?/, 'smtp ehlo');
+
+# smtp starttls
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8026));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 STARTTLS/, 'smtp ehlo - starttls');
+
+# smtp starttls only
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 STARTTLS/, 'smtp ehlo - starttls only');
+
+###############################################################################
+
+sub get_auth_caps {
+    my ($s) = @_;
+    my @meth;
+
+    while ($s->read()) {
+        last if /^\./;
+        push @meth, $1 if /(.*?)\x0d\x0a?/ms;
+    }
+    join ':', @meth;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_error_log.t ../asynch_mode_nginx/test/nginx-tests/mail_error_log.t
--- nginx-release-1.20.1/test/nginx-tests/mail_error_log.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_error_log.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,269 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx mail imap module, error_log directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Sys::Hostname;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/);
+
+$t->plan(30)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log %%TESTDIR%%/e_glob.log info;
+error_log %%TESTDIR%%/e_glob2.log info;
+error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% info;
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+
+        error_log %%TESTDIR%%/e_debug.log debug;
+        error_log %%TESTDIR%%/e_info.log info;
+        error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% info;
+        error_log stderr info;
+    }
+
+    server {
+        listen     127.0.0.1:8145;
+        protocol   imap;
+
+        error_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% info;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+    or die "Can't open stderr file: $!";
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run_daemon(\&syslog_daemon, port(8981), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8982), $t, 's_info.log');
+
+$t->waitforsocket('127.0.0.1:' . port(8144));
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_info.log');
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+# error_log levels
+
+SKIP: {
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(lines($t, 'e_debug.log', '[debug]'), 0, 'file debug in debug');
+
+}
+
+isnt(lines($t, 'e_info.log', '[info]'), 0, 'file info in info');
+is(lines($t, 'e_info.log', '[debug]'), 0, 'file debug in info');
+isnt(lines($t, 'stderr', '[info]'), 0, 'stderr info in info');
+is(lines($t, 'stderr', '[debug]'), 0, 'stderr debug in info');
+
+# multiple error_log
+
+like($t->read_file('e_glob.log'), qr!nginx/[.0-9]+!, 'error global');
+like($t->read_file('e_glob2.log'), qr!nginx/[.0-9]+!, 'error global 2');
+is_deeply(levels($t, 'e_glob.log'), levels($t, 'e_glob2.log'),
+    'multiple error global');
+
+# syslog
+
+parse_syslog_message('syslog', get_syslog());
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'e_glob.log'),
+    'global syslog messages');
+is_deeply(levels($t, 's_info.log'), levels($t, 'e_info.log'),
+    'mail syslog messages');
+
+###############################################################################
+
+sub lines {
+    my ($t, $file, $pattern) = @_;
+
+    if ($file eq 'stderr') {
+        return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+    }
+
+    my $path = $t->testdir() . '/' . $file;
+    open my $fh, '<', $path or return "$!";
+    my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+    close $fh;
+    return $value;
+}
+
+sub levels {
+    my ($t, $file) = @_;
+    my %levels_hash;
+
+    map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+    return \%levels_hash;
+}
+
+sub get_syslog {
+    my $data = '';
+    my ($s);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(1);
+        $s = IO::Socket::INET->new(
+            Proto => 'udp',
+            LocalAddr => '127.0.0.1:' . port(8983)
+        );
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145))->read();
+
+    IO::Select->new($s)->can_read(1.5);
+    while (IO::Select->new($s)->can_read(0.1)) {
+        my $buffer;
+        sysread($s, $buffer, 4096);
+        $data .= $buffer;
+    }
+    $s->close();
+    return $data;
+}
+
+sub parse_syslog_message {
+    my ($desc, $line) = @_;
+
+    ok($line, $desc);
+
+SKIP: {
+    skip "$desc timeout", 18 unless $line;
+
+    my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+        'Sep', 'Oct', 'Nov', 'Dec');
+
+    my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+        $line =~ /^<(\d{1,3})>                # PRI
+            ([A-Z][a-z]{2})\s            # mon
+            ([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s    # date
+            ([\S]*)\s                # host
+            (\w{1,32}):\s                # tag
+            (.*)/x;                    # MSG
+
+    my $sev = $pri & 0x07;
+    my $fac = ($pri & 0x03f8) >> 3;
+
+    ok(defined($pri), "$desc has PRI");
+    ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+    ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+    ok(defined($mon), "$desc has month");
+    ok((grep $mon, @months), "$desc valid month");
+
+    ok(defined($mday), "$desc has day");
+    ok($mday <= 31, "$desc valid day");
+
+    ok(defined($hour), "$desc has hour");
+    ok($hour < 24, "$desc valid hour");
+
+    ok(defined($minute), "$desc has minutes");
+    ok($minute < 60, "$desc valid minutes");
+
+    ok(defined($sec), "$desc has seconds");
+    ok($sec < 60, "$desc valid seconds");
+
+    ok(defined($host), "$desc has host");
+    is($host, lc(hostname()), "$desc valid host");
+
+    ok(defined($tag), "$desc has tag");
+    like($tag, qr'\w+', "$desc valid tag");
+
+    ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+}
+
+###############################################################################
+
+sub syslog_daemon {
+    my ($port, $t, $file) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$port"
+    );
+
+    open my $fh, '>', $t->testdir() . '/' . $file;
+    select $fh; $| = 1;
+
+    while (1) {
+        my $buffer;
+        $s->recv($buffer, 4096);
+        print $fh $buffer . "\n";
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_imap_ssl.t ../asynch_mode_nginx/test/nginx-tests/mail_imap_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/mail_imap_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_imap_ssl.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,228 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx mail imap module with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap http rewrite/)
+    ->has_daemon('openssl')->plan(12)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    auth_http_pass_client_cert on;
+
+    ssl_certificate_key 1.example.com.key;
+    ssl_certificate 1.example.com.crt;
+
+    server {
+        listen     127.0.0.1:8142;
+        protocol   imap;
+    }
+
+    server {
+        listen     127.0.0.1:8143 ssl %%SSL_ASYNCH%%;
+        protocol   imap;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8145 ssl %%SSL_ASYNCH%%;
+        protocol   imap;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8146 ssl %%SSL_ASYNCH%%;
+        protocol   imap;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen     127.0.0.1:8147 ssl %%SSL_ASYNCH%%;
+        protocol   imap;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format  test  '$http_auth_ssl:$http_auth_ssl_verify:'
+                      '$http_auth_ssl_subject:$http_auth_ssl_issuer:'
+                      '$http_auth_ssl_serial:$http_auth_ssl_fingerprint:'
+                      '$http_auth_ssl_cert:$http_auth_pass';
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            access_log auth.log test;
+
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8144));
+
+###############################################################################
+
+my $cred = sub { encode_base64("\0test\@example.com\0$_[0]", '') };
+my %ssl = (
+    SSL => 1,
+    SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+    SSL_error_trap => sub { die $_[1] },
+);
+
+# no ssl connection
+
+my $s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8142));
+$s->ok('plain connection');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s1"));
+
+# no cert
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8143), %ssl);
+$s->check(qr/BYE No required SSL certificate/, 'no cert');
+
+# no cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8145), %ssl);
+$s->ok('no optional cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s2"));
+
+# wrong cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+    PeerAddr => '127.0.0.1:' . port(8145),
+    SSL_cert_file => "$d/1.example.com.crt",
+    SSL_key_file => "$d/1.example.com.key",
+    %ssl,
+);
+$s->check(qr/BYE SSL certificate error/, 'bad optional cert');
+
+# wrong cert with ssl_verify_client optional_no_ca
+
+$s = Test::Nginx::IMAP->new(
+    PeerAddr => '127.0.0.1:' . port(8147),
+    SSL_cert_file => "$d/1.example.com.crt",
+    SSL_key_file => "$d/1.example.com.key",
+    %ssl,
+);
+$s->ok('bad optional_no_ca cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s3"));
+
+# matching cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+    PeerAddr => '127.0.0.1:' . port(8145),
+    SSL_cert_file => "$d/2.example.com.crt",
+    SSL_key_file => "$d/2.example.com.key",
+    %ssl,
+);
+$s->ok('good cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s4"));
+
+# trusted cert with ssl_verify_client optional
+
+$s = Test::Nginx::IMAP->new(
+    PeerAddr => '127.0.0.1:' . port(8146),
+    SSL_cert_file => "$d/3.example.com.crt",
+    SSL_key_file => "$d/3.example.com.key",
+    %ssl,
+);
+$s->ok('trusted cert');
+$s->send('1 AUTHENTICATE PLAIN ' . $cred->("s5"));
+$s->read();
+
+# test auth_http request header fields with access_log
+
+$t->stop();
+
+my $f = $t->read_file('auth.log');
+
+like($f, qr/^-:-:-:-:-:-:-\x0d?\x0a?:s1$/m, 'log - plain connection');
+like($f, qr/^on:NONE:-:-:-:-:-\x0d?\x0a?:s2$/m, 'log - no cert');
+like($f, qr!^on:FAILED(?:.*):(/?CN=1.example.com):\1:\w+:\w+:[^:]+:s3$!m,
+    'log - bad cert');
+like($f, qr!^on:SUCCESS:(/?CN=2.example.com):\1:\w+:\w+:[^:]+:s4$!m,
+    'log - good cert');
+like($f, qr!^on:SUCCESS:(/?CN=3.example.com):\1:\w+:\w+:[^:]+:s5$!m,
+    'log - trusted cert');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_imap.t ../asynch_mode_nginx/test/nginx-tests/mail_imap.t
--- nginx-release-1.20.1/test/nginx-tests/mail_imap.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_imap.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,274 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx mail imap module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+        imap_auth  plain cram-md5 external;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+            set $passw "";
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass = 'test@example.com:secret') {
+                set $reply OK;
+            }
+            if ($userpass = 'te\\"st@example.com:se\\"cret') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass = 'external:test@example.com:') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8144%%;
+            add_header Auth-Pass $passw;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::IMAP::imap_test_daemon);
+$t->run()->plan(29);
+
+$t->waitforsocket('127.0.0.1:' . port(8144));
+
+###############################################################################
+
+# login
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+$s->send('a01 LOGIN');
+$s->check(qr/^a01 BAD/, 'login without arguments');
+
+$s->send('a02 LOGIN test@example.com bad');
+$s->check(qr/^a02 NO/, 'login with bad password');
+
+$s->send('a03 LOGIN test@example.com secret');
+$s->ok('login');
+
+# auth
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE');
+$s->check(qr/^\S+ BAD/, 'auth without arguments');
+
+# auth plain
+
+$s->send('1 AUTHENTICATE PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^\S+ NO/, 'auth plain with bad password');
+
+$s->send('1 AUTHENTICATE PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->ok('auth plain');
+
+# auth login simple
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth login username challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login simple');
+
+# auth login with username
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login with username password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login with username');
+
+# auth cram-md5
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE CRAM-MD5');
+$s->check(qr/\+ /, 'auth cram-md5 challenge');
+
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->ok('auth cram-md5');
+
+# auth external
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE EXTERNAL');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth external challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# auth external with username
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('1 AUTHENTICATE EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+# quoted strings
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 LOGIN "te\\\\\"st@example.com" "se\\\\\"cret"');
+$s->ok('quoted strings');
+
+# literals
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 LOGIN {18}');
+$s->check(qr/\+ /, 'login username literal continue');
+
+$s->send('te\"st@example.com' . ' {8}');
+$s->check(qr/\+ /, 'login password literal continue');
+
+$s->send('se\"cret');
+$s->ok('login literals');
+
+# non-synchronizing literals
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 LOGIN {18+}' . CRLF
+    . 'te\"st@example.com' . ' {8+}' . CRLF
+    . 'se\"cret');
+$s->ok('login non-sync literals');
+
+# backslash in quotes and literals
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 LOGIN {18+}' . CRLF
+    . 'te\"st@example.com' . ' "se\\\\\"cret"');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->ok('backslash in literal');
+
+}
+
+# pipelining
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 INVALID COMMAND WITH ARGUMENTS' . CRLF
+    . 'a02 NOOP');
+$s->check(qr/^a01 BAD/, 'pipelined invalid command');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->ok('pipelined noop after invalid command');
+
+}
+
+$s->send('a03 FOOBAR {10+}' . CRLF
+    . 'test test ' . CRLF
+    . 'a04 NOOP');
+$s->check(qr/^a03 BAD/, 'invalid with non-sync literal');
+$s->check(qr/^(a04 |$)/, 'literal not command');
+
+TODO: {
+todo_skip('not yet', 2) unless $t->has_version('1.21.0');
+
+# skipped without a fix, since with level-triggered event methods
+# this hogs cpu till the connection is closed by the backend server,
+# and generates a lot of debug logs
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 LOGIN test@example.com secret' . CRLF
+    . 'a02 LOGOUT');
+$s->ok('pipelined login');
+$s->ok('pipelined logout');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_max_errors.t ../asynch_mode_nginx/test/nginx-tests/mail_max_errors.t
--- nginx-release-1.20.1/test/nginx-tests/mail_max_errors.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_max_errors.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,129 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for mail max_errors.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+use Test::Nginx::POP3;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail imap pop3 smtp/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    auth_http  http://127.0.0.1:8080; # unused
+
+    max_errors 2;
+
+    server {
+        listen     127.0.0.1:8143;
+        protocol   imap;
+    }
+
+    server {
+        listen     127.0.0.1:8110;
+        protocol   pop3;
+    }
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+    }
+}
+
+EOF
+
+$t->try_run('no max_errors')->plan(18);
+
+###############################################################################
+
+# imap
+
+my $s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 FOO');
+$s->check(qr/^a01 BAD/, 'imap first error');
+$s->send('a02 BAR');
+$s->check(qr/^a02 BAD/, 'imap second error');
+$s->send('a03 BAZZ');
+$s->check(qr/^$/, 'imap max errors');
+
+$s = Test::Nginx::IMAP->new();
+$s->read();
+
+$s->send('a01 FOO' . CRLF . 'a02 BAR' . CRLF . 'a03 BAZZ');
+$s->check(qr/^a01 BAD/, 'imap pipelined first error');
+$s->check(qr/^a02 BAD/, 'imap pipelined second error');
+$s->check(qr/^$/, 'imap pipelined max errors');
+
+# pop3
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('FOO');
+$s->check(qr/^-ERR/, 'pop3 first error');
+$s->send('BAR');
+$s->check(qr/^-ERR/, 'pop3 second error');
+$s->send('BAZZ');
+$s->check(qr/^$/, 'pop3 max errors');
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('FOO' . CRLF . 'BAR' . CRLF . 'BAZZ');
+$s->check(qr/^-ERR/, 'pop3 pipelined first error');
+$s->check(qr/^-ERR/, 'pop3 pipelined second error');
+$s->check(qr/^$/, 'pop3 pipelined max errors');
+
+# smtp
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+
+$s->send('FOO');
+$s->check(qr/^5.. /, 'smtp first error');
+$s->send('BAR');
+$s->check(qr/^5.. /, 'smtp second error');
+$s->send('BAZZ');
+$s->check(qr/^$/, 'smtp max errors');
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+
+$s->send('FOO' . CRLF . 'BAR' . CRLF . 'BAZZ');
+$s->check(qr/^5.. /, 'smtp pipelined first error');
+$s->check(qr/^5.. /, 'smtp pipelined second error');
+$s->check(qr/^$/, 'smtp pipelined max errors');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_pop3.t ../asynch_mode_nginx/test/nginx-tests/mail_pop3.t
--- nginx-release-1.20.1/test/nginx-tests/mail_pop3.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_pop3.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,256 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx mail pop3 module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::POP3;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail pop3 http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+
+    server {
+        listen     127.0.0.1:8110;
+        protocol   pop3;
+        pop3_auth  plain apop cram-md5 external;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+            set $passw "";
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:secret$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^external:test@example.com:$') {
+                set $reply OK;
+                set $passw secret;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8111%%;
+            add_header Auth-Pass $passw;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::POP3::pop3_test_daemon);
+$t->run()->plan(28);
+
+$t->waitforsocket('127.0.0.1:' . port(8111));
+
+###############################################################################
+
+my $s = Test::Nginx::POP3->new();
+$s->ok('greeting');
+
+# user / pass
+
+$s->send('USER test@example.com');
+$s->ok('user');
+
+$s->send('PASS secret');
+$s->ok('pass');
+
+# apop
+
+$s = Test::Nginx::POP3->new();
+$s->check(qr/<.*\@.*>/, 'apop salt');
+
+$s->send('APOP test@example.com ' . ('1' x 32));
+$s->check(qr/^-ERR/, 'apop error');
+
+$s->send('APOP test@example.com ' . ('0' x 32));
+$s->ok('apop');
+
+# auth capabilities
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH');
+$s->ok('auth');
+
+is(get_auth_caps($s), 'PLAIN:LOGIN:CRAM-MD5:EXTERNAL', 'auth capabilities');
+
+# auth plain
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^-ERR/, 'auth plain with bad password');
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->ok('auth plain');
+
+# auth login simple
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth login username challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login simple');
+
+# auth login with username
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'auth login with username password challenge');
+
+$s->send(encode_base64('secret', ''));
+$s->ok('auth login with username');
+
+# auth cram-md5
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH CRAM-MD5');
+$s->check(qr/\+ /, 'auth cram-md5 challenge');
+
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->ok('auth cram-md5');
+
+# auth external
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH EXTERNAL');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'auth external challenge');
+
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# auth external with username
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+# pipelining
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('INVALID COMMAND WITH ARGUMENTS' . CRLF
+    . 'NOOP');
+$s->check(qr/^-ERR/, 'pipelined invalid command');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->ok('pipelined noop after invalid command');
+
+}
+
+$s->send('USER test@example.com' . CRLF
+    . 'PASS secret' . CRLF
+    . 'QUIT');
+$s->ok('pipelined user');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->ok('pipelined pass');
+$s->ok('pipelined quit');
+
+}
+
+$s = Test::Nginx::POP3->new();
+$s->read();
+
+$s->send('AUTH LOGIN' . CRLF
+    . encode_base64('test@example.com', '') . CRLF
+    . encode_base64('secret', ''));
+$s->check(qr/\+ VXNlcm5hbWU6/, 'pipelined auth username challenge');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->check(qr/\+ UGFzc3dvcmQ6/, 'pipelined auth password challenge');
+$s->ok('pipelined auth');
+
+}
+
+###############################################################################
+
+sub get_auth_caps {
+    my ($s) = @_;
+    my @meth;
+
+    while ($s->read()) {
+        last if /^\./;
+        push @meth, $1 if /(.*?)\x0d\x0a?/ms;
+    }
+    join ':', @meth;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_proxy_protocol.t ../asynch_mode_nginx/test/nginx-tests/mail_proxy_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/mail_proxy_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_proxy_protocol.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,135 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mail proxy module, PROXY protocol with realip.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout             15s;
+    proxy_smtp_auth           on;
+    proxy_protocol            on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    smtp_auth  login plain;
+
+    server {
+        listen    127.0.0.1:8025 proxy_protocol;
+        protocol  smtp;
+
+        auth_http_header  X-Type proxy;
+    }
+
+    server {
+        listen    127.0.0.1:8027 proxy_protocol;
+        protocol  smtp;
+
+        set_real_ip_from  127.0.0.1/32;
+        auth_http_header  X-Type realip;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+            set $test $http_x_type:$http_client_ip:$http_proxy_protocol_addr;
+
+            if ($test = proxy:127.0.0.1:192.0.2.1) {
+                set $reply OK;
+            }
+
+            if ($test = realip:192.0.2.1:192.0.2.1) {
+                set $reply OK;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->try_run('no proxy_protocol')->plan(8);
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+# connection with PROXY protocol
+
+my $s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8025));
+$s->send('PROXY TCP4 192.0.2.1 192.0.2.2 123 5678');
+$s->check(qr/^220 /, "greeting with proxy_protocol");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo with proxy_protocol");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth with proxy_protocol');
+
+$s->send('XPROXY');
+$s->check(qr/^211 PROXY TCP4 127.0.0.1 127.0.0.1 \d+ \d+/,
+    'proxy protocol to backend');
+
+# connection with PROXY protocol and set_realip_from
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+
+$s->send('PROXY TCP4 192.0.2.1 192.0.2.2 123 5678');
+$s->check(qr/^220 /, "greeting with proxy_protocol and realip");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo with proxy_protocol and realip");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth with proxy_protocol and realip');
+
+$s->send('XPROXY');
+$s->check(qr/^211 PROXY TCP4 192.0.2.1 127.0.0.1 \d+ \d+/,
+    'proxy_protocol to backend and realip');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_proxy_smtp_auth.t ../asynch_mode_nginx/test/nginx-tests/mail_proxy_smtp_auth.t
--- nginx-release-1.20.1/test/nginx-tests/mail_proxy_smtp_auth.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_proxy_smtp_auth.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,149 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx mail proxy module, the proxy_smtp_auth directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout             15s;
+    proxy_smtp_auth           on;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    smtp_auth  login plain external;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+    }
+
+    server {
+        listen     127.0.0.1:8027;
+        protocol   smtp;
+        xclient    off;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port   %%PORT_8026%%;
+            add_header Auth-Wait   1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->try_run('no proxy_smtp_auth')->plan(7);
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+# The following combinations may be sent to backend with proxy_smtp_auth on:
+#
+# ehlo, xclient, auth
+# ehlo, xclient, helo, auth
+# ehlo, xclient, ehlo, auth
+# helo, auth
+# ehlo, auth
+#
+# Test them in order.
+
+# ehlo, xclient, auth
+
+my $s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('ehlo, xclient, auth');
+
+# ehlo, xclient, helo, auth
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('HELO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('ehlo, xclient, helo, auth');
+
+# ehlo, xclient, ehlo, auth
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('ehlo, xclient, ehlo, auth');
+
+# helo, auth
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('helo, auth');
+
+# ehlo, auth
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('ehlo, auth');
+
+# Try auth external
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH EXTERNAL');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'auth external challenge');
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/^4.. /, 'auth external no password');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_resolver.t ../asynch_mode_nginx/test/nginx-tests/mail_resolver.t
--- nginx-release-1.20.1/test/nginx-tests/mail_resolver.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_resolver.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,455 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mail resolver.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl smtp http rewrite/)
+    ->has_daemon('openssl')->plan(11)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    auth_http    http://127.0.0.1:8080/mail/auth;
+    smtp_auth    none;
+    server_name  locahost;
+
+    proxy_timeout 15s;
+
+    # prevent useless resend
+    resolver_timeout 2s;
+
+    server {
+        listen    127.0.0.1:8025;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8981_UDP%%
+                  127.0.0.1:%%PORT_8982_UDP%%
+                  127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8027;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8982_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8028;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8983_UDP%%;
+        resolver_timeout 1s;
+    }
+
+    server {
+        listen    127.0.0.1:8029;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8984_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8030;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    server {
+        listen    127.0.0.1:8031;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8986_UDP%%;
+        resolver_timeout 1s;
+    }
+
+    server {
+        listen    127.0.0.1:8032;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8987_UDP%%;
+    }
+
+    server {
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        listen    127.0.0.1:8033 ssl %%SSL_ASYNCH%%;
+        protocol  smtp;
+        resolver  127.0.0.1:%%PORT_8983_UDP%%;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply $http_client_host;
+
+            if ($http_client_host !~ UNAVAIL) {
+                set $reply OK;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run_daemon(\&dns_daemon, port($_), $t) foreach (8981 .. 8987);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+$t->waitforfile($t->testdir . '/' . port($_)) foreach (8981 .. 8987);
+
+###############################################################################
+
+# PTR
+
+my $s = Test::Nginx::SMTP->new();
+my $s2 = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('PTR');
+
+$s->send('QUIT');
+$s->read();
+
+$s2->read();
+$s2->send('EHLO example.com');
+$s2->ok('PTR waiting');
+
+# Cached PTR prevents from querying bad ns on port 8983
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('PTR cached');
+
+$s->send('QUIT');
+$s->read();
+
+# SERVFAIL
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR SERVFAIL');
+
+$s->send('QUIT');
+$s->read();
+
+# PTR with zero length RDATA
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8028));
+$s2 = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8028));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR empty');
+
+$s->send('QUIT');
+$s->read();
+
+# resolver timeout is set
+
+$s2->read();
+$s2->send('EHLO example.com');
+$s2->ok('PTR empty waiting');
+
+# CNAME
+
+TODO: {
+local $TODO = 'support for CNAME RR';
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8029));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('CNAME');
+
+$s->send('QUIT');
+$s->read();
+
+}
+
+# uncompressed answer
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8030));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('uncompressed PTR');
+
+$s->send('QUIT');
+$s->read();
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8031));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR type');
+
+$s->send('QUIT');
+$s->read();
+
+# CNAME and PTR in one answer section
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8032));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('CNAME with PTR');
+
+$s->send('QUIT');
+$s->read();
+
+# before 1.17.3, read event while in resolving resulted in duplicate resolving
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->has_version('1.17.3');
+
+my %ssl = (
+    SSL => 1,
+    SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+    SSL_error_trap => sub { die $_[1] },
+);
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8033), %ssl);
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->read();
+
+$s->send('RCPT TO:<test@example.com>');
+$s->check(qr/TEMPUNAVAIL/, 'PTR SSL empty');
+
+$s->send('QUIT');
+$s->read();
+
+}
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data, $port) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant SERVFAIL    => 2;
+    use constant NXDOMAIN    => 3;
+
+    use constant A        => 1;
+    use constant CNAME    => 5;
+    use constant PTR    => 12;
+    use constant DNAME    => 39;
+
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if ($name eq 'a.example.net' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name eq '1.0.0.127.in-addr.arpa' && $type == PTR) {
+        if ($port == port(8981)) {
+            push @rdata, rd_name(PTR, $ttl, 'a.example.net');
+
+        } elsif ($port == port(8982)) {
+            $rcode = SERVFAIL;
+
+        } elsif ($port == port(8983)) {
+            # zero length RDATA
+
+            push @rdata, pack("n3N n", 0xc00c, PTR, IN, $ttl, 0);
+
+        } elsif ($port == port(8984)) {
+            # PTR answered with CNAME
+
+            push @rdata, rd_name(CNAME, $ttl,
+                '1.1.0.0.127.in-addr.arpa');
+
+        } elsif ($port == port(8985)) {
+            # uncompressed answer
+
+            push @rdata, pack("(C/a*)6x n2N n(C/a*)3x",
+                ('1', '0', '0', '127', 'in-addr', 'arpa'),
+                PTR, IN, $ttl, 15, ('a', 'example', 'net'));
+
+        } elsif ($port == port(8986)) {
+            push @rdata, rd_name(DNAME, $ttl, 'a.example.net');
+
+        } elsif ($port == port(8987)) {
+            # PTR answered with CNAME+PTR
+
+            push @rdata, rd_name(CNAME, $ttl,
+                '1.1.0.0.127.in-addr.arpa');
+            push @rdata, pack("n3N n(C/a*)3 x", 0xc034,
+                PTR, IN, $ttl, 15, ('a', 'example', 'net'));
+        }
+
+    } elsif ($name eq '1.1.0.0.127.in-addr.arpa' && $type == PTR) {
+        push @rdata, rd_name(PTR, $ttl, 'a.example.net');
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_name {
+    my ($type, $ttl, $name) = @_;
+    my ($rdlen, @rdname);
+
+    @rdname = split /\./, $name;
+    $rdlen = length(join '', @rdname) + @rdname + 1;
+    pack("n3N n(C/a*)* x", 0xc00c, $type, IN, $ttl, $rdlen, @rdname);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    # use a special pack string to not zero pad
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data, $port);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_smtp_greeting_delay.t ../asynch_mode_nginx/test/nginx-tests/mail_smtp_greeting_delay.t
--- nginx-release-1.20.1/test/nginx-tests/mail_smtp_greeting_delay.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_smtp_greeting_delay.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,61 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_greeting_delay  1s;
+    }
+}
+
+EOF
+
+###############################################################################
+
+# With smtp_greeting_delay session expected to be closed after first error
+# message if client sent something before greeting.
+
+my $s = Test::Nginx::SMTP->new();
+$s->send('HELO example.com');
+$s->check(qr/^5.. /, "command before greeting - session must be rejected");
+ok($s->eof(), "session have to be closed");
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_smtp.t ../asynch_mode_nginx/test/nginx-tests/mail_smtp.t
--- nginx-release-1.20.1/test/nginx-tests/mail_smtp.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_smtp.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,345 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx mail smtp module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_auth  login plain none cram-md5 external;
+    }
+
+    server {
+        listen     127.0.0.1:8027;
+        protocol   smtp;
+        smtp_auth  none;
+        smtp_client_buffer 128;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            set $reply ERROR;
+
+            if ($http_auth_smtp_to ~ example.com) {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:secret$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_user:$http_auth_salt:$http_auth_pass";
+            if ($userpass ~ '^test@example.com:<.*@.*>:0{32}$') {
+                set $reply OK;
+            }
+
+            set $userpass "$http_auth_method:$http_auth_user:$http_auth_pass";
+            if ($userpass ~ '^external:test@example.com:$') {
+                set $reply OK;
+            }
+
+            add_header Auth-Status $reply;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->plan(41);
+
+$t->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0bad", ''));
+$s->check(qr/^5.. /, 'auth plain with bad password');
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth plain');
+
+# We are talking to backend from this point
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->ok('mail from after auth');
+
+$s->send('RSET');
+$s->ok('rset');
+
+$s->send('MAIL FROM:<test@xn--e1afmkfd.xn--80akhbyknj4f> SIZE=100');
+$s->ok("idn mail from (example.test in russian)");
+
+$s->send('QUIT');
+$s->ok("quit");
+
+# Try auth login in simple form
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'auth login simple username challenge');
+$s->send(encode_base64('test@example.com', ''));
+$s->check(qr/^334 UGFzc3dvcmQ6/, 'auth login simple password challenge');
+$s->send(encode_base64('secret', ''));
+$s->authok('auth login simple');
+
+# Try auth plain with username.  Details:
+#
+# [MS-XLOGIN]: SMTP Protocol AUTH LOGIN Extension Specification
+# http://download.microsoft.com/download/5/D/D/5DD33FDF-91F5-496D-9884-0A0B0EE698BB/%5BMS-XLOGIN%5D.pdf
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH LOGIN ' . encode_base64('test@example.com', ''));
+$s->check(qr/^334 UGFzc3dvcmQ6/, 'auth login with username password challenge');
+$s->send(encode_base64('secret', ''));
+$s->authok('auth login with username');
+
+# Try auth cram-md5
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH CRAM-MD5');
+$s->check(qr/^334 /, 'auth cram-md5 challenge');
+$s->send(encode_base64('test@example.com ' . ('0' x 32), ''));
+$s->authok('auth cram-md5');
+
+# Try auth external
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH EXTERNAL');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'auth external challenge');
+$s->send(encode_base64('test@example.com', ''));
+$s->ok('auth external');
+
+# Try auth external with username
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('AUTH EXTERNAL ' . encode_base64('test@example.com', ''));
+$s->ok('auth external with username');
+
+# Try auth plain with pipelining
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('INVALID COMMAND WITH ARGUMENTS' . CRLF
+    . 'RSET');
+$s->read();
+$s->ok('pipelined rset after invalid command');
+
+$s->send('AUTH PLAIN '
+    . encode_base64("\0test\@example.com\0bad", '') . CRLF
+    . 'MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->ok('mail from after failed pipelined auth');
+
+$s->send('AUTH PLAIN '
+    . encode_base64("\0test\@example.com\0secret", '') . CRLF
+    . 'MAIL FROM:<test@example.com> SIZE=100');
+$s->read();
+$s->ok('mail from after pipelined auth');
+
+# Try auth none
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->ok('auth none - mail from');
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('auth none - rcpt to');
+
+$s->send('RSET');
+$s->ok('auth none - rset, should go to backend');
+
+# Auth none with pipelining
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100' . CRLF
+    . 'RCPT TO:<test@example.com>' . CRLF
+    . 'RSET');
+
+$s->ok('pipelined mail from');
+$s->ok('pipelined rcpt to');
+$s->ok('pipelined rset');
+
+# Pipelining with split command
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->print('MAIL FROM:<test@example.com> SIZE=100' . CRLF
+    . 'RCPT TO:<test@example.com>' . CRLF
+    . 'RS');
+
+$s->ok('split pipelined mail from');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->ok('split pipelined rcpt to');
+
+}
+
+$s->send('ET');
+$s->ok('split pipelined rset');
+
+# Pipelining longer than smtp_client_buffer
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8027));
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100' . CRLF
+    . 'RCPT TO:<foo@example.com>' . CRLF
+    . 'RCPT TO:<bar@example.com>' . CRLF
+    . 'RCPT TO:<baz@example.com>' . CRLF
+    . 'RCPT TO:<foobar@example.com>' . CRLF
+    . 'RSET');
+
+TODO: {
+todo_skip 'long pipelined - not yet', 6 unless $t->has_version('1.21.0');
+
+$s->ok('long pipelined mail from');
+$s->ok('long pipelined rcpt to');
+$s->ok('long pipelined rcpt to 2');
+$s->ok('long pipelined rcpt to 3');
+$s->ok('long pipelined rcpt to 4');
+$s->ok('long pipelined rset');
+
+}
+
+# Connection must stay even if error returned to rcpt to command
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+
+$s->send('MAIL FROM:<test@example.com> SIZE=100');
+$s->read(); # skip mail from reply
+
+$s->send('RCPT TO:<example.com>');
+$s->check(qr/^5.. /, "bad rcpt to");
+
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('good rcpt to');
+
+# Make sure command split into many packets processed correctly
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+
+$s->print('HEL');
+select undef, undef, undef, 0.1;
+$s->send('O example.com');
+$s->ok('split command');
+
+# Invalid command split into many packets
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+
+$s->print('FOO B');
+select undef, undef, undef, 0.1;
+$s->send('AR');
+$s->check(qr/^5.. /, 'invalid split command');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.21.0');
+
+$s->send('HELO example.com');
+$s->ok('good after invalid split command');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_smtp_xclient.t ../asynch_mode_nginx/test/nginx-tests/mail_smtp_xclient.t
--- nginx-release-1.20.1/test/nginx-tests/mail_smtp_xclient.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_smtp_xclient.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail smtp http rewrite/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    on;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+        smtp_auth  login plain none;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port   %%PORT_8026%%;
+            add_header Auth-Wait   1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+# When XCLIENT's HELO= argument isn't used, the  following combinations may be
+# send to backend with xclient on:
+#
+# xclient
+# xclient, helo
+# xclient, ehlo
+# xclient, from, rcpt
+# xclient, helo, from, rcpt
+# xclient, ehlo, from, rcpt
+#
+# Test them in order.
+
+# xclient
+
+my $s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient');
+
+# xclient, helo
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('HELO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient, helo');
+
+# xclient, ehlo
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('xclient, ehlo');
+
+# xclient, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, from');
+
+# xclient, helo, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('HELO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, helo, from');
+
+# xclient, ehlo, from, rcpt
+
+$s = Test::Nginx::SMTP->new();
+$s->read();
+$s->send('EHLO example.com');
+$s->read();
+$s->send('MAIL FROM:<test@example.com>');
+$s->read();
+$s->send('RCPT TO:<test@example.com>');
+$s->ok('xclient, ehlo, from');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_ssl_conf_command.t ../asynch_mode_nginx/test/nginx-tests/mail_ssl_conf_command.t
--- nginx-release-1.20.1/test/nginx-tests/mail_ssl_conf_command.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_ssl_conf_command.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mail ssl module, ssl_conf_command.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    auth_http  http://127.0.0.1:8080;   # unused
+
+    server {
+        listen       127.0.0.1:8443 ssl %%SSL_ASYNCH%%;
+        protocol     imap;
+
+        ssl_protocols TLSv1.2;
+
+        ssl_session_tickets off;
+        ssl_conf_command Options SessionTicket;
+
+        ssl_prefer_server_ciphers on;
+        ssl_conf_command Options -ServerPreference;
+        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+        ssl_conf_command Certificate override.crt;
+        ssl_conf_command PrivateKey override.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'override') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->try_run('no ssl_conf_command')->plan(3);
+
+###############################################################################
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+my ($s, $ssl) = get_ssl_socket();
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=override/, 'Certificate');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(ses => $ses);
+ok(Net::SSLeay::session_reused($ssl), 'SessionTicket');
+
+($s, $ssl) = get_ssl_socket(ciphers =>
+    'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384');
+is(Net::SSLeay::get_cipher($ssl),
+    'ECDHE-RSA-AES128-GCM-SHA256', 'ServerPreference');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my (%extra) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port(8443));
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $extra{ses}) if $extra{ses};
+    Net::SSLeay::set_cipher_list($ssl, $extra{ciphers}) if $extra{ciphers};
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mail_ssl.t ../asynch_mode_nginx/test/nginx-tests/mail_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/mail_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mail_ssl.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,306 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for mail ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::IMAP;
+use Test::Nginx::POP3;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/mail mail_ssl imap pop3 smtp/)
+    ->has_daemon('openssl')->plan(20);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+mail {
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    ssl_password_file password;
+
+    auth_http  http://127.0.0.1:8080;    # unused
+
+    ssl_session_cache none;
+
+    server {
+        listen             127.0.0.1:8143;
+        listen             127.0.0.1:8145 ssl %%SSL_ASYNCH%%;
+        protocol           imap;
+
+        ssl_session_cache  builtin;
+    }
+
+    server {
+        listen             127.0.0.1:8146 ssl %%SSL_ASYNCH%%;
+        protocol           imap;
+
+        ssl_session_cache  off;
+    }
+
+    server {
+        listen             127.0.0.1:8147;
+        protocol           imap;
+
+        # Special case for enabled "ssl" directive.
+
+        ssl on;
+        %%TEST_GLOBALS_HTTPS%%
+        ssl_session_cache  builtin:1000;
+    }
+
+    server {
+        listen             127.0.0.1:8148 ssl %%SSL_ASYNCH%%;
+        protocol           imap;
+
+        ssl_session_cache shared:SSL:1m;
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+
+    server {
+        listen             127.0.0.1:8149;
+        protocol           imap;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8150;
+        protocol           imap;
+
+        starttls           only;
+    }
+
+    server {
+        listen             127.0.0.1:8151;
+        protocol           pop3;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8152;
+        protocol           pop3;
+
+        starttls           only;
+    }
+
+    server {
+        listen             127.0.0.1:8153;
+        protocol           smtp;
+
+        starttls           on;
+    }
+
+    server {
+        listen             127.0.0.1:8154;
+        protocol           smtp;
+
+        starttls           only;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'inherits') {
+    system("openssl genrsa -out $d/$name.key -passout pass:localhost "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:localhost"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+$t->write_file('password', 'localhost');
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+# simple tests to ensure that nothing broke with ssl_password_file directive
+
+my $s = Test::Nginx::IMAP->new();
+$s->ok('greeting');
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'login');
+
+# ssl_session_cache
+
+my ($ssl, $ses);
+
+($s, $ssl) = get_ssl_socket(8145);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8145, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin session reused');
+
+($s, $ssl) = get_ssl_socket(8146);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8146, $ses);
+is(Net::SSLeay::session_reused($ssl), 0, 'session not reused');
+
+($s, $ssl) = get_ssl_socket(8147);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8147, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin size session reused');
+
+($s, $ssl) = get_ssl_socket(8148);
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(8148, $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'shared session reused');
+
+# ssl_certificate inheritance
+
+($s, $ssl) = get_ssl_socket(8145);
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=localhost/, 'CN');
+
+($s, $ssl) = get_ssl_socket(8148);
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=inherits/, 'CN inner');
+
+# starttls imap
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8149));
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'imap auth before startls on');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8149));
+$s->read();
+
+$s->send('1 STARTTLS');
+$s->ok('imap starttls on');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8150));
+$s->read();
+
+$s->send('1 AUTHENTICATE LOGIN');
+$s->check(qr/^\S+ BAD/, 'imap auth before startls only');
+
+$s = Test::Nginx::IMAP->new(PeerAddr => '127.0.0.1:' . port(8150));
+$s->read();
+
+$s->send('1 STARTTLS');
+$s->ok('imap starttls only');
+
+# starttls pop3
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8151));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/\+ VXNlcm5hbWU6/, 'pop3 auth before startls on');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8151));
+$s->read();
+
+$s->send('STLS');
+$s->ok('pop3 starttls on');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8152));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^-ERR/, 'pop3 auth before startls only');
+
+$s = Test::Nginx::POP3->new(PeerAddr => '127.0.0.1:' . port(8152));
+$s->read();
+
+$s->send('STLS');
+$s->ok('pop3 starttls only');
+
+# starttls smtp
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8153));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^334 VXNlcm5hbWU6/, 'smtp auth before startls on');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8153));
+$s->read();
+
+$s->send('STARTTLS');
+$s->ok('smtp starttls on');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8154));
+$s->read();
+
+$s->send('AUTH LOGIN');
+$s->check(qr/^5.. /, 'smtp auth before startls only');
+
+$s = Test::Nginx::SMTP->new(PeerAddr => '127.0.0.1:' . port(8154));
+$s->read();
+
+$s->send('STARTTLS');
+$s->ok('smtp starttls only');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($port, $ses) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/map_complex.t ../asynch_mode_nginx/test/nginx-tests/map_complex.t
--- nginx-release-1.20.1/test/nginx-tests/map_complex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/map_complex.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for map module with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        var      foo:$y;
+        var2     $y:foo;
+        default  foo:$y;
+    }
+
+    map $args $y {
+        default  bar;
+        same     baz;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Foo $x;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(3);
+
+###############################################################################
+
+like(http_get('/?var'), qr/foo:bar/, 'map cv');
+like(http_get('/?var2'), qr/bar:foo/, 'map cv 2');
+like(http_get('/?same'), qr/foo:baz/, 'map cv key');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/map.t ../asynch_mode_nginx/test/nginx-tests/map.t
--- nginx-release-1.20.1/test/nginx-tests/map.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/map.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for map module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $x {
+        default                     0;
+        foo                         bar;
+        foo2                        bar;
+    }
+
+    map $args $y {
+        hostnames;
+        default                     0;
+        example.com                 foo;
+        example.*                   right-wildcard;
+        *.example.com               left-wildcard;
+        .dot.example.com            special-wildcard;
+        ~^REGEX.EXAMPLE\.ORG$       regex-sensitive;
+        ~*^www.regex.example\.org$  regex-insensitive;
+        \include                    include;
+        server                      $server_name;
+        var                         $z;
+    }
+
+    map $args $z {
+        default                     0;
+        var                         baz;
+        include                     map.conf;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Foo "x:$x y:$y\n";
+            return 204;
+        }
+        location /z {
+            add_header X-Foo "z:$z\n";
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('map.conf', "foo bar;");
+$t->run();
+
+###############################################################################
+
+like(http_get('/?1'), qr/x:0 y:0/, 'map default');
+like(http_get('/?foo'), qr/x:bar y:0/, 'map foo bar');
+like(http_get('/?foo2'), qr/x:bar y:0/, 'map foo bar key');
+like(http_get('/?example.com'), qr/x:0 y:foo/, 'map example.com foo');
+like(http_get('/?EXAMPLE.COM'), qr/x:0 y:foo/, 'map EXAMPLE.COM foo');
+like(http_get('/?example.com.'), qr/x:0 y:foo/, 'map example.com. foo');
+like(http_get('/?example.org'), qr/x:0 y:right-wildcard/,
+    'map example.org wildcard');
+like(http_get('/?foo.example.com'), qr/x:0 y:left-wildcard/,
+    'map foo.example.com wildcard');
+like(http_get('/?foo.example.com.'), qr/x:0 y:left-wildcard/,
+    'map foo.example.com. wildcard');
+like(http_get('/?dot.example.com'), qr/x:0 y:special-wildcard/,
+    'map dot.example.com special wildcard');
+like(http_get('/?www.dot.example.com'), qr/x:0 y:special-wildcard/,
+    'map www.dot.example.com special wildcard');
+like(http_get('/?REGEX.EXAMPLE.ORG'), qr/x:0 y:regex-sensitive/,
+    'map REGEX.EXAMPLE.ORG');
+like(http_get('/?regex.example.org'), qr/x:0 y:0/,
+    'map regex.example.org');
+like(http_get('/?www.regex.example.org'), qr/x:0 y:regex-insensitive/,
+    'map www.regex.example.org insensitive');
+like(http_get('/?WWW.REGEX.EXAMPLE.ORG'), qr/x:0 y:regex-insensitive/,
+    'map WWW.REGEX.EXAMPLE.ORG insensitive');
+like(http_get('/?include'), qr/x:0 y:include/, 'map special parameter');
+like(http_get('/?server'), qr/x:0 y:localhost/, 'map server_name variable');
+like(http_get('/?var'), qr/x:0 y:baz/, 'map z variable');
+like(http_get('/z?foo'), qr/z:bar/, 'include foo bar');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/map_volatile.t ../asynch_mode_nginx/test/nginx-tests/map_volatile.t
--- nginx-release-1.20.1/test/nginx-tests/map_volatile.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/map_volatile.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for map module with volatile.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http map/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $uri $uri_cached {
+        /1/          /1/redirect;
+        /1/redirect  uncached;
+    }
+
+    map $uri $uri_uncached {
+        volatile;
+
+        /2/          /2/redirect;
+        /2/redirect  uncached;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /1 {
+            index $uri_cached;
+        }
+        location /1/redirect {
+            add_header X-URI $uri_cached always;
+        }
+
+        location /2 {
+            index $uri_uncached;
+        }
+        location /2/redirect {
+            add_header X-URI $uri_uncached always;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/1');
+mkdir($t->testdir() . '/2');
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(http_get('/1/'), qr!X-URI: /1/redirect!, 'map');
+like(http_get('/2/'), qr/X-URI: uncached/, 'map volatile');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/memcached_fake_extra.t ../asynch_mode_nginx/test/nginx-tests/memcached_fake_extra.t
--- nginx-release-1.20.1/test/nginx-tests/memcached_fake_extra.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/memcached_fake_extra.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,96 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Test for memcached backend returning extra data after trailer.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&memcached_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start fake memcached";
+
+###############################################################################
+
+$t->todo_alerts() unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/SEE-THIS/, 'memcached data after trailer');
+
+###############################################################################
+
+sub memcached_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/\x0d\x0a$/);
+        }
+
+        print $client 'VALUE / 0 8' . CRLF;
+        print $client 'SEE-THIS' . CRLF . 'END' . CRLF
+            . "\0" . ("1" x 1024);
+
+        select(undef, undef, undef, 0.2);
+
+        print $client 'EXTRA' . CRLF;
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/memcached_fake.t ../asynch_mode_nginx/test/nginx-tests/memcached_fake.t
--- nginx-release-1.20.1/test/nginx-tests/memcached_fake.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/memcached_fake.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for memcached backend with fake daemon.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached ssi/)->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+        }
+
+        location /ssi {
+            default_type text/html;
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+    '<!--#include virtual="/" set="blah" -->' .
+    'blah: <!--#echo var="blah" -->');
+
+$t->run_daemon(\&memcached_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start fake memcached";
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'memcached split trailer');
+
+like(http_get('/ssi.html'), qr/SEE-THIS/, 'memcached ssi var');
+
+like(`grep -F '[error]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no errors');
+
+###############################################################################
+
+sub memcached_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/\x0d\x0a$/);
+        }
+
+        print $client 'VALUE / 0 8' . CRLF;
+        print $client 'SEE-TH';
+        select(undef, undef, undef, 0.1);
+        print $client 'IS';
+        select(undef, undef, undef, 0.1);
+        print $client CRLF . 'EN';
+        select(undef, undef, undef, 0.1);
+        print $client 'D' . CRLF;
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/memcached_keepalive_stale.t ../asynch_mode_nginx/test/nginx-tests/memcached_keepalive_stale.t
--- nginx-release-1.20.1/test/nginx-tests/memcached_keepalive_stale.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/memcached_keepalive_stale.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for stale events handling in upstream keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http memcached upstream_keepalive rewrite/)
+    ->has_daemon('memcached')->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+worker_processes 2;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080 sndbuf=32k;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass memd;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts1 = ();
+
+if ($memhelp =~ /repcached/) {
+    # repcached patches adds additional listen socket memcached
+    # that should be different too
+
+    push @memopts1, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+    # UDP ports no longer off by default in memcached 1.2.7+
+
+    push @memopts1, '-U', '0';
+}
+if ($memhelp =~ /-t/) {
+    # for connection stats consistency in threaded memcached 1.3+
+
+    push @memopts1, '-t', '1';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts1);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Unable to start memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+    connect_timeout => 1.0);
+
+# It's possible that stale events occur, i.e. read event handler called
+# for just saved upstream connection without any data available for
+# read.  We shouldn't close upstream connection in such situation.
+#
+# This happens due to reading from upstream connection on downstream write
+# events.  More likely to happen with multiple workers due to use of posted
+# events.
+#
+# Stale event may only happen if reading response from upstream requires
+# entering event loop, i.e. response should be big enough.  On the other
+# hand, it is less likely to occur with full client's connection output
+# buffer.
+#
+# We use here 2 workers, 20k response and set output buffer on clients
+# connection to 32k.  This allows more or less reliably reproduce stale
+# events at least on FreeBSD testbed here.
+
+$memd1->set('/big', 'X' x 20480);
+
+my $total = $memd1->stats()->{total}->{total_connections};
+
+for (1 .. 100) {
+    http_get('/big');
+}
+
+cmp_ok($memd1->stats()->{total}->{total_connections}, '<=', $total + 2,
+    'only one connection per worker used');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/memcached_keepalive.t ../asynch_mode_nginx/test/nginx-tests/memcached_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/memcached_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/memcached_keepalive.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,194 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for memcached with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http memcached upstream_keepalive rewrite/)
+    ->has_daemon('memcached')->plan(15)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    upstream memd3 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        keepalive 1;
+    }
+
+    upstream memd4 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        keepalive 10;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass memd;
+        }
+
+        location /next {
+            set $memcached_key $uri;
+            memcached_next_upstream  not_found;
+            memcached_pass memd;
+        }
+
+        location /memd3 {
+            set $memcached_key "/";
+            memcached_pass memd3;
+        }
+
+        location /memd4 {
+            set $memcached_key "/";
+            memcached_pass memd4;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts1 = ();
+my @memopts2 = ();
+
+if ($memhelp =~ /repcached/) {
+    # repcached patches adds additional listen socket memcached
+    # that should be different too
+
+    push @memopts1, '-X', port(8083);
+    push @memopts2, '-X', port(8084);
+}
+if ($memhelp =~ /-U/) {
+    # UDP ports no longer off by default in memcached 1.2.7+
+
+    push @memopts1, '-U', '0';
+    push @memopts2, '-U', '0';
+}
+if ($memhelp =~ /-t/) {
+    # for connection stats consistency in threaded memcached 1.3+
+
+    push @memopts1, '-t', '1';
+    push @memopts2, '-t', '1';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts1);
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8082), @memopts2);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Unable to start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8082))
+    or die "Unable to start second memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+    connect_timeout => 1.0);
+my $memd2 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8082) ],
+    connect_timeout => 1.0);
+
+$memd1->set('/', 'SEE-THIS');
+$memd2->set('/', 'SEE-THIS');
+$memd1->set('/big', 'X' x 1000000);
+
+my $total = $memd1->stats()->{total}->{total_connections};
+
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request');
+like(http_get('/notfound'), qr/ 404 /, 'keepalive memcached not found');
+like(http_get('/next'), qr/ 404 /,
+    'keepalive not found with memcached_next_upstream');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+like(http_get('/'), qr/SEE-THIS/, 'keepalive memcached request again');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+    'only one connection used');
+
+# Since nginx doesn't read all data from connection in some situations (head
+# requests, post_action, errors writing to client) we have to close such
+# connections.  Check if we really do close them.
+
+$total = $memd1->stats()->{total}->{total_connections};
+
+unlike(http_head('/'), qr/SEE-THIS/, 'head request');
+like(http_get('/'), qr/SEE-THIS/, 'get after head');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+    'head request closes connection');
+
+$total = $memd1->stats()->{total}->{total_connections};
+
+unlike(http_head('/big'), qr/XXX/, 'big head');
+like(http_get('/'), qr/SEE-THIS/, 'get after big head');
+
+is($memd1->stats()->{total}->{total_connections}, $total + 1,
+    'big head request closes connection');
+
+# two backends with maximum number of cached connections set to 1,
+# should establish new connection on each request
+
+$total = $memd1->stats()->{total}->{total_connections} +
+    $memd2->stats()->{total}->{total_connections};
+
+http_get('/memd3');
+http_get('/memd3');
+http_get('/memd3');
+
+is($memd1->stats()->{total}->{total_connections} +
+    $memd2->stats()->{total}->{total_connections}, $total + 3,
+    '3 connections should be established');
+
+# two backends with maximum number of cached connections set to 10,
+# should establish only two connections (1 per backend)
+
+$total = $memd1->stats()->{total}->{total_connections} +
+    $memd2->stats()->{total}->{total_connections};
+
+http_get('/memd4');
+http_get('/memd4');
+http_get('/memd4');
+
+is($memd1->stats()->{total}->{total_connections} +
+    $memd2->stats()->{total}->{total_connections}, $total + 2,
+    'connection per backend');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/memcached.t ../asynch_mode_nginx/test/nginx-tests/memcached.t
--- nginx-release-1.20.1/test/nginx-tests/memcached.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/memcached.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for memcached backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached/)
+    ->has_daemon('memcached')->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $memcached_key $uri;
+            memcached_pass 127.0.0.1:8081;
+        }
+
+        location /next {
+            set $memcached_key $uri;
+            memcached_next_upstream  not_found;
+            memcached_pass 127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+    # repcached patch adds additional listen socket
+    push @memopts, '-X', port(8082);
+}
+if ($memhelp =~ /-U/) {
+    # UDP port is on by default in memcached 1.2.7+
+    push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start memcached";
+
+###############################################################################
+
+my $memd = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+    connect_timeout => 1.0);
+$memd->set('/', 'SEE-THIS')
+    or die "can't put value into memcached: $!";
+
+like(http_get('/'), qr/SEE-THIS/, 'memcached request');
+
+like(http_get('/notfound'), qr/ 404 /, 'memcached not found');
+
+like(http_get('/next'), qr/ 404 /, 'not found with memcached_next_upstream');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'memcached no data in HEAD');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/merge_slashes.t ../asynch_mode_nginx/test/nginx-tests/merge_slashes.t
--- nginx-release-1.20.1/test/nginx-tests/merge_slashes.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/merge_slashes.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,61 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for URI normalization, merge_slashes off.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        merge_slashes off;
+
+        location / {
+            add_header  X-URI  "x $uri x";
+            return      204;
+        }
+    }
+}
+
+EOF
+
+###############################################################################
+
+local $TODO = 'not yet' unless $t->has_version('1.17.5');
+
+like(http_get('/foo//../bar'), qr!x /foo/bar x!, 'merge slashes');
+like(http_get('/foo///../bar'), qr!x /foo//bar x!, 'merge slashes 2');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mirror_proxy.t ../asynch_mode_nginx/test/nginx-tests/mirror_proxy.t
--- nginx-release-1.20.1/test/nginx-tests/mirror_proxy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mirror_proxy.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,129 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http mirror module and it's interaction with proxy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy mirror rewrite limit_req/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(7);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone  $uri  zone=slow:1m  rate=30r/m;
+    log_format  test  $request_uri:$request_body;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mirror /mirror;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /off {
+            mirror /mirror/off;
+            mirror_request_body off;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /mirror {
+            internal;
+            proxy_pass http://127.0.0.1:8082;
+            limit_req  zone=slow burst=1;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            client_body_timeout 1s;
+            proxy_pass http://127.0.0.1:$server_port/return204;
+            access_log %%TESTDIR%%/test.log test;
+            add_header X-Body $request_body;
+        }
+
+        location /return204 {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_post('/'), qr/X-Body: 1234567890\x0d?$/m, 'mirror proxy');
+like(http_post('/off'), qr/X-Body: 1234567890\x0d?$/m, 'mirror_request_body');
+
+# delayed subrequest should not affect main request processing nor stuck itself
+
+SKIP: {
+skip 'hang on win32', 1 if $^O eq 'MSWin32' and !$ENV{TEST_NGINX_UNSAFE};
+
+TODO: {
+local $TODO = 'not yet';
+
+like(http_post('/delay?1'), qr/X-Body: 1234567890\x0d?$/m, 'mirror delay');
+
+}
+
+}
+
+$t->todo_alerts() unless $^O eq 'MSWin32';
+$t->stop();
+
+my $log = $t->read_file('test.log');
+like($log, qr!^/:1234567890$!m, 'log - request body');
+like($log, qr!^/mirror:1234567890$!m, 'log - request body in mirror');
+like($log, qr!^/off:1234567890$!m, 'log - mirror_request_body off');
+like($log, qr!^/mirror/off:-$!m,, 'log - mirror_request_body off in mirror');
+
+###############################################################################
+
+sub http_post {
+    my ($url) = @_;
+
+    http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+Content-Length: 10
+
+1234567890
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mirror.t ../asynch_mode_nginx/test/nginx-tests/mirror.t
--- nginx-release-1.20.1/test/nginx-tests/mirror.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mirror.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http mirror module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mirror/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test $uri;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mirror /mirror;
+
+            location /off {
+                mirror off;
+            }
+        }
+
+        location /many {
+            mirror /mirror/1;
+            mirror /mirror/2;
+        }
+
+        location /mirror {
+            log_subrequest on;
+            access_log test$args.log test;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('many', '');
+$t->write_file('off', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/index.html?1'), qr/200 OK/, 'request');
+like(http_get('/?2'), qr/200 OK/, 'internal redirect');
+like(http_get('/off?3'), qr/200 OK/, 'mirror off');
+like(http_get('/many?4'), qr/200 OK/, 'mirror many');
+
+$t->stop();
+
+is($t->read_file('test1.log'), "/mirror\n", 'log - request');
+is($t->read_file('test2.log'), "/mirror\n/mirror\n", 'log - redirect');
+ok(!-e $t->testdir() . '/test3.log', 'log - mirror off');
+is($t->read_file('test4.log'), "/mirror/1\n/mirror/2\n", 'log - mirror many');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mp4_ssi.t ../asynch_mode_nginx/test/nginx-tests/mp4_ssi.t
--- nginx-release-1.20.1/test/nginx-tests/mp4_ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mp4_ssi.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for mp4 module in subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4 ssi/)->has_daemon('ffprobe')
+    ->has_daemon('ffmpeg')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+        }
+        location /ssi {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+    unless grep /lavfi/, `ffmpeg -loglevel quiet -formats`;
+system('ffmpeg -nostdin -loglevel quiet -y '
+    . '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+    . '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+    . '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+    . "${\($t->testdir())}/ssi.mp4") == 0
+    or die "Can't create mp4 file: $!";
+
+$t->write_file('index.html', 'X<!--#include virtual="/ssi.mp4?end=1" -->X');
+
+$t->run()->plan(1);
+
+###############################################################################
+
+(my $r = get('/')) =~ s/([^\x20-\x7e])/sprintf('\\x%02x', ord($1))/gmxe;
+unlike($r, qr/\\x0d(\\x0a)?0\\x0d(\\x0a)?\\x0d(\\x0a)?\w/, 'only final chunk');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/mp4.t ../asynch_mode_nginx/test/nginx-tests/mp4.t
--- nginx-release-1.20.1/test/nginx-tests/mp4.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/mp4.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,168 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mp4 module.
+# Ensures that requested stream duration is given with sane accuracy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_content /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4/)->has_daemon('ffprobe')
+    ->has_daemon('ffmpeg')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+    unless grep /lavfi/, `ffmpeg -loglevel quiet -formats`;
+system('ffmpeg -nostdin -loglevel quiet -y '
+    . '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+    . '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+    . '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+    . "${\($t->testdir())}/test.mp4") == 0
+    or die "Can't create mp4 file: $!";
+system('ffmpeg -nostdin -loglevel quiet -y '
+    . '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+    . '-f lavfi -i testsrc=duration=20:size=320x200:rate=15 '
+    . '-map 0:0 -map 1:0 -pix_fmt yuv420p -g 15 -c:v libx264 '
+    . '-movflags +faststart '
+    . "${\($t->testdir())}/no_mdat.mp4") == 0
+    or die "Can't create mp4 file: $!";
+
+my $sbad = <<'EOF';
+00000000:  00 00 00 1c 66 74 79 70  69 73 6f 6d 00 00 02 00  |....ftypisom....|
+00000010:  69 73 6f 6d 69 73 6f 32  6d 70 34 31 00 00 00 09  |isomiso2mp41....|
+00000020:  6d 64 61 74 00 00 00 00  94 6d 6f 6f 76 00 00 00  |mdat.....moov...|
+00000030:  8c 74 72 61 6b 00 00 00  84 6d 64 69 61 00 00 00  |.trak....mdia...|
+00000040:  7c 6d 69 6e 66 00 00 00  74 73 74 62 6c 00 00 00  ||minf...tstbl...|
+00000050:  18 73 74 74 73 00 00 00  00 00 00 00 01 00 00 03  |.stts...........|
+00000060:  3a 00 00 04 00 00 00 00  28 73 74 73 63 00 00 00  |:.......(stsc...|
+00000070:  00 00 00 00 02 00 00 00  01 00 00 03 0f 00 00 00  |................|
+00000080:  01 00 00 00 02 00 00 00  2b 00 00 00 01 00 00 00  |........+.......|
+00000090:  14 73 74 73 7a 00 00 00  00 00 00 05 a9 00 00 03  |.stsz...........|
+000000a0:  3b 00 00 00 18 63 6f 36  34 00 00 00 00 00 00 00  |;....co64.......|
+000000b0:  01 ff ff ff ff f0 0f fb  e7                       |.........|
+EOF
+
+$t->write_file('bad.mp4', unhex($sbad));
+$t->run()->plan(27);
+
+###############################################################################
+
+my $test_uri = '/test.mp4';
+
+again:
+
+is(durations($t, 0.0), '10.0 20.0', 'start zero');
+is(durations($t, 2), '8.0 18.0', 'start integer');
+is(durations($t, 7.1), '2.9 12.9', 'start float');
+
+is(durations($t, 6, 9), '3.0 3.0', 'start end integer');
+is(durations($t, 2.7, 5.6), '2.9 2.9', 'start end float');
+
+is(durations($t, undef, 9), '9.0 9.0', 'end integer');
+is(durations($t, undef, 5.6), '5.6 5.6', 'end float');
+
+# invalid range results in ignoring end argument
+
+like(http_head("$test_uri?start=1&end=1"), qr/200 OK/, 'zero range');
+like(http_head("$test_uri?start=1&end=0"), qr/200 OK/, 'negative range');
+
+# start/end values exceeding track/file duration
+
+unlike(http_head("$test_uri?end=11"), qr!HTTP/1.1 500!,
+    'end beyond short track');
+unlike(http_head("$test_uri?end=21"), qr!HTTP/1.1 500!, 'end beyond EOF');
+unlike(http_head("$test_uri?start=11"), qr!HTTP/1.1 500!,
+    'start beyond short track');
+like(http_head("$test_uri?start=21"), qr!HTTP/1.1 500!, 'start beyond EOF');
+
+$test_uri = '/no_mdat.mp4', goto again unless $test_uri eq '/no_mdat.mp4';
+
+# corrupted formats
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.9');
+
+like(http_get("/bad.mp4?start=0.5"), qr/500 Internal/, 'co64 chunk beyond EOF');
+
+}
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /sendfile on/
+    and !$t->has_version('1.17.9');
+
+###############################################################################
+
+sub durations {
+    my ($t, $start, $end) = @_;
+    my $path = $t->{_testdir} . '/frag.mp4';
+
+    my $uri = $test_uri;
+    if (defined $start) {
+        $uri .= "?start=$start";
+        if (defined $end) {
+            $uri .= "&end=$end";
+        }
+
+    } elsif (defined $end) {
+        $uri .= "?end=$end";
+    }
+
+    $t->write_file('frag.mp4', http_content(http_get($uri)));
+
+    my $r = `ffprobe -show_streams $path 2>/dev/null`;
+    Test::Nginx::log_core('||', $r);
+    sprintf "%.1f %.1f", $r =~ /duration=(\d+\.\d+)/g;
+}
+
+sub unhex {
+    my ($input) = @_;
+    my $buffer = '';
+
+    for my $l ($input =~ m/:  +((?:[0-9a-f]{2,4} +)+) /gms) {
+        for my $v ($l =~ m/[0-9a-f]{2}/g) {
+            $buffer .= chr(hex($v));
+        }
+    }
+
+    return $buffer;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/msie_refresh.t ../asynch_mode_nginx/test/nginx-tests/msie_refresh.t
--- nginx-release-1.20.1/test/nginx-tests/msie_refresh.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/msie_refresh.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for msie_refresh.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        msie_refresh on;
+
+        location / {
+            return 301 text;
+        }
+
+        location /space {
+            return 301 "space ";
+        }
+
+        location /error_page {
+            return 301;
+            error_page 301 text;
+        }
+
+        location /off {
+            msie_refresh off;
+            return 301 text;
+        }
+
+        location /ssi {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html', 'X<!--#include virtual="/" -->X');
+$t->run();
+
+###############################################################################
+
+like(get('/'), qr/Refresh.*URL=text"/, 'msie refresh');
+like(get('/space'), qr/URL=space%20"/, 'msie refresh escaped url');
+like(get('/error_page'), qr/URL=text"/, 'msie refresh error page');
+
+unlike(get('/off'), qr/Refresh/, 'msie refresh disabled');
+
+unlike(get('/ssi.html'), qr/^0\x0d\x0a?\x0d\x0a?\w/m, 'only final chunk');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+User-Agent: MSIE foo
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/not_modified_finalize.t ../asynch_mode_nginx/test/nginx-tests/not_modified_finalize.t
--- nginx-release-1.20.1/test/nginx-tests/not_modified_finalize.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/not_modified_finalize.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for not modified filter and filter finalization.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=cache:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        error_page 412 /error412.html;
+
+        location / {
+            proxy_pass        http://127.0.0.1:8081;
+            proxy_cache       cache;
+            proxy_cache_lock  on;
+            proxy_cache_valid 1h;
+        }
+
+        location /error412 {
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'test file');
+$t->write_file('error412.html', 'error412');
+
+$t->run();
+
+###############################################################################
+
+# we trigger filter finalization in not modified filter by using
+# the If-Unmodified-Since/If-Match header;
+# with cache enabled and updating bit set, this currently results in
+# "stalled cache updating" alerts
+
+like(http_match_get('/t.html'), qr//, 'request 412');
+
+$t->todo_alerts();
+
+# in addition, in 1.11.10 .. 1.17.1, if the response was previously
+# cached, such a request resulted in r->cache null pointer dereference
+# in ngx_http_upstream_cache_background_update(), after it was reset
+# during internal redirect
+
+http_get('/t.html');
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $ENV{TEST_NGINX_UNSAFE}
+    or $t->has_version('1.17.1');
+
+like(http_match_get('/t.html'), qr//, 'request 412 cached');
+
+}
+
+###############################################################################
+
+sub http_match_get {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+If-Match: tt
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/not_modified_proxy.t ../asynch_mode_nginx/test/nginx-tests/not_modified_proxy.t
--- nginx-release-1.20.1/test/nginx-tests/not_modified_proxy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/not_modified_proxy.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,143 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for not modified filter module and it's interaction with proxy.
+#
+# Notably, requests which are proxied should be skipped (that is, if
+# a backend returned 200, we should pass 200 to a client without any
+# attempts to handle conditional headers in the request), but responses
+# from cache should be handled.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=one:1m;
+
+    proxy_set_header If-Modified-Since "";
+    proxy_set_header If-Unmodified-Since "";
+    proxy_set_header If-None-Match "";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /etag {
+            add_header Last-Modified "";
+        }
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8080/;
+        }
+
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_cache one;
+            proxy_cache_valid 200 1y;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+$t->write_file('etag', '');
+
+$t->run();
+
+###############################################################################
+
+my ($t1, $lm, $etag);
+
+$t1 = http_get('/cache/t');
+$t1 =~ /Last-Modified: (.*)/; $lm = $1;
+$t1 =~ /ETag: (.*)/; $etag = $1;
+
+like(http_get_ims('/t', $lm), qr/ 304 /, 'if-modified-since');
+like(http_get_ims('/proxy/t', $lm), qr/ 200 /, 'ims proxy ignored');
+like(http_get_ims('/cache/t', $lm), qr/ 304 /, 'ims from cache');
+
+$t1 = 'Fri, 05 Jul 1985 14:30:52 GMT';
+
+like(http_get_iums('/t', $t1), qr/ 412 /, 'if-unmodified-since');
+like(http_get_iums('/proxy/t', $t1), qr/ 200 /, 'iums proxy ignored');
+like(http_get_iums('/cache/t', $t1), qr/ 412 /, 'iums from cache');
+
+like(http_get_inm('/t', $etag), qr/ 304 /, 'if-none-match');
+like(http_get_inm('/proxy/t', $etag), qr/ 200 /, 'inm proxy ignored');
+like(http_get_inm('/cache/t', $etag), qr/ 304 /, 'inm from cache');
+
+# backend response with ETag only, no Last-Modified
+
+$t1 = http_get('/cache/etag');
+$t1 =~ /ETag: (.*)/; $etag = $1;
+
+like(http_get_inm('/etag', $etag), qr/ 304 /, 'if-none-match etag only');
+like(http_get_inm('/proxy/etag', $etag), qr/ 200 /, 'inm etag proxy ignored');
+like(http_get_inm('/cache/etag', $etag), qr/ 304 /, 'inm etag from cache');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url, $ims) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Modified-Since: $ims
+
+EOF
+}
+
+sub http_get_iums {
+    my ($url, $ims) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Unmodified-Since: $ims
+
+EOF
+}
+
+sub http_get_inm {
+    my ($url, $inm) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-None-Match: $inm
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/not_modified.t ../asynch_mode_nginx/test/nginx-tests/not_modified.t
--- nginx-release-1.20.1/test/nginx-tests/not_modified.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/not_modified.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for not modified filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has('http')->plan(15)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            if_modified_since before;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get_ims('/t', 'Wed, 08 Jul 2037 22:53:52 GMT'), qr/ 304 /,
+    '0x7F000000');
+like(http_get_ims('/t', 'Tue, 19 Jan 2038 03:14:07 GMT'), qr/ 304 /,
+    '0x7FFFFFFF');
+
+SKIP: {
+    skip "only for 32-bit time_t", 2 if (gmtime(0xFFFFFFFF))[5] == 206;
+
+    like(http_get_ims('/t', 'Tue, 19 Jan 2038 03:14:08 GMT'), qr/ 200 /,
+        '0x7FFFFFFF + 1');
+    like(http_get_ims('/t', 'Fri, 25 Feb 2174 09:42:23 GMT'), qr/ 200 /,
+        '0x17FFFFFFF');
+}
+
+# If-Match, If-None-Match tests
+
+my ($t1, $etag);
+
+$t1 = http_get('/t');
+$t1 =~ /ETag: (".*")/;
+$etag = $1;
+
+like(http_get_inm('/t', $etag), qr/ 304 /, 'if-none-match');
+like(http_get_inm('/t', '"foo"'), qr/ 200 /, 'if-none-match fail');
+like(http_get_inm('/t', '"foo", "bar", ' . $etag . ' , "baz"'), qr/ 304 /,
+    'if-none-match with complex list');
+like(http_get_inm('/t', '*'), qr/ 304 /, 'if-none-match all');
+like(http_get_inm('/t', 'W/' . $etag), qr/ 304 /, 'if-none-match weak');
+like(http_get_im('/t', $etag), qr/ 200 /, 'if-match');
+like(http_get_im('/t', '"foo"'), qr/ 412 /, 'if-match fail');
+like(http_get_im('/t', '"foo", "bar", ' . "\t" . $etag . ' , "baz"'),
+    qr/ 200 /, 'if-match with complex list');
+like(http_get_im('/t', '*'), qr/ 200 /, 'if-match all');
+like(http_get_im('/t', 'W/' . $etag), qr/ 412 /, 'if-match weak fail');
+
+# server MUST ignore precondition if its response wouldn't be 2xx or 412
+
+like(http_get_im('/nx', '"foo"'), qr/ 404 /, 'if-match ignored with 404');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url, $ims) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Modified-Since: $ims
+
+EOF
+}
+
+sub http_get_inm {
+    my ($url, $inm) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-None-Match: $inm
+
+EOF
+}
+
+sub http_get_im {
+    my ($url, $inm) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+If-Match: $inm
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/perl_gzip.t ../asynch_mode_nginx/test/nginx-tests/perl_gzip.t
--- nginx-release-1.20.1/test/nginx-tests/perl_gzip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/perl_gzip.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Compress::Gzip; };
+plan(skip_all => "IO::Compress::Gzip not found") if $@;
+
+my $t = Test::Nginx->new()->has(qw/http perl gzip/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        %%GZIP_TYPES%%
+        %%QATZIP_ENABLE%%
+        %%QATZIP_TYPES%%
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                $r->print("TEST");
+                return OK;
+            }';
+        }
+
+        location /gz {
+            perl 'sub {
+                my $r = shift;
+                $r->header_out("Content-Encoding", "gzip");
+                $r->send_http_header("text/plain");
+                return OK if $r->header_only;
+                use IO::Compress::Gzip;
+                my $in = "TEST";
+                my $out;
+                IO::Compress::Gzip::gzip(\\$in => \\$out);
+                $r->print($out);
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_gzip_like(http_gzip_request('/'), qr/TEST/, 'perl response gzipped');
+http_gzip_like(http_gzip_request('/gz'), qr/TEST/, 'not doublegzipped');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/perl_sleep.t ../asynch_mode_nginx/test/nginx-tests/perl_sleep.t
--- nginx-release-1.20.1/test/nginx-tests/perl_sleep.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/perl_sleep.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for embedded perl module, $r->sleep().
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl ssi/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+            sendfile_max_chunk 100;
+            postpone_output 0;
+        }
+
+        location /sleep {
+            perl 'sub {
+                my $r = shift;
+
+                $r->sleep(100, sub {
+                    my $r = shift;
+                    $r->send_http_header;
+                    $r->print("it works");
+                    return OK;
+                });
+
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('subrequest.html', ('x' x 200) .
+    'X<!--#include virtual="/sleep" -->X');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/sleep'), qr/works/, 'perl sleep');
+like(http_get('/subrequest.html'), qr/works/, 'perl sleep in subrequest');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/perl_ssi.t ../asynch_mode_nginx/test/nginx-tests/perl_ssi.t
--- nginx-release-1.20.1/test/nginx-tests/perl_ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/perl_ssi.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,66 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl ssi/)->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+        }
+
+        location /dummy {
+            perl 'sub foo { my $r = shift; $r->print(join ",", @_); }';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html', 'X<!--#perl sub="foo" arg="arg1" -->X');
+$t->write_file('t2.html', 'X<!--#perl sub="foo" arg="arg1" arg="arg2" -->X');
+$t->write_file('noargs.html', 'X<!--#perl sub="foo" -->X');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t1.html'), qr/Xarg1X/, 'perl ssi response');
+like(http_get('/t2.html'), qr/Xarg1,arg2X/, 'perl ssi two args');
+like(http_get('/noargs.html'), qr/XX/, 'perl ssi noargs');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/perl.t ../asynch_mode_nginx/test/nginx-tests/perl.t
--- nginx-release-1.20.1/test/nginx-tests/perl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/perl.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,316 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for embedded perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http perl rewrite/)->plan(24)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $testvar "TEST";
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->status(204) if $r->args =~ /204/;
+
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                my $v = $r->variable("testvar");
+
+                $r->print("testvar: $v\n");
+
+                $r->print("host: ", $r->header_in("Host"), "\n");
+                $r->print("xfoo: ", $r->header_in("X-Foo"), "\n");
+                $r->print("cookie: ", $r->header_in("Cookie"), "\n");
+                $r->print("xff: ", $r->header_in("X-Forwarded-For"), "\n");
+
+                return OK;
+            }';
+        }
+
+        location /range {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->header_out("Content-Length", "42");
+                $r->allow_ranges();
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                $r->print("x" x 42);
+
+                return OK;
+            }';
+        }
+
+        location /body {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                if ($r->has_request_body(\&post)) {
+                    return OK;
+                }
+
+                return HTTP_BAD_REQUEST;
+
+                sub post {
+                    my $r = shift;
+                    $r->send_http_header;
+                    $r->print("body: ", $r->request_body, "\n");
+                    $r->print("file: ", $r->request_body_file, "\n");
+                }
+            }';
+        }
+
+        location /discard {
+            perl 'sub {
+                use warnings;
+                use strict;
+
+                my $r = shift;
+
+                $r->discard_request_body;
+
+                $r->send_http_header("text/plain");
+
+                return OK if $r->header_only;
+
+                $r->print("host: ", $r->header_in("Host"), "\n");
+
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/ 200 .*TEST/s, 'perl response');
+like(http_head('/'), qr/ 200 (?!.*TEST)/s, 'perl header_only');
+like(http_get('/?204'), qr/ 204 (?!.*TEST)/s, 'perl status, args');
+
+# various $r->header_in() cases
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/host: localhost/, 'perl header_in known');
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'X-Foo: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/xfoo: foo/, 'perl header_in unknown');
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'Cookie: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo/, 'perl header_in cookie');
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'Cookie: foo1' . CRLF
+    . 'Cookie: foo2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/cookie: foo1; foo2/, 'perl header_in cookie2');
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'X-Forwarded-For: foo' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/xff: foo/, 'perl header_in xff');
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'X-Forwarded-For: foo1' . CRLF
+    . 'X-Forwarded-For: foo2' . CRLF
+    . 'Host: localhost' . CRLF . CRLF
+), qr/xff: foo1, foo2/, 'perl header_in xff2');
+
+# headers_out content-length tests with range filter
+
+like(http_get('/range'), qr/Content-Length: 42.*^x{42}$/ms,
+    'perl header_out content-length');
+
+like(http(
+    'GET /range HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Range: bytes=0-1' . CRLF . CRLF
+), qr/Content-Length: 2.*^xx$/ms, 'perl header_out content-length range');
+
+like(http(
+    'GET /range HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Range: bytes=0-1,3-5' . CRLF . CRLF
+), qr/Content-Length: (?!42).*^xx\x0d.*^xxx\x0d/ms,
+    'perl header_out content-length multipart');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.2');
+
+like(http(
+    'GET /range HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Range: bytes=100000-' . CRLF . CRLF
+), qr|^\QHTTP/1.1 416\E.*(?!xxx)|ms, 'perl range not satisfiable');
+
+}
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $t->has_version('1.17.1')
+    or $ENV{TEST_NGINX_UNSAFE};
+
+like(http(
+    'GET / HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'If-Match: tt' . CRLF . CRLF
+), qr|200 OK|ms, 'perl precondition failed');
+
+}
+
+# various request body tests
+
+like(http_get('/body'), qr/400 Bad Request/, 'perl no body');
+
+like(http(
+    'GET /body HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Content-Length: 10' . CRLF . CRLF
+    . '1234567890'
+), qr/body: 1234567890/, 'perl body preread');
+
+like(http(
+    'GET /body HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Content-Length: 10' . CRLF . CRLF,
+    sleep => 0.1,
+    body => '1234567890'
+), qr/body: 1234567890/, 'perl body late');
+
+like(http(
+    'GET /body HTTP/1.0' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Content-Length: 10' . CRLF . CRLF
+    . '12345',
+    sleep => 0.1,
+    body => '67890'
+), qr/body: 1234567890/, 'perl body split');
+
+like(http(
+    'GET /body HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF
+    . 'a' . CRLF
+    . '1234567890' . CRLF
+    . '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked');
+
+like(http(
+    'GET /body HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF,
+    sleep => 0.1,
+    body => 'a' . CRLF . '1234567890' . CRLF . '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked late');
+
+like(http(
+    'GET /body HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF
+    . 'a' . CRLF
+    . '12345',
+    sleep => 0.1,
+    body => '67890' . CRLF . '0' . CRLF . CRLF
+), qr/body: 1234567890/, 'perl body chunked split');
+
+like(http(
+    'GET /discard HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF
+    . 'a' . CRLF
+    . '1234567890' . CRLF
+    . '0' . CRLF . CRLF
+), qr/host: localhost/, 'perl body discard');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.2');
+
+like(http(
+    'GET /discard HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF
+    . 'ak' . CRLF
+    . '1234567890' . CRLF
+    . '0' . CRLF . CRLF
+), qr/400 Bad Request/, 'perl body discard bad chunk');
+
+like(http(
+    'GET /body HTTP/1.1' . CRLF
+    . 'Host: localhost' . CRLF
+    . 'Connection: close' . CRLF
+    . 'Transfer-Encoding: chunked' . CRLF . CRLF
+    . 'ak' . CRLF
+    . '1234567890' . CRLF
+    . '0' . CRLF . CRLF
+), qr/400 Bad Request/, 'perl body bad chunk');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/post_action.t ../asynch_mode_nginx/test/nginx-tests/post_action.t
--- nginx-release-1.20.1/test/nginx-tests/post_action.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/post_action.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,82 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for nginx post_action directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            post_action /post.html;
+        }
+
+        location /post.html {
+            # static
+        }
+
+        location /remote {
+            post_action /post.remote;
+        }
+
+        location /post.remote {
+            proxy_pass http://127.0.0.1:8080/post.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('post.html', 'HIDDEN');
+$t->write_file('remote', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/m, 'post action');
+unlike(http_get('/'), qr/HIDDEN/m, 'no additional body');
+
+like(http_get('/remote'), qr/SEE-THIS/m, 'post action proxy');
+unlike(http_get('/remote'), qr/HIDDEN/m, 'no additional body proxy');
+
+$t->stop();
+
+like(`cat ${\($t->testdir())}/access.log`, qr/post/, 'post action in logs');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_bind.t ../asynch_mode_nginx/test/nginx-tests/proxy_bind.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_bind.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_bind.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        proxy_bind      127.0.0.2;
+
+        location / {
+            proxy_bind  127.0.0.1;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /inherit {
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /off {
+            proxy_bind  off;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /var {
+            proxy_bind  $arg_b;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+
+        location /port {
+            proxy_bind  127.0.0.2:$remote_port;
+            proxy_pass  http://127.0.0.1:8081/;
+            add_header  X-Client-Port $remote_port;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr;
+            add_header   X-Port $remote_port;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.1/, 'bind');
+like(http_get('/inherit'), qr/X-IP: 127.0.0.2/, 'bind inherit');
+like(http_get('/off'), qr/X-IP: 127.0.0.1/, 'bind off');
+like(http_get('/var?b=127.0.0.2'), qr/X-IP: 127.0.0.2/, 'bind var');
+like(http_get('/port'), qr/Port: (\d+)(?!\d).*Port: \1/s, 'bind port');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_bind_transparent_capability.t ../asynch_mode_nginx/test/nginx-tests/proxy_bind_transparent_capability.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_bind_transparent_capability.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_bind_transparent_capability.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind transparent with Linux CAP_NET_RAW capability.
+# Ensure that such configuration isn't broken under a non-priveleged user.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'no linux capability') if $^O ne 'linux';
+plan(skip_all => 'must be root') if $> != 0;
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_bind  127.0.0.2 transparent;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr always;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'transparent');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_bind_transparent.t ../asynch_mode_nginx/test/nginx-tests/proxy_bind_transparent.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_bind_transparent.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_bind_transparent.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy_bind transparent.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => 'must be root') if $> != 0;
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+user root wheel;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_bind  127.0.0.2 transparent;
+            proxy_pass  http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        server_name     localhost;
+
+        location / {
+            add_header   X-IP $remote_addr always;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'transparent');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_bypass.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_bypass.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_bypass.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_bypass.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, proxy_cache_bypass.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=one:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_cache one;
+            proxy_cache_key $uri;
+            proxy_cache_bypass $arg_bypass;
+            proxy_cache_valid any 1y;
+
+            proxy_intercept_errors on;
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            return 403;
+        }
+
+        add_header X-Cache-Status $upstream_cache_status;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t'), qr/SEE-THIS/, 'request');
+
+$t->write_file('t', 'NOOP');
+
+like(http_get('/t'), qr/SEE-THIS/, 'request cached');
+like(http_get('/t?bypass=1'), qr/NOOP/, 'cache bypassed');
+like(http_get('/t'), qr/NOOP/, 'cached after bypass');
+
+# ticket #827, cache item "error" field was not cleared
+# on cache bypass
+
+like(http_get('/t2'), qr/403 Forbidden/, 'intercepted error');
+
+$t->write_file('t2', 'NOOP');
+
+like(http_get('/t2'), qr/403 Forbidden/, 'error cached');
+like(http_get('/t2?bypass=1'), qr/NOOP/, 'error cache bypassed');
+like(http_get('/t2'), qr/NOOP/, 'error cached after bypass');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_chunked.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_chunked.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for proxy cache with Transfer-Encoding: chunked.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path %%TESTDIR%%/cache keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_cache NAME;
+            proxy_cache_valid any 1m;
+            add_header X-Status $upstream_cache_status;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_chunked_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get("/"), qr/SEE-THIS/s, "chunked");
+like(http_get("/"), qr/SEE-THIS.*HIT/s, "chunked cached");
+
+###############################################################################
+
+sub http_chunked_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        print $client <<'EOF';
+HTTP/1.1 200 OK
+X-Test: SEE-THIS
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+        print $client "85" . CRLF;
+        select undef, undef, undef, 0.1;
+        print $client "FOO" . ("0123456789abcdef" x 8) . CRLF . CRLF;
+
+        print $client "0" . CRLF . CRLF;
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_convert_head.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_convert_head.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_convert_head.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_convert_head.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache with proxy_cache_convert_head directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_cache   NAME;
+
+        proxy_cache_key $request_uri;
+
+        proxy_cache_valid   200 302  2s;
+
+        add_header X-Cache-Status $upstream_cache_status;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081/t.html;
+            proxy_cache_convert_head   off;
+
+            location /inner {
+                proxy_pass http://127.0.0.1:8081/t.html;
+                proxy_cache_convert_head on;
+            }
+        }
+
+        location /on {
+            proxy_pass http://127.0.0.1:8081/t.html;
+            proxy_cache_convert_head on;
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Method $request_method;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Method: GET/, 'get');
+like(http_head('/?2'), qr/X-Method: HEAD/, 'head');
+like(http_head('/?2'), qr/HIT/, 'head cached');
+unlike(http_get('/?2'), qr/SEE-THIS/, 'get after head');
+
+like(http_get('/on'), qr/X-Method: GET/, 'on - get');
+like(http_head('/on?2'), qr/X-Method: GET/, 'on - head');
+
+like(http_get('/inner'), qr/X-Method: GET/, 'inner - get');
+like(http_head('/inner?2'), qr/X-Method: GET/, 'inner - head');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_error.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_error.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_error.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_error.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, "header already sent" alerts on backend errors,
+# http://mailman.nginx.org/pipermail/nginx-devel/2018-January/010737.html.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_read_timeout 500ms;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            postpone_output 0;
+            limit_rate 512;
+            expires 1m;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('big.html', 'x' x 1024);
+
+$t->run();
+
+###############################################################################
+
+# make a HEAD request; since cache is enabled, nginx converts HEAD to GET
+# and will set u->pipe->downstream_error to suppress sending the response
+# body to the client
+
+like(http_head('/big.html'), qr/200 OK/, 'head request');
+
+# once proxy_read_timeout expires, nginx will call
+# ngx_http_finalize_upstream_request() with u->pipe->downstream_error set
+# and rc = NGX_HTTP_GATEWAY_BAD_GATEWAY; after revision ad3f342f14ba046c this
+# will result in ngx_http_finalize_request(NGX_HTTP_GATEWAY_BAD_GATEWAY),
+# leading to an attempt to return additional error response and
+# the "header already sent" alert; fixed in 93abb5a855d6
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock_age.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock_age.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock_age.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock_age.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,152 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache lock aged.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_age 100ms;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = http_get('/', start => 1);
+
+like(http_get('/'), qr/request 2/, 'request');
+like(http_get('/'), qr/request 2/, 'request cached');
+
+http_get('/close');
+
+like(http_end($s), qr/request 1/, 'request aged');
+like(http_get('/'), qr/request 1/, 'request aged cached');
+
+###############################################################################
+
+sub http_daemon {
+    my (@ports) = @_;
+    my @socks;
+
+    for my $port (@ports) {
+        my $server = IO::Socket::INET->new(
+            Proto => 'tcp',
+            LocalHost => "127.0.0.1:$port",
+            Listen => 5,
+            Reuse => 1
+        )
+            or die "Can't create listening socket: $!\n";
+        push @socks, $server;
+    }
+
+    my $sel = IO::Select->new(@socks);
+    my $num = 0;
+    my $s;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if (grep $_ == $fh, @socks) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (process_socket($fh, \$num, \$s)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+# Returns true to close connection
+
+sub process_socket {
+    my ($client, $num, $s) = @_;
+
+    my $headers = '';
+    my $uri = '';
+
+    while (<$client>) {
+        $headers .= $_;
+        last if (/^\x0d?\x0a?$/);
+    }
+    return 1 if $headers eq '';
+
+    $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+    return 1 if $uri eq '';
+
+    # finish a previously saved socket
+    close $$s if $uri eq '/close';
+
+    $$num++;
+
+    print $client <<EOF;
+HTTP/1.1 200 OK
+Cache-Control: max-age=300
+Connection: close
+
+request $$num
+EOF
+
+    # save socket and wait
+    if ($$num == 1) {
+        $$s = $client;
+        return 0;
+    }
+
+    return 1;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock_ssi.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock_ssi.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock_ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock_ssi.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache lock with subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache ssi/)
+    ->write_file_expand('nginx.conf', <<'EOF')->plan(2);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_timeout 100ms;
+
+            proxy_read_timeout 3s;
+        }
+
+        location = /ssi.html {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+        limit_req zone=one burst=5;
+    }
+
+}
+
+EOF
+
+$t->write_file('ssi.html',
+    '<!--#include virtual="/active" -->' .
+    '<!--#include virtual="/locked" -->' .
+    'end'
+);
+
+$t->write_file('active', 'active');
+$t->write_file('locked', 'locked');
+
+$t->run();
+
+###############################################################################
+
+# problem: if proxy cache lock wakeup happens in an inactive
+# subrequest, just a connection write event may not trigger any
+# further work
+
+# main request -> subrequest /active (waiting for a backend),
+#              -> subrequest /locked (locked by another request)
+
+# this doesn't result in an infinite timeout as second subrequest
+# is woken up by the postpone filter once first subrequest completes,
+# but this is suboptimal behaviour
+
+http_get('/charge');
+my $start = time();
+
+my $s = http_get('/locked', start => 1);
+select undef, undef, undef, 0.2;
+
+like(http_get('/ssi.html'), qr/end/, 'cache lock ssi');
+http_end($s);
+cmp_ok(time() - $start, '<=', 5, 'parallel execution after lock timeout');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_lock.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_lock.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,165 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache lock.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(17)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+        }
+
+        location /timeout {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_lock on;
+            proxy_cache_lock_timeout 200ms;
+        }
+
+        location /nolock {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_fake_daemon);
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# sequential requests
+
+for my $i (1 .. 5) {
+    like(http_get('/seq'), qr/request 1/, 'sequential request ' . $i);
+}
+
+# parallel requests
+
+my @sockets;
+
+for my $i (1 .. 5) {
+    $sockets[$i] = http_get('/par1', start => 1);
+}
+
+for my $i (1 .. 5) {
+    like(http_end($sockets[$i]), qr/request 1/, 'parallel request ' . $i);
+}
+
+like(http_get('/par1'), qr/request 1/, 'first request cached');
+
+# since 1.7.8, parallel requests with cache lock timeout expired are not cached
+
+for my $i (1 .. 3) {
+    $sockets[$i] = http_get('/timeout', start => 1);
+}
+
+like(http_end($sockets[1]), qr/request 1/, 'lock timeout - first');
+
+my $rest = http_end($sockets[2]);
+$rest .= http_end($sockets[3]);
+
+like($rest, qr/request (2.*request 3|3.*request 2)/s, 'lock timeout - rest');
+like(http_get('/timeout'), qr/request 1/, 'lock timeout - first only cached');
+
+# no lock
+
+for my $i (1 .. 3) {
+    $sockets[$i] = http_get('/nolock', start => 1);
+}
+
+$rest = join '', map { http_end($sockets[$_]) } (1 .. 3);
+
+like($rest, qr/request 1/, 'nolock - first');
+like($rest, qr/request 3/, 'nolock - last');
+like(http_get('/nolock'), qr/request 3/, 'nolock - last cached');
+
+###############################################################################
+
+sub http_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $num = 0;
+    my $uri = '';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            if (/GET (.*) HTTP/ && $1 ne $uri) {
+                $uri = $1;
+                $num = 0;
+            }
+
+            $uri = $1 if /GET (.*) HTTP/;
+            last if /^\x0d?\x0a?$/;
+        }
+
+        next unless $uri;
+
+        select(undef, undef, undef, 1.1);
+
+        $num++;
+        print $client <<"EOF";
+HTTP/1.1 200 OK
+Cache-Control: max-age=300
+Connection: close
+
+request $num
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_manager.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_manager.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_manager.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_manager.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, manager parameters.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long test') unless $ENV{TEST_NGINX_UNSAFE};
+
+plan(skip_all => 'page size is not appropriate') unless
+        POSIX::sysconf(&POSIX::_SC_PAGESIZE) == 4096;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  max_size=0  keys_zone=NAME:1m
+                       manager_sleep=5  manager_files=2  manager_threshold=10;
+
+    proxy_cache_path   %%TESTDIR%%/water  keys_zone=NAM2:16k
+                       manager_sleep=5;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_valid   any   1m;
+        }
+
+        location /water/ {
+            proxy_pass    http://127.0.0.1:8081/t.html;
+            proxy_cache   NAM2;
+
+            proxy_cache_valid   any   1m;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run()->plan(3);
+
+###############################################################################
+
+my $d = $t->testdir();
+
+# wait for cache manager start
+
+sleep 1;
+
+http_get("/t.html?$_") for (1 .. 5);
+
+# pretend we could not fit into zone
+
+http_get("/water/?$_") for (1 .. 100);
+
+my $n = files("$d/water");
+
+# wait for cache manager process
+
+sleep 10;
+
+cmp_ok(files("$d/water"), '<', $n, 'manager watermark');
+
+is(files("$d/cache"), 3, 'manager files');
+
+sleep 5;
+
+is(files("$d/cache"), 1, 'manager sleep');
+
+###############################################################################
+
+sub files {
+    my ($path) = @_;
+    my $dh;
+
+    opendir($dh, $path);
+    return scalar grep { ! /^\./ } readdir($dh);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_max_range_offset.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_max_range_offset.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_max_range_offset.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_max_range_offset.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache_max_range_offset directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 2;
+        }
+
+        location /zero/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 0;
+        }
+
+        location /min_uses/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_max_range_offset 2;
+            proxy_cache_min_uses 2;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Range $http_range;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run()->plan(8);
+
+###############################################################################
+
+unlike(get('/t.html?1', 'bytes=1-'), qr/X-Range/, 'range - below');
+like(get('/t.html?2', 'bytes=3-'), qr/X-Range/, 'range - above');
+like(get('/t.html?3', 'bytes=-1'), qr/X-Range/, 'range - last');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/t.html?4', 'bytes=1-1,3-'), qr/X-Range/, 'range - multipart above');
+
+}
+
+like(get('/zero/t.html?5', 'bytes=0-0'), qr/X-Range/, 'always non-cacheable');
+like(get('/min_uses/t.html?6', 'bytes=1-'), qr/X-Range/, 'below min_uses');
+
+# no range in client request
+
+like(http_get('/t.html'), qr/SEE-THIS/, 'no range');
+
+$t->write_file('t.html', 'NOOP');
+like(http_get('/t.html'), qr/SEE-THIS/, 'no range - cached');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Range: $extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_min_free.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_min_free.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_min_free.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_min_free.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, min_free parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2 min_free=4k
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   NAME;
+
+            proxy_cache_valid   any      1m;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->try_run('no proxy_cache_path min_free')->plan(2);
+
+###############################################################################
+
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request');
+
+$t->write_file('t.html', 'NOOP');
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request cached');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_path.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_path.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_path.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_path.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,88 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache with use_temp_path parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1
+                       keys_zone=ON:1m      use_temp_path=on;
+    proxy_cache_path   %%TESTDIR%%/cache2
+                       keys_zone=OFF:1m     use_temp_path=off;
+    proxy_cache_path   %%TESTDIR%%/cache4   levels=1:2
+                       keys_zone=LEVELS:1m  use_temp_path=off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   $arg_c;
+
+            proxy_cache_valid   any      1m;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t?c=ON'), qr/MISS.*SEE-THIS/ms, 'temp path');
+like(http_get('/t?c=OFF'), qr/MISS.*SEE-THIS/ms, 'temp path off');
+like(http_get('/t?c=LEVELS'), qr/MISS.*SEE-THIS/ms, 'temp path levels');
+
+$t->write_file('t', 'SEE-THAT');
+
+like(http_get('/t?c=ON'), qr/HIT.*SEE-THIS/ms, 'temp path cached');
+like(http_get('/t?c=OFF'), qr/HIT.*SEE-THIS/ms, 'temp path cached off');
+like(http_get('/t?c=LEVELS'), qr/HIT.*SEE-THIS/ms, 'temp path cached levels');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_range.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_range.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_range.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_range.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache and range filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+        }
+
+        location /min_uses {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+            proxy_cache_min_uses 2;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /tbig.html {
+            limit_rate 50k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+
+# should not fit in a single proxy buffer
+
+$t->write_file('tbig.html',
+    join('', map { sprintf "XX%06dXX", $_ } (1 .. 7000)));
+
+$t->run();
+
+###############################################################################
+
+like(http_get_range('/t.html?1', 'Range: bytes=4-'), qr/^THIS/m,
+    'range on first request');
+
+{
+local $TODO = 'not yet';
+
+like(http_get_range('/t.html?2', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+    'multipart range on first request');
+}
+
+like(http_get_range('/t.html?1', 'Range: bytes=4-'), qr/^THIS/m,
+    'cached range');
+like(http_get_range('/t.html?1', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+    'cached multipart range');
+
+like(http_get_range('/min_uses/t.html?3', 'Range: bytes=4-'),
+    qr/^THIS/m, 'range below min_uses');
+
+like(http_get_range('/min_uses/t.html?4', 'Range: bytes=0-2,4-'),
+    qr/^SEE.*^THIS/ms, 'multipart range below min_uses');
+
+like(http_get_range('/tbig.html', 'Range: bytes=0-19'),
+    qr/^XX000001XXXX000002XX$/ms, 'range of response received in parts');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_revalidate.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_revalidate.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_revalidate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_revalidate.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache revalidation with conditional requests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(23)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=one:1m;
+
+    proxy_cache_revalidate on;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   one;
+
+            proxy_cache_valid  200 404  2s;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+        location /etag/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_hide_header Last-Modified;
+        }
+        location /201 {
+            add_header Last-Modified "Mon, 02 Mar 2015 17:20:58 GMT";
+            add_header Cache-Control "max-age=1";
+            add_header X-If-Modified-Since $http_if_modified_since;
+            return 201;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('t', 'SEE-THIS');
+$t->write_file('t2', 'SEE-THIS');
+$t->write_file('t3', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+# request documents and make sure they are cached
+
+like(http_get('/t'), qr/X-Cache-Status: MISS.*SEE/ms, 'request');
+like(http_get('/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'request cached');
+
+like(http_get('/t2'), qr/X-Cache-Status: MISS.*SEE/ms, '2nd request');
+like(http_get('/t2'), qr/X-Cache-Status: HIT.*SEE/ms, '2nd request cached');
+
+like(http_get('/etag/t'), qr/X-Cache-Status: MISS.*SEE/ms, 'etag');
+like(http_get('/etag/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'etag cached');
+
+like(http_get('/etag/t2'), qr/X-Cache-Status: MISS.*SEE/ms, 'etag2');
+like(http_get('/etag/t2'), qr/X-Cache-Status: HIT.*SEE/ms, 'etag2 cached');
+
+like(http_get('/201'), qr/X-Cache-Status: MISS/, 'other status');
+like(http_get('/201'), qr/X-Cache-Status: HIT/, 'other status cached');
+
+like(http_get('/t3'), qr/SEE/, 'cache before 404');
+
+# wait for a while for cached responses to expire
+
+select undef, undef, undef, 3.5;
+
+# 1st document isn't modified, and should be revalidated on first request
+# (a 304 status code will appear in backend's logs), then cached again
+
+like(http_get('/t'), qr/X-Cache-Status: REVALIDATED.*SEE/ms, 'revalidated');
+like(http_get('/t'), qr/X-Cache-Status: HIT.*SEE/ms, 'cached again');
+
+rename("$d/t3", "$d/t3_moved");
+
+like(http_get('/t3'), qr/ 404 /, 'cache 404 response');
+
+select undef, undef, undef, 0.1;
+like($t->read_file('access.log'), qr/ 304 /, 'not modified');
+
+# 2nd document is recreated with a new content
+
+$t->write_file('t2', 'NEW');
+like(http_get('/t2'), qr/X-Cache-Status: EXPIRED.*NEW/ms, 'revalidate failed');
+like(http_get('/t2'), qr/X-Cache-Status: HIT.*NEW/ms, 'new response cached');
+
+# the same for etag:
+# 1st document isn't modified
+# 2nd document is recreated
+
+like(http_get('/etag/t'), qr/X-Cache-Status: REVALIDATED.*SEE/ms,
+    'etag revalidated');
+like(http_get('/etag/t'), qr/X-Cache-Status: HIT.*SEE/ms,
+    'etag cached again');
+like(http_get('/etag/t2'), qr/X-Cache-Status: EXPIRED.*NEW/ms,
+    'etag2 revalidate failed');
+like(http_get('/etag/t2'), qr/X-Cache-Status: HIT.*NEW/ms,
+    'etag2 new response cached');
+
+# check that conditional requests are only used for 200/206 responses
+
+# d0ce06cb9be1 in 1.7.3 changed to ignore header filter's work to strip
+# the Last-Modified header when storing non-200/206 in cache;
+# 1573fc7875fa in 1.7.9 effectively turned it back.
+
+unlike(http_get('/201'), qr/X-If-Modified/, 'other status no revalidation');
+
+# wait for a while for a cached 404 response to expire
+
+select undef, undef, undef, 3.5;
+
+# check that conditional requests are not used to revalidate 404 response
+
+# before fd283aa92e04 introduced in 1.7.7, this test passed by chance because
+# of the If-Modified-Since header that was sent with Epoch in revalidation
+# of responses cached without the Last-Modified header;
+# fd283aa92e04 leaved (an legitimate) successful revalidation of 404 by ETag
+# (introduced by 44b9ab7752e3 in 1.7.3), which caused the test to fail;
+# 1573fc7875fa in 1.7.9 changed to not revalidate non-200/206 responses but
+# leaked Last-Modified and ETag into 404 inherited from stale 200/206 response;
+# 174512857ccf in 1.7.11 fixed the leak and allowed the test to pass.
+
+rename("$d/t3_moved", "$d/t3");
+
+like(http_get('/t3'), qr/SEE/, 'no 404 revalidation after stale 200');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache gzip/)->plan(15)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        gzip on;
+        %%GZIP_MIN_LENGTH_0%%
+        %%QATZIP_ENABLE%%
+        %%QATZIP_MIN_LENGTH_0%%
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   NAME;
+
+            proxy_cache_valid   200 302  2s;
+            proxy_cache_valid   301      1d;
+            proxy_cache_valid   any      1m;
+
+            proxy_cache_min_uses  1;
+
+            proxy_cache_use_stale  error timeout invalid_header http_500
+                                   http_404;
+
+            proxy_no_cache  $arg_e;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            limit_rate 512;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('t2.html', 'SEE-THIS');
+$t->write_file('empty.html', '');
+$t->write_file('big.html', 'x' x 1024);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request');
+
+$t->write_file('t.html', 'NOOP');
+like(http_get('/t.html'), qr/SEE-THIS/, 'proxy request cached');
+
+unlike(http_head('/t2.html'), qr/SEE-THIS/, 'head request');
+like(http_get('/t2.html'), qr/SEE-THIS/, 'get after head');
+unlike(http_head('/t2.html'), qr/SEE-THIS/, 'head after get');
+
+like(http_head('/empty.html?head'), qr/MISS/, 'empty head first');
+like(http_head('/empty.html?head'), qr/HIT/, 'empty head second');
+
+like(http_get_range('/t.html', 'Range: bytes=4-'), qr/^THIS/m, 'cached range');
+like(http_get_range('/t.html', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+    'cached multipart range');
+
+like(http_get('/empty.html'), qr/MISS/, 'empty get first');
+like(http_get('/empty.html'), qr/HIT/, 'empty get second');
+
+select(undef, undef, undef, 3.1);
+unlink $t->testdir() . '/t.html';
+like(http_gzip_request('/t.html'),
+    qr/HTTP.*STALE.*1c\x0d\x0a.{28}\x0d\x0a0\x0d\x0a\x0d\x0a\z/s,
+    'non-empty get stale');
+
+unlink $t->testdir() . '/empty.html';
+like(http_gzip_request('/empty.html'),
+    qr/HTTP.*STALE.*14\x0d\x0a.{20}\x0d\x0a0\x0d\x0a\x0d\x0a\z/s,
+    'empty get stale');
+
+# no client connection close with response on non-cacheable HEAD requests
+# see 545b5e4d83b2 in nginx for detailed explanation
+
+my $s = http(<<EOF, start => 1);
+HEAD /big.html?e=1 HTTP/1.1
+Host: localhost
+
+EOF
+
+my $r = http_get('/t.html', socket => $s);
+
+like($r, qr/Connection: keep-alive/, 'non-cacheable head - keepalive');
+like($r, qr/SEE-THIS/, 'non-cacheable head - second');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_use_stale.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_use_stale.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_use_stale.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_use_stale.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,315 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache_use_stale.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite limit_req ssi/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2  keys_zone=NAME:1m;
+
+    limit_req_zone  $binary_remote_addr  zone=one:1m  rate=10r/m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /ssi.html {
+            ssi on;
+            sendfile_max_chunk  4k;
+        }
+
+        location /escape {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_background_update  on;
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   NAME;
+
+            proxy_cache_key  $uri;
+
+            proxy_cache_revalidate  on;
+
+            proxy_cache_background_update  on;
+
+            add_header X-Cache-Status $upstream_cache_status;
+
+            location /t4.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_revalidate  off;
+            }
+
+            location /t5.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_background_update  off;
+            }
+
+            location ~ /(reg)(?P<name>exp).html {
+                proxy_pass    http://127.0.0.1:8081/$1$name.html;
+
+                proxy_cache_background_update  on;
+            }
+
+            location /updating/ {
+                proxy_pass    http://127.0.0.1:8081/;
+
+                proxy_cache_use_stale  updating;
+            }
+
+            location /t7.html {
+                proxy_pass    http://127.0.0.1:8081;
+
+                sendfile_max_chunk  4k;
+            }
+
+            location /t8.html {
+                proxy_pass    http://127.0.0.1:8081/t.html;
+
+                proxy_cache_valid  1s;
+            }
+
+            if ($arg_if) {
+                # nothing
+            }
+        }
+    }
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        add_header Cache-Control $http_x_cache_control;
+
+        if ($arg_lim) {
+            set $limit_rate 1k;
+        }
+
+        if ($arg_e) {
+            return 500;
+        }
+
+        location / { }
+
+        location /t6.html {
+            limit_req zone=one burst=2;
+        }
+
+        location /t9.html {
+            add_header Cache-Control "max-age=1, stale-while-revalidate=10";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->write_file('tt.html', 'SEE-THIS');
+$t->write_file('t2.html', 'SEE-THIS');
+$t->write_file('t3.html', 'SEE-THIS');
+$t->write_file('t6.html', 'SEE-THIS');
+$t->write_file('t7.html', 'SEE-THIS' x 1024);
+$t->write_file('t9.html', 'SEE-THIS' x 1024);
+$t->write_file('ssi.html', 'xxx <!--#include virtual="/t9.html" --> xxx');
+$t->write_file('escape.html', 'SEE-THIS');
+$t->write_file('escape html', 'SEE-THIS');
+$t->write_file('regexp.html', 'SEE-THIS');
+
+$t->run()->plan(36);
+
+###############################################################################
+
+like(get('/t.html', 'max-age=1, stale-if-error=5'), qr/MISS/, 'stale-if-error');
+like(http_get('/t.html?e=1'), qr/HIT/, 's-i-e - cached');
+
+like(get('/t2.html', 'max-age=1, stale-while-revalidate=10'), qr/MISS/,
+    'stale-while-revalidate');
+like(http_get('/t2.html'), qr/HIT/, 's-w-r - cached');
+
+get('/tt.html', 'max-age=1, stale-if-error=3');
+get('/t3.html', 'max-age=1, stale-while-revalidate=2');
+get('/t4.html', 'max-age=1, stale-while-revalidate=3');
+get('/t5.html', 'max-age=1, stale-while-revalidate=3');
+get('/t6.html', 'max-age=1, stale-while-revalidate=4');
+get('/t7.html', 'max-age=1, stale-while-revalidate=10');
+http_get('/ssi.html');
+get('/updating/t.html', 'max-age=1');
+get('/updating/t2.html', 'max-age=1, stale-while-revalidate=2');
+get('/updating/tt.html', 'max-age=1, stale-if-error=5');
+get('/t8.html', 'stale-while-revalidate=10');
+get('/escape.htm%6C', 'max-age=1, stale-while-revalidate=10');
+get('/escape html', 'max-age=1, stale-while-revalidate=10');
+get('/regexp.html', 'max-age=1, stale-while-revalidate=10');
+
+sleep 2;
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+# stale 5xx response is ignored since 1.19.3,
+# "proxy_cache_use_stale updating;" allows to get it still
+
+like(http_get('/t.html?e=1'), qr/ 500 /, 's-i-e - stale 5xx ignore');
+like(http_get('/tt.html?e=1'), qr/ 500 /, 's-i-e - stale 5xx ignore 2');
+
+}
+
+like(http_get('/updating/tt.html'), qr/STALE/, 's-i-e - stale 5xx updating');
+like(http_get('/t.html'), qr/REVALIDATED/, 's-i-e - revalidated');
+
+like(http_get('/t2.html?e=1'), qr/STALE/, 's-w-r - revalidate error');
+like(http_get('/t2.html'), qr/STALE/, 's-w-r - stale while revalidate');
+like(http_get('/t2.html'), qr/HIT/, 's-w-r - revalidated');
+
+like(get('/t4.html', 'max-age=1, stale-while-revalidate=2'), qr/STALE/,
+    's-w-r - unconditional revalidate');
+like(http_get('/t4.html'), qr/HIT/, 's-w-r - unconditional revalidated');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+like(http_get('/t5.html?e=1'), qr/ 500 /,
+    's-w-r - foreground revalidate error');
+
+}
+
+like(http_get('/t5.html'), qr/REVALIDATED/, 's-w-r - foreground revalidated');
+
+# proxy_pass to regular expression with named and positional captures
+
+like(http_get('/regexp.html'), qr/STALE/, 's-w-r - regexp background update');
+like(http_get('/regexp.html'), qr/HIT/, 's-w-r - regexp revalidated');
+
+# UPDATING while s-w-r
+
+$t->write_file('t6.html', 'SEE-THAT');
+
+my $s = get('/t6.html', 'max-age=1, stale-while-revalidate=2', start => 1);
+select undef, undef, undef, 0.2;
+like(http_get('/t6.html'), qr/UPDATING.*SEE-THIS/s, 's-w-r - updating');
+like(http_end($s), qr/STALE.*SEE-THIS/s, 's-w-r - updating stale');
+like(http_get('/t6.html'), qr/HIT.*SEE-THAT/s, 's-w-r - updating revalidated');
+
+# stale-while-revalidate with proxy_cache_use_stale updating
+
+like(http_get('/updating/t.html'), qr/STALE/,
+    's-w-r - use_stale updating stale');
+like(http_get('/updating/t.html'), qr/HIT/,
+    's-w-r - use_stale updating revalidated');
+
+# stale-while-revalidate with proxy_cache_valid
+
+like(http_get('/t8.html'), qr/STALE/, 's-w-r - proxy_cache_valid revalidate');
+like(http_get('/t8.html'), qr/HIT/, 's-w-r - proxy_cache_valid revalidated');
+
+sleep 2;
+
+like(http_get('/t2.html?e=1'), qr/STALE/, 's-w-r - stale after revalidate');
+like(http_get('/t3.html?e=1'), qr/ 500 /, 's-w-r - ceased');
+like(http_get('/tt.html?e=1'), qr/ 500 /, 's-i-e - ceased');
+like(http_get('/updating/t2.html'), qr/STALE/,
+    's-w-r - overriden with use_stale updating');
+
+# stale response not blocked by background update.
+# before 1.13.1, if stale response was not sent in one pass, its remaining
+# part was blocked and not sent until background update has been finished
+
+$t->write_file('t7.html', 'SEE-THAT' x 1024);
+
+my $r = read_all(get('/t7.html?lim=1', 'max-age=1', start => 1));
+like($r, qr/STALE.*^(SEE-THIS){1024}$/ms, 's-w-r - stale response not blocked');
+
+$t->write_file('t9.html', 'SEE-THAT' x 1024);
+$t->write_file('ssi.html', 'xxx <!--#include virtual="/t9.html?lim=1" --> xxx');
+
+$r = read_all(http_get('/ssi.html', start => 1));
+like($r, qr/^xxx (SEE-THIS){1024} xxx$/ms, 's-w-r - not blocked in subrequest');
+
+# "aio_write" is used to produce "open socket ... left in connection" alerts.
+
+$t->todo_alerts() if $t->read_file('nginx.conf') =~ /aio_write on/
+        and $t->read_file('nginx.conf') =~ /aio threads/ and $^O eq 'freebsd';
+
+# due to the missing content_handler inheritance in a cloned subrequest,
+# this used to access a static file in the update request
+
+like(http_get('/t2.html?if=1'), qr/STALE/, 'background update in if');
+like(http_get('/t2.html?if=1'), qr/HIT/, 'background update in if - updated');
+
+# ticket #1430, uri escaping in cloned subrequests
+
+$t->write_file('escape.html', 'SEE-THAT');
+$t->write_file('escape html', 'SEE-THAT');
+
+get('/escape.htm%6C', 'max-age=1');
+get('/escape html', 'max-age=1');
+
+like(http_get('/escape.htm%6C'), qr/HIT/, 'escaped after escaped');
+like(http_get('/escape.html'), qr/MISS/, 'unescaped after escaped');
+like(http_get('/escape html'), qr/HIT/, 'space after escaped space');
+like(http_get('/escape%20html'), qr/HIT/, 'escaped space after escaped space');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+X-Cache-Control: $extra
+
+EOF
+}
+
+# background update is known to postpone closing connection with client
+
+sub read_all {
+    my ($s) = @_;
+    my $r = '';
+    while (IO::Select->new($s)->can_read(1)) {
+        $s->sysread(my $buf, 8192) or last;
+        log_in($buf);
+        $r .= $buf;
+    }
+    return $r;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_valid.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_valid.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_valid.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_valid.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,133 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, the proxy_cache_valid directive
+# used with the caching parameters set in the response header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(12)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+
+            proxy_cache_valid  200 401  1m;
+
+            proxy_intercept_errors on;
+            error_page 404 401 = @fallback;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location @fallback {
+            return 403;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Cache-Control $http_x_cc always;
+            error_page 403 = /index-no-cache;
+        }
+
+        location /index-no-cache {
+            add_header Cache-Control no-cache always;
+            return 401;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+like(get('/t.html?1', 'X-CC: max-age=1'), qr/MISS/, 'max-age');
+like(get('/t.html?2', 'X-CC: max-age=1, s-maxage=10'), qr/MISS/, 's-maxage');
+like(http_get('/t.html?3'), qr/MISS/, 'proxy_cache_valid');
+
+$t->write_file('t.html', 'NOOP');
+
+like(http_get('/t.html?1'), qr/HIT/, 'max-age cached');
+like(http_get('/t.html?2'), qr/HIT/, 's-maxage cached');
+like(http_get('/t.html?3'), qr/HIT/, 'proxy_cache_valid cached');
+
+select undef, undef, undef, 2.1;
+
+# Cache-Control in the response header overrides proxy_cache_valid
+
+like(http_get('/t.html?1'), qr/EXPIRED/, 'max-age ceased');
+like(http_get('/t.html?2'), qr/HIT/, 's-maxage overrides max-age');
+
+# ticket #1382, cache item "error" field was not set from Cache-Control: max-age
+
+like(get('/t2.html', 'X-CC: max-age=1'), qr/403 Forbidden/, 'intercept error');
+
+$t->write_file('t2.html', 'NOOP');
+
+like(http_get('/t2.html'), qr/403 Forbidden/, 'error cached from max-age');
+
+# ticket #1382, cache item "error" field was set regardless of u->cacheable.
+
+like(http_get('/'), qr/403 Forbidden/, 'error no-cache');
+
+$t->write_file('index.html', '');
+
+like(http_get('/'), qr/200 OK/, 'error no-cache - not cacheable');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_variables.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_variables.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_variables.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,95 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache, proxy_cache directive with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache1  levels=1:2
+                       keys_zone=NAME1:1m;
+    proxy_cache_path   %%TESTDIR%%/cache2  levels=1:2
+                       keys_zone=NAME2:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            proxy_cache   $arg_c;
+
+            proxy_cache_valid   any      1m;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/?c=NAME1'), qr/MISS.*SEE-THIS/ms, 'proxy request');
+like(http_get('/?c=NAME1'), qr/HIT.*SEE-THIS/ms, 'proxy request cached');
+
+unlike(http_head('/?c=NAME1'), qr/SEE-THIS/, 'head request');
+
+$t->write_file('index.html', 'SEE-THAT');
+
+like(http_get('/?c=NAME2'), qr/MISS.*SEE-THAT/ms, 'proxy request 2');
+like(http_get('/?c=NAME2'), qr/HIT.*SEE-THAT/ms, 'proxy request 2 cached');
+
+# some invalid cases
+
+like(http_get('/?c=NAME'), qr/ 500 /, 'proxy_cache unknown');
+like(http_get('/'), qr/(?<!X-Cache).*SEE-THAT/ms, 'proxy_cache empty');
+
+$t->write_file('index.html', 'SEE-THOSE');
+
+like(http_get('/'), qr/SEE-THOSE/, 'proxy_cache empty - not cached');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cache_vary.t ../asynch_mode_nginx/test/nginx-tests/proxy_cache_vary.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cache_vary.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cache_vary.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,327 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy cache, the Vary header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache gzip rewrite/)
+    ->plan(49)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache keys_zone=one:1m inactive=5s;
+    proxy_cache_key    $uri;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Cache-Status $upstream_cache_status;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+        }
+
+        location /replace/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+        }
+
+        location /revalidate/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+            proxy_cache_revalidate on;
+        }
+
+        location /ignore/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   one;
+            proxy_ignore_headers Vary;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        gzip on;
+        gzip_min_length 0;
+        gzip_http_version 1.0;
+        gzip_vary on;
+
+        expires 2s;
+
+        location / {
+            if ($args = "novary") {
+                return 200 "the only variant\n";
+            }
+        }
+
+        location /asterisk {
+            gzip off;
+            add_header Vary "*";
+        }
+
+        location /complex {
+            gzip off;
+            add_header Vary ",, Accept-encoding , ,";
+        }
+
+        location /cold {
+            expires max;
+            add_header Vary $arg_vary;
+            add_header Xtra $arg_xtra;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('asterisk', 'SEE-THIS');
+$t->write_file('complex', 'SEE-THIS');
+$t->write_file('cold', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first request');
+like(get('/', 'gzip'), qr/HIT/ms, 'vary match cached');
+like(get('/', 'deflate'), qr/MISS/ms, 'vary mismatch');
+like(get('/', 'deflate'), qr/HIT/ms, 'vary mismatch cached');
+like(get('/', 'foo'), qr/MISS/ms, 'vary mismatch 2');
+like(get('/', 'foo'), qr/HIT/ms, 'vary mismatch 2 cached');
+like(get('/', 'gzip'), qr/HIT/ms, 'multiple representations cached');
+
+SKIP: {
+skip 'long tests', 6 unless $ENV{TEST_NGINX_UNSAFE};
+
+# make sure all variants are properly expire
+# and removed after inactive timeout
+
+sleep(3);
+
+like(get('/', 'gzip'), qr/EXPIRED/ms, 'first expired');
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'second variant expired');
+
+like(get('/', 'gzip'), qr/HIT/ms, 'first cached after expire');
+like(get('/', 'deflate'), qr/HIT/ms, 'second cached after expire');
+
+sleep(12);
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first inactive removed');
+like(get('/', 'deflate'), qr/MISS/ms, 'second variant removed');
+
+}
+
+SKIP: {
+skip 'long tests', 6 unless $ENV{TEST_NGINX_UNSAFE};
+
+# check if the variant which was loaded first will be properly
+# removed if it's not requested (but another variant is requested
+# at the same time)
+
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump1');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump2');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump3');
+sleep(3);
+like(get('/', 'deflate'), qr/EXPIRED/ms, 'bump4');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/', 'gzip'), qr/MISS/ms, 'first not bumped by second requests');
+
+}
+
+like(get('/', 'deflate'), qr/HIT/ms, 'second variant cached');
+
+}
+
+# if a response without Vary is returned to replace previously returned
+# responses with Vary, make sure it is then used in all cases
+
+like(get('/replace/', 'gzip'), qr/MISS/, 'replace first');
+like(get('/replace/', 'deflate'), qr/MISS/, 'replace second');
+
+sleep(3);
+
+like(get('/replace/?novary', 'deflate'), qr/EXPIRED/, 'replace novary');
+like(get('/replace/?zztest', 'gzip'), qr/HIT/, 'all replaced');
+
+# make sure revalidation of variants works fine
+
+like(get('/revalidate/', 'gzip'), qr/MISS/, 'revalidate first');
+like(get('/revalidate/', 'deflate'), qr/MISS/, 'revalidate second');
+
+sleep(3);
+
+like(get('/revalidate/', 'gzip'), qr/REVALIDATED/, 'revalidated first');
+like(get('/revalidate/', 'deflate'), qr/REVALIDATED/, 'revalidated second');
+like(get('/revalidate/', 'gzip'), qr/HIT/, 'revalidate first after');
+like(get('/revalidate/', 'deflate'), qr/HIT/, 'revalidate second after');
+
+# if the Vary header is ignored, cached version can be returned
+# regardless of request headers
+
+like(get('/ignore/', 'gzip'), qr/MISS/ms, 'another request');
+like(get('/ignore/', 'deflate'), qr/HIT/ms, 'vary ignored');
+
+# check parsing of Vary with multiple headers listed
+
+like(get('/complex', 'gzip'), qr/MISS/ms, 'vary complex first');
+like(get('/complex', 'deflate'), qr/MISS/ms, 'vary complex second');
+like(get('/complex', 'gzip'), qr/HIT/ms, 'vary complex first cached');
+like(get('/complex', 'deflate'), qr/HIT/ms, 'vary complex second cached');
+
+# From RFC 7231, "7.1.4. Vary",
+# http://tools.ietf.org/html/rfc7231#section-7.1.4:
+#
+#    A Vary field value of "*" signals that anything about the request
+#    might play a role in selecting the response representation, possibly
+#    including elements outside the message syntax (e.g., the client's
+#    network address).  A recipient will not be able to determine whether
+#    this response is appropriate for a later request without forwarding
+#    the request to the origin server.
+#
+# In theory, If-None-Match can be used to check if the representation
+# present in the cache is appropriate.  This seems to be only possible
+# with strong entity tags though, as representation with different
+# content condings may share the same weak entity tag.
+
+like(get('/asterisk', 'gzip'), qr/MISS/ms, 'vary asterisk first');
+like(get('/asterisk', 'gzip'), qr/MISS/ms, 'vary asterisk second');
+
+# From RFC 7234, "4.1. Calculating Secondary Keys with Vary",
+# http://tools.ietf.org/html/rfc7234#section-4.1:
+#
+#    The selecting header fields from two requests are defined to match if
+#    and only if those in the first request can be transformed to those in
+#    the second request by applying any of the following:
+#
+#    o  adding or removing whitespace, where allowed in the header field's
+#       syntax
+#
+#    o  combining multiple header fields with the same field name (see
+#       Section 3.2 of [RFC7230])
+#
+#    o  normalizing both header field values in a way that is known to
+#       have identical semantics, according to the header field's
+#       specification (e.g., reordering field values when order is not
+#       significant; case-normalization, where values are defined to be
+#       case-insensitive)
+#
+# Only whitespace normalization is currently implemented.
+
+like(get('/', 'foo, bar'), qr/MISS/ms, 'normalize first');
+like(get('/', 'foo,bar'), qr/HIT/ms, 'normalize whitespace');
+like(get('/', 'foo,,  ,bar , '), qr/HIT/ms, 'normalize empty');
+like(get('/', 'foobar'), qr/MISS/ms, 'normalize no whitespace mismatch');
+
+TODO: {
+local $TODO = 'not yet';
+
+like(get('/', 'bar,foo'), qr/HIT/ms, 'normalize order');
+
+}
+
+# keep c->body_start when Vary changes (ticket #2029)
+
+# before 1.19.3, this prevented updating c->body_start of a main key
+# triggering "cache file .. has too long header" critical errors
+
+get1('/cold?vary=z', 'z:1');
+like(get1('/cold?vary=x,y', 'x:1'), qr/MISS/, 'change first');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+like(get1('/cold?vary=x,y', 'x:1'), qr/HIT/, 'change first cached');
+
+}
+
+like(get1('/cold?vary=x,y&xtra=1', 'x:2'), qr/MISS/, 'change second');
+like(get1('/cold?vary=x,y&xtra=1', 'x:2'), qr/HIT/, 'change second cached');
+
+$t->stop();
+$t->run();
+
+# reset c->body_start when loading a secondary key variant
+
+# before 1.19.3, it was loaded using a variant stored with a main key
+# triggering "cache file .. has too long header" critical errors
+
+like(get1('/cold?vary=x,y', 'x:1'), qr/HIT/, 'cold first');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+like(get1('/cold?vary=x,y&xtra=1', 'x:2'), qr/HIT/, 'cold second');
+
+}
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.3');
+
+like(`grep -F '[crit]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no crit');
+
+}
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Accept-Encoding: $extra
+
+EOF
+}
+
+sub get1 {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_chunked_extra.t ../asynch_mode_nginx/test/nginx-tests/proxy_chunked_extra.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_chunked_extra.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_chunked_extra.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Test for http backend returning response with Transfer-Encoding: chunked,
+# followed by some extra data.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_buffer_size 128;
+        proxy_buffers 4 128;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 1s;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_chunked_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/200 OK(?!.*zzz)/s, 'chunked with extra data');
+
+}
+
+###############################################################################
+
+sub http_chunked_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        # return a large response start to allocate
+        # multiple buffers; stop at the buffer end
+
+        print $client ""
+            . "HTTP/1.1 200 OK" . CRLF
+            . "Connection: close" . CRLF
+            . "Transfer-Encoding: chunked" . CRLF . CRLF
+            . "80" . CRLF . ("x" x 126) . CRLF . CRLF
+            . "80" . CRLF . ("x" x 126) . CRLF . CRLF
+            . "80" . CRLF . ("x" x 126) . CRLF . CRLF
+            . "80" . CRLF . ("x" x 126) . CRLF . CRLF
+            . "20" . CRLF . ("x" x 30) . CRLF . CRLF;
+
+        select(undef, undef, undef, 0.3);
+
+        # fill three full buffers here, so they are
+        # processed in order, regardless of the
+        # p->upstream_done flag set
+
+        print $client ""
+            . "75" . CRLF . ("y" x 115) . CRLF . CRLF
+            . "0" . CRLF . CRLF
+            . "75" . CRLF . ("z" x 115) . CRLF . CRLF
+            . "0" . CRLF . CRLF
+            . "75" . CRLF . ("z" x 115) . CRLF . CRLF
+            . "0" . CRLF . CRLF;
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_chunked.t ../asynch_mode_nginx/test/nginx-tests/proxy_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_chunked.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,112 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for http backend returning response with Transfer-Encoding: chunked.
+
+# Since nginx uses HTTP/1.0 in requests to backend it's backend bug, but we
+# want to handle this gracefully.  And anyway chunked support will be required
+# for HTTP/1.1 backend connections.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 1s;
+        }
+        location /nobuffering {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 1s;
+            proxy_buffering off;
+        }
+        location /inmemory.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('inmemory.html',
+    '<!--#include virtual="/" set="one" --><!--#echo var="one" -->');
+
+$t->run_daemon(\&http_chunked_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/\x0d\x0aSEE-THIS$/s, 'chunked');
+like(http_get('/nobuffering'), qr/\x0d\x0aSEE-THIS$/s, 'chunked nobuffering');
+like(http_get('/inmemory.html'), qr/\x0d\x0aSEE-THIS$/s, 'chunked inmemory');
+
+###############################################################################
+
+sub http_chunked_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+Transfer-Encoding: chunked
+
+9
+SEE-THIS
+
+0
+
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cookie_flags.t ../asynch_mode_nginx/test/nginx-tests/proxy_cookie_flags.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cookie_flags.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cookie_flags.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the proxy_cookie_flags directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_cookie_flags a secure httponly samesite=none;
+            proxy_cookie_flags b secure httponly samesite=lax;
+            proxy_cookie_flags c secure httponly samesite=strict;
+            proxy_cookie_flags d nosecure nohttponly nosamesite;
+
+            proxy_cookie_flags $arg_complex secure;
+            proxy_cookie_flags ~BAR httponly;
+
+            location /off/ {
+                proxy_pass http://127.0.0.1:8081;
+                proxy_cookie_flags off;
+            }
+        }
+
+        location /var/ {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_cookie_flags $arg_v $arg_f1 $arg_f2 $arg_f3;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            set $c "$arg_v$arg_complex=path=domain=; Domain=example.org$arg_f";
+            add_header Set-Cookie $c;
+            return 200 OK;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no proxy_cookie_flags')->plan(14);
+
+###############################################################################
+
+is(http_get_set_cookie('/?v=a'),
+    'a=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=None',
+    'flags set all');
+is(http_get_set_cookie('/?v=b'),
+    'b=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=Lax',
+    'flags set lax');
+is(http_get_set_cookie('/?v=c'),
+    'c=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=Strict',
+    'flags set strict');
+
+# edit already set flags
+
+is(http_get_set_cookie('/?v=a&f=;Secure;HttpOnly;SameSite=Lax'),
+    'a=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=None',
+    'flags reset all');
+is(http_get_set_cookie('/?v=b&f=;Secure;HttpOnly;SameSite=None'),
+    'b=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=Lax',
+    'flags reset lax');
+is(http_get_set_cookie('/?v=c&f=;Secure;HttpOnly;SameSite=None'),
+    'c=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=Strict',
+    'flags reset strict');
+
+is(http_get_set_cookie('/?v=d&f=;secure;httponly;samesite=lax'),
+    'd=path=domain=; Domain=example.org',
+    'flags remove');
+
+is(http_get_set_cookie('/?v=nx&f=;samesite=none'),
+    'nx=path=domain=; Domain=example.org;samesite=none', 'flags no match');
+
+is(http_get_set_cookie('/?complex=v'),
+    'v=path=domain=; Domain=example.org; Secure', 'flags variable');
+is(http_get_set_cookie('/?v=foobarbaz'),
+    'foobarbaz=path=domain=; Domain=example.org; HttpOnly', 'flags regex');
+
+is(http_get_set_cookie('/off/?v=a'), 'a=path=domain=; Domain=example.org',
+    'flags off');
+
+# variables in flags
+
+is(http_get_set_cookie('/var/?v=v&f1=secure&f2=httponly&f3=samesite=none'),
+    'v=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=None',
+    'flags set');
+is(http_get_set_cookie('/var/?v=v&f=;Secure;HttpOnly;SameSite=Lax' .
+    '&f1=secure&f2=httponly&f3=samesite=none'),
+    'v=path=domain=; Domain=example.org; Secure; HttpOnly; SameSite=None',
+    'flags reset');
+is(http_get_set_cookie('/var/?v=v&f=;secure;httponly;samesite=lax' .
+    '&f1=nosecure&f2=nohttponly&f3=nosamesite'),
+    'v=path=domain=; Domain=example.org',
+    'flags remove');
+
+###############################################################################
+
+sub http_get_set_cookie {
+    my ($uri) = @_;
+    http_get($uri) =~ /^Set-Cookie:\s(.+?)\x0d?$/mi;
+    return $1;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_cookie.t ../asynch_mode_nginx/test/nginx-tests/proxy_cookie.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_cookie.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_cookie.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for the proxy_cookie_domain and proxy_cookie_path directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_cookie_domain www.example.org .example.com;
+            proxy_cookie_domain .$server_name.com en.$server_name.org;
+            proxy_cookie_domain ~^(.+)\.com$ $1.org;
+
+            proxy_cookie_path /path/ /new/;
+            proxy_cookie_path /$server_name/ /new/$server_name/;
+            proxy_cookie_path ~^/regex/(.+)$ /$1;
+            proxy_cookie_path ~*^/caseless/(.+)$ /$1;
+
+            location /off/ {
+                proxy_pass http://127.0.0.1:8081;
+
+                proxy_cookie_domain off;
+                proxy_cookie_path off;
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            if ($arg_domain) {
+                set $sc_domain "; Domain=$arg_domain";
+            }
+            if ($arg_path) {
+                set $sc_path "; Path=$arg_path";
+            }
+            add_header Set-Cookie v=path=domain=$sc_domain$sc_path;
+            return 200 OK;
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(9);
+
+###############################################################################
+
+my $port = port(8080);
+
+is(http_get_set_cookie('/?domain=www.Example.org'),
+    'v=path=domain=; Domain=example.com', 'domain rewrite');
+is(http_get_set_cookie('/?domain=.LocalHost.com'),
+    'v=path=domain=; Domain=.en.localhost.org',
+    'domain rewrite with vars');
+is(http_get_set_cookie('/?domain=www.example.COM'),
+    'v=path=domain=; Domain=www.example.org', 'domain regex rewrite');
+
+is(http_get_set_cookie('/?path=/path/test.html'),
+    'v=path=domain=; Path=/new/test.html', 'path rewrite');
+is(http_get_set_cookie('/?path=/localhost/test.html'),
+    'v=path=domain=; Path=/new/localhost/test.html',
+    'path rewrite with vars');
+is(http_get_set_cookie('/?path=/regex/test.html'),
+    'v=path=domain=; Path=/test.html', 'path regex rewrite');
+is(http_get_set_cookie('/?path=/CASEless/test.html'),
+    'v=path=domain=; Path=/test.html', 'path caseless regex rewrite');
+
+is(http_get_set_cookie('/?domain=www.example.org&path=/path/test.html'),
+    'v=path=domain=; Domain=example.com; Path=/new/test.html',
+    'domain and path rewrite');
+is(http_get_set_cookie('/off/?domain=www.example.org&path=/path/test.html'),
+    'v=path=domain=; Domain=www.example.org; Path=/path/test.html',
+    'domain and path rewrite off');
+
+###############################################################################
+
+sub http_get_set_cookie {
+    my ($uri) = @_;
+    http_get("http://127.0.0.1:$port$uri") =~ /^Set-Cookie:\s(.+?)\x0d?$/mi;
+    return $1;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_extra_data.t ../asynch_mode_nginx/test/nginx-tests/proxy_extra_data.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_extra_data.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_extra_data.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,238 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for http backend with extra data.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+    ->has(qw/http proxy cache rewrite addition/)->plan(22)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path cache keys_zone=one:1m;
+    proxy_cache_key $request_uri;
+    proxy_cache_valid any 1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            add_after_body /after;
+        }
+
+        location /unbuf/ {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_buffering off;
+            add_after_body /after;
+        }
+
+        location /head/ {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_cache one;
+            add_after_body /after;
+        }
+
+        location /after {
+            return 200 ":after\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/, 'response with extra data');
+
+}
+
+like(http_get('/short'), qr/SEE-THIS(?!.*:after)/s, 'too short response');
+like(http_get('/empty'), qr/200 OK(?!.*:after)/s, 'empty too short response');
+
+like(http_head('/'), qr/200 OK(?!.*SEE-THIS)/s, 'no data in HEAD');
+like(http_head('/short'), qr/200 OK(?!.*SEE-THIS)/s, 'too short to HEAD');
+like(http_head('/empty'), qr/200 OK/, 'empty response to HEAD');
+
+# unbuffered responses
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/unbuf/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/,
+    'unbuffered with extra data');
+
+}
+
+like(http_get('/unbuf/short'), qr/SEE-THIS(?!.*:after)/s,
+    'unbuffered too short response');
+like(http_get('/unbuf/empty'), qr/200 OK(?!.*:after)/s,
+    'unbuffered empty too short response');
+
+like(http_head('/unbuf/'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered no data in HEAD');
+like(http_head('/unbuf/short'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered too short response to HEAD');
+like(http_head('/unbuf/empty'), qr/200 OK/,
+    'unbuffered empty response to HEAD');
+
+# caching of responsses to HEAD requests
+
+like(http_head('/head/empty'), qr/200 OK(?!.*SEE-THIS)/s, 'head no body');
+like(http_head('/head/matching'), qr/200 OK(?!.*SEE-THIS)/s, 'head matching');
+like(http_head('/head/extra'), qr/200 OK(?!.*SEE-THIS)/s, 'head extra');
+like(http_head('/head/short'), qr/200 OK(?!.*SEE-THIS)/s, 'head too short');
+
+like(http_get('/head/empty'), qr/SEE-THIS/, 'head no body cached');
+like(http_get('/head/matching'), qr/SEE-THIS/, 'head matching cached');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/head/extra'), qr/SEE-THIS(?!-BUT-NOT-THIS)/s,
+    'head extra cached');
+
+}
+
+like(http_get('/head/short'), qr/SEE-THIS(?!.*:after)/s,
+    'head too short cached');
+
+
+# "zero size buf" alerts (ticket #2117)
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/zero'), qr/200 OK(?!.*NOT-THIS)/s, 'zero size');
+
+}
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.7');
+
+like(http_get('/unbuf/zero'), qr/200 OK(?!.*NOT-THIS)/s,
+    'unbuffered zero size');
+
+}
+
+$t->todo_alerts() if $t->has_version('1.19.1') and !$t->has_version('1.19.7');
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my ($uri, $head);
+
+    while (my $c = $server->accept()) {
+        $c->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$c>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+        $uri =~ s!^/unbuf!!;
+
+        $head = ($headers =~ /^HEAD/);
+
+        if ($uri eq '/') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS-BUT-NOT-THIS\n");
+
+        } elsif ($uri eq '/zero') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 0\n\n");
+            $c->print("NOT-THIS\n");
+
+        } elsif ($uri eq '/short') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+            $c->print("SEE-THIS-TOO-SHORT-RESPONSE\n");
+
+        } elsif ($uri eq '/empty') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+
+        } elsif ($uri eq '/head/empty') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS") unless $head;
+
+        } elsif ($uri eq '/head/matching') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS");
+
+        } elsif ($uri eq '/head/extra') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS-BUT-NOT-THIS\n");
+
+        } elsif ($uri eq '/head/short') {
+            $c->print("HTTP/1.1 200 OK\n");
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+            $c->print("SEE-THIS\n");
+        }
+
+        close $c;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_force_ranges.t ../asynch_mode_nginx/test/nginx-tests/proxy_force_ranges.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_force_ranges.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_force_ranges.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy cache and range filter.
+# proxy_force_ranges enables partial response regardless Accept-Ranges.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+        }
+
+        location /proxy/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_force_ranges on;
+            add_trailer X-Trailer "";
+        }
+
+        location /cache/ {
+            proxy_pass    http://127.0.0.1:8081/;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+
+            proxy_force_ranges on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            max_ranges 0;
+            add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+            add_header ETag '"59a5401c-8"';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# serving range requests requires Accept-Ranges by default
+
+unlike(http_get_range('/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+    'range without Accept-Ranges');
+
+like(http_get_range('/cache/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+    'uncached range');
+like(http_get_range('/cache/t.html', 'Range: bytes=4-'), qr/^THIS/m,
+    'cached range');
+like(http_get_range('/cache/t.html', 'Range: bytes=0-2,4-'), qr/^SEE.*^THIS/ms,
+    'cached multipart range');
+
+# If-Range HTTP-date request
+
+like(http_get_range('/proxy/t.html',
+    "Range: bytes=4-\nIf-Range: Mon, 28 Sep 1970 06:00:00 GMT"),
+    qr/^THIS/m, 'if-range last-modified proxy');
+
+# If-Range entity-tag request
+
+like(http_get_range('/proxy/t.html',
+    "Range: bytes=4-\nIf-Range: \"59a5401c-8\""),
+    qr/^THIS/m, 'if-range etag proxy');
+
+# range sent using chunked transfer encoding
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.0');
+
+like(http_get_range('/proxy/t.html', 'Range: bytes=-2'),
+    qr/2${CRLF}IS${CRLF}0$CRLF$CRLF$/, 'no dublicate final chunk');
+
+}
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_if.t ../asynch_mode_nginx/test/nginx-tests/proxy_if.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_if.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_if.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,244 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy module related to use with the "if" directive.
+# See http://wiki.nginx.org/IfIsEvil for more details.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite http_ssl/)
+    ->has_daemon('openssl')->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->todo_alerts();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081/;
+        }
+
+        # request was sent to backend without uri changed
+        # to '/' due to if
+
+        location /proxy-pass-uri {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            if ($arg_if) {
+                # nothing
+            }
+
+            location /proxy-pass-uri/inner {
+                # no proxy_pass here, static
+
+                if ($arg_if) {
+                    # nothing
+                }
+            }
+        }
+
+        # same as the above, but there is a special handling
+        # in configuration merge; it used to do wrong things with
+        # nested locations though
+
+        location /proxy-pass-uri-lmt {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            limit_except POST {
+                # nothing
+            }
+
+            location /proxy-pass-uri-lmt/inner {
+                # no proxy_pass here, static
+
+                limit_except POST {
+                    # nothing
+                }
+            }
+        }
+
+        location /proxy-pass-uri-lmt-different {
+            proxy_pass http://127.0.0.1:8081/replacement;
+
+            limit_except POST {
+                proxy_pass http://127.0.0.1:8081;
+            }
+        }
+
+        # segmentation fault in old versions,
+        # fixed to return 500 Internal Error in nginx 1.3.10
+
+        location /proxy-inside-if-crash {
+
+            set $true 1;
+
+            if ($true) {
+                # proxy_pass inside if
+                proxy_pass http://127.0.0.1:8081;
+            }
+
+            if ($true) {
+                # no handler here
+            }
+        }
+
+        # normal proxy_pass and proxy_pass with variables
+        # use distinct field, and inheritance should be mutually
+        # exclusive
+
+        location /variables {
+            proxy_pass http://127.0.0.1:8081/outer/$host;
+
+            if ($arg_if) {
+                proxy_pass http://127.0.0.1:8081;
+            }
+
+            location /variables/inner {
+                proxy_pass http://127.0.0.1:8081;
+            }
+        }
+
+        # ssl context shouldn't be inherited into nested
+        # locations with different proxy_pass, but should
+        # be correctly inherited into if's
+
+        location /ssl {
+            proxy_pass https://127.0.0.1:8082/outer;
+            %%PROXY_ASYNCH_ENABLE%%
+
+            if ($arg_if) {
+                # inherited from outer
+            }
+
+            location /ssl/inner {
+                proxy_pass http://127.0.0.1:8081;
+                %%PROXY_ASYNCH_DISABLE%%
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+
+        return 200 "uri:$uri\n";
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!uri:/$!, 'proxy request');
+
+like(http_get('/proxy-pass-uri'), qr!uri:/replacement$!,
+    'proxy_pass uri changed');
+
+# due to missing information about an original location where
+# proxy_pass was specified, this used to pass request with
+# original unmodified uri
+
+like(http_get('/proxy-pass-uri?if=1'), qr!uri:/replacement$!,
+    'proxy_pass uri changed in if');
+
+like(http_get('/proxy-pass-uri/inner'), qr!404 Not Found!,
+    'proxy_pass uri changed inner');
+like(http_get('/proxy-pass-uri/inner?if=1'), qr!404 Not Found!,
+    'proxy_pass uri changed inner in if');
+
+# limit_except
+
+like(http_get('/proxy-pass-uri-lmt'), qr!uri:/replacement$!,
+    'proxy_pass uri and limit_except');
+
+# special handling of limit_except resulted in wrong handling
+# of requests in nested locations
+
+like(http_get('/proxy-pass-uri-lmt/inner'), qr!404 Not Found!,
+    'proxy_pass uri and limit_except, inner');
+
+like(http_get('/proxy-pass-uri-lmt-different'),
+    qr!uri:/proxy-pass-uri-lmt-different!,
+    'proxy_pass and limit_except with different proxy_pass');
+
+# segmentation fault in old versions,
+# fixed to return 500 Internal Error in nginx 1.3.10
+
+like(http_get('/proxy-inside-if-crash'), qr!500 Internal Server Error!,
+    'proxy_pass inside if');
+
+# normal proxy_pass and proxy_pass with variables
+# use distinct field, and inheritance should be mutually
+# exclusive, see ticket #645
+
+like(http_get('/variables'), qr!uri:/outer!,
+    'proxy_pass variables');
+like(http_get('/variables?if=1'), qr!uri:/variables!,
+    'proxy_pass variables if');
+like(http_get('/variables/inner'), qr!uri:/variables/inner!,
+    'proxy_pass variables nested');
+
+# ssl context shouldn't be inherited into nested
+# locations with different proxy_pass, but should
+# be correctly inherited into if's
+
+like(http_get('/ssl'), qr!uri:/outer!,
+    'proxy_pass ssl');
+like(http_get('/ssl?if=1'), qr!uri:/outer!,
+    'proxy_pass ssl inside if');
+like(http_get('/ssl/inner'), qr!uri:/ssl/inner!,
+    'proxy_pass nossl inside ssl');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_implicit.t ../asynch_mode_nginx/test/nginx-tests/proxy_implicit.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_implicit.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_implicit.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for an upstream implicitly defined by proxy_pass.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ SOCK_STREAM IPPROTO_TCP AF_INET6 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { die if $Socket::VERSION < 1.96; };
+plan(skip_all => 'Socket too old for getaddrinfo') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://localhost:%%PORT_8080%%/stub;
+            proxy_next_upstream http_404;
+            add_header X-Addr $upstream_addr always;
+        }
+
+        location /var {
+            proxy_pass http://$arg_b/stub;
+            proxy_next_upstream http_404;
+            add_header X-Addr $upstream_addr always;
+        }
+
+        location /stub { }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(3);
+
+###############################################################################
+
+my $p = port(8080);
+my @addrs = resolve('localhost');
+my $exp = qr/$addrs[0]:$p/ if @addrs == 1;
+my $v1 = "$addrs[0]:$p", my $v2 = "$addrs[1]:$p" if @addrs == 2;
+$exp = qr/\Q$v1, $v2\E|\Q$v2, $v1\E/ if @addrs == 2;
+die "too many addresses in localhost" if @addrs > 2;
+
+like(http_get('/'), qr/Not Found/, 'implicit upstream');
+like(http_get('/'), $exp, 'implicit upstream all tried');
+like(http_get("/var?b=localhost:$p"), qr/Not Found/,
+    'implicit upstream by variable');
+
+###############################################################################
+
+sub resolve {
+    my ($name) = @_;
+
+    my $ai_addrconfig = eval { Socket::AI_ADDRCONFIG() };
+    my ($err, @res) = Socket::getaddrinfo($name, "",
+        { socktype => SOCK_STREAM, protocol => IPPROTO_TCP,
+            flags => $ai_addrconfig });
+    die "Cannot getaddrinfo - $err" if $err;
+
+    my @addrs;
+    foreach my $ai (@res) {
+        my ($err, $addr) = Socket::getnameinfo($ai->{addr},
+            Socket::NI_NUMERICHOST(), Socket::NIx_NOSERV());
+        die "Cannot getnameinfo - $err" if $err;
+        $addr = '[' . $addr . ']' if $ai->{family} == AF_INET6;
+        push @addrs, $addr;
+    }
+    return @addrs;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_keepalive.t ../asynch_mode_nginx/test/nginx-tests/proxy_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_keepalive.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,357 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for proxy with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Socket::INET;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive ssi rewrite/)
+    ->plan(49)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+
+        location / {
+            proxy_pass http://backend;
+        }
+
+        location /unbuffered/ {
+            proxy_pass http://backend;
+            proxy_buffering off;
+        }
+
+        location /inmemory/ {
+            ssi on;
+            rewrite ^ /ssi.html break;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+    '<!--#include virtual="/include$request_uri" set="x" -->' .
+    'set: <!--#echo var="x" -->');
+
+$t->run_daemon(\&http_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start test backend";
+
+###############################################################################
+
+# There are 3 mostly independent modes of upstream operation:
+#
+# 1. Buffered, i.e. normal mode with "proxy_buffering on;"
+# 2. Unbuffered, i.e. "proxy_buffering off;".
+# 3. In memory, i.e. ssi <!--#include ... set -->
+#
+# These all should be tested.
+
+my ($r, $n);
+
+# buffered
+
+like($r = http_get('/buffered/length1'), qr/SEE-THIS/, 'buffered');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/length2'), qr/X-Connection: $n.*SEE/ms, 'buffered 2');
+
+like($r = http_get('/buffered/chunked1'), qr/SEE-THIS/, 'buffered chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/chunked2'), qr/X-Connection: $n/,
+    'buffered chunked 2');
+
+like($r = http_get('/buffered/complex1'), qr/(0123456789){100}/,
+    'buffered complex chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/complex2'), qr/X-Connection: $n/,
+    'buffered complex chunked 2');
+
+like($r = http_get('/buffered/chunk01'), qr/200 OK/, 'buffered 0 chunk');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/chunk02'), qr/X-Connection: $n/, 'buffered 0 chunk 2');
+
+like($r = http_head('/buffered/length/head1'), qr/(?!SEE-THIS)/,
+    'buffered head');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_head('/buffered/length/head2'), qr/X-Connection: $n/,
+    'buffered head 2');
+
+like($r = http_get('/buffered/empty1'), qr/200 OK/, 'buffered empty');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/empty2'), qr/X-Connection: $n/, 'buffered empty 2');
+
+like($r = http_get('/buffered/304nolen1'), qr/304 Not/, 'buffered 304');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/304nolen2'), qr/X-Connection: $n/, 'buffered 304 2');
+
+like($r = http_get('/buffered/304len1'), qr/304 Not/,
+    'buffered 304 with length');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/buffered/304len2'), qr/X-Connection: $n/,
+    'buffered 304 with length 2');
+
+# unbuffered
+
+like($r = http_get('/unbuffered/length1'), qr/SEE-THIS/, 'unbuffered');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/length2'), qr/X-Connection: $n/, 'unbuffered 2');
+
+like($r = http_get('/unbuffered/chunked1'), qr/SEE-THIS/, 'unbuffered chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/chunked2'), qr/X-Connection: $n/,
+    'unbuffered chunked 2');
+
+like($r = http_get('/unbuffered/complex1'), qr/(0123456789){100}/,
+    'unbuffered complex chunked');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/complex2'), qr/X-Connection: $n/,
+    'unbuffered complex chunked 2');
+
+like($r = http_get('/unbuffered/chunk01'), qr/200 OK/, 'unbuffered 0 chunk');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/chunk02'), qr/X-Connection: $n/,
+    'unbuffered 0 chunk 2');
+
+like($r = http_get('/unbuffered/empty1'), qr/200 OK/, 'unbuffered empty');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/empty2'), qr/X-Connection: $n/,
+    'unbuffered empty 2');
+
+like($r = http_head('/unbuffered/length/head1'), qr/(?!SEE-THIS)/,
+    'unbuffered head');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_head('/unbuffered/length/head2'), qr/X-Connection: $n/,
+    'unbuffered head 2');
+
+like($r = http_get('/unbuffered/304nolen1'), qr/304 Not/, 'unbuffered 304');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/304nolen2'), qr/X-Connection: $n/,
+    'unbuffered 304 2');
+
+like($r = http_get('/unbuffered/304len1'), qr/304 Not/,
+    'unbuffered 304 with length');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/unbuffered/304len2'), qr/X-Connection: $n/,
+    'unbuffered 304 with length 2');
+
+# in memory
+
+like($r = http_get('/inmemory/length1'), qr/SEE-THIS/, 'inmemory');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/length2'), qr/SEE-THIS$n/, 'inmemory 2');
+
+like($r = http_get('/inmemory/empty1'), qr/200 OK/, 'inmemory empty');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/empty2'), qr/200 OK/, 'inmemory empty 2');
+
+like($r = http_get('/inmemory/chunked1'), qr/SEE-THIS/, 'inmemory chunked');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/chunked2'), qr/SEE-THIS$n/, 'inmemory chunked 2');
+
+like($r = http_get('/inmemory/complex1'), qr/(0123456789){100}/,
+    'inmemory complex chunked');
+$r =~ m/SEE-THIS(\d+)/; $n = $1;
+like(http_get('/inmemory/complex2'), qr/SEE-THIS$n/,
+    'inmemory complex chunked 2');
+
+like(http_get('/inmemory/chunk01'), qr/set: $/, 'inmemory 0 chunk');
+like(http_get('/inmemory/chunk02'), qr/set: $/, 'inmemory 0 chunk 2');
+
+# closed connection tests
+
+like(http_get('/buffered/closed1'), qr/200 OK/, 'buffered closed 1');
+like(http_get('/buffered/closed2'), qr/200 OK/, 'buffered closed 2');
+like(http_get('/unbuffered/closed1'), qr/200 OK/, 'unbuffered closed 1');
+like(http_get('/unbuffered/closed2'), qr/200 OK/, 'unbuffered closed 2');
+like(http_get('/inmemory/closed1'), qr/200 OK/, 'inmemory closed 1');
+like(http_get('/inmemory/closed2'), qr/200 OK/, 'inmemory closed 2');
+
+# check for errors, shouldn't be any
+
+like(`grep -F '[error]' ${\($t->testdir())}/error.log`, qr/^$/s, 'no errors');
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $ccount = 0;
+    my $rcount = 0;
+
+    # dumb server which is able to keep connections alive
+
+    while (my $client = $server->accept()) {
+        Test::Nginx::log_core('||',
+            "connection from " . $client->peerhost());
+        $client->autoflush(1);
+        $ccount++;
+
+        while (1) {
+            my $headers = '';
+            my $uri = '';
+
+            while (<$client>) {
+                Test::Nginx::log_core('||', $_);
+                $headers .= $_;
+                last if (/^\x0d?\x0a?$/);
+            }
+
+            last if $headers eq '';
+            $rcount++;
+
+            $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+            if ($uri =~ m/length/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Content-Length: 26" . CRLF . CRLF;
+                print $client "TEST-OK-IF-YOU-SEE-THIS" .
+                    sprintf("%03d", $ccount)
+                    unless $headers =~ /^HEAD/i;
+
+            } elsif ($uri =~ m/empty/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Content-Length: 0" . CRLF . CRLF;
+
+            } elsif ($uri =~ m/304nolen/) {
+                print $client
+                    "HTTP/1.1 304 Not Modified" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF . CRLF;
+
+            } elsif ($uri =~ m/304len/) {
+                print $client
+                    "HTTP/1.1 304 Not Modified" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Content-Length: 100" . CRLF . CRLF;
+
+            } elsif ($uri =~ m/chunked/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Transfer-Encoding: chunked" . CRLF .
+                    CRLF;
+                print $client
+                    "1a" . CRLF .
+                    "TEST-OK-IF-YOU-SEE-THIS" .
+                    sprintf("%03d", $ccount) . CRLF .
+                    "0" . CRLF . CRLF
+                    unless $headers =~ /^HEAD/i;
+
+            } elsif ($uri =~ m/complex/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Transfer-Encoding: chunked" . CRLF .
+                    CRLF;
+
+                if ($headers !~ /^HEAD/i) {
+                    for my $n (1..100) {
+                        print $client
+                            "a" . CRLF .
+                            "0123456789" . CRLF;
+                        select undef, undef, undef, 0.01
+                            if $n % 50 == 0;
+                    }
+                    print $client
+                        "1a" . CRLF .
+                        "TEST-OK-IF-YOU-SEE-THIS" .
+                        sprintf("%03d", $ccount) .
+                        CRLF .
+                        "0" . CRLF;
+                    select undef, undef, undef, 0.05;
+                    print $client CRLF;
+                }
+
+            } elsif ($uri =~ m/chunk0/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Transfer-Encoding: chunked" . CRLF .
+                    CRLF;
+                print $client
+                    "0" . CRLF . CRLF
+                    unless $headers =~ /^HEAD/i;
+
+            } elsif ($uri =~ m/closed/) {
+                print $client
+                    "HTTP/1.1 200 OK" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Connection: close" . CRLF .
+                    "Content-Length: 12" . CRLF . CRLF .
+                    "0123456789" . CRLF;
+                last;
+
+            } else {
+                print $client
+                    "HTTP/1.1 404 Not Found" . CRLF .
+                    "X-Request: $rcount" . CRLF .
+                    "X-Connection: $ccount" . CRLF .
+                    "Connection: close" . CRLF . CRLF .
+                    "Oops, '$uri' not found" . CRLF;
+                last;
+            }
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_limit_rate.t ../asynch_mode_nginx/test/nginx-tests/proxy_limit_rate.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_limit_rate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_limit_rate.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the proxy_limit_rate directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8080;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/data;
+            proxy_buffer_size 4k;
+            proxy_limit_rate 20000;
+            add_header X-Msec $msec;
+        }
+
+        location /keepalive {
+            proxy_http_version 1.1;
+            proxy_set_header Connection "";
+            proxy_pass http://u/data;
+            proxy_buffer_size 4k;
+            proxy_limit_rate 20000;
+            add_header X-Msec $msec;
+        }
+
+        location /data {
+        }
+    }
+}
+
+EOF
+
+$t->write_file('data', 'X' x 40000);
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/');
+
+my ($t1) = $r =~ /X-Msec: (\d+)/;
+my $diff = time() - $t1;
+
+# four chunks are split with three 1s delays
+
+cmp_ok($diff, '>=', 1, 'proxy_limit_rate');
+like($r, qr/^(XXXXXXXXXX){4000}\x0d?\x0a?$/m, 'response body');
+
+# in case keepalive connection was saved with the delayed flag,
+# the read timer used to be a delay timer in the next request
+
+like(http_get('/keepalive'), qr/200 OK/, 'keepalive');
+like(http_get('/keepalive'), qr/200 OK/, 'keepalive 2');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_merge_headers.t ../asynch_mode_nginx/test/nginx-tests/proxy_merge_headers.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_merge_headers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_merge_headers.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,115 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for proxy_set_header inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache rewrite/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    proxy_set_header X-Blah "blah";
+    proxy_hide_header X-Hidden;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_cache  NAME;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+
+            location /nested/ {
+                proxy_pass   http://127.0.0.1:8081;
+                proxy_pass_header X-Pad;
+            }
+        }
+
+        location /no/ {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   off;
+        }
+
+        location /setbody/ {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_set_body "body";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Hidden "hidden";
+            add_header X-Pad "passed";
+            return 200 "ims=$http_if_modified_since;blah=$http_x_blah;";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;blah=blah;/,
+    'if-modified-since cleared with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;blah=blah;/,
+    'if-modified-since preserved without cache');
+
+like(http_get_ims('/setbody/'), qr/blah=blah;/,
+    'proxy_set_header inherited with proxy_set_body');
+
+unlike(http_get('/'), qr/X-Pad/, 'proxy_pass_header default');
+like(http_get('/nested/'), qr/X-Pad/, 'proxy_pass_header nested');
+unlike(http_get('/'), qr/X-Hidden/, 'proxy_hide_header inherited');
+unlike(http_get('/nested/'), qr/X-Hidden/, 'proxy_hide_header nested');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_method.t ../asynch_mode_nginx/test/nginx-tests/proxy_method.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_method.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_method.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,87 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Lazurkin
+
+# Tests for proxy_method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /preserve {
+            proxy_pass http://127.0.0.1:8080/get-method;
+        }
+
+        location /const {
+            proxy_pass http://127.0.0.1:8080/get-method;
+            proxy_method POST;
+        }
+
+        location /var {
+            proxy_pass http://127.0.0.1:8080/get-method;
+            proxy_method $arg_method;
+        }
+
+        location /parent {
+            proxy_method POST;
+            location /parent/child {
+                proxy_pass http://127.0.0.1:8080/get-method;
+            }
+        }
+
+        location /get-method {
+            return 200 "request_method=$request_method";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/preserve'), qr/request_method=GET/,
+    'proxy_method from request');
+
+like(http_get('/const'), qr/request_method=POST/,
+    'proxy_method from constant');
+
+like(http_get('/var?method=POST'), qr/request_method=POST/,
+    'proxy_method from variable');
+
+like(http_get('/parent/child'), qr/request_method=POST/,
+    'proxy_method from parent');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_next_upstream.t ../asynch_mode_nginx/test/nginx-tests/proxy_next_upstream.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_next_upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_next_upstream.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,157 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy module, proxy_next_upstream directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 down;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+            proxy_next_upstream http_500 http_404;
+        }
+
+        location /all/ {
+            proxy_pass http://u2;
+            proxy_next_upstream http_500 http_404;
+            error_page 404 /all/404;
+            proxy_intercept_errors on;
+        }
+
+        location /all/404 {
+            return 200 "$upstream_addr\n";
+        }
+
+        location /down {
+            proxy_pass http://u3;
+            proxy_next_upstream http_404;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 404;
+        }
+        location /ok {
+            return 200 "AND-THIS\n";
+        }
+        location /500 {
+            return 500;
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            return 200 "TEST-OK-IF-YOU-SEE-THIS\n";
+        }
+
+        location /all/ {
+            return 404;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+# check if both request fallback to a backend
+# which returns valid response
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/'), qr/SEE-THIS/, 'second request');
+
+# make sure backend isn't switched off after
+# proxy_next_upstream http_404
+
+like(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'not down');
+
+# next upstream on http_500
+
+like(http_get('/500'), qr/SEE-THIS/, 'request 500');
+like(http_get('/500'), qr/SEE-THIS/, 'request 500 second');
+
+# make sure backend switched off with http_500
+
+unlike(http_get('/ok') . http_get('/ok'), qr/AND-THIS/, 'down after 500');
+
+# make sure all backends are tried once
+
+like(http_get('/all/rr'),
+    qr/^127.0.0.1:($p1, 127.0.0.1:$p2|$p2, 127.0.0.1:$p1)$/mi,
+    'all tried once');
+
+# make sure backend marked as down doesn't count towards "no live upstreams"
+# after all backends are tried with http_404
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.6');
+
+like(http_get('/down/'), qr/Not Found/, 'all tried with down');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_next_upstream_tries.t ../asynch_mode_nginx/test/nginx-tests/proxy_next_upstream_tries.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_next_upstream_tries.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_next_upstream_tries.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,259 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module, proxy_next_upstream_tries
+# and proxy_next_upstream_timeout directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081 backup;
+        server 127.0.0.1:8081 backup;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_next_upstream http_404;
+        proxy_intercept_errors on;
+        error_page 404 /404;
+
+        location /tries {
+            proxy_pass http://u;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/backup {
+            proxy_pass http://u2;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/resolver {
+            resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+            proxy_pass http://$host:%%PORT_8081%%;
+            proxy_next_upstream_tries 2;
+        }
+
+        location /tries/zero {
+            proxy_pass http://u;
+            proxy_next_upstream_tries 0;
+        }
+
+        location /timeout {
+            proxy_pass http://u/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/backup {
+            proxy_pass http://u2/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/resolver {
+            resolver 127.0.0.1:%%PORT_8982_UDP%%;
+
+            proxy_pass http://$host:%%PORT_8081%%/w2;
+            proxy_next_upstream_timeout 3800ms;
+        }
+
+        location /timeout/zero {
+            proxy_pass http://u/w;
+            proxy_next_upstream_timeout 0;
+        }
+
+        location /404 {
+            return 200 x${upstream_status}x;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&dns_daemon, port(8982), $t);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+like(http_get('/tries'), qr/x404, 404x/, 'tries');
+like(http_get('/tries/backup'), qr/x404, 404x/, 'tries backup');
+like(http_get('/tries/resolver'), qr/x404, 404x/, 'tries resolved');
+like(http_get('/tries/zero'), qr/x404, 404, 404x/, 'tries zero');
+
+# two tries fit into 1.9s
+
+SKIP: {
+skip 'long tests', 4 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/timeout'), qr/x404, 404x/, 'timeout');
+like(http_get('/timeout/backup'), qr/x404, 404x/, 'timeout backup');
+like(http_get('/timeout/resolver'), qr/x404, 404x/, 'timeout resolved');
+like(http_get('/timeout/zero'), qr/x404, 404, 404x/, 'timeout zero');
+
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        next if $headers eq '';
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/w') {
+            Test::Nginx::log_core('||', "$port: sleep(1)");
+            select undef, undef, undef, 1;
+        }
+
+        if ($uri eq '/w2') {
+            Test::Nginx::log_core('||', "$port: sleep(2)");
+            select undef, undef, undef, 2;
+        }
+
+        Test::Nginx::log_core('||', "$port: response, 404");
+        print $client <<EOF;
+HTTP/1.1 404 Not Found
+Connection: close
+
+EOF
+
+    } continue {
+        close $client;
+    }
+}
+
+sub reply_handler {
+    my ($recv_data) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant A        => 1;
+    use constant IN        => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    @rdata = map { rd_addr($ttl, '127.0.0.1') } (1 .. 3) if $type == A;
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Proto => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_noclose.t ../asynch_mode_nginx/test/nginx-tests/proxy_noclose.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_noclose.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_noclose.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,152 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for http backend not closing connection properly after sending full
+# reply.  This is in fact backend bug, but it seems common, and anyway
+# correct handling is required to support persistent connections.
+
+# There are actually 2 nginx problems here:
+#
+# 1. It doesn't send reply in-time even if got Content-Length and all the data.
+#
+# 2. If upstream times out some data may be left in input buffer and won't be
+#    sent to downstream.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 2s;
+        }
+
+        location /uselen {
+            proxy_pass http://127.0.0.1:8081;
+
+            # test will wait only 2s for reply, we it will fail if
+            # Content-Length not used as a hint
+
+            proxy_read_timeout 10s;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_noclose_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'request to bad backend');
+like(http_get('/multi'), qr/AND-THIS/, 'bad backend - multiple packets');
+like(http_get('/uselen'), qr/SEE-THIS/, 'content-length actually used');
+
+TODO: {
+local $TODO = 'not yet';
+local $SIG{__WARN__} = sub {};
+
+like(http_get('/nolen'), qr/SEE-THIS/, 'bad backend - no content length');
+
+}
+
+###############################################################################
+
+sub http_noclose_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $multi = 0;
+        my $nolen = 0;
+
+        while (<$client>) {
+            $multi = 1 if /multi/;
+            $nolen = 1 if /nolen/;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        if ($nolen) {
+
+            print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+        } elsif ($multi) {
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Content-Length: 32
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+            select undef, undef, undef, 0.1;
+            print $client 'AND-THIS';
+
+        } else {
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Content-Length: 24
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+        }
+
+        my $select = IO::Select->new($client);
+        $select->can_read(10);
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_non_idempotent.t ../asynch_mode_nginx/test/nginx-tests/proxy_non_idempotent.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_non_idempotent.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_non_idempotent.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,137 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy_next_upstream non_idempotent.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_keepalive/)
+    ->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=0;
+        server 127.0.0.1:8081 max_fails=0;
+    }
+
+    upstream uk {
+        server 127.0.0.1:8081 max_fails=0;
+        server 127.0.0.1:8081 max_fails=0;
+        keepalive 10;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-IP $upstream_addr always;
+
+        location / {
+            proxy_pass http://u;
+            proxy_next_upstream error timeout http_404;
+        }
+
+        location /non {
+            proxy_pass http://u;
+            proxy_next_upstream error timeout non_idempotent;
+        }
+
+        location /keepalive {
+            proxy_pass http://uk;
+            proxy_next_upstream error timeout;
+            proxy_http_version 1.1;
+            proxy_set_header Connection "";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+
+        location /404 {
+            return 404 SEE-THIS;
+        }
+
+        location /keepalive/establish {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# non-idempotent requests should not be retried by default
+# if a request has been sent to a backend
+
+like(http_get('/'), qr/X-IP: (\S+), \1\x0d?$/m, 'get');
+like(http_post('/'), qr/X-IP: (\S+)\x0d?$/m, 'post');
+
+# non-idempotent requests should not be retried by default,
+# in particular, not emit builtin error page due to next upstream
+
+like(http_get('/404'), qr/X-IP: (\S+), \1.*SEE-THIS/s, 'get 404');
+like(http_post('/404'), qr/X-IP: (\S++)(?! ).*SEE-THIS/s, 'post 404');
+
+# with "proxy_next_upstream non_idempotent" there is no
+# difference between idempotent and non-idempotent requests,
+# non-idempotent requests are retried as usual
+
+like(http_get('/non'), qr/X-IP: (\S+), \1\x0d?$/m, 'get non_idempotent');
+like(http_post('/non'), qr/X-IP: (\S+), \1\x0d?$/m, 'post non_idempotent');
+
+# cached connections follow the same rules
+
+like(http_get('/keepalive/establish'), qr/204 No Content/m, 'keepalive');
+like(http_post('/keepalive/drop'), qr/X-IP: (\S+)\x0d?$/m, 'keepalive post');
+
+###############################################################################
+
+sub http_post {
+    my ($uri, %extra) = @_;
+    my $cl = $extra{cl} || 0;
+
+    http(<<"EOF");
+POST $uri HTTP/1.0
+Content-Length: $cl
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_pass_request.t ../asynch_mode_nginx/test/nginx-tests/proxy_pass_request.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_pass_request.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_pass_request.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,139 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for proxy_pass_request_headers, proxy_pass_request_body directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_pass_request_headers off;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /body {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_pass_request_headers on;
+            proxy_pass_request_body off;
+        }
+
+        location /both {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_pass_request_headers off;
+            proxy_pass_request_body off;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(get('/', 'foo', 'bar'), qr/Header: none.*Body: bar/s, 'no headers');
+like(get('/body', 'foo', 'bar'), qr/Header: foo.*Body: none/s, 'no body');
+like(get('/both', 'foo', 'bar'), qr/Header: none.*Body: none/s, 'both');
+
+###############################################################################
+
+sub get {
+    my ($uri, $header, $body) = @_;
+    my $cl = length("$body\n");
+
+    http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Header: $header
+Content-Length: $cl
+
+$body
+EOF
+}
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $r = '';
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(2);
+            $client->sysread($r, 4096);
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            next;
+        }
+
+        next if $r eq '';
+
+        Test::Nginx::log_core('|| <<', $r);
+
+        my $header = $r =~ /x-header: (\S+)/i && $1 || 'none';
+        my $body = $r =~ /\x0d\x0a?\x0d\x0a?(.+)/ && $1 || 'none';
+
+        print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Header: $header
+X-Body: $body
+
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol2_server.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol2_server.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol2_server.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol2_server.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,155 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    add_header X-IP $remote_addr!$remote_port;
+    add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+    add_header X-PPS $proxy_protocol_server_addr!$proxy_protocol_server_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->try_run('no proxy_protocol_server_addr')->plan(28);
+
+###############################################################################
+
+my $p = pack("N3C", 0x0D0A0D0A, 0x000D0A51, 0x5549540A, 0x21);
+my $tcp4 = $p . pack("CnN2n2", 0x11, 12, 0xc0000201, 0xc0000202, 123, 567);
+my $tcp6 = $p . pack("CnNx8NNx8Nn2", 0x21, 36,
+    0x20010db8, 0x00000001, 0x20010db8, 0x00000002, 123, 567);
+my $tlv = $p . pack("CnN2n2x9", 0x11, 21, 0xc0000201, 0xc0000202, 123, 567);
+my $unk1 = $p . pack("Cxx", 0x01);
+my $unk2 = $p . pack("CnC4", 0x41, 4, 1, 2, 3, 4);
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tcp4 proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+like($r, qr/X-PPS: 2001:DB8::2!567\x0d/i, 'tcp6 proxy server');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $tlv);
+like($r, qr/SEE-THIS/, 'tlv request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tlv proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tlv proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tlv client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+    my ($url, $proxy) = @_;
+    return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol2.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol2.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol2.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,148 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(23);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr!$remote_port;
+        add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $p = pack("N3C", 0x0D0A0D0A, 0x000D0A51, 0x5549540A, 0x21);
+my $tcp4 = $p . pack("CnN2n2", 0x11, 12, 0xc0000201, 0xc0000202, 123, 5678);
+my $tcp6 = $p . pack("CnNx8NNx8Nn2", 0x21, 36,
+    0x20010db8, 0x00000001, 0x20010db8, 0x00000002, 123, 5678);
+my $tlv = $p . pack("CnN2n2x9", 0x11, 21, 0xc0000201, 0xc0000202, 123, 5678);
+my $unk1 = $p . pack("Cxx", 0x01);
+my $unk2 = $p . pack("CnC4", 0x41, 4, 1, 2, 3, 4);
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $tlv);
+like($r, qr/SEE-THIS/, 'tlv request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tlv proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tlv client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+    my ($url, $proxy) = @_;
+    return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol_ipv6.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_ipv6.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol_ipv6.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_ipv6.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,81 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol on IPv6 listening socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip stream/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       [::1]:%%PORT_8080%% proxy_protocol;
+        server_name  localhost;
+
+        add_header X-IP $remote_addr;
+        add_header X-PP $proxy_protocol_addr;
+        real_ip_header proxy_protocol;
+
+        location / { }
+        location /pp {
+            set_real_ip_from ::1/128;
+            error_page 404 =200 /t;
+        }
+    }
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  [::1]:%%PORT_8080%%;
+
+        proxy_protocol on;
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+$t->try_run('no inet6 support')->plan(3);
+
+###############################################################################
+
+my $r = http_get('/t');
+like($r, qr/X-IP: ::1/, 'realip');
+like($r, qr/X-PP: 127.0.0.1/, 'proxy protocol');
+
+$r = http_get('/pp');
+like($r, qr/X-IP: 127.0.0.1/, 'proxy protocol realip');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol_server.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_server.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol_server.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_server.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,148 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    add_header X-IP $remote_addr!$remote_port;
+    add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+    add_header X-PPS $proxy_protocol_server_addr!$proxy_protocol_server_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->try_run('no proxy_protocol_server_addr')->plan(24);
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 123 567' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 123 567' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+like($r, qr/X-PPS: 192.0.2.2!567\x0d/, 'tcp4 proxy server');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+like($r, qr/X-PPS: 2001:DB8::2!567\x0d/i, 'tcp6 proxy server');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+like($r, qr/X-PPS: !\x0d/, 'unknown proxy server 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+    my ($url, $proxy) = @_;
+    return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,142 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http access realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(20);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp $remote_addr:$remote_port;
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol;
+        server_name  localhost;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr!$remote_port;
+        add_header X-PP $proxy_protocol_addr!$proxy_protocol_port;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+                access_log %%TESTDIR%%/pp4.log pp;
+            }
+
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+                access_log %%TESTDIR%%/pp6.log pp;
+            }
+        }
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 123 5678' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 123 5678' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy');
+unlike($r, qr/X-IP: (192.0.2.1|[^!]+!123\x0d)/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: (2001:DB8::1|[^!]+!123\x0d)/i, 'tcp6 client');
+
+$r = pp_get('/t1', $unk1);
+like($r, qr/SEE-THIS/, 'unknown request 1');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 1');
+
+$r = pp_get('/t1', $unk2);
+like($r, qr/SEE-THIS/, 'unknown request 2');
+like($r, qr/X-PP: !\x0d/, 'unknown proxy 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1!123\x0d/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1!123\x0d/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1!123\x0d/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1!123\x0d/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+is($t->read_file('pp4.log'), "192.0.2.1:123\n", 'tcp4 log');
+is($t->read_file('pp6.log'), "2001:db8::1:123\n", 'tcp6 log');
+
+###############################################################################
+
+sub pp_get {
+    my ($url, $proxy) = @_;
+    return http($proxy . <<EOF);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_protocol_unix.t ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_unix.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_protocol_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_protocol_unix.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for haproxy protocol with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+    ->has(qw/http realip stream stream_realip stream_return unix/)
+    ->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock proxy_protocol;
+        server_name  localhost;
+
+        add_header X-IP $remote_addr;
+        add_header X-PP $proxy_protocol_addr;
+        real_ip_header proxy_protocol;
+
+        location / { }
+        location /pp {
+            set_real_ip_from unix:;
+            error_page 404 =200 /t;
+        }
+    }
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen      unix:%%TESTDIR%%/unix1.sock proxy_protocol;
+        return      $remote_addr:$proxy_protocol_addr;
+    }
+
+    server {
+        listen      unix:%%TESTDIR%%/unix2.sock proxy_protocol;
+        return      $remote_addr:$proxy_protocol_addr;
+
+        set_real_ip_from unix:;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  unix:%%TESTDIR%%/unix.sock;
+
+        proxy_protocol on;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  unix:%%TESTDIR%%/unix1.sock;
+
+        proxy_protocol on;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  unix:%%TESTDIR%%/unix2.sock;
+
+        proxy_protocol on;
+    }
+}
+
+EOF
+
+$t->write_file('t', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/t');
+like($r, qr/X-IP: unix/, 'remote_addr');
+like($r, qr/X-PP: 127.0.0.1/, 'proxy_protocol_addr');
+
+$r = http_get('/pp');
+like($r, qr/X-IP: 127.0.0.1/, 'remote_addr realip');
+
+# listen proxy_protocol in stream
+
+is(get(8081), 'unix::127.0.0.1', 'stream proxy_protocol');
+is(get(8082), '127.0.0.1:127.0.0.1', 'stream proxy_protocol realip');
+
+###############################################################################
+
+sub get {
+    Test::Nginx::Stream->new(PeerPort => port(shift))->read();
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_redirect.t ../asynch_mode_nginx/test/nginx-tests/proxy_redirect.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_redirect.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_redirect.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for the proxy_redirect directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            set $some_var var_here;
+
+            proxy_pass http://127.0.0.1:8081;
+
+            proxy_redirect http://127.0.0.1:8081/var_in_second/
+                           /$some_var/;
+            proxy_redirect http://127.0.0.1:8081/$some_var/ /replaced/;
+
+            proxy_redirect ~^(.+)/regex_w_([^/]+) $1/$2/test.html;
+            proxy_redirect ~*re+gexp? /replaced/test.html;
+        }
+
+        location /expl_default/ {
+            proxy_pass http://127.0.0.1:8081/replace_this/;
+            proxy_redirect wrong wrong;
+            proxy_redirect default;
+        }
+
+        location /impl_default/ {
+            proxy_pass http://127.0.0.1:8081/replace_this/;
+        }
+
+        location /off/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_redirect off;
+
+            location /off/on/ {
+                proxy_pass http://127.0.0.1:8081;
+                proxy_redirect http://127.0.0.1:8081/off/ /;
+
+                location /off/on/on/ {
+                    proxy_pass http://127.0.0.1:8081;
+                }
+            }
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Refresh "7; url=http://127.0.0.1:8081$uri";
+            return http://127.0.0.1:8081$uri;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my ($p0, $p1) = (port(8080), port(8081));
+
+is(http_get_location("http://127.0.0.1:$p0/impl_default/test.html"),
+    "http://127.0.0.1:$p0/impl_default/test.html", 'implicit default');
+is(http_get_location("http://127.0.0.1:$p0/expl_default/test.html"),
+    "http://127.0.0.1:$p0/expl_default/test.html", 'explicit default');
+
+is(http_get_refresh("http://127.0.0.1:$p0/impl_default/test.html"),
+    '7; url=/impl_default/test.html', 'implicit default (refresh)');
+is(http_get_refresh("http://127.0.0.1:$p0/expl_default/test.html"),
+    '7; url=/expl_default/test.html', 'explicit default (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/var_in_second/test.html"),
+    "http://127.0.0.1:$p0/var_here/test.html", 'variable in second arg');
+is(http_get_refresh("http://127.0.0.1:$p0/var_in_second/test.html"),
+    '7; url=/var_here/test.html', 'variable in second arg (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/off/test.html"),
+    "http://127.0.0.1:$p1/test.html", 'rewrite off');
+is(http_get_location("http://127.0.0.1:$p0/off/on/test.html"),
+    "http://127.0.0.1:$p0/on/test.html", 'rewrite off overwrite');
+
+is(http_get_location("http://127.0.0.1:$p0/off/on/on/test.html"),
+    "http://127.0.0.1:$p0/on/on/test.html", 'rewrite inheritance');
+
+is(http_get_location("http://127.0.0.1:$p0/var_here/test.html"),
+    "http://127.0.0.1:$p0/replaced/test.html", 'variable in first arg');
+is(http_get_refresh("http://127.0.0.1:$p0/var_here/test.html"),
+    '7; url=/replaced/test.html', 'variable in first arg (refresh)');
+
+is(http_get_location("http://127.0.0.1:$p0/ReeegEX/test.html"),
+    "http://127.0.0.1:$p0/replaced/test.html", 'caseless regexp');
+is(http_get_location("http://127.0.0.1:$p0/regex_w_captures/test.html"),
+    "http://127.0.0.1:$p1/captures/test.html", 'regexp w/captures');
+
+is(http_get_refresh("http://127.0.0.1:$p0/ReeegEX/test.html"),
+    '7; url=/replaced/test.html', 'caseless regexp (refresh)');
+is(http_get_refresh("http://127.0.0.1:$p0/regex_w_captures/test.html"),
+    "7; url=http://127.0.0.1:$p1/captures/test.html",
+    'regexp w/captures (refresh)');
+
+###############################################################################
+
+sub http_get_location {
+    my ($url) = @_;
+    http_get($url) =~ /^Location:\s(.+?)\x0d?$/mi;
+    return $1;
+}
+
+sub http_get_refresh {
+    my ($url) = @_;
+    http_get($url) =~ /^Refresh:\s(.+?)\x0d?$/mi;
+    return $1;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_chunked.t ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_chunked.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_chunked.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_chunked.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,340 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body, chunked transfer-encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(22);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+        proxy_http_version 1.1;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+        location /error_page {
+            proxy_pass http://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+    qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+    '0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+    '0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard 2');
+
+# proxy with file only is disabled in unbuffered mode
+
+like(http_get_body('/small', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082));
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '5' . CRLF . '01234' . CRLF,
+    'no preread - body part');
+is($s->{upload}('56789', last => 1),
+    '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF,
+    'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '5' . CRLF . '01234' . CRLF, 'preread - preread');
+is($s->{upload}('56789', last => 1),
+    '5' . CRLF . '56789' . CRLF . '0' . CRLF . CRLF, 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), '01234', many => 1);
+ok($s, 'chunks');
+
+SKIP: {
+skip 'chunks failed', 3 unless $s;
+
+is($s->{preread}, '9' . CRLF . '01234many' . CRLF, 'chunks - preread');
+is($s->{upload}('56789', many => 1, last => 1),
+    '9' . CRLF . '56789many' . CRLF . '0' . CRLF . CRLF, 'chunks - body');
+
+like($s->{http_end}(), qr/200 OK/, 'chunks - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $body) . CRLF
+        . $body . CRLF
+        . "0" . CRLF . CRLF
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF
+        . sprintf("%x", length $last) . CRLF
+        . $last . CRLF
+        . "0" . CRLF . CRLF
+    );
+}
+
+sub get_body {
+    my ($url, $port, $body, %extra) = @_;
+    my ($server, $client, $s);
+    my ($last, $many) = (0, 0);
+
+    $last = $extra{last} if defined $extra{last};
+    $many = $extra{many} if defined $extra{many};
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+EOF
+
+    if (defined $body) {
+        $r .= sprintf("%x", length $body) . CRLF;
+        $r .= $body . CRLF;
+    }
+    if (defined $body && $many) {
+        $r .= sprintf("%x", length 'many') . CRLF;
+        $r .= 'many' . CRLF;
+    }
+    if ($last) {
+        $r .= "0" . CRLF . CRLF;
+    }
+
+    $s = http($r, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(5);
+
+        $client = $server->accept();
+
+        log2c("(new connection $client)");
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    $client->sysread(my $buf, 1024);
+    log2i($buf);
+
+    $buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+    my $f = { preread => $buf };
+    $f->{upload} = sub {
+        my ($body, %extra) = @_;
+        my ($last, $many) = (0, 0);
+
+        $last = $extra{last} if defined $extra{last};
+        $many = $extra{many} if defined $extra{many};
+
+        my $buf = sprintf("%x", length $body) . CRLF;
+        $buf .= $body . CRLF;
+        if ($many) {
+            $buf .= sprintf("%x", length 'many') . CRLF;
+            $buf .= 'many' . CRLF;
+        }
+        if ($last) {
+            $buf .= "0" . CRLF . CRLF;
+        }
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            log_out($buf);
+            $s->write($buf);
+
+            $client->sysread($buf, 1024);
+            log2i($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    $f->{http_end} = sub {
+        my $buf = '';
+
+        $client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        $client->close;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            $s->sysread($buf, 1024);
+            log_in($buf);
+
+            $s->close();
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_keepalive.t ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_keepalive.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,88 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body and proxy with keepalive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+
+        location / {
+            proxy_pass http://backend;
+            add_header X-Body $request_body;
+            proxy_request_buffering off;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+# We emulate an early upstream server response while proxy is still
+# transmitting the request body.  In this case, the request body is
+# discarded by proxy, and 2nd request will be processed by upstream
+# as remain request body.
+
+http(<<EOF);
+GET /t1 HTTP/1.0
+Host: localhost
+Content-Length: 10
+
+EOF
+
+like(http_get('/t1'), qr/200 OK.*SEE/ms, 'keepalive after discarded');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_ssl.t ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering_ssl.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,312 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy rewrite/)
+    ->has_daemon('openssl')->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass https://127.0.0.1:8081;
+        }
+        location /error_page {
+            proxy_pass https://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location /preread {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8082/;
+            proxy_request_buffering off;
+        }
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+    qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+    '0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+    '0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard 2');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 15, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body part');
+is($s->{upload}('abcde'), 'abcde', 'preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Content-Length: " . (length $body) . CRLF . CRLF
+        . $body
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Content-Length: " . (length $last) . CRLF . CRLF
+        . $last
+    );
+}
+
+sub get_body {
+    my ($url, $port, $length, $body) = @_;
+    my ($server, $client, $s);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+    if (defined $body) {
+        $r .= $body;
+    }
+
+    $s = http($r, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(5);
+
+        $client = $server->accept();
+
+        log2c("(new connection $client)");
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    $client->sysread(my $buf, 1024);
+    log2i($buf);
+
+    $buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+    my $f = { preread => $buf };
+    $f->{upload} = sub {
+        my $buf = shift;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            log_out($buf);
+            $s->write($buf);
+
+            $client->sysread($buf, 1024);
+            log2i($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    $f->{http_end} = sub {
+        my $buf = '';
+
+        $client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        $client->close;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            $s->sysread($buf, 1024);
+            log_in($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering.t ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_request_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_request_buffering.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,289 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for unbuffered request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(18);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        client_header_buffer_size 1k;
+        proxy_request_buffering off;
+
+        location / {
+            client_body_buffer_size 2k;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /small {
+            client_body_in_file_only on;
+            proxy_pass http://127.0.0.1:8080/;
+        }
+        location /single {
+            client_body_in_single_buffer on;
+            add_header X-Body "$request_body";
+            proxy_pass http://127.0.0.1:8081;
+        }
+        location /discard {
+            return 200 "TEST\n";
+        }
+        location /preread {
+            proxy_pass http://127.0.0.1:8082/;
+        }
+        location /error_page {
+            proxy_pass http://127.0.0.1:8081/404;
+            error_page 404 /404;
+            proxy_intercept_errors on;
+        }
+        location /404 {
+            return 200 "$request_body\n";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/discard;
+        }
+        location /404 { }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+unlike(http_get('/'), qr/X-Body:/ms, 'no body');
+
+like(http_get_body('/', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'body');
+
+like(http_get_body('/', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in two buffers');
+
+like(http_get_body('/single', '0123456789' x 128),
+    qr/X-Body: (0123456789){128}\x0d?$/ms, 'body in single buffer');
+
+like(http_get_body('/error_page', '0123456789'),
+    qr/^0123456789$/m, 'body in error page');
+
+# pipelined requests
+
+like(http_get_body('/', '0123456789', '0123456789' x 128, '0123456789' x 512,
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined');
+like(http_get_body('/', '0123456789' x 128, '0123456789' x 512, '0123456789',
+    'foobar'), qr/X-Body: foobar\x0d?$/ms, 'body pipelined 2');
+
+like(http_get_body('/discard', '0123456789', '0123456789' x 128,
+    '0123456789' x 512, 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard');
+like(http_get_body('/discard', '0123456789' x 128, '0123456789' x 512,
+    '0123456789', 'foobar'), qr/(TEST.*){4}/ms,
+    'body discard 2');
+
+# proxy with file only is disabled in unbuffered mode
+
+like(http_get_body('/small', '0123456789'),
+    qr/X-Body: 0123456789\x0d?$/ms, 'small body in file only');
+
+# interactive tests
+
+my $s = get_body('/preread', port(8082), 10);
+ok($s, 'no preread');
+
+SKIP: {
+skip 'no preread failed', 3 unless $s;
+
+is($s->{upload}('01234'), '01234', 'no preread - body part');
+is($s->{upload}('56789'), '56789', 'no preread - body part 2');
+
+like($s->{http_end}(), qr/200 OK/, 'no preread - response');
+
+}
+
+$s = get_body('/preread', port(8082), 10, '01234');
+ok($s, 'preread');
+
+SKIP: {
+skip 'preread failed', 3 unless $s;
+
+is($s->{preread}, '01234', 'preread - preread');
+is($s->{upload}('56789'), '56789', 'preread - body');
+
+like($s->{http_end}(), qr/200 OK/, 'preread - response');
+
+}
+
+###############################################################################
+
+sub http_get_body {
+    my $uri = shift;
+    my $last = pop;
+    return http( join '', (map {
+        my $body = $_;
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Content-Length: " . (length $body) . CRLF . CRLF
+        . $body
+    } @_),
+        "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Content-Length: " . (length $last) . CRLF . CRLF
+        . $last
+    );
+}
+
+sub get_body {
+    my ($url, $port, $length, $body) = @_;
+    my ($server, $client, $s);
+
+    $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $r = <<EOF;
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+EOF
+
+    if (defined $body) {
+        $r .= $body;
+    }
+
+    $s = http($r, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(5);
+
+        $client = $server->accept();
+
+        log2c("(new connection $client)");
+
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    $client->sysread(my $buf, 1024);
+    log2i($buf);
+
+    $buf =~ s/.*?\x0d\x0a?\x0d\x0a?(.*)/$1/ms;
+
+    my $f = { preread => $buf };
+    $f->{upload} = sub {
+        my $buf = shift;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            log_out($buf);
+            $s->write($buf);
+
+            $client->sysread($buf, 1024);
+            log2i($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    $f->{http_end} = sub {
+        my $buf = '';
+
+        $client->write(<<EOF);
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        $client->close;
+
+        eval {
+            local $SIG{ALRM} = sub { die "timeout\n" };
+            local $SIG{PIPE} = sub { die "sigpipe\n" };
+            alarm(5);
+
+            $s->sysread($buf, 1024);
+            log_in($buf);
+
+            alarm(0);
+        };
+        alarm(0);
+        if ($@) {
+            log_in("died: $@");
+            return undef;
+        }
+
+        return $buf;
+    };
+    return $f;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_set_body.t ../asynch_mode_nginx/test/nginx-tests/proxy_set_body.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_set_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_set_body.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,82 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for proxy_set_body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8080/body;
+            proxy_set_body "body";
+        }
+
+        location /p1 {
+            proxy_pass http://127.0.0.1:8080/x1;
+            proxy_set_body "body";
+        }
+
+        location /p2 {
+            proxy_pass http://127.0.0.1:8080/body;
+            proxy_set_body "body two";
+        }
+
+        location /x1 {
+            add_header X-Accel-Redirect /p2;
+            return 204;
+        }
+
+        location /body {
+            add_header X-Body $request_body;
+            proxy_pass http://127.0.0.1:8080/empty;
+        }
+
+        location /empty {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-Body: body/, 'proxy_set_body');
+like(http_get('/p1'), qr/X-Body: body two/, 'proxy_set_body twice');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssi_body.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssi_body.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssi_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssi_body.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for proxied subrequest with request body in file.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/;
+            client_body_in_file_only on;
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html', 'X<!--# include virtual="test.html" -->X');
+$t->write_file('test.html', 'YY');
+
+$t->run();
+
+###############################################################################
+
+# Request body cache file is released once a response is got.
+# If later a subrequest tries to use body, it fails.
+
+like(http_get_body('/proxy/ssi.html', "1234567890"), qr/^XYYX$/m,
+    'body in file in proxied subrequest');
+
+###############################################################################
+
+sub http_get_body {
+    my ($url, $body, %extra) = @_;
+
+    my $p = "GET $url HTTP/1.0" . CRLF
+        . "Host: localhost" . CRLF
+        . "Content-Length: " . (length $body) . CRLF . CRLF
+        . $body;
+
+    return http($p, %extra);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_certificate.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_certificate.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_certificate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_certificate.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with proxy certificate to ssl backend.
+# The proxy_ssl_certificate and proxy_ssl_password_file directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+    ->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        proxy_ssl_session_reuse off;
+
+        location /verify {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_certificate 1.example.com.crt;
+            proxy_ssl_certificate_key 1.example.com.key;
+        }
+
+        location /fail {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_certificate 2.example.com.crt;
+            proxy_ssl_certificate_key 2.example.com.key;
+        }
+
+        location /encrypted {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_certificate 3.example.com.crt;
+            proxy_ssl_certificate_key 3.example.com.key;
+            proxy_ssl_password_file password;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/verify'), qr/X-Verify: SUCCESS/ms, 'verify certificate');
+like(http_get('/fail'), qr/X-Verify: FAILED/ms, 'fail certificate');
+like(http_get('/encrypted'), qr/X-Verify: SUCCESS/ms, 'with encrypted key');
+
+like(http_get('/verify'), qr!X-Name: /?CN=1.example!, 'valid certificate');
+unlike(http_get('/fail'), qr!X-Name: /?CN=1.example!, 'invalid certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_certificate_vars.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_certificate_vars.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_certificate_vars.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_certificate_vars.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,149 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with variables in ssl certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_ssl_session_reuse off;
+
+        location / {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_certificate $arg_cert.example.com.crt;
+            proxy_ssl_certificate_key $arg_cert.example.com.key;
+        }
+
+        location /encrypted {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_certificate $arg_cert.example.com.crt;
+            proxy_ssl_certificate_key $arg_cert.example.com.key;
+            proxy_ssl_password_file password;
+        }
+
+        location /none {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_certificate $arg_cert;
+            proxy_ssl_certificate_key $arg_cert;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->try_run('no upstream ssl_certificate variables')->plan(4);
+
+###############################################################################
+
+like(http_get('/?cert=1'),
+    qr/X-Verify: SUCCESS/ms, 'variable - verify certificate');
+like(http_get('/?cert=2'),
+    qr/X-Verify: FAILED/ms, 'variable - fail certificate');
+like(http_get('/encrypted?cert=3'),
+    qr/X-Verify: SUCCESS/ms, 'variable - with encrypted key');
+like(http_get('/none'),
+    qr/X-Verify: NONE/ms, 'variable - no certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_conf_command.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_conf_command.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_conf_command.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_conf_command.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy to ssl backend, proxy_ssl_conf_command.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_ssl_certificate localhost.crt;
+        proxy_ssl_certificate_key localhost.key;
+        proxy_ssl_conf_command Certificate override.crt;
+        proxy_ssl_conf_command PrivateKey override.key;
+
+        location / {
+            proxy_pass https://127.0.0.1:8081/;
+            %%PROXY_ASYNCH_ENABLE%%
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+        ssl_verify_client optional_no_ca;
+
+        location / {
+            add_header X-Cert $ssl_client_s_dn;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'override') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+$t->try_run('no proxy_ssl_conf_command')->plan(1);
+
+###############################################################################
+
+like(http_get('/'), qr/CN=override/, 'Certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_keepalive.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_keepalive.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for proxy with keepalive to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy upstream_keepalive/)
+    ->has_daemon('openssl')->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+        keepalive 1;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        proxy_http_version 1.1;
+
+        location / {
+            proxy_pass https://u/;
+            proxy_set_header Connection $args;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            add_header X-Connection $connection;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my ($r, $n);
+
+like($r = http_get('/'), qr/200 OK.*SEE-THIS/ms, 'first');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/'), qr/X-Connection: $n[^\d].*SEE-THIS/ms, 'second');
+
+http_get('/?close');
+unlike(http_get('/'), qr/X-Connection: $n[^\d]/, 'close');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_name.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_name.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_name.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_name.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,156 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni proxy/)
+    ->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        %%PROXY_ASYNCH_ENABLE%%
+    }
+
+    upstream backend2 {
+        server 127.0.0.1:8081;
+        %%PROXY_ASYNCH_ENABLE%%
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # session reuse is off, as sessions are cached
+        # for a particular upstream, and resumed session
+        # will use server name previously negotiated
+
+        proxy_ssl_session_reuse off;
+
+        location /1 {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name 1.example.com;
+            proxy_ssl_server_name on;
+        }
+
+        location /2 {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name 2.example.com;
+            proxy_ssl_server_name on;
+
+        }
+
+        location /off {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name off;
+        }
+
+        location /default {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name on;
+        }
+
+        location /default2 {
+            proxy_pass https://backend2/;
+            proxy_ssl_server_name on;
+        }
+
+        location /port {
+            proxy_pass https://backend/;
+            proxy_ssl_server_name on;
+            proxy_ssl_name backend:123;
+        }
+
+        location /ip {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_server_name on;
+        }
+
+        location /ip6 {
+            proxy_pass https://[::1]:%%PORT_8081%%/;
+            proxy_ssl_server_name on;
+        }
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl %%SSL_ASYNCH%;
+        listen [::1]:%%PORT_8081%% ssl %%SSL_ASYNCH%%;
+        server_name 1.example.com;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+
+        add_header X-Name $ssl_server_name,;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /commonName=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+
+$t->try_run('no inet6 support')->plan(9);
+
+###############################################################################
+
+like(http_get('/1'), qr/200 OK.*X-Name: 1.example.com,/ms, 'name 1');
+like(http_get('/2'), qr/200 OK.*X-Name: 2.example.com,/ms, 'name 2');
+like(http_get('/off'), qr/200 OK.*X-Name: ,/ms, 'no name');
+
+like(http_get('/default'), qr/200 OK.*X-Name: backend,/ms, 'default');
+like(http_get('/default2'), qr/200 OK.*X-Name: backend2,/ms, 'default2');
+like(http_get('/default'), qr/200 OK.*X-Name: backend,/ms, 'default again');
+
+like(http_get('/port'), qr/200 OK.*X-Name: backend,/ms, 'no port in name');
+like(http_get('/ip'), qr/200 OK.*X-Name: ,/ms, 'no ip');
+like(http_get('/ip6'), qr/200 OK.*X-Name: ,/ms, 'no ipv6');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,190 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+    ->plan(8)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen 127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+
+        location / {
+            add_header X-Session $ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        location /ssl_reuse {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /ssl {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_session_reuse off;
+        }
+
+        location /timeout {
+            proxy_pass https://127.0.0.1:8082;
+            proxy_connect_timeout 3s;
+        }
+
+        location /timeout_h {
+            proxy_pass https://127.0.0.1:8083;
+            proxy_connect_timeout 1s;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('big.html', 'xxxxxxxxxx' x 72000);
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run_daemon(\&http_daemon, port(8083));
+$t->run();
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl');
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl 2');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: \./s, 'ssl session new');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused 2');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/timeout'), qr/200 OK/, 'proxy connect timeout');
+
+}
+
+like(http_get('/timeout_h'), qr/504 Gateway/, 'proxy handshake timeout');
+
+is(length(Test::Nginx::http_content(http_get('/ssl/big.html'))), 720000,
+    'big length');
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        if ($port == port(8083)) {
+            sleep 3;
+
+            close $client;
+            next;
+        }
+
+        my $headers = '';
+        my $uri = '';
+
+        # would fail on waitforsocket
+
+        eval {
+            IO::Socket::SSL->start_SSL($client,
+                SSL_server => 1,
+                SSL_cert_file => "$d/localhost.crt",
+                SSL_key_file => "$d/localhost.key",
+                SSL_error_trap => sub { die $_[1] }
+            );
+        };
+        next if $@;
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+        next if $uri eq '';
+
+        if ($uri eq '/timeout') {
+            sleep 4;
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_ssl_verify.t ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_verify.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_ssl_verify.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_ssl_verify.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,172 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Tests for proxy to ssl backend, backend certificate verification.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl proxy/)
+    ->has_daemon('openssl')->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        location /verify {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /wildcard {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name foo.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /fail {
+            proxy_pass https://127.0.0.1:8081/;
+            proxy_ssl_name no.match.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /cn {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name 2.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /cn/fail {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name bad.example.com;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /untrusted {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_verify on;
+            proxy_ssl_trusted_certificate 1.example.com.crt;
+            proxy_ssl_session_reuse off;
+        }
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl;
+        server_name 1.example.com;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        add_header X-Name $ssl_server_name;
+    }
+
+    server {
+        listen 127.0.0.1:8082 ssl;
+        server_name 2.example.com;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        add_header X-Name $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.1.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+x509_extensions = v3_req
+
+[ req_distinguished_name ]
+commonName=no.match.example.com
+
+[ v3_req ]
+subjectAltName = DNS:example.com,DNS:*.example.com
+EOF
+
+$t->write_file('openssl.2.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+
+[ req_distinguished_name ]
+commonName=2.example.com
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.$name.conf "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+# subjectAltName
+
+like(http_get('/verify'), qr/200 OK/ms, 'verify');
+like(http_get('/wildcard'), qr/200 OK/ms, 'verify wildcard');
+like(http_get('/fail'), qr/502 Bad/ms, 'verify fail');
+
+# commonName
+
+like(http_get('/cn'), qr/200 OK/ms, 'verify cn');
+like(http_get('/cn/fail'), qr/502 Bad/ms, 'verify cn fail');
+
+# untrusted
+
+like(http_get('/untrusted'), qr/502 Bad/ms, 'untrusted');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_store.t ../asynch_mode_nginx/test/nginx-tests/proxy_store.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_store.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_store.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for proxy_store functionality.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new();
+
+$t->write_file_expand('nginx.conf', <<'EOF')->has(qw/http proxy ssi/)->plan(9);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /store- {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_store on;
+        }
+        location /store-string- {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_store %%TESTDIR%%$uri;
+        }
+        location /ssi.html {
+            ssi on;
+        }
+        location /index-big.html {
+            limit_rate  200k;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->write_file('index-nostore.html', 'SEE-THIS');
+$t->write_file('index-big.html', 'x' x (100 << 10));
+$t->write_file('ssi.html',
+    '<!--#include virtual="/store-index-big.html?1" -->' .
+    '<!--#include virtual="/store-index-big.html?2" -->'
+);
+$t->run();
+
+###############################################################################
+
+like(http_get('/store-index.html'), qr/SEE-THIS/, 'proxy request');
+ok(-e $t->testdir() . '/store-index.html', 'result stored');
+
+like(http_get('/store-string-index.html'), qr/SEE-THIS/,
+    'proxy string path request');
+ok(-e $t->testdir() . '/store-string-index.html', 'string path result stored');
+
+like(http_head('/store-index-nostore.html'), qr/200 OK/, 'head request');
+ok(!-e $t->testdir() . '/store-index-nostore.html', 'result not stored');
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0, 'no temp files');
+
+http_get('/store-index-big.html', aborted => 1, sleep => 0.1);
+
+select(undef, undef, undef, 0.5);
+select(undef, undef, undef, 2.5)
+    if scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]};
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0,
+    'no temp files after aborted request');
+
+http_get('/ssi.html', aborted => 1, sleep => 0.1);
+
+select(undef, undef, undef, 0.5);
+select(undef, undef, undef, 2.5)
+    if scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]};
+
+ok(scalar @{[ glob $t->testdir() . '/proxy_temp/*' ]} == 0,
+    'no temp files after aborted ssi');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy.t ../asynch_mode_nginx/test/nginx-tests/proxy.t
--- nginx-release-1.20.1/test/nginx-tests/proxy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy.t	2022-03-15 13:23:40.580403191 -0500
@@ -0,0 +1,293 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(28);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format time '$upstream_connect_time:$upstream_header_time:'
+                    '$upstream_response_time';
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Connect $upstream_connect_time;
+        add_header X-Header $upstream_header_time;
+        add_header X-Response $upstream_response_time;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 2s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /var {
+            proxy_pass http://$arg_b;
+            proxy_read_timeout 2s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /timeout {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_connect_timeout 2s;
+        }
+
+        location /time/ {
+            proxy_pass http://127.0.0.1:8081/;
+            access_log %%TESTDIR%%/time.log time;
+        }
+
+        location /pnu {
+            proxy_pass http://u2/bad;
+        }
+
+        location /vars {
+            proxy_pass http://127.0.0.1:8080/stub;
+
+            add_header X-Proxy-Host $proxy_host;
+            add_header X-Proxy-Port $proxy_port;
+            add_header X-Proxy-Forwarded $proxy_add_x_forwarded_for;
+        }
+
+        location /stub { }
+    }
+}
+
+EOF
+
+$t->write_file('stub', '');
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/multi'), qr/AND-THIS/, 'proxy request with multiple packets');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'proxy head request');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081) . '/'), qr/SEE-THIS/,
+    'proxy with variables');
+like(http_get('/var?b=u/'), qr/SEE-THIS/, 'proxy with variables to upstream');
+
+like(http_get('/timeout'), qr/200 OK/, 'proxy connect timeout');
+
+my $re = qr/(\d\.\d{3})/;
+my $p0 = port(8080);
+my ($ct, $ht, $rt, $ct2, $ht2, $rt2, $ct3, $ht3, $rt3);
+
+like(http_get('/vars'), qr/X-Proxy-Host:\s127\.0\.0\.1:$p0/, 'proxy_host');
+like(http_get('/vars'), qr/X-Proxy-Port:\s$p0/, 'proxy_port');
+like(http_xff('/vars', '192.0.2.1'), qr/X-Proxy-Forwarded:.*192\.0\.2\.1/,
+    'proxy_add_x_forwarded_for');
+
+($ct, $ht) = get('/time/header');
+cmp_ok($ct, '<', 1, 'connect time - slow response header');
+cmp_ok($ht, '>=', 1, 'header time - slow response header');
+
+($ct, $ht) = get('/time/body');
+cmp_ok($ct, '<', 1, 'connect time - slow response body');
+cmp_ok($ht, '<', 1, 'header time - slow response body');
+
+my $s = http_get('/time/header', start => 1);
+select undef, undef, undef, 0.4;
+close ($s);
+
+# expect no header time in 1st (bad) upstream, no (yet) response time in 2nd
+
+$re = qr/(\d\.\d{3}|-)/;
+($ct, $ct2, $ht, $ht2, $rt, $rt2) = get('/pnu', many => 1);
+
+cmp_ok($ct, '<', 1, 'connect time - next');
+cmp_ok($ct2, '<', 1, 'connect time - next 2');
+
+is($ht, '-', 'header time - next');
+cmp_ok($ht2, '<', 1, 'header time - next 2');
+
+cmp_ok($rt, '>=', 1, 'response time - next');
+is($rt2, '-', 'response time - next 2');
+
+$t->stop();
+
+($ct, $ht, $rt, $ct2, $ht2, $rt2, $ct3, $ht3, $rt3)
+    = $t->read_file('time.log') =~ /^$re:$re:$re\n$re:$re:$re\n$re:$re:$re$/;
+
+cmp_ok($ct, '<', 1, 'connect time log - slow response header');
+cmp_ok($ct2, '<', 1, 'connect time log - slow response body');
+cmp_ok($ct3, '<', 1, 'connect time log - client close');
+
+cmp_ok($ht, '>=', 1, 'header time log - slow response header');
+cmp_ok($ht2, '<', 1, 'header time log - slow response body');
+is($ht3, '-', 'header time log - client close');
+
+cmp_ok($rt, '>=', 1, 'response time log - slow response header');
+cmp_ok($rt2, '>=', 1, 'response time log - slow response body');
+cmp_ok($rt3, '>', $ct3, 'response time log - client close');
+
+###############################################################################
+
+sub get {
+    my ($uri, %extra) = @_;
+    my $re = $extra{many} ? qr/$re, $re?/ : $re;
+    my $r = http_get($uri);
+    $r =~ /X-Connect: $re/, $r =~ /X-Header: $re/, $r =~ /X-Response: $re/;
+}
+
+sub http_xff {
+    my ($uri, $xff) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+sub http_daemon {
+    my $once = 1;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/') {
+            print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+            print $client "TEST-OK-IF-YOU-SEE-THIS"
+                unless $headers =~ /^HEAD/i;
+
+        } elsif ($uri eq '/multi') {
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+            select undef, undef, undef, 0.1;
+            print $client 'AND-THIS';
+
+        } elsif ($uri eq '/timeout') {
+            sleep 3;
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+        } elsif ($uri eq '/bad') {
+
+            if ($once) {
+                $once = 0;
+                select undef, undef, undef, 1.1;
+                next;
+            }
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-AND-THIS
+EOF
+
+        } elsif ($uri eq '/header') {
+            select undef, undef, undef, 1.1;
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-AND-THIS;
+EOF
+
+        } elsif ($uri eq '/body') {
+
+            print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+SEE-THIS-
+EOF
+
+            select undef, undef, undef, 1.1;
+            print $client 'AND-THIS';
+
+        } else {
+
+            print $client <<"EOF";
+HTTP/1.1 404 Not Found
+Connection: close
+
+Oops, '$uri' not found
+EOF
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_unfinished.t ../asynch_mode_nginx/test/nginx-tests/proxy_unfinished.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_unfinished.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_unfinished.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,261 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy and prematurely closed connections.  Incomplete
+# responses shouldn't loose information about their incompleteness.
+
+# In particular, incomplete responses:
+#
+# - shouldn't be cached
+#
+# - if a response is sent using chunked transfer encoding,
+#   final chunk shouldn't be sent
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_content /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache sub/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=one:1m;
+
+    server {
+        listen       127.0.0.1:8080 sndbuf=32k;
+        server_name  localhost;
+
+        location / {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8081;
+        }
+
+        location /un/ {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_cache one;
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /proxy/ {
+            sub_filter foo bar;
+            sub_filter_types *;
+            proxy_pass http://127.0.0.1:8080/local/;
+            proxy_buffer_size 1k;
+            proxy_buffers 4 1k;
+        }
+
+        location /local/ {
+            alias %%TESTDIR%%/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('big.html', 'X' x (1024 * 1024) . 'finished');
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+http_get('/cache/length');
+like(http_get('/cache/length'), qr/MISS/, 'unfinished not cached');
+
+# chunked encoding has enough information to don't cache a response,
+# much like with Content-Length available
+
+http_get('/cache/chunked');
+like(http_get('/cache/chunked'), qr/MISS/, 'unfinished chunked');
+
+# make sure there is no final chunk in unfinished responses
+
+like(http_get_11('/length'), qr/unfinished.*no-last-chunk/s,
+    'length no final chunk');
+like(http_get_11('/chunked'), qr/unfinished.*no-last-chunk/s,
+    'chunked no final chunk');
+
+# but there is final chunk in complete responses
+
+like(http_get_11('/length/ok'), qr/finished\x0d\x0a$/s,
+    'length final chunk');
+like(http_get_11('/chunked/ok'), qr/finished\x0d\x0a$/s,
+    'chunked final chunk');
+
+# the same with proxy_buffering set to off
+
+like(http_get_11('/un/length'), qr/unfinished.*no-last-chunk/s,
+    'unbuffered length no final chunk');
+like(http_get_11('/un/chunked'), qr/unfinished.*no-last-chunk/s,
+    'unbuffered chunked no final chunk');
+
+like(http_get_11('/un/length/ok'), qr/finished\x0d\x0a$/s,
+    'unbuffered length final chunk');
+like(http_get_11('/un/chunked/ok'), qr/finished\x0d\x0a$/s,
+    'unbuffered chunked final chunk');
+
+# big responses
+
+like(http_get('/big', sleep => 0.1), qr/unfinished/s, 'big unfinished');
+like(http_get('/big/ok', sleep => 0.1), qr/finished/s, 'big finished');
+like(http_get('/un/big', sleep => 0.1), qr/unfinished/s, 'big unfinished un');
+like(http_get('/un/big/ok', sleep => 0.1), qr/finished/s, 'big finished un');
+
+# if disk buffering fails for some reason, there should be
+# no final chunk
+
+chmod(0000, $t->testdir() . '/proxy_temp');
+
+my $r = http_get_11('/proxy/big.html', sleep => 0.5);
+
+SKIP: {
+skip 'finished', 1 if length($r) == 1024 * 1024 + 8;
+
+like($r, qr/X(?!.*\x0d\x0a?0\x0d\x0a?)/s, 'no proxy temp');
+
+}
+
+chmod(0700, $t->testdir() . '/proxy_temp');
+
+###############################################################################
+
+sub http_get_11 {
+    my ($uri, %extra) = @_;
+
+    return http_content(http(
+        "GET $uri HTTP/1.1" . CRLF .
+        "Connection: close" . CRLF .
+        "Host: localhost" . CRLF . CRLF,
+        %extra
+    ));
+}
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/length') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 100" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "unfinished" . CRLF;
+
+        } elsif ($uri eq '/length/ok') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 10" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "finished" . CRLF;
+
+        } elsif ($uri eq '/big') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 1000100" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+            for (1 .. 10000) {
+                print $client ("X" x 98) . CRLF;
+            }
+            print $client "unfinished" . CRLF;
+
+        } elsif ($uri eq '/big/ok') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Content-Length: 1000010" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF;
+            for (1 .. 10000) {
+                print $client ("X" x 98) . CRLF;
+            }
+            print $client "finished" . CRLF;
+
+        } elsif ($uri eq '/chunked') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "ff" . CRLF .
+                "unfinished" . CRLF;
+
+        } elsif ($uri eq '/chunked/ok') {
+            print $client
+                "HTTP/1.1 200 OK" . CRLF .
+                "Transfer-Encoding: chunked" . CRLF .
+                "Cache-Control: max-age=300" . CRLF .
+                "Connection: close" . CRLF .
+                CRLF .
+                "a" . CRLF .
+                "finished" . CRLF .
+                CRLF . "0" . CRLF . CRLF;
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_unix.t ../asynch_mode_nginx/test/nginx-tests/proxy_unix.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_unix.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,156 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy unix/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+            proxy_read_timeout 1s;
+            proxy_connect_timeout 2s;
+        }
+
+        location /var {
+            proxy_pass http://$arg_b;
+            proxy_read_timeout 1s;
+        }
+
+        location /u {
+            proxy_pass http://u;
+            proxy_read_timeout 1s;
+        }
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&http_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+    last if -S $path;
+    select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'proxy request');
+like(http_get('/multi'), qr/AND-THIS/, 'proxy request with multiple packets');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'proxy head request');
+
+like(http_get("/var?b=unix:$path:/"), qr/SEE-THIS/, 'proxy with variables');
+
+like(http_get('/u'), qr/SEE-THIS/, 'proxy implicit upstream');
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::UNIX->new(
+        Proto => 'tcp',
+        Local => shift,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if (grep { $uri eq $_ } ('/', '/u')) {
+            print $client <<'EOF';
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+            print $client "TEST-OK-IF-YOU-SEE-THIS"
+                unless $headers =~ /^HEAD/i;
+
+        } elsif ($uri eq '/multi') {
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+            select undef, undef, undef, 0.1;
+            print $client 'AND-THIS';
+
+        } else {
+
+            print $client <<"EOF";
+HTTP/1.1 404 Not Found
+Connection: close
+
+Oops, '$uri' not found
+EOF
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_upgrade.t ../asynch_mode_nginx/test/nginx-tests/proxy_upgrade.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_upgrade.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_upgrade.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,345 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy upgrade support.
+# In contrast to proxy_websocket.t, this test doesn't try to use binary
+# WebSocket protocol, but uses simple plain text protocol instead.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)
+    ->write_file_expand('nginx.conf', <<'EOF')->plan(31);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$bytes_sent $body_bytes_sent $sent_http_connection";
+    access_log %%TESTDIR%%/cc.log test;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+
+        location /ssi.html {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('ssi.html', '<!--#include virtual="/upgrade" --> SEE-THIS');
+
+$t->run_daemon(\&upgrade_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start test backend";
+
+###############################################################################
+
+# establish connection
+
+my @r;
+my $s = upgrade_connect();
+ok($s, "handshake");
+
+SKIP: {
+    skip "handshake failed", 22 unless $s;
+
+    # send a frame
+
+    upgrade_write($s, 'foo');
+    is(upgrade_read($s), 'bar', "upgrade response");
+
+    # send some big frame
+
+    upgrade_write($s, 'foo' x 16384);
+    like(upgrade_read($s), qr/^(bar){16384}$/, "upgrade big response");
+
+    # send multiple frames
+
+    for my $i (1 .. 10) {
+        upgrade_write($s, ('foo' x 16384) . $i, continue => 1);
+        upgrade_write($s, 'bazz' . $i, continue => $i != 10);
+    }
+
+    for my $i (1 .. 10) {
+        like(upgrade_read($s), qr/^(bar){16384}\d+$/, "upgrade $i");
+        is(upgrade_read($s), 'bazz' . $i, "upgrade small $i");
+    }
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# establish connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+$s = upgrade_connect(message => "foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+    skip "handshake failed", 2 unless $s;
+
+    is(upgrade_read($s), "bar", "response pipelined");
+
+    upgrade_write($s, "foo");
+    is(upgrade_read($s), "bar", "next to pipelined");
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# connection should not be upgraded unless upgrade was actually
+# requested and allowed by configuration
+
+$s = upgrade_connect(noheader => 1);
+ok(!$s, "handshake noupgrade");
+
+# connection upgrade in subrequests shouldn't cause a segfault
+
+$s = upgrade_connect(uri => '/ssi.html');
+ok(!$s, "handshake in subrequests");
+
+# bytes sent on upgraded connection
+# verify with 1) data actually read by client, 2) expected data from backend
+
+$t->stop();
+
+open my $f, '<', "$d/cc.log" or die "Can't open cc.log: $!";
+
+is($f->getline(), shift (@r) . " 540793 upgrade\n", 'log - bytes');
+is($f->getline(), shift (@r) . " 22 upgrade\n", 'log - bytes pipelined');
+like($f->getline(), qr/\d+ 0 /, 'log - bytes noupgrade');
+
+###############################################################################
+
+sub upgrade_connect {
+    my (%opts) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1:' . port(8080),
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    # send request, $h->to_string
+
+    my $uri = $opts{uri} || '/';
+
+    my $buf = "GET $uri HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . ($opts{noheader} ? '' : "Upgrade: foo" . CRLF)
+        . "Connection: Upgrade" . CRLF . CRLF;
+
+    $buf .= $opts{message} . CRLF . 'FIN' if defined $opts{message};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    log_out($buf);
+    $s->syswrite($buf);
+
+    # read response
+
+    my $got = '';
+    $buf = '';
+
+    while (1) {
+        $buf = upgrade_getline($s);
+        last unless defined $buf and length $buf;
+        log_in($buf);
+        $got .= $buf;
+        last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+    }
+
+    # parse server response
+
+    return if $got !~ m!HTTP/1.1 101!;
+
+    # make sure next line is "handshaked"
+
+    $buf = upgrade_read($s);
+
+    return if !defined $buf or $buf ne 'handshaked';
+    return $s;
+}
+
+sub upgrade_getline {
+    my ($s) = @_;
+    my ($h, $buf);
+
+    ${*$s}->{_upgrade_private} ||= { b => '', r => 0 };
+    $h = ${*$s}->{_upgrade_private};
+
+    if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+        $h->{b} = $2;
+        return $1;
+    }
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_read(3)) {
+        my $n = $s->sysread($buf, 1024);
+        last unless $n;
+
+        $h->{b} .= $buf;
+        $h->{r} += $n;
+
+        if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+            $h->{b} = $2;
+            return $1;
+        }
+    };
+}
+
+sub upgrade_write {
+    my ($s, $message, %extra) = @_;
+
+    $message = $message . CRLF;
+    $message = $message . 'FIN' unless $extra{continue};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_write(1.5)) {
+        my $n = $s->syswrite($message);
+        last unless $n;
+        $message = substr($message, $n);
+        last unless length $message;
+    }
+
+    if (length $message) {
+        $s->close();
+    }
+}
+
+sub upgrade_read {
+    my ($s) = @_;
+    my $m = upgrade_getline($s);
+    $m =~ s/\x0d?\x0a// if defined $m;
+    log_in($m);
+    return $m;
+}
+
+###############################################################################
+
+sub upgrade_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    while (my $client = $server->accept()) {
+        upgrade_handle_client($client);
+    }
+}
+
+sub upgrade_handle_client {
+    my ($client) = @_;
+
+    $client->autoflush(1);
+    $client->blocking(0);
+
+    my $poll = IO::Poll->new;
+
+    my $handshake = 1;
+    my $unfinished = '';
+    my $buffer = '';
+    my $n;
+
+    log2c("(new connection $client)");
+
+    while (1) {
+        $poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+        my $p = $poll->poll(0.5);
+        log2c("(poll $p)");
+
+        foreach my $reader ($poll->handles(POLLIN)) {
+            $n = $client->sysread(my $chunk, 65536);
+            return unless $n;
+
+            log2i($chunk);
+
+            if ($handshake) {
+                $buffer .= $chunk;
+                next unless $buffer =~ /\x0d?\x0a\x0d?\x0a$/;
+
+                log2c("(handshake done)");
+
+                $handshake = 0;
+                $buffer = 'HTTP/1.1 101 Switching' . CRLF
+                    . 'Upgrade: foo' . CRLF
+                    . 'Connection: Upgrade' . CRLF . CRLF
+                    . 'handshaked' . CRLF;
+
+                log2o($buffer);
+
+                next;
+            }
+
+            $unfinished .= $chunk;
+
+            if ($unfinished =~ m/\x0d?\x0aFIN\z/) {
+                $unfinished =~ s/FIN\z//;
+                $unfinished =~ s/foo/bar/g;
+                log2o($unfinished);
+                $buffer .= $unfinished;
+                $unfinished = '';
+            }
+        }
+
+        foreach my $writer ($poll->handles(POLLOUT)) {
+            next unless length $buffer;
+            $n = $writer->syswrite($buffer);
+            substr $buffer, 0, $n, '';
+        }
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_upstream_cookie.t ../asynch_mode_nginx/test/nginx-tests/proxy_upstream_cookie.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_upstream_cookie.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_upstream_cookie.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for the $upstream_cookie_<name> variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-Upstream-Cookie $upstream_cookie_tc;
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header Set-Cookie $http_x_test_cookie;
+            return 204;
+        }
+
+        # embed multiline cookie with add_header
+        location /mcomma {
+            add_header Set-Cookie "tc=one,two,three";
+            add_header Set-Cookie "tc=four,five,six";
+            return 204;
+        }
+        location /msemicolon {
+            add_header Set-Cookie "tc=one;two;three";
+            add_header Set-Cookie "tc=four;five;six";
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+is(http_get_uc('tc='), undef, 'value_none');
+is(http_get_uc('tc=;'), undef, 'semicolon');
+is(http_get_uc('tc= ;'), undef, 'space_semicolon');
+is(http_get_uc('tc =   ; Domain=example.com;'), undef, 'space_semicolon_more');
+
+is(http_get_uc('tc=x'), 'x', 'onechar');
+is(http_get_uc('tc=,'), ',', 'comma');
+is(http_get_uc('tc	=	content     ;'), undef, 'tabbed');
+is(http_get_uc('tc="content"'), '"content"', 'dquoted');
+is(http_get_uc('tc=content'), 'content', 'normal');
+is(http_get_uc('tc=con  tent; Domain=example.com'), 'con  tent',
+    'internal_space');
+is(http_get_uc('tc = content'), 'content', 'separated');
+
+is(http_get_uc('tc=1.2.3'), '1.2.3', 'dots');
+is(http_get_uc('tc==abc'), '=abc', 'deq');
+is(http_get_uc('tc==;abc'), '=', 'deqsemi');
+is(http_get_uc('=tc=content'), undef, 'eqfirst');
+is(http_get_uc('tc=first,tc=second'), 'first,tc=second', 'two_comma');
+is(http_get_uc('tc=first;tc=second'), 'first', 'two_semicolon');
+
+like(http_get('/mcomma'), qr/^X-Upstream-Cookie: one,two,three\x0d?$/mi,
+    'multiline comma');
+like(http_get('/msemicolon'), qr/^X-Upstream-Cookie: one\x0d?$/mi,
+    'multiline semicolon');
+
+###############################################################################
+
+sub http_get_uc {
+    my ($cookie) = @_;
+
+    http(<<EOF) =~ qr/^X-Upstream-Cookie:\s(.+?)\x0d?$/mi;
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+X-Test-Cookie: $cookie
+
+EOF
+
+    return $1;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_variables.t ../asynch_mode_nginx/test/nginx-tests/proxy_variables.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_variables.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,135 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy module with upstream variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format u $uri:$upstream_response_length:$upstream_bytes_received:
+                 $upstream_bytes_sent:$upstream_http_x_len;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            access_log %%TESTDIR%%/test.log u;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $r;
+
+my ($l1) = ($r = http_get('/')) =~ /X-Len: (\d+)/;
+like($r, qr/SEE-THIS/, 'proxy request');
+
+my ($l2) = ($r = http_get('/multi')) =~ /X-Len: (\d+)/;
+like($r, qr/AND-THIS/, 'proxy request with multiple packets');
+
+$t->stop();
+
+my $f = $t->read_file('test.log');
+Test::Nginx::log_core('||', $f);
+
+like($f, qr!^/:23:68:$l1:$l1!m, 'log - response length');
+like($f, qr!^/multi:32:77:$l2:$l2!m, 'log - response length - multi packets');
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+        my $len = length($headers);
+
+        if ($uri eq '/') {
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Len: $len
+
+EOF
+            print $client "TEST-OK-IF-YOU-SEE-THIS"
+                unless $headers =~ /^HEAD/i;
+
+        } elsif ($uri eq '/multi') {
+
+            print $client <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+X-Len: $len
+
+TEST-OK-IF-YOU-SEE-THIS
+EOF
+
+            select undef, undef, undef, 0.1;
+            print $client 'AND-THIS';
+        }
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_websocket.t ../asynch_mode_nginx/test/nginx-tests/proxy_websocket.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_websocket.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_websocket.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,303 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for http proxy websockets support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use IO::Socket::INET;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Protocol::WebSocket::Handshake::Client;
+    require Protocol::WebSocket::Handshake::Server;
+    require Protocol::WebSocket::Frame;
+};
+
+plan(skip_all => 'Protocol::WebSocket not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)
+    ->write_file_expand('nginx.conf', <<'EOF')->plan(26);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&websocket_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start test backend";
+
+###############################################################################
+
+# establish websocket connection
+
+my $s = websocket_connect();
+ok($s, "websocket handshake");
+
+SKIP: {
+    skip "handshake failed", 22 unless $s;
+
+    # send a frame
+
+    websocket_write($s, 'foo');
+    is(websocket_read($s), 'bar', "websocket response");
+
+    # send some big frame
+
+    websocket_write($s, 'foo' x 16384);
+    like(websocket_read($s), qr/^(bar){16384}$/, "websocket big response");
+
+    # send multiple frames
+
+    for my $i (1 .. 10) {
+        websocket_write($s, ('foo' x 16384) . $i);
+        websocket_write($s, 'bazz' . $i);
+    }
+
+    for my $i (1 .. 10) {
+        like(websocket_read($s), qr/^(bar){16384}\d+$/, "websocket $i");
+        is(websocket_read($s), 'bazz' . $i, "websocket small $i");
+    }
+}
+
+# establish websocket connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+undef $s;
+$s = websocket_connect("foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+    skip "handshake failed", 2 unless $s;
+
+    is(websocket_read($s), "bar", "response pipelined");
+
+    websocket_write($s, "foo");
+    is(websocket_read($s), "bar", "next to pipelined");
+}
+
+###############################################################################
+
+sub websocket_connect {
+    my ($message) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1:' . port(8080)
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    my $h = Protocol::WebSocket::Handshake::Client->new(
+        url => 'ws://localhost');
+
+    # send request, $h->to_string
+
+    my $buf = $h->to_string;
+    $buf .= Protocol::WebSocket::Frame->new($message)->to_bytes
+        if $message;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    log_out($buf);
+    $s->syswrite($buf);
+
+    # read response
+
+    my $got = '';
+    $buf = '';
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_read(1.5)) {
+        my $n = $s->sysread($buf, 1024);
+        last unless $n;
+        log_in($buf);
+        $got .= $buf;
+        last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+    }
+
+    # parse server response
+
+    $h->parse($got);
+
+    # store the rest for later websocket_read()
+    # see websocket_read() for details
+
+    ${*$s}->{_websocket_frame} ||= Protocol::WebSocket::Frame->new();
+    ${*$s}->{_websocket_frame}->append($got);
+
+    return $s if $h->is_done;
+}
+
+sub websocket_write {
+    my ($s, $message) = @_;
+    my $frame = Protocol::WebSocket::Frame->new($message);
+
+    local $SIG{PIPE} = 'IGNORE';
+    $s->blocking(1);
+
+    log_out($frame->to_bytes);
+    $s->syswrite($frame->to_bytes);
+}
+
+sub websocket_read {
+    my ($s) = @_;
+    my ($buf, $got);
+
+    # store frame object in socket itself to simplify things
+    # this works as $s is IO::Handle, see man IO::Handle
+
+    ${*$s}->{_websocket_frame} ||= Protocol::WebSocket::Frame->new();
+    my $frame = ${*$s}->{_websocket_frame};
+
+    $s->blocking(0);
+    $got = $frame->next();
+    return $got if defined $got;
+
+    while (IO::Select->new($s)->can_read(1.5)) {
+        my $n = $s->sysread($buf, 65536);
+        return $got unless $n;
+        log_in($buf);
+        $frame->append($buf);
+        $got = $frame->next();
+        return $got if defined $got;
+    }
+}
+
+###############################################################################
+
+sub websocket_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    while (my $client = $server->accept()) {
+        websocket_handle_client($client);
+    }
+}
+
+sub websocket_handle_client {
+    my ($client) = @_;
+
+    $client->autoflush(1);
+    $client->blocking(0);
+
+    my $poll = IO::Poll->new;
+
+    my $hs = Protocol::WebSocket::Handshake::Server->new;
+    my $frame = Protocol::WebSocket::Frame->new;
+    my $buffer = '';
+    my $closed;
+    my $n;
+
+    log2c("(new connection $client)");
+
+    while (1) {
+        $poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+        my $p = $poll->poll(0.5);
+        log2c("(poll $p)");
+
+        foreach ($poll->handles(POLLIN)) {
+            $n = $client->sysread(my $chunk, 65536);
+            return unless $n;
+
+            log2i($chunk);
+
+            if (!$hs->is_done) {
+                unless (defined $hs->parse($chunk)) {
+                    log2c("(error: " . $hs->error . ")");
+                    return;
+                }
+
+                if ($hs->is_done) {
+                    $buffer = $hs->to_string;
+                    log2o($buffer);
+                }
+
+                log2c("(parse: $chunk)");
+            }
+
+            $frame->append($chunk);
+
+            while (defined(my $message = $frame->next)) {
+                my $f;
+
+                if ($frame->is_close) {
+                    log2c("(close frame)");
+                    $closed = 1;
+                    $f = $frame->new(type => 'close')
+                        ->to_bytes;
+                } else {
+                    $message =~ s/foo/bar/g;
+                    $f = $frame->new($message)->to_bytes;
+                }
+
+                log2o($f);
+                $buffer .= $f;
+            }
+        }
+
+        foreach my $writer ($poll->handles(POLLOUT)) {
+            next unless length $buffer;
+            $n = $writer->syswrite($buffer);
+            substr $buffer, 0, $n, '';
+        }
+
+        if ($closed && length $buffer == 0) {
+            log2c("(closed)");
+            return;
+        }
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/proxy_xar.t ../asynch_mode_nginx/test/nginx-tests/proxy_xar.t
--- nginx-release-1.20.1/test/nginx-tests/proxy_xar.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/proxy_xar.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,125 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for proxy X-Accel-Redirect functionality.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        # catch safe and unhandled unsafe URIs,
+        # bypassed with redirect to named location
+        if ($upstream_http_x_accel_redirect) {
+            return 200 "xar: $upstream_http_x_accel_redirect uri: $uri
+                        method: $request_method";
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/return-xar;
+        }
+        location /return-xar {
+            add_header  X-Accel-Redirect     $arg_xar;
+
+            # this headers will be preserved on
+            # X-Accel-Redirect
+
+            add_header  Content-Type         text/blah;
+            add_header  Set-Cookie           blah=blah;
+            add_header  Content-Disposition  attachment;
+            add_header  Cache-Control        no-cache;
+            add_header  Expires              fake;
+            add_header  Accept-Ranges        parrots;
+
+            # others won't be
+            add_header  Something            other;
+
+            return 204;
+        }
+        location @named {
+            return 200 "named xar: $upstream_http_x_accel_redirect uri: $uri";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $r = http_get('/proxy?xar=/index.html');
+like($r, qr/xar: \/index.html uri: \/index.html/, 'X-Accel-Redirect works');
+like($r, qr/^Content-Type: text\/blah/m, 'Content-Type preserved');
+like($r, qr/^Set-Cookie: blah=blah/m, 'Set-Cookie preserved');
+like($r, qr/^Content-Disposition: attachment/m, 'Content-Disposition preserved');
+like($r, qr/^Cache-Control: no-cache/m, 'Cache-Control preserved');
+like($r, qr/^Expires: fake/m, 'Expires preserved');
+like($r, qr/^Accept-Ranges: parrots/m, 'Accept-Ranges preserved');
+unlike($r, qr/^Something/m, 'other headers stripped');
+
+like(http_post('/proxy?xar=/index.html'), qr/method: GET/,
+    'X-Accel-Redirect method name');
+
+# escaped characters
+
+like(http_get('/proxy?xar=/foo?bar'), qr/200 OK.*xar: \/foo\?bar/s,
+    'X-Accel-Redirect value unchanged');
+unlike(http_get('/proxy?xar=..'), qr/200 OK/,
+    'X-Accel-Redirect unsafe dotdot');
+unlike(http_get('/proxy?xar=../foo'), qr/200 OK/,
+    'X-Accel-Redirect unsafe dotdotsep');
+unlike(http_get('/proxy?xar=/foo/..'), qr/200 OK/,
+    'X-Accel-Redirect unsafe sepdotdot');
+unlike(http_get('/proxy?xar=/foo/.%2e'), qr/200 OK/,
+    'X-Accel-Redirect unsafe unescaped');
+like(http_get('/proxy?xar=/foo%20bar'), qr/uri: \/foo bar/,
+    'X-Accel-Redirect unescaped');
+
+like(http_get('/proxy?xar=@named'),
+    qr!200 OK.*named xar: \@named uri: /proxy!s, 'in named location');
+
+###############################################################################
+
+sub http_post {
+    my ($url) = @_;
+    http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/random_index.t ../asynch_mode_nginx/test/nginx-tests/random_index.t
--- nginx-release-1.20.1/test/nginx-tests/random_index.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/random_index.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for random index module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http random_index symlink/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            random_index on;
+        }
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+mkdir("$d/x");
+mkdir("$d/x/test-dir");
+symlink("$d/x/test-dir", "$d/x/test-dir-link");
+
+$t->write_file('test-file', 'RIGHT');
+symlink("$d/test-file", "$d/x/test-file-link");
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/x/'), qr/RIGHT/s, 'file');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/range_charset.t ../asynch_mode_nginx/test/nginx-tests/range_charset.t
--- nginx-release-1.20.1/test/nginx-tests/range_charset.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/range_charset.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,117 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for range filter on proxied response with charset.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache charset/)->plan(10)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    proxy_cache_path   %%TESTDIR%%/cache  levels=1:2
+                       keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_cache   NAME;
+            proxy_cache_valid 200 1m;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        charset B;
+
+        location /t2.html {
+            add_header X-Accel-Charset A;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# range request on proxied response with charset attribute in content-type
+# NB: to get partial content, requests need to be served from cache
+
+http_get('/t1.html');
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, 10-19');
+like($t1, qr/ 206 /, 'charset - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=\w+\x0d\x0a/,
+    'charset - content type');
+like($t1, qr/Content-Type: text\/html; charset=B(?!; charset)/,
+    'charset - charset attribute');
+like($t1, qr/X000XXXXXX/m, 'charset - content 0-9');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'charset - content 10-19');
+
+http_get('/t2.html');
+$t1 = http_get_range('/t2.html', 'Range: bytes=0-9, 10-19');
+like($t1, qr/ 206 /, 'x-accel-charset - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=\w+\x0d\x0a/,
+    'x-accel-charset - content type');
+like($t1, qr/Content-Type: text\/html; charset=A(?!; charset)/,
+    'x-accel-charset - charset attribute');
+like($t1, qr/Y000YYYYYY/m, 'x-accel-charset - content 0-9');
+like($t1, qr/Y001YYYYYY\x0d?$/m, 'x-accel-charset - content 10-19');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/range_flv.t ../asynch_mode_nginx/test/nginx-tests/range_flv.t
--- nginx-release-1.20.1/test/nginx-tests/range_flv.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/range_flv.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http flv/)->plan(12);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            flv;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.flv',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# FLV has 13 byte header at start.
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=0-9');
+like($t1, qr/ 206 /, 'first bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'first bytes - correct length');
+like($t1, qr/Content-Range: bytes 0-9\/913/, 'first bytes - content range');
+like($t1, qr/^FLV.{7}$/m, 'first bytes - correct content');
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes 903-912\/913/,
+    'final bytes - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes - correct content');
+
+$t1 = http_get_range('/t1.flv?start=100', 'Range: bytes=0-99');
+like($t1, qr/ 206 /, 'multi buffers - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multi buffers - content length');
+like($t1, qr/Content-Range: bytes 0-99\/913/, 'multi buffers - content range');
+like($t1, qr/^FLV.{10}X010XXXXXX(X01[1-7]XXXXXX){7}X018XXX$/m,
+    'multi buffers - correct content');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/range_if_range.t ../asynch_mode_nginx/test/nginx-tests/range_if_range.t
--- nginx-release-1.20.1/test/nginx-tests/range_if_range.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/range_if_range.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for range filter module with If-Range header.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t2.html {
+            add_header Last-Modified "";
+        }
+
+        location /t3.html {
+            add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t3.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+# If-Range
+
+$t1 = http_get_range('/t1.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range wrong');
+like($t1, qr/Last-Modified: /, 'if-range wrong - last modified');
+
+$t1 =~ m/Last-Modified: (.*)/m;
+my $last = $1;
+
+$t1 = http_get_range('/t1.html', "Range: bytes=0-9\nIf-Range: $last");
+like($t1, qr/ 206 /, 'if-range');
+
+# If-Range + add_header Last-Modified ""
+
+$t1 = http_get_range('/t2.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range notime');
+unlike($t1, qr/Last-Modified: /, 'if-range notime - no last modified');
+
+# If-Range + add_header Last-Modified "Mon, 28 Sep 1970 06:00:00 GMT"
+
+$t1 = http_get_range('/t3.html', "Range: bytes=0-9\nIf-Range: wrong");
+like($t1, qr/200 OK/, 'if-range time wrong');
+like($t1, qr/Last-Modified: Mon, 28 Sep 1970 06:00:00 GMT/,
+    'if-range time wrong - last modified');
+
+$t1 = http_get_range('/t3.html',
+    "Range: bytes=0-9\nIf-Range: Mon, 28 Sep 1970 06:00:00 GMT");
+like($t1, qr/ 206 /, 'if-range time');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/range_mp4.t ../asynch_mode_nginx/test/nginx-tests/range_mp4.t
--- nginx-release-1.20.1/test/nginx-tests/range_mp4.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/range_mp4.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,116 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for mp4 module with range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http mp4/)->has_daemon('ffmpeg');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            mp4;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no lavfi')
+    unless grep /lavfi/, `ffmpeg -nostdin -loglevel quiet -formats`;
+system('ffmpeg -loglevel quiet -y '
+    . '-f lavfi -i testsrc=duration=10:size=320x200:rate=15 '
+    . "-pix_fmt yuv420p -c:v libx264 ${\($t->testdir())}/test.mp4") == 0
+    or die "Can't create mp4 file: $!";
+
+$t->run()->plan(13);
+
+###############################################################################
+
+# simply ensure that mp4 start argument works, we rely on this in range tests
+
+my $fsz0 = http_head('/test.mp4') =~ /Content-Length: (\d+)/ && $1;
+my $fsz = http_head('/test.mp4?start=1') =~ /Content-Length: (\d+)/ && $1;
+isnt($fsz0, $fsz, 'mp4 start argument works');
+
+my $t1;
+
+# MP4 has minimally 16 byte ftyp object at start
+
+my $start = $fsz - 10;
+my $last = $fsz - 1;
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-9');
+like($t1, qr/ 206 /, 'first bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'first bytes - content length');
+like($t1, qr/Content-Range: bytes 0-9\/$fsz/, 'first bytes - content range');
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes $start-$last\/$fsz/,
+    'final bytes - content range');
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-99');
+like($t1, qr/ 206 /, 'multi buffers - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multi buffers - content length');
+like($t1, qr/Content-Range: bytes 0-99\/$fsz/,
+    'multi buffers - content range');
+
+TODO: {
+local $TODO = 'multipart range on mp4';
+
+$t1 = http_get_range('/test.mp4?start=1', 'Range: bytes=0-10,11-99');
+like($t1, qr/ 206 /, 'multipart range - 206 partial reply');
+like($t1, qr/Content-Length: 100/, 'multipart range - content length');
+like($t1, qr/Content-Range: bytes 0-10,11-99\/$fsz/,
+    'multipart range - content range');
+
+}
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+HEAD $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/range.t ../asynch_mode_nginx/test/nginx-tests/range.t
--- nginx-release-1.20.1/test/nginx-tests/range.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/range.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,171 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for range filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http charset/)->plan(41);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    charset_map B A {
+        58 59; # X -> Y
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t2.html {
+            charset A;
+            source_charset B;
+        }
+
+        location /t3.html {
+            max_ranges 2;
+        }
+
+        location /t4.html {
+            max_ranges 0;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t2.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t3.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->write_file('t4.html',
+    join('', map { sprintf "X%03dXXXXXX", $_ } (0 .. 99)));
+$t->run();
+
+###############################################################################
+
+my $t1;
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-8');
+like($t1, qr/ 206 /, 'range request - 206 partial reply');
+like($t1, qr/Content-Length: 9/, 'range request - correct length');
+like($t1, qr/Content-Range: bytes 0-8\/1000/, 'range request - content range');
+like($t1, qr/^X000XXXXX$/m, 'range request - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=-10');
+like($t1, qr/ 206 /, 'final bytes - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+    'final bytes - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=990-');
+like($t1, qr/ 206 /, 'final bytes explicit - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'final bytes explicit - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+    'final bytes explicit - content range');
+like($t1, qr/^X099XXXXXX$/m, 'final bytes explicit - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=990-1990');
+like($t1, qr/ 206 /, 'more than length - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'more than length - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/,
+    'more than length - content range');
+like($t1, qr/^X099XXXXXX$/m, 'more than length - correct content');
+
+$t1 = http_get_range('/t2.html', 'Range: bytes=990-1990');
+like($t1, qr/ 206 /, 'recoded - 206 partial reply');
+like($t1, qr/Content-Length: 10/, 'recoded - content length');
+like($t1, qr/Content-Range: bytes 990-999\/1000/, 'recoded - content range');
+like($t1, qr/^Y099YYYYYY$/m, 'recoded - correct content');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, -10, 10-19');
+like($t1, qr/ 206 /, 'multipart - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=/,
+    'multipart - content type');
+like($t1, qr/X000XXXXXX/m, 'multipart - content 0-9');
+like($t1, qr/^X099XXXXXX\x0d?$/m, 'multipart - content -10 aka 990-999');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'multipart - content 10-19');
+
+$t1 = http_get_range('/t1.html', 'Range: bytes=0-9, -10, 100000-, 10-19');
+like($t1, qr/ 206 /, 'multipart big - 206 partial reply');
+like($t1, qr/Content-Type: multipart\/byteranges; boundary=/,
+    'multipart big - content type');
+like($t1, qr/X000XXXXXX/m, 'multipart big - content 0-9');
+like($t1, qr/^X099XXXXXX\x0d?$/m, 'multipart big - content -10 aka 990-999');
+like($t1, qr/X001XXXXXX\x0d?$/m, 'multipart big - content 10-19');
+
+like(http_get_range('/t1.html', 'Range: bytes=100000-'), qr/ 416 /,
+    'not satisfiable - too big first byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=alpha'), qr/ 416 /,
+    'not satisfiable - alpha in first byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=10-alpha'), qr/ 416 /,
+    'not satisfiable - alpha in last byte pos');
+like(http_get_range('/t1.html', 'Range: bytes=10'), qr/ 416 /,
+    'not satisfiable - no hyphen');
+like(http_get_range('/t1.html', 'Range: bytes=10-11 12-'), qr/ 416 /,
+    'not satisfiable - no comma');
+
+# last-byte-pos is taken to be equal to one less than the current length
+# of the entity-body in bytes -- rfc2616 sec 14.35.
+
+like(http_get_range('/t1.html', 'Range: bytes=0-10001'), qr/ 206 /,
+    'satisfiable - last byte pos adjusted');
+
+# total size of all ranges is greater than source response size
+
+like(http_get_range('/t1.html', 'Range: bytes=0-10001, 0-0'), qr/ 200 /,
+    'not satisfiable - malicious byte ranges');
+
+like(http_get_range('/t3.html', 'Range: bytes=0-9, -10'), qr/ 206 /,
+    'max_ranges not reached');
+like(http_get_range('/t3.html', 'Range: bytes=0-9, -10, 10000-'), qr/ 206 /,
+    'max_ranges not reached bad range');
+unlike(http_get_range('/t3.html', 'Range: bytes=0-9, -10, 10-19'),
+    qr/ 206 /, 'max_ranges reached');
+unlike(http_get_range('/t4.html', 'Range: bytes=0-9'), qr/ 206 /,
+    'max_ranges zero');
+
+###############################################################################
+
+sub http_get_range {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/README ../asynch_mode_nginx/test/nginx-tests/README
--- nginx-release-1.20.1/test/nginx-tests/README	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/README	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,56 @@
+# Copyright (C) Intel, Inc.
+Test suite for nginx.
+
+Use prove to run tests as one usually do for perl tests.  Individual tests
+may be run as well.
+
+Note: tests run nginx (and backend daemons if needed) listening on localhost
+and may use various ports in 8000 .. 8999 range.
+
+Usage:
+
+    $ TEST_NGINX_BINARY=/path/to/nginx prove .
+
+By default tests expect nginx binary to be at ../nginx/objs/nginx.
+
+Environment variables:
+
+TEST_NGINX_BINARY
+
+    Sets path to nginx binary to be tested, defaults to "../nginx/objs/nginx".
+
+TEST_NGINX_MODULES
+
+    Sets path to modules directory, defaults to dirname of TEST_NGINX_BINARY.
+
+TEST_NGINX_VERBOSE
+
+    Be a bit more verbose (in particular, print requests sent and responses
+    got from nginx).  Note that this requires prove -v (or HARNESS_VERBOSE).
+
+TEST_NGINX_LEAVE
+
+    If set, temporary directory with configs and logs won't be deleted on test
+    completion.  Useful for debugging.
+
+TEST_NGINX_CATLOG
+
+    Cat error log to stdout after test completion.  Useful for debugging.
+
+TEST_NGINX_UNSAFE
+
+    Run unsafe tests.
+
+TEST_NGINX_GLOBALS
+
+    Sets additional directives in main context.
+
+TEST_NGINX_GLOBALS_HTTP
+
+    Sets additional directives in http context.
+
+TEST_NGINX_GLOBALS_STREAM
+
+    Sets additional directives in stream context.
+
+Happy testing!
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/realip_hostname.t ../asynch_mode_nginx/test/nginx-tests/realip_hostname.t
--- nginx-release-1.20.1/test/nginx-tests/realip_hostname.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/realip_hostname.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, 'unix:' and hostname in set_real_ip_from.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip proxy unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        location /1 {
+            set_real_ip_from  localhost;
+            add_header X-IP $remote_addr;
+        }
+
+        location /2 {
+            set_real_ip_from  unix:;
+            add_header X-IP $remote_addr;
+        }
+
+        location /unix {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+            proxy_set_header X-Real-IP 192.0.2.1;
+        }
+
+        location /ip {
+            proxy_pass http://127.0.0.1:8080/;
+            proxy_set_header X-Real-IP 192.0.2.1;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/1') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/unix/2'), qr/X-IP: 192.0.2.1/, 'realip unix');
+unlike(http_get('/unix/1'), qr/X-IP: 192.0.2.1/, 'realip unix - no match');
+
+like(http_get('/ip/1'), qr/X-IP: 192.0.2.1/, 'realip hostname');
+unlike(http_get('/ip/2'), qr/X-IP: 192.0.2.1/, 'realip hostname - no match');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/realip_remote_addr.t ../asynch_mode_nginx/test/nginx-tests/realip_remote_addr.t
--- nginx-release-1.20.1/test/nginx-tests/realip_remote_addr.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/realip_remote_addr.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, realip_remote_addr variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    set_real_ip_from  127.0.0.1/32;
+    set_real_ip_from  192.0.2.1/32;
+    real_ip_header    X-Forwarded-For;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP $remote_addr;
+            add_header X-Real-IP $realip_remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('1', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+like(http_get('/1'), qr/X-Real-IP: 127.0.0.1/m, 'request');
+like(http_get('/'), qr/X-Real-IP: 127.0.0.1/m, 'request redirect');
+
+like(http_xff('/1', '192.0.2.1'), qr/X-Real-IP: 127.0.0.1/m, 'realip');
+like(http_xff('/', '192.0.2.1'), qr/X-Real-IP: 127.0.0.1/m, 'realip redirect');
+
+###############################################################################
+
+sub http_xff {
+    my ($uri, $xff) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/realip_remote_port.t ../asynch_mode_nginx/test/nginx-tests/realip_remote_port.t
--- nginx-release-1.20.1/test/nginx-tests/realip_remote_port.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/realip_remote_port.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,98 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for nginx realip module, $realip_remote_port variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    set_real_ip_from  127.0.0.1/32;
+    real_ip_header    X-Forwarded-For;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            add_header X-IP $remote_addr;
+            add_header X-Real-Port $realip_remote_port;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('1', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+my ($sp, $data) = http_sp_get('/1');
+like($data, qr/X-Real-Port: $sp/, 'request');
+
+($sp, $data) = http_sp_get('/');
+like($data, qr/X-Real-Port: $sp/, 'request redirect');
+
+($sp, $data) = http_sp_xff('/1', '127.0.0.1:123');
+like($data, qr/X-Real-Port: $sp/, 'realip');
+
+($sp, $data) = http_sp_xff('/', '127.0.0.1:123');
+like($data, qr/X-Real-Port: $sp/, 'realip redirect');
+
+###############################################################################
+
+sub http_sp_get {
+    my $s = http_get(shift, start => 1);
+    return ($s->sockport(), http_end($s));
+}
+
+sub http_sp_xff {
+    my ($url, $xff) = @_;
+
+    my $s = http(<<EOF, start => 1);
+GET $url HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+
+    return ($s->sockport(), http_end($s));
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/realip.t ../asynch_mode_nginx/test/nginx-tests/realip.t
--- nginx-release-1.20.1/test/nginx-tests/realip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/realip.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx realip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http realip rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    add_header X-IP $remote_addr;
+    set_real_ip_from  127.0.0.1/32;
+    set_real_ip_from  10.0.1.0/24;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /custom {
+            real_ip_header    X-Real-IP-Custom;
+        }
+
+        location /1 {
+            real_ip_header    X-Forwarded-For;
+            real_ip_recursive off;
+        }
+
+        location /2 {
+            real_ip_header    X-Forwarded-For;
+            real_ip_recursive on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        return 204;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('custom', '');
+$t->write_file('1', '');
+$t->write_file('2', '');
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(8);
+
+###############################################################################
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip');
+GET / HTTP/1.0
+Host: localhost
+X-Real-IP: 192.0.2.1
+
+EOF
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip custom');
+GET /custom HTTP/1.0
+Host: localhost
+X-Real-IP-Custom: 192.0.2.1
+
+EOF
+
+like(http_xff('/1', '10.0.0.1, 192.0.2.1'), qr/^X-IP: 192.0.2.1/m,
+    'realip multi');
+like(http_xff('/1', '192.0.2.1, 10.0.1.1, 127.0.0.1'),
+    qr/^X-IP: 127.0.0.1/m, 'realip recursive off');
+like(http_xff('/2', '10.0.1.1, 192.0.2.1, 127.0.0.1'),
+    qr/^X-IP: 192.0.2.1/m, 'realip recursive on');
+
+like(http(<<EOF), qr/^X-IP: 10.0.1.1/m, 'realip multi xff recursive off');
+GET /1 HTTP/1.0
+Host: localhost
+X-Forwarded-For: 192.0.2.1
+X-Forwarded-For: 127.0.0.1, 10.0.1.1
+
+EOF
+
+like(http(<<EOF), qr/^X-IP: 192.0.2.1/m, 'realip multi xff recursive on');
+GET /2 HTTP/1.0
+Host: localhost
+X-Forwarded-For: 10.0.1.1
+X-Forwarded-For: 192.0.2.1
+X-Forwarded-For: 127.0.0.1
+
+EOF
+
+my $s = IO::Socket::INET->new('127.0.0.1:' . port(8081));
+like(http(<<EOF, socket => $s), qr/ 204 .*192.0.2.1/s, 'realip post read');
+GET / HTTP/1.0
+Host: localhost
+X-Real-IP: 192.0.2.1
+
+EOF
+
+###############################################################################
+
+sub http_xff {
+    my ($uri, $xff) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+Host: localhost
+X-Forwarded-For: $xff
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/referer.t ../asynch_mode_nginx/test/nginx-tests/referer.t
--- nginx-release-1.20.1/test/nginx-tests/referer.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/referer.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,211 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+
+# Tests for referer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http referer rewrite/)->plan(54);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  another;
+
+        valid_referers server_names;
+        return 200 "$host value $invalid_referer";
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  _;
+
+        location / {
+            valid_referers server_names;
+            return 200 "$host value $invalid_referer";
+        }
+        server_name  below;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost ~bar ~^anchoredre$;
+
+        location /blocked {
+            valid_referers blocked www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /none {
+            valid_referers none www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /simple {
+            valid_referers www.example.org;
+            return 200 "value $invalid_referer";
+        }
+        location /regex {
+            valid_referers ~example.org ~(?-i)example.net;
+            return 200 "value $invalid_referer";
+        }
+        location /regex2 {
+            valid_referers ~example.org/uri;
+            return 200 "value $invalid_referer";
+        }
+        location /regex3 {
+            valid_referers ~example.org$;
+            return 200 "value $invalid_referer";
+        }
+        location /uri {
+            valid_referers www.example.org/uri;
+            return 200 "value $invalid_referer";
+        }
+        location /sn {
+            valid_referers server_names;
+            return 200 "value $invalid_referer";
+        }
+        location /sn_blocked {
+            valid_referers blocked server_names;
+            return 200 "value $invalid_referer";
+        }
+        location /wc {
+            valid_referers *.example.com *.example.org www.example.* example.*;
+            return 200 "value $invalid_referer";
+        }
+        location /long {
+            valid_referers ~.*;
+            return 200 "value $invalid_referer";
+        }
+        location /wc2 {
+            valid_referers www.example.*/uri;
+            return 200 "value $invalid_referer";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+ok(valid('/simple', 'http://www.example.org'), 'simple');
+ok(valid('/simple', 'http://www.example.org/uri'), 'simple uri');
+ok(valid('/simple', 'http://www.example.org:' . port(8080) . '/uri'),
+    'simple port uri');
+ok(!valid('/simple', 'localhost'), 'simple invalid');
+ok(valid('/simple', 'https://www.example.org'), 'https');
+ok(!valid('/simple', 'example.com'), 'no scheme');
+ok(!valid('/simple'), 'no none');
+ok(valid('/none'), 'none');
+ok(!valid('/none', ''), 'none empty');
+
+ok(valid('/blocked', 'www.example.org'), 'blocked');
+ok(valid('/blocked', 'www.example.com'), 'blocked 2');
+ok(valid('/blocked', 'http://su'), 'blocked short');
+ok(valid('/blocked', 'foobar'), 'blocked short no scheme');
+ok(valid('/blocked', ''), 'blocked empty');
+
+ok(!valid('/simple', 'foobar'), 'small');
+ok(valid('/simple', 'http://www.example.org/' . 'a' x 256), 'long uri');
+ok(!valid('/simple', 'http://www.example.' . 'a' x 256), 'long hostname');
+ok(!valid('/wc', 'http://example.' . 'a' x 256), 'long hostname wildcard');
+
+ok(valid('/long', 'http://' . 'a' x 255), 'long hostname 255');
+ok(valid('/long', 'http://' . 'a' x 256), 'long hostname 256');
+ok(!valid('/long', 'http://' . 'a' x 257), 'long hostname 257');
+
+ok(valid('/uri', 'http://www.example.org/uri'), 'uri');
+ok(valid('/uri', 'http://www.example.org/urii'), 'uri prefix');
+ok(!valid('/uri', 'http://www.example.org/uRi'), 'uri case');
+ok(valid('/uri', 'http://www.example.org:' . port(8080) . '/urii'), 'uri port');
+ok(!valid('/uri', 'http://www.example.org/ur'), 'uri invalid len');
+ok(!valid('/uri', 'http://www.example.org/urd'), 'uri invalid cmp');
+
+ok(valid('/regex', 'http://www.example.org'), 'regex');
+ok(valid('/regex', 'http://www.eXample.org'), 'regex caseless');
+ok(valid('/regex', 'http://www.example.org/uri'), 'regex uri');
+ok(!valid('/regex', 'http://www.example.com'), 'regex mismatch');
+ok(!valid('/regex', 'http://www.eXample.net'), 'regex case mismatch');
+
+ok(valid('/regex2', 'http://www.example.org/uri'), 'regex 2 uri');
+ok(!valid('/regex2', 'http://www.example.org'), 'regex 2 no uri');
+ok(valid('/regex2', 'http://www.example.org/uRI'), 'regex 2 uri caseless');
+ok(valid('/regex3', 'https://www.eXample.org'), 'regex https');
+
+ok(valid('/sn', 'http://localhost'), 'server_names');
+ok(valid('/sn', 'http://localHost'), 'server_names caseless');
+ok(valid('/sn', 'http://localhost/uri'), 'server_names uri');
+ok(valid('/sn', 'http://foobar'), 'server_names regex');
+ok(valid('/sn', 'http://foobAr'), 'server_names regex caseless');
+ok(valid('/sn', 'http://foobAr/uri'), 'server_names regex caseless uri');
+ok(valid('/sn', 'http://anchoredre/uri'), 'server_names regex anchored');
+ok(valid('/sn', 'http://foobar/uri'), 'server_names regex uri');
+ok(!valid('/sn', 'localhost'), 'server_names no scheme');
+ok(!valid('/sn', 'foobar'), 'server_names regex no scheme');
+ok(valid('/sn_blocked', 'localhost'), 'server_names no scheme blocked');
+
+ok(valid('/wc', 'http://www.example.org'), 'wildcard head');
+ok(valid('/wc', 'http://www.example.net'), 'wildcard tail');
+ok(valid('/wc2', 'http://www.example.net/uri'), 'wildcard uri');
+ok(valid('/wc2', 'http://www.example.net/urii'), 'wildcard uri prefix');
+ok(!valid('/wc2', 'http://www.example.net/uRI'), 'wildcard uri case');
+
+ok(valid('/', 'http://another', 'another'), 'server context');
+
+# server_name below valid_referers
+
+ok(valid('/', 'http://below', 'below'), 'server below');
+
+###############################################################################
+
+sub valid {
+    my ($uri, $referer, $host) = @_;
+    my $text;
+
+    $host = 'localhost' unless defined $host;
+
+    unless (defined $referer) {
+        $text = http_get($uri);
+    } else {
+        $text = http(<<EOF);
+GET $uri HTTP/1.0
+Host: $host
+Referer: $referer
+
+EOF
+    }
+
+    $text =~ /value 1/ && return 0;
+    $text =~ /value/ && return 1;
+    fail("no valid_referers in $uri");
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/request_id.t ../asynch_mode_nginx/test/nginx-tests/request_id.t
--- nginx-release-1.20.1/test/nginx-tests/request_id.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/request_id.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,111 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for request_id variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format id $request_id;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Request-Id $request_id;
+        add_header X-blah blah;
+
+        location / {
+            ssi on;
+        }
+        location /body {
+            return 200 $request_id;
+        }
+        location /log {
+            access_log %%TESTDIR%%/id.log id;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('add.html', '<!--#include virtual="/body" -->');
+$t->run()->plan(12);
+
+###############################################################################
+
+my ($id1) = http_get('/') =~ qr/^X-Request-Id: (.*)\x0d/m;
+my ($id2) = http_get('/') =~ qr/^X-Request-Id: (.*)\x0d/m;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2');
+
+isnt($id1, $id2, 'different id');
+
+# same request
+
+($id1, $id2) = http_get('/body')
+    =~ qr/^X-Request-Id: (.*?)\x0d.*\x0d\x0a(.*)/ms;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - same');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - same');
+
+is($id1, $id2, 'equal id - same');
+
+# subrequest
+
+($id1, $id2) = http_get('/add.html')
+    =~ qr/^X-Request-Id: (.*?)\x0d.*\x0d\x0a(.*)/ms;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - sub');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - sub');
+
+is($id1, $id2, 'equal id - sub');
+
+# log
+
+($id1) = http_get('/log') =~ qr/^X-Request-Id: (.*)\x0d/m;
+
+$t->stop();
+
+$id2 = $t->read_file('/id.log');
+chomp $id2;
+
+like($id1, qr/^[a-z0-9]{32}$/, 'format id 1 - log');
+like($id2, qr/^[a-z0-9]{32}$/, 'format id 2 - log');
+
+is($id1, $id2, 'equal id - log');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/rewrite_if.t ../asynch_mode_nginx/test/nginx-tests/rewrite_if.t
--- nginx-release-1.20.1/test/nginx-tests/rewrite_if.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/rewrite_if.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,196 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for rewrite "if" condition.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(33)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            if ($arg_c) {
+                return 204;
+            }
+        }
+
+        location /sp {
+            if ( $arg_c ) {
+                return 204;
+            }
+        }
+
+        location /eq {
+            if ($arg_c = 1) {
+                return 204;
+            }
+        }
+
+        location /not {
+            if ($arg_c != 2) {
+                return 204;
+            }
+        }
+
+        location /pos {
+            if ($arg_c ~ foo) {
+                return 204;
+            }
+        }
+
+        location /cpos {
+            if ($arg_c ~* foo) {
+                return 204;
+            }
+        }
+
+        location /neg {
+            if ($arg_c !~ foo) {
+                return 204;
+            }
+        }
+
+        location /cneg {
+            if ($arg_c !~* foo) {
+                return 204;
+            }
+        }
+
+        location /plain {
+            if (-f %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /dir {
+            if (-d %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /exist {
+            if (-e %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /exec {
+            if (-x %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_plain {
+            if (!-f %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_dir {
+            if (!-d %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_exist {
+            if (!-e %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+
+        location /not_exec {
+            if (!-x %%TESTDIR%%/$arg_c) {
+                return 204;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('file', '');
+mkdir($t->testdir() . '/dir');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/?c=1'), qr/ 204 /, 'var');
+unlike(http_get('/?c=0'), qr/ 204 /, 'false');
+like(http_get('/sp?c=1'), qr/ 204 /, 'spaces');
+
+like(http_get('/eq?c=1'), qr/ 204 /, 'equal');
+unlike(http_get('/eq?c=2'), qr/ 204 /, 'equal false');
+like(http_get('/not?c=1'), qr/ 204 /, 'not equal');
+unlike(http_get('/not?c=2'), qr/ 204 /, 'not equal false');
+
+like(http_get('/pos?c=food'), qr/ 204 /, 'match');
+like(http_get('/cpos?c=FooD'), qr/ 204 /, 'match case');
+like(http_get('/neg?c=FooD'), qr/ 204 /, 'match negative');
+like(http_get('/cneg?c=bar'), qr/ 204 /, 'match negative case');
+
+unlike(http_get('/pos?c=FooD'), qr/ 204 /, 'mismatch');
+unlike(http_get('/cpos?c=bar'), qr/ 204 /, 'mismatch case');
+unlike(http_get('/neg?c=food'), qr/ 204 /, 'mismatch negative');
+unlike(http_get('/cneg?c=FooD'), qr/ 204 /, 'mismatch negative case');
+
+like(http_get('/plain?c=file'), qr/ 204 /, 'plain file');
+unlike(http_get('/plain?c=dir'), qr/ 204 /, 'plain dir');
+unlike(http_get('/not_plain?c=file'), qr/ 204 /, 'not plain file');
+like(http_get('/not_plain?c=dir'), qr/ 204 /, 'not plain dir');
+
+unlike(http_get('/dir/?c=file'), qr/ 204 /, 'directory file');
+like(http_get('/dir?c=dir'), qr/ 204 /, 'directory dir');
+like(http_get('/not_dir?c=file'), qr/ 204 /, 'not directory file');
+unlike(http_get('/not_dir?c=dir'), qr/ 204 /, 'not directory dir');
+
+like(http_get('/exist?c=file'), qr/ 204 /, 'exist file');
+like(http_get('/exist?c=dir'), qr/ 204 /, 'exist dir');
+unlike(http_get('/exist?c=nx'), qr/ 204 /, 'exist non-existent');
+unlike(http_get('/not_exist?c=file'), qr/ 204 /, 'not exist file');
+unlike(http_get('/not_exist?c=dir'), qr/ 204 /, 'not exist dir');
+like(http_get('/not_exist?c=nx'), qr/ 204 /, 'not exist non-existent');
+
+SKIP: {
+skip 'no exec on win32', 4 if $^O eq 'MSWin32';
+
+unlike(http_get('/exec?c=file'), qr/ 204 /, 'executable file');
+like(http_get('/exec?c=dir'), qr/ 204 /, 'executable dir');
+like(http_get('/not_exec?c=file'), qr/ 204 /, 'not executable file');
+unlike(http_get('/not_exec?c=dir'), qr/ 204 /, 'not executable dir');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/rewrite_set.t ../asynch_mode_nginx/test/nginx-tests/rewrite_set.t
--- nginx-release-1.20.1/test/nginx-tests/rewrite_set.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/rewrite_set.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for rewrite set.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite ssi/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssi on;
+
+        location /t1 {
+            set $http_foo "set_foo";
+            return 200 'X<!--#echo var="http_foo" -->X';
+        }
+
+        location /t2 {
+            return 200 'X<!--#echo var="http_bar" -->X';
+        }
+
+        location /t3 {
+            return 200 'X<!--#echo var="http_baz" -->X';
+        }
+
+        location /t4 {
+            set $http_connection "bar";
+            return 200 "X${http_connection}X\n";
+        }
+
+        # set in other context
+        location /other {
+            set $http_bar "set_bar";
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+# prefixed variables
+
+like(http_get_extra('/t1.html', 'Foo: http_foo'), qr/Xset_fooX/,
+    'set in this context');
+like(http_get_extra('/t2.html', 'Bar: http_bar'), qr/Xhttp_barX/,
+    'set in other context');
+
+like(http_get_extra('/t3.html', 'Baz: http_baz'), qr/Xhttp_bazX/, 'not set');
+
+like(http_get('/t4.html'), qr/XbarX/, 'set get in return');
+
+###############################################################################
+
+sub http_get_extra {
+    my ($uri, $extra) = @_;
+    return http(<<EOF);
+GET $uri HTTP/1.0
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/rewrite.t ../asynch_mode_nginx/test/nginx-tests/rewrite.t
--- nginx-release-1.20.1/test/nginx-tests/rewrite.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/rewrite.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,250 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for rewrite module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite proxy/)->plan(23)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            rewrite ^ http://example.com/ redirect;
+        }
+
+        location /add {
+            rewrite ^ http://example.com/?c=d redirect;
+        }
+
+        location /no {
+            rewrite ^ http://example.com/?c=d? redirect;
+        }
+
+        location /return204 {
+            return 204;
+        }
+
+        location /return200 {
+            return 200;
+        }
+
+        location /return306 {
+            return 306;
+        }
+
+        location /return405 {
+            return 405;
+        }
+
+        location /error404return405 {
+            error_page 404 /return405;
+            return 404;
+        }
+
+        location /error405return204 {
+            error_page 405 /return204;
+            return 405;
+        }
+
+        location /error405return200 {
+            error_page 405 /return200;
+            return 405;
+        }
+
+        location /return200text {
+            return 200 "text";
+        }
+
+        location /return404text {
+            return 404 "text";
+        }
+
+        location /return302text {
+            return 302 "text";
+        }
+
+        location /error405return200text {
+            error_page 405 /return200text;
+            return 405;
+        }
+
+        location /error302return200text {
+            error_page 302 /return200text;
+            return 302 "text";
+        }
+
+        location /error405return302text {
+            error_page 405 /return302text;
+            return 405;
+        }
+
+        location /error405rewrite {
+            error_page 405 /;
+            return 405;
+        }
+
+        location /error405directory {
+            error_page 405 /directory;
+            return 405;
+        }
+
+        location /directory {
+        }
+
+        location /capture {
+            rewrite ^(.*) $1?c=d;
+            return 200 "uri:$uri args:$args";
+        }
+
+        location /capturedup {
+            rewrite ^(.*) $1?c=$1;
+            return 200 "uri:$uri args:$args";
+        }
+
+        location /break {
+            rewrite ^ /return200;
+            break;
+            proxy_pass http://127.0.0.1:8080/return204;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr!^Location: http://example.com/\x0d?$!ms, 'simple');
+like(http_get('/?a=b'), qr!^Location: http://example.com/\?a=b\x0d?$!ms,
+    'simple with args');
+like(http_get('/add'), qr!^Location: http://example.com/\?c=d\x0d?$!ms,
+    'add args');
+
+like(http_get('/add?a=b'), qr!^Location: http://example.com/\?c=d&a=b\x0d?$!ms,
+    'add args with args');
+
+like(http_get('/no?a=b'), qr!^Location: http://example.com/\?c=d\x0d?$!ms,
+    'no args with args');
+
+like(http_get('/return204'), qr!204 No Content!, 'return 204');
+like(http_get('/return200'), qr!200 OK!, 'return 200');
+like(http_get('/return306'), qr!HTTP/1.1 306 !, 'return 306');
+like(http_get('/return405'), qr!HTTP/1.1 405.*body!ms, 'return 405');
+
+# this used to result in 404, but was changed in 1.15.4
+# to respond with 405 instead, much like a real error would do
+
+like(http_get('/error404return405'), qr!HTTP/1.1 405!, 'error 404 return 405');
+
+# status code should be 405, and entity body is expected (vs. normal 204
+# replies which doesn't expect to have body); use HTTP/1.1 for test
+# to make problem clear
+
+my $r = http(<<EOF);
+GET /error405return204 HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+like($r, qr/HTTP\/1.1 405.*(Content-Length|\x0d\0a0\x0d\x0a)/ms,
+    'error 405 return 204');
+
+# the same test, but with return 200.  this doesn't have special
+# handling and returns builtin error page body (the same problem as
+# in /error405return200text below)
+
+like(http_get('/error405return200'), qr/HTTP\/1.1 405(?!.*body)/ms,
+    'error 405 return 200');
+
+# tests involving return with two arguments, as introduced in
+# 0.8.42
+
+like(http_get('/return200text'), qr!text\z!, 'return 200 text');
+like(http_get('/return404text'), qr!text\z!, 'return 404 text');
+
+like(http_get('/error405return200text'), qr!HTTP/1.1 405.*text\z!ms,
+    'error 405 to return 200 text');
+
+# return 302 is somewhat special: it adds Location header instead of
+# body text.  additionally it doesn't sent reply directly (as it's done for
+# other returns since 0.8.42) but instead returns NGX_HTTP_* code
+
+like(http_get('/return302text'), qr!HTTP/1.1 302.*Location: text!ms,
+    'return 302 text');
+
+like(http_get('/error302return200text'),
+    qr!HTTP/1.1 302.*Location: text.*text\z!ms,
+    'error 302 return 200 text');
+
+# in contrast to other return's this shouldn't preserve original status code
+# from error, and the same applies to "rewrite ... redirect" as an error
+# handler; both should in line with e.g. directory redirect as well
+
+like(http_get('/error405return302text'),
+    qr!HTTP/1.1 302.*Location: text!ms,
+    'error 405 return 302 text');
+
+like(http_get('/error405rewrite'),
+    qr!HTTP/1.1 302.*Location: http://example.com/!ms,
+    'error 405 rewrite redirect');
+
+like(http_get('/error405directory'),
+    qr!HTTP/1.1 301.*Location: http://!ms,
+    'error 405 directory redirect');
+
+# escaping of uri if there are args added in rewrite, and length
+# is actually calculated (ticket #162)
+
+like(http_get('/capture/%25?a=b'),
+    qr!^uri:/capture/% args:c=d&a=b$!ms,
+    'escape with added args');
+
+like(http_get('/capturedup/%25?a=b'),
+    qr!^uri:/capturedup/% args:c=/capturedup/%25&a=b$!ms,
+    'escape with added args');
+
+# break
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.8');
+
+like(http_get('/break'), qr/200/, 'valid_location reset');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/rewrite_unescape.t ../asynch_mode_nginx/test/nginx-tests/rewrite_unescape.t
--- nginx-release-1.20.1/test/nginx-tests/rewrite_unescape.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/rewrite_unescape.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,164 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for escaping/unescaping in rewrite module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /t1 {
+            rewrite ^ $arg_r? redirect;
+        }
+
+        location /t2 {
+            rewrite ^ http://example.com$request_uri? redirect;
+        }
+
+        location /t3 {
+            rewrite ^ http://example.com$uri redirect;
+        }
+
+        location /t4 {
+            rewrite ^(.*) http://example.com$1 redirect;
+        }
+
+        location /t5 {
+            rewrite ^ http://example.com/blah%20%3Fblah redirect;
+        }
+
+        location /t6 {
+            rewrite ^ http://example.com/blah%20%2Fblah redirect;
+        }
+    }
+}
+
+EOF
+
+mkdir($t->testdir() . '/directory');
+
+$t->run();
+
+###############################################################################
+
+# Some rewrites and expected (?) behaviour
+#
+# /t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com/?from
+# got:      http://example.com/?from
+#
+# /t1?r=http%3A%2F%2Fexample.com%0D%0Asplit
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com%0D%0Asplit
+# got:      http://example.com%0D%0Asplit
+#
+# /t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom%3Dblah
+# rewrite ^ $arg_r? redirect;
+# expected: http://example.com/?from=blah
+# got:      http://example.com/?from%3Dblah
+#
+# /blah%3Fblah
+# rewrite ^ http://example.com$request_uri? redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /blah%3Fblah
+# rewrite ^ http://example.com$uri redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /blah%3Fblah
+# rewrite ^(.*) http://example.com$1 redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+# /
+# rewrite ^ http://example.com/blah%3Fblah redirect;
+# expected: http://example.com/blah%3Fblah
+# got:      http://example.com/blah?blah
+#
+
+location('/t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom',
+    'http://example.com/?from', 'escaped argument');
+
+location('/t1?r=http%3A%2F%2Fexample.com%0D%0Asplit',
+    'http://example.com%0D%0Asplit', 'escaped argument header splitting');
+
+TODO: {
+local $TODO = 'not yet';
+
+# Fixing this cases will require major changes to the whole approach and
+# likely to break some currently working cases.  On the other hand, current
+# behaviour is far from acceptable.  Should be carefully thought.
+
+location('/t1?r=http%3A%2F%2Fexample.com%2F%3Ffrom%3Dblah',
+    'http://example.com/?from=blah', 'escaped argument with complex query');
+
+location('/t2/blah%20%3Fblah',
+    'http://example.com/t2/blah%20%3Fblah', 'escaped $request_uri');
+
+location('/t3/blah%20%3Fblah',
+    'http://example.com/t3/blah%20%3Fblah', 'escaped $uri');
+
+location('/t4/blah%20%3Fblah',
+    'http://example.com/t4/blah%20%3Fblah', 'escaped $1');
+
+location('/t5',
+    'http://example.com/blah%20%3Fblah', 'escaped static');
+
+location('/t5?arg=blah',
+    'http://example.com/blah%20%3Fblah?arg=blah',
+    'escaped static with argument');
+
+location('/t6',
+    'http://example.com/blah%20%2Fblah', 'escaped static slash');
+
+}
+
+###############################################################################
+
+sub location {
+    my ($url, $value, $name) = @_;
+    my $data = http_get($url);
+    if ($data !~ qr!^Location: (.*?)\x0d?$!ms) {
+        fail($name);
+        return;
+    }
+    my $location = $1;
+    is($location, $value, $name);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi_body.t ../asynch_mode_nginx/test/nginx-tests/scgi_body.t
--- nginx-release-1.20.1/test/nginx-tests/scgi_body.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi_body.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,134 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for scgi backend with chunked request body.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+
+like(http_get('/'), qr/X-Body: /, 'scgi no body');
+
+like(http_get_length('/', ''), qr/X-Body: /, 'scgi empty body');
+like(http_get_length('/', 'foobar'), qr/X-Body: foobar/, 'scgi body');
+
+like(http(<<EOF), qr/X-Body: foobar/, 'scgi chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+6
+foobar
+0
+
+EOF
+
+like(http(<<EOF), qr/X-Body: /, 'scgi empty chunked');
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+Transfer-Encoding: chunked
+
+0
+
+EOF
+
+###############################################################################
+
+sub http_get_length {
+    my ($url, $body) = @_;
+    my $length = length $body;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+Content-Length: $length
+
+$body
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+    my $body;
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+
+        read($request->connection, $body,
+            $request->env->{CONTENT_LENGTH});
+
+        $request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+X-Body: $body
+
+SEE-THIS
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi_cache.t ../asynch_mode_nginx/test/nginx-tests/scgi_cache.t
--- nginx-release-1.20.1/test/nginx-tests/scgi_cache.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi_cache.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for scgi_cache.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi cache/)->plan(10)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    scgi_cache_path  %%TESTDIR%%/cache  keys_zone=one:1m;
+    scgi_cache_key   $request_uri;
+
+    add_header       X-Cache-Status  $upstream_cache_status;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $uri;
+            scgi_cache one;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/len'), qr/MISS/, 'length');
+like(http_get('/len'), qr/HIT/, 'length cached');
+
+like(http_get('/nolen'), qr/MISS/, 'no length');
+like(http_get('/nolen'), qr/HIT/, 'no length cached');
+
+like(http_get('/len/empty'), qr/MISS/, 'empty length');
+like(http_get('/len/empty'), qr/HIT/, 'empty length cached');
+
+like(http_get('/nolen/empty'), qr/MISS/, 'empty no length');
+like(http_get('/nolen/empty'), qr/HIT/, 'empty no length cached');
+
+like(http_get('/unfinished'), qr/MISS/, 'unfinished');
+like(http_get('/unfinished'), qr/MISS/, 'unfinished not cached');
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+    my %count;
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+
+        my $uri = $request->env->{REQUEST_URI} || '';
+        my $c = $request->connection();
+
+        $count{$uri} ||= 0;
+        $count{$uri}++;
+
+        if ($uri eq '/len') {
+            $c->print(
+                "Content-Length: 9" . CRLF .
+                "Content-Type: text/html" . CRLF .
+                "Cache-Control: max-age=300" . CRLF . CRLF .
+                "test body"
+            );
+
+        } elsif ($uri eq '/nolen') {
+            $c->print(
+                "Content-Type: text/html" . CRLF .
+                "Cache-Control: max-age=300" . CRLF . CRLF .
+                "test body"
+            );
+
+        } elsif ($uri eq '/len/empty') {
+            $c->print(
+                "Content-Length: 0" . CRLF .
+                "Content-Type: text/html" . CRLF .
+                "Cache-Control: max-age=300" . CRLF . CRLF
+            );
+
+        } elsif ($uri eq '/nolen/empty') {
+            $c->print(
+                "Content-Type: text/html" . CRLF .
+                "Cache-Control: max-age=300" . CRLF . CRLF
+            );
+
+        } elsif ($uri eq '/unfinished') {
+            $c->print(
+                "Content-Length: 10" . CRLF .
+                "Content-Type: text/html" . CRLF .
+                "Cache-Control: max-age=300" . CRLF . CRLF
+            );
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi_extra_data.t ../asynch_mode_nginx/test/nginx-tests/scgi_extra_data.t
--- nginx-release-1.20.1/test/nginx-tests/scgi_extra_data.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi_extra_data.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,225 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Test for scgi backend with extra data.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()
+    ->has(qw/http scgi cache rewrite addition/)->plan(22)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    scgi_param SCGI 1;
+    scgi_param REQUEST_URI $request_uri;
+    scgi_param REQUEST_METHOD $request_method;
+
+    scgi_cache_path cache keys_zone=one:1m;
+    scgi_cache_key $request_uri;
+    scgi_cache_valid any 1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            add_after_body /after;
+        }
+
+        location /unbuf/ {
+            scgi_pass 127.0.0.1:8081;
+            scgi_buffering off;
+            add_after_body /after;
+        }
+
+        location /head/ {
+            scgi_pass 127.0.0.1:8081;
+            scgi_cache one;
+            add_after_body /after;
+        }
+
+        location /after {
+            return 200 ":after\n";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/, 'response with extra data');
+like(http_get('/short'), qr/SEE-THIS(?!.*:after)/s, 'too short response');
+like(http_get('/empty'), qr/200 OK(?!.*:after)/s, 'empty too short response');
+
+}
+
+like(http_head('/'), qr/200 OK(?!.*SEE-THIS)/s, 'no data in HEAD');
+like(http_head('/short'), qr/200 OK(?!.*SEE-THIS)/s, 'too short to HEAD');
+like(http_head('/empty'), qr/200 OK/, 'empty response to HEAD');
+
+# unbuffered responses
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/unbuf/'), qr/SEE-THIS(?!-BUT-NOT-THIS)/,
+    'unbuffered with extra data');
+like(http_get('/unbuf/short'), qr/SEE-THIS(?!.*:after)/s,
+    'unbuffered too short response');
+like(http_get('/unbuf/empty'), qr/200 OK(?!.*:after)/s,
+    'unbuffered empty too short response');
+
+}
+
+like(http_head('/unbuf/'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered no data in HEAD');
+like(http_head('/unbuf/short'), qr/200 OK(?!.*SEE-THIS)/s,
+    'unbuffered too short response to HEAD');
+like(http_head('/unbuf/empty'), qr/200 OK/,
+    'unbuffered empty response to HEAD');
+
+# caching of responsses to HEAD requests
+
+like(http_head('/head/empty'), qr/200 OK(?!.*SEE-THIS)/s, 'head no body');
+like(http_head('/head/matching'), qr/200 OK(?!.*SEE-THIS)/s, 'head matching');
+like(http_head('/head/extra'), qr/200 OK(?!.*SEE-THIS)/s, 'head extra');
+like(http_head('/head/short'), qr/200 OK(?!.*SEE-THIS)/s, 'head too short');
+
+like(http_get('/head/empty'), qr/SEE-THIS/, 'head no body cached');
+like(http_get('/head/matching'), qr/SEE-THIS/, 'head matching cached');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/head/extra'), qr/SEE-THIS(?!-BUT-NOT-THIS)/s,
+    'head extra cached');
+like(http_get('/head/short'), qr/SEE-THIS(?!.*:after)/s,
+    'head too short cached');
+
+}
+
+# "zero size buf" alerts (ticket #2117)
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+like(http_get('/zero'), qr/200 OK(?!.*NOT-THIS)/s, 'zero size');
+
+}
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.7');
+
+like(http_get('/unbuf/zero'), qr/200 OK(?!.*NOT-THIS)/s,
+    'unbuffered zero size');
+
+}
+
+$t->todo_alerts() if $t->has_version('1.19.1') and !$t->has_version('1.19.7');
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+    my ($c, $uri, $head);
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+        
+        $uri = $request->env->{REQUEST_URI};
+        $uri =~ s!^/unbuf!!;
+
+        $head = $request->env->{REQUEST_METHOD} eq 'HEAD';
+
+        $c = $request->connection();
+
+        if ($uri eq '/') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS-BUT-NOT-THIS\n");
+
+        } elsif ($uri eq '/zero') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 0\n\n");
+            $c->print("NOT-THIS\n");
+
+        } elsif ($uri eq '/short') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+            $c->print("SEE-THIS-TOO-SHORT-RESPONSE\n");
+
+        } elsif ($uri eq '/empty') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+
+        } elsif ($uri eq '/head/empty') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS") unless $head;
+
+        } elsif ($uri eq '/head/matching') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS");
+
+        } elsif ($uri eq '/head/extra') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 8\n\n");
+            $c->print("SEE-THIS-BUT-NOT-THIS\n");
+
+        } elsif ($uri eq '/head/short') {
+            $c->print("Content-Type: text/html\n");
+            $c->print("Content-Length: 100\n\n");
+            $c->print("SEE-THIS\n");
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi_gzip.t ../asynch_mode_nginx/test/nginx-tests/scgi_gzip.t
--- nginx-release-1.20.1/test/nginx-tests/scgi_gzip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi_gzip.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for scgi backend and gzip.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi gzip/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            gzip on;
+            %%QATZIP_ENABLE%%
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+            scgi_param HTTP_X_BLAH "blah";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_gzip_request('/'), qr/Content-Encoding: gzip/, 'scgi request');
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+
+        $request->connection()->print(<<EOF);
+Content-Type: text/html
+
+SEE-THIS-1234567890-1234567890
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi_merge_params.t ../asynch_mode_nginx/test/nginx-tests/scgi_merge_params.t
--- nginx-release-1.20.1/test/nginx-tests/scgi_merge_params.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi_merge_params.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for scgi_param inheritance.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi cache/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    scgi_cache_path  %%TESTDIR%%/cache  levels=1:2
+                     keys_zone=NAME:1m;
+
+    scgi_cache_key   stub;
+
+    scgi_param SCGI 1;
+    scgi_param HTTP_X_BLAH "blah";
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        scgi_cache  NAME;
+
+        location / {
+            scgi_pass    127.0.0.1:8081;
+        }
+
+        location /no/ {
+            scgi_pass    127.0.0.1:8081;
+            scgi_cache   off;
+        }
+
+        location /custom/ {
+            scgi_pass    127.0.0.1:8081;
+            scgi_param   SCGI 1;
+            scgi_param   HTTP_X_BLAH  "custom";
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get_ims('/'), qr/ims=;/,
+    'if-modified-since cleared with cache');
+like(http_get_ims('/'), qr/iums=;/,
+    'if-unmodified-since cleared with cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+    'custom params with cache');
+
+like(http_get_ims('/no/'), qr/ims=blah;/,
+    'if-modified-since preserved without cache');
+like(http_get_ims('/no/'), qr/iums=blah;/,
+    'if-unmodified-since preserved without cache');
+like(http_get_ims('/'), qr/blah=blah;/,
+    'custom params without cache');
+
+like(http_get_ims('/custom/'), qr/ims=;/,
+    'if-modified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/iums=;/,
+    'if-unmodified-since cleared with cache custom');
+like(http_get_ims('/custom/'), qr/blah=custom;/,
+    'custom params with cache custom');
+
+###############################################################################
+
+sub http_get_ims {
+    my ($url) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Connection: close
+If-Modified-Since: blah
+If-Unmodified-Since: blah
+
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+
+        my $ims = $request->env->{HTTP_IF_MODIFIED_SINCE} || '';
+        my $iums = $request->env->{HTTP_IF_UNMODIFIED_SINCE} || '';
+        my $blah = $request->env->{HTTP_X_BLAH} || '';
+
+        $request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+ims=$ims;iums=$iums;blah=$blah;
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/scgi.t ../asynch_mode_nginx/test/nginx-tests/scgi.t
--- nginx-release-1.20.1/test/nginx-tests/scgi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/scgi.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,145 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for scgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require SCGI; };
+plan(skip_all => 'SCGI not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http scgi/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            scgi_pass 127.0.0.1:8081;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+            scgi_param HTTP_X_BLAH "blah";
+        }
+
+        location /var {
+            scgi_pass $arg_b;
+            scgi_param SCGI 1;
+            scgi_param REQUEST_URI $request_uri;
+        }
+
+    }
+}
+
+EOF
+
+$t->run_daemon(\&scgi_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'scgi request');
+like(http_get('/redir'), qr/ 302 /, 'scgi redirect');
+like(http_get('/'), qr/^3$/m, 'scgi third request');
+
+unlike(http_head('/'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get_headers('/headers'), qr/SEE-THIS/,
+    'scgi request with many ignored headers');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+    'scgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'scgi with variables to upstream');
+
+###############################################################################
+
+sub http_get_headers {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
+
+sub scgi_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $scgi = SCGI->new($server, blocking => 1);
+    my $count = 0;
+
+    while (my $request = $scgi->accept()) {
+        eval { $request->read_env(); };
+        next if $@;
+
+        $count++;
+
+        $request->connection()->print(<<EOF);
+Location: http://localhost/redirect
+Content-Type: text/html
+
+SEE-THIS
+$count
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/secure_link.t ../asynch_mode_nginx/test/nginx-tests/secure_link.t
--- nginx-release-1.20.1/test/nginx-tests/secure_link.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/secure_link.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,192 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx secure_link module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Digest::MD5 qw/ md5 md5_hex /;
+use MIME::Base64 qw/ encode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http secure_link rewrite/)->plan(19);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            # new style
+            # /test.html?hash=BASE64URL
+
+            secure_link      $arg_hash;
+            secure_link_md5  secret$uri;
+
+            # invalid hash
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            # expired
+            if ($secure_link = "0") {
+                return 403;
+            }
+
+            # $secure_link = "1"
+        }
+
+        location = /expires.html {
+            # new style with expires
+            # /test.html?hash=BASE64URL&expires=12345678
+
+            add_header X-Expires $secure_link_expires;
+
+            secure_link      $arg_hash,$arg_expires;
+            secure_link_md5  secret$uri$arg_expires;
+
+            # invalid hash
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            # expired
+            if ($secure_link = "0") {
+                return 403;
+            }
+
+            # $secure_link = "1"
+        }
+
+        location /p/ {
+            # old style
+            # /p/d8e8fca2dc0f896fd7cb4cb0031ba249/test.html
+
+            secure_link_secret secret;
+
+            if ($secure_link = "") {
+                return 403;
+            }
+
+            rewrite ^ /$secure_link break;
+        }
+
+        location /inheritance/ {
+            secure_link_secret secret;
+
+            location = /inheritance/test {
+                secure_link      Xr4ilOzQ4PCOq3aQ0qbuaQ==;
+                secure_link_md5  secret;
+
+                if ($secure_link = "1") {
+                    rewrite ^ /test.html break;
+                }
+
+                return 403;
+            }
+        }
+
+        location /stub {
+            return 200 x$secure_link${secure_link_expires}x;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.html', 'PASSED');
+$t->write_file('expires.html', 'PASSED');
+$t->run();
+
+###############################################################################
+
+# new style
+
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA=='),
+    qr/PASSED/, 'request md5');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA'),
+    qr/PASSED/, 'request md5 no padding');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHAQQ'),
+    qr/^HTTP.*403/, 'request md5 too long');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHA-TOOLONG'),
+    qr/^HTTP.*403/, 'request md5 too long encoding');
+like(http_get('/test.html?hash=BADHASHLENGTH'),
+    qr/^HTTP.*403/, 'request md5 decode error');
+like(http_get('/test.html?hash=q-5vpkjBkRXXtkUMXiJVHX=='),
+    qr/^HTTP.*403/, 'request md5 mismatch');
+like(http_get('/test.html'), qr/^HTTP.*403/, 'request no hash');
+
+# new style with expires
+
+my ($expires, $hash);
+
+$expires = time() + 86400;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+    qr/PASSED/, 'request md5 not expired');
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+    qr/X-Expires: $expires/, 'secure_link_expires variable');
+
+$expires = time() - 86400;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+    qr/^HTTP.*403/, 'request md5 expired');
+
+$expires = 0;
+$hash = encode_base64url(md5("secret/expires.html$expires"));
+like(http_get('/expires.html?hash=' . $hash . '&expires=' . $expires),
+    qr/^HTTP.*403/, 'request md5 invalid expiration');
+
+# old style
+
+like(http_get('/p/' . md5_hex('test.html' . 'secret') . '/test.html'),
+    qr/PASSED/, 'request old style');
+like(http_get('/p/' . md5_hex('fake') . '/test.html'), qr/^HTTP.*403/,
+    'request old style fake hash');
+like(http_get('/p/' . 'foo' . '/test.html'), qr/^HTTP.*403/,
+    'request old style short hash');
+like(http_get('/p/' . 'x' x 32 . '/test.html'), qr/^HTTP.*403/,
+    'request old style corrupt hash');
+like(http_get('/p%2f'), qr/^HTTP.*403/, 'request old style bad uri');
+like(http_get('/p/test.html'), qr/^HTTP.*403/, 'request old style no hash');
+like(http_get('/inheritance/test'), qr/PASSED/, 'inheritance');
+
+like(http_get('/stub'), qr/xx/, 'secure_link not found');
+
+###############################################################################
+
+sub encode_base64url {
+    my $e = encode_base64(shift, "");
+    $e =~ s/=+\z//;
+    $e =~ tr[+/][-_];
+    return $e;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/server_tokens.t ../asynch_mode_nginx/test/nginx-tests/server_tokens.t
--- nginx-release-1.20.1/test/nginx-tests/server_tokens.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/server_tokens.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for server_tokens directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /200 {
+            return 200;
+        }
+
+        location /404 {
+            return 404;
+        }
+
+        location /off {
+            server_tokens off;
+
+            location /off/200 {
+                return 200;
+            }
+
+            location /off/404 {
+                return 404;
+            }
+        }
+
+        location /on {
+            server_tokens on;
+
+            location /on/200 {
+                return 200;
+            }
+
+            location /on/404 {
+                return 404;
+            }
+        }
+
+        location /b {
+            server_tokens build;
+
+            location /b/200 {
+                return 200;
+            }
+
+            location /b/404 {
+                return 404;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->run()->plan(12);
+
+###############################################################################
+
+my $re = qr/nginx\/\d+\.\d+\.\d+/;
+
+like(http_get_server('/200'), $re, 'tokens default 200');
+like(http_get_server('/404'), $re, 'tokens default 404');
+like(http_body('/404'), $re, 'tokens default 404 body');
+
+is(http_get_server('/off/200'), 'nginx', 'tokens off 200');
+is(http_get_server('/off/404'), 'nginx', 'tokens off 404');
+like(http_body('/off/404'), qr/nginx(?!\/)/, 'tokens off 404 body');
+
+like(http_get_server('/on/200'), $re, 'tokens on 200');
+like(http_get_server('/on/404'), $re, 'tokens on 404');
+like(http_body('/on/404'), $re, 'tokens on 404 body');
+
+$re = qr/$re \Q($1)\E/ if $t->{_configure_args} =~ /--build=(\S+)/;
+
+like(http_get_server('/b/200'), $re, 'tokens build 200');
+like(http_get_server('/b/404'), $re, 'tokens build 404');
+like(http_body('/b/404'), $re, 'tokens build 404 body');
+
+###############################################################################
+
+sub http_body {
+    my ($uri) = shift;
+    return http_get($uri) =~ /.*?\x0d\x0a?\x0d\x0a?(.*)/ms && $1;
+}
+
+sub http_get_server {
+    my ($url) = @_;
+    return http_get($url) =~ /^Server:\s(.+?)\x0d?$/mi && $1 || undef;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/slice.t ../asynch_mode_nginx/test/nginx-tests/slice.t
--- nginx-release-1.20.1/test/nginx-tests/slice.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/slice.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,344 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for slice filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy cache fastcgi slice rewrite/)
+    ->plan(79);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path   %%TESTDIR%%/cache  keys_zone=NAME:1m;
+    proxy_cache_path   %%TESTDIR%%/cach3  keys_zone=NAME3:1m;
+    proxy_cache_key    $uri$is_args$args$slice_range;
+
+    fastcgi_cache_path   %%TESTDIR%%/cache2  keys_zone=NAME2:1m;
+    fastcgi_cache_key    $uri$is_args$args$slice_range;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+
+        location /proxy/ {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_set_header   Range  $slice_range;
+        }
+
+        location /cache/ {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_cache   NAME;
+
+            proxy_set_header   Range  $slice_range;
+
+            proxy_cache_valid   200 206  1h;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /fastcgi {
+            slice 2;
+
+            fastcgi_pass    127.0.0.1:8082;
+
+            fastcgi_cache   NAME2;
+
+            fastcgi_param   Range $slice_range;
+
+            fastcgi_cache_valid   200 206  1h;
+
+            fastcgi_force_ranges  on;
+
+            add_header X-Cache-Status $upstream_cache_status;
+        }
+
+        location /cache-redirect {
+            error_page 404 = @fallback;
+        }
+
+        location @fallback {
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/t$is_args$args;
+
+            proxy_cache   NAME3;
+
+            proxy_set_header   Range  $slice_range;
+
+            proxy_cache_valid   200 206  1h;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        add_header Accept-Ranges bytes;
+
+        location / {
+            if ($http_range = "") {
+                set $limit_rate 100;
+        }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t', '0123456789abcdef');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+like(http_get('/cache/nx'), qr/ 404 /, 'not found');
+like(http_get('/cache/t'), qr/ 200 .*0123456789abcdef$/ms, 'no range');
+
+$r = get('/proxy/t', 'Range: bytes=3-4');
+like($r, qr/ 206 /, 'proxy - 206 partial reply');
+like($r, qr/^34$/m, 'proxy - correct content');
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.2');
+
+unlike($r, qr/Accept-Ranges/, 'proxy - no original accept-ranges');
+
+}
+
+$r = get('/cache/t?single', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'single - 206 partial reply');
+like($r, qr/^0$/m, 'single - correct content');
+like($r, qr/Status: MISS/m, 'single - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'single cached - 206 partial reply');
+like($r, qr/^0$/m, 'single cached - correct content');
+like($r, qr/Status: HIT/m, 'single cached - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=1-1");
+like($r, qr/ 206 /, 'single next - 206 partial reply');
+like($r, qr/^1$/m, 'single next - correct content');
+like($r, qr/Status: HIT/m, 'single next - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice next - 206 partial reply');
+like($r, qr/^2$/m, 'slice next - correct content');
+like($r, qr/Status: MISS/m, 'slice next - cache status');
+
+$r = get('/cache/t?single', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice next cached - 206 partial reply');
+like($r, qr/^2$/m, 'slice next cached - correct content');
+like($r, qr/Status: HIT/m, 'slice next cached - cache status');
+
+$r = get('/cache/t?median', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice median - 206 partial reply');
+like($r, qr/^2$/m, 'slice median - correct content');
+like($r, qr/Status: MISS/m, 'slice median - cache status');
+
+$r = get('/cache/t?median', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'before median - 206 partial reply');
+like($r, qr/^0$/m, 'before median - correct content');
+like($r, qr/Status: MISS/m, 'before median - cache status');
+
+# range span to multiple slices
+
+$r = get('/cache/t?range', "Range: bytes=1-2");
+like($r, qr/ 206 /, 'slice range - 206 partial reply');
+like($r, qr/^12$/m, 'slice range - correct content');
+like($r, qr/Status: MISS/m, 'slice range - cache status');
+
+$r = get('/cache/t?range', "Range: bytes=0-0");
+like($r, qr/ 206 /, 'slice 1st - 206 partial reply');
+like($r, qr/^0$/m, 'slice 1st - correct content');
+like($r, qr/Status: HIT/m, 'slice 1st - cache status');
+
+$r = get('/cache/t?range', "Range: bytes=2-2");
+like($r, qr/ 206 /, 'slice 2nd - 206 partial reply');
+like($r, qr/^2$/m, 'slice 2nd - correct content');
+like($r, qr/Status: HIT/m, 'slice 2nd - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=3-4");
+like($r, qr/ 206 /, 'range median - 206 partial reply');
+like($r, qr/^34$/m, 'range median - correct content');
+like($r, qr/Status: MISS/m, 'range median - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=2-3");
+like($r, qr/ 206 /, 'range prev - 206 partial reply');
+like($r, qr/^23$/m, 'range prev - correct content');
+like($r, qr/Status: HIT/m, 'range prev - cache status');
+
+$r = get('/cache/t?mrange', "Range: bytes=4-5");
+like($r, qr/ 206 /, 'range next - 206 partial reply');
+like($r, qr/^45$/m, 'range next - correct content');
+like($r, qr/Status: HIT/m, 'range next - cache status');
+
+$r = get('/cache/t?first', "Range: bytes=2-");
+like($r, qr/ 206 /, 'first bytes - 206 partial reply');
+like($r, qr/^23456789abcdef$/m, 'first bytes - correct content');
+like($r, qr/Status: MISS/m, 'first bytes - cache status');
+
+$r = get('/cache/t?first', "Range: bytes=4-");
+like($r, qr/ 206 /, 'first bytes cached - 206 partial reply');
+like($r, qr/^456789abcdef$/m, 'first bytes cached - correct content');
+like($r, qr/Status: HIT/m, 'first bytes cached - cache status');
+
+# multiple ranges
+# we want 206, but 200 is also fine
+
+$r = get('/cache/t?many', "Range: bytes=3-3,4-4");
+like($r, qr/200 OK/, 'many - 206 partial reply');
+like($r, qr/^0123456789abcdef$/m, 'many - correct content');
+
+$r = get('/cache/t?last', "Range: bytes=-10");
+like($r, qr/206 /, 'last bytes - 206 partial reply');
+like($r, qr/^6789abcdef$/m, 'last bytes - correct content');
+
+# respect not modified and range filters
+
+my ($etag) = http_get('/t') =~ /ETag: (.*)/;
+
+like(get('/cache/t?inm', "If-None-Match: $etag"), qr/ 304 /, 'inm');
+like(get('/cache/t?inm', "If-None-Match: bad"), qr/ 200 /, 'inm bad');
+
+like(get('/cache/t?im', "If-Match: $etag"), qr/ 200 /, 'im');
+like(get('/cache/t?im', "If-Match: bad"), qr/ 412 /, 'im bad');
+
+$r = get('/cache/t?if', "Range: bytes=3-4\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range - 206 partial reply');
+like($r, qr/^34$/m, 'if-range - correct content');
+
+# respect Last-Modified from non-cacheable response with If-Range
+
+my ($lm) = http_get('/t') =~ /Last-Modified: (.*)/;
+$r = get('/proxy/t', "Range: bytes=3-4\nIf-Range: $lm");
+like($r, qr/ 206 /, 'if-range last-modified proxy - 206 partial reply');
+like($r, qr/^34$/m, 'if-range last-modified proxy - correct content');
+
+$r = get('/cache/t?ifb', "Range: bytes=3-4\nIf-Range: bad");
+like($r, qr/ 200 /, 'if-range bad - 200 ok');
+like($r, qr/^0123456789abcdef$/m, 'if-range bad - correct content');
+
+# first slice isn't known
+
+$r = get('/cache/t?skip', "Range: bytes=6-7\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range skip slice - 206 partial reply');
+like($r, qr/^67$/m, 'if-range skip slice - correct content');
+
+$r = get('/cache/t?skip', "Range: bytes=6-7\nIf-Range: $etag");
+like($r, qr/ 206 /, 'if-range skip slice - cached - 206 partial reply');
+like($r, qr/^67$/m, 'if-range skip slice - cached - correct content');
+like($r, qr/HIT/, 'if-range skip bytes - cached - cache status');
+
+$r = get('/cache/t?skip', "Range: bytes=2-3");
+like($r, qr/ 206 /, 'if-range skip slice - skipped - 206 partial reply');
+like($r, qr/^23$/m, 'if-range skip slice - skipped - correct content');
+like($r, qr/MISS/, 'if-range skip bytes - skipped - cache status');
+
+SKIP: {
+    eval { require FCGI; };
+    skip 'FCGI not installed', 5 if $@;
+    skip 'win32', 5 if $^O eq 'MSWin32';
+
+    $t->run_daemon(\&fastcgi_daemon);
+    $t->waitforsocket('127.0.0.1:' . port(8082));
+
+    like(http_get('/fastcgi'), qr/200 OK.*MISS.*^012345678$/ms, 'fastcgi');
+    like(http_get('/fastcgi'), qr/200 OK.*HIT.*^012345678$/ms,
+        'fastcgi cached');
+
+    like(get("/fastcgi?1", "Range: bytes=0-0"), qr/ 206 .*MISS.*^0$/ms,
+        'fastcgi slice');
+    like(get("/fastcgi?1", "Range: bytes=1-1"), qr/ 206 .*HIT.*^1$/ms,
+        'fastcgi slice cached');
+    like(get("/fastcgi?1", "Range: bytes=2-2"), qr/ 206 .*MISS.*^2$/ms,
+        'fastcgi slice next');
+}
+
+# slicing in named location
+
+$r = http_get('/cache-redirect');
+
+like($r, qr/ 200 .*^0123456789abcdef$/ms, 'in named location');
+is(scalar @{[ glob $t->testdir() . '/cach3/*' ]}, 8,
+    'in named location - cache entries');
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
+
+sub fastcgi_daemon {
+    my $socket = FCGI::OpenSocket('127.0.0.1:' . port(8082), 5);
+    my $request = FCGI::Request(\*STDIN, \*STDOUT, \*STDERR, \%ENV,
+        $socket);
+
+    my $body = '012345678';
+    my $len = length($body);
+
+    while ($request->Accept() >= 0) {
+        my ($start, $stop) = $ENV{Range} =~ /bytes=(\d+)-(\d+)/;
+        my $body = substr($body, $start, ($stop - $start) + 1);
+        $stop = $len - 1 if $stop > $len - 1;
+
+        print <<EOF;
+Status: 206
+Content-Type: text/html
+Content-Range: bytes $start-$stop/$len
+
+EOF
+
+        print $body;
+    }
+
+    FCGI::CloseSocket($socket);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/split_clients.t ../asynch_mode_nginx/test/nginx-tests/split_clients.t
--- nginx-release-1.20.1/test/nginx-tests/split_clients.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/split_clients.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for split_client module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http split_clients/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    split_clients $connection $variant {
+        51.2%  ".one";
+        10%    ".two";
+        *      ".three";
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            index index${variant}.html;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.one.html', 'first');
+$t->write_file('index.two.html', 'second');
+$t->write_file('index.three.html', 'third');
+
+$t->run();
+
+###############################################################################
+
+# NB: split_clients distribution is a subject to implementation details
+
+like(many('/', 20), qr/first: 12, second: 2, third: 6/, 'split');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count) = @_;
+    my %dist;
+
+    for (1 .. $count) {
+        if (http_get($uri) =~ /(first|second|third)/) {
+            $dist{$1} = 0 unless defined $dist{$1};
+            $dist{$1}++;
+        }
+    }
+
+    return join ', ', map { $_ . ": " . $dist{$_} } sort keys %dist;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssi_delayed.t ../asynch_mode_nginx/test/nginx-tests/ssi_delayed.t
--- nginx-release-1.20.1/test/nginx-tests/ssi_delayed.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssi_delayed.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,119 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Roman Arutyunyan
+# (C) Nginx, Inc.
+
+# Test for subrequest bug with delay (see 903fb1ddc07f for details).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+        location /delayed.html {
+            ssi on;
+            sendfile_max_chunk 100;
+            postpone_output 0;
+        }
+
+        location /1 {
+            proxy_buffers 3 256;
+            proxy_buffer_size 256;
+            proxy_max_temp_file_size 0;
+            proxy_pass http://127.0.0.1:8081;
+        }
+    }
+}
+
+EOF
+
+
+$t->write_file('delayed.html', ('x' x 100) . '<!--#include virtual="/1"-->');
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# If a response sending is delayed by sendfile_max_chunk, and
+# then we've switched to a different subrequest, which is not yet
+# ready to handle corresponding write event, wev->delayed won't be
+# cleared.  This results in the subrequest response not being
+# sent to the client, and the whole request will hang if all proxy
+# buffers will be exhausted.  Fixed in 1.11.13 (903fb1ddc07f).
+
+like(http_get('/delayed.html'), qr/x{100}y{1024}SEE-THIS/, 'delayed');
+
+###############################################################################
+
+sub http_daemon {
+    my ($t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my $data = ('y' x 1024) . 'SEE-THIS';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        select undef, undef, undef, 0.5;
+
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+$data
+EOF
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssi_if.t ../asynch_mode_nginx/test/nginx-tests/ssi_if.t
--- nginx-release-1.20.1/test/nginx-tests/ssi_if.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssi_if.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,274 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for nginx ssi module, "if" statement.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi/)->plan(43);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+
+my $if_elif_else =
+    '<!--#if expr="$arg_if" -->IF'
+    . '<!--#elif expr="$arg_elif" -->ELIF'
+    . '<!--#else -->ELSE'
+    . '<!--#endif -->';
+
+my $zig = 'GOOD';
+my $zag = 'GOOD';
+
+foreach my $i (reverse 1 .. 15) {
+    if ($i % 2) {
+        $zig =
+        "<!--#if expr='\$arg_$i' -->$i<!--#else -->$zig<!--#endif -->";
+        $zag =
+        "<!--#if expr='\$arg_$i' -->$zag<!--#else -->$i<!--#endif -->";
+    } else {
+        $zig =
+        "<!--#if expr='\$arg_$i' -->$zig<!--#else -->$i<!--#endif -->";
+        $zag =
+        "<!--#if expr='\$arg_$i' -->$i<!--#else -->$zag<!--#endif -->";
+    }
+}
+
+$t->run();
+
+###############################################################################
+
+$t->write_file('if_var.html', 'x<!--#if expr="$arg_v" -->OK<!--#endif -->x');
+
+like(http_get('/if_var.html?v=1'), qr/^xOKx$/m, 'if variable exists');
+like(http_get('/if_var.html'), qr/^xx$/m, 'if variable not exists');
+
+
+$t->write_file('if_eq.html',
+    'x<!--#if expr="$arg_v = equal" -->OK<!--#endif -->x');
+
+like(http_get('/if_eq.html?v=equal'), qr/^xOKx$/m, 'if var = text');
+like(http_get('/if_eq.html?v=notequal'), qr/^xx$/m, 'if var = text (false)');
+
+
+$t->write_file('if_neq.html',
+    'x<!--#if expr="equal != $arg_v" -->OK<!--#endif -->x');
+
+like(http_get('/if_neq.html?v=notequal'), qr/^xOKx$/m, 'if text != var');
+like(http_get('/if_neq.html?v=equal'), qr/^xx$/m, 'if text != var (false)');
+
+
+SKIP: {
+    # PCRE may not be available unless we have rewrite module
+
+    skip 'no PCRE', 4 unless $t->has_module('rewrite');
+
+    $t->write_file('if_eq_re.html',
+        'x<!--#if expr="$arg_v = /re+gexp?/" -->OK<!--#endif -->x');
+
+    like(http_get('/if_eq_re.html?v=XreeeegexX'), qr/^xOKx$/m,
+        'if var = /regex/');
+    like(http_get('/if_eq_re.html?v=XrgxX'), qr/^xx$/m,
+        'if var = /regex/ (false)');
+
+
+    $t->write_file('if_neq_re.html',
+        'x<!--#if expr="$arg_v != /re+gexp?/" -->OK<!--#endif -->x');
+
+    like(http_get('/if_neq_re.html?v=XrgxX'), qr/^xOKx$/m,
+        'if var != /regex/');
+    like(http_get('/if_neq_re.html?v=XreeeegexX'), qr/^xx$/m,
+        'if var != /regex/ (false)');
+}
+
+
+$t->write_file('if_varvar.html',
+    'x<!--#if expr="$arg_v = var$arg_v2" -->OK<!--#endif -->x');
+
+like(http_get('/if_varvar.html?v=varHERE&v2=HERE'), qr/^xOKx$/m,
+    'if var = complex');
+
+
+SKIP: {
+    # PCRE may not be available unless we have rewrite module
+
+    skip 'no PCRE', 2 unless $t->has_module('rewrite');
+
+    $t->write_file('if_cap_re.html',
+        'x<!--#if expr="$arg_v = /(CAP\d).*(CAP\d)/" -->'
+            . '<!--#echo var="1" -->x<!--#echo var="2" -->'
+        . '<!--#endif -->x');
+
+    like(http_get('/if_cap_re.html?v=hereCAP1andCAP2'), qr/^xCAP1xCAP2x$/m,
+        'if regex with captures');
+
+
+    $t->write_file('if_ncap_re.html',
+        'x<!--#if expr="$arg_v = /(?P<ncap>HERE)/" -->'
+            . '<!--#echo var="ncap" -->'
+        . '<!--#endif -->x');
+
+    like(http_get('/if_ncap_re.html?v=captureHEREeee'), qr/^xHEREx$/m,
+        'if regex with named capture');
+}
+
+
+$t->write_file('if.html', 'x' . $if_elif_else . 'x');
+
+like(http_get('/if.html?if=1'), qr/^xIFx$/m, 'if');
+like(http_get('/if.html?if=1&elif=1'), qr/^xIFx$/m, 'if suppresses elif');
+like(http_get('/if.html?elif=1'), qr/^xELIFx$/m, 'elif');
+like(http_get('/if.html'), qr/^xELSEx$/m, 'else');
+
+
+$t->write_file('if_multi.html',
+    'x<!--#if expr="$arg_1" -->IF1<!--#else -->ELSE1<!--#endif -->'
+    . 'x<!--#if expr="$arg_2" -->IF2<!--#else -->ELSE2<!--#endif -->'
+    . 'x<!--#if expr="$arg_3" -->IF3<!--#else -->ELSE3<!--#endif -->'
+    . 'x<!--#if expr="$arg_4" -->IF4<!--#else -->ELSE4<!--#endif -->'
+    . 'x<!--#if expr="$arg_5" -->IF5<!--#else -->ELSE5<!--#endif -->x');
+
+like(http_get('/if_multi.html?1=t&2=t&3=t&4=t&5=t'),
+    qr/^xIF1xIF2xIF3xIF4xIF5x$/m, 'multiple if (sequentially)');
+like(http_get('/if_multi.html?1=t&3=t&5=t'), qr/^xIF1xELSE2xIF3xELSE4xIF5x$/m,
+    'multiple if (interlaced)');
+like(http_get('/if_multi.html?2=t&4=t'), qr/^xELSE1xIF2xELSE3xIF4xELSE5x$/m,
+    'multiple if (interlaced reversed)');
+
+
+$t->write_file('if_in_block.html',
+    '<!--#block name="one" -->' . $if_elif_else . '<!--#endblock -->'
+    . 'x<!--#include virtual="/404?$args" stub="one" -->x');
+
+like(http_get('/if_in_block.html?if=1'), qr/^xIFx$/m, 'if (in block)');
+like(http_get('/if_in_block.html?if=1&elif=1'), qr/^xIFx$/m,
+    'if suppresses elif (in block)');
+like(http_get('/if_in_block.html?elif=1'), qr/^xELIFx$/m, 'elif (in block)');
+like(http_get('/if_in_block.html'), qr/^xELSEx$/m, 'else (in block)');
+
+
+$t->write_file('if_config_set_echo.html',
+    'x<!--#if expr="$arg_if" -->'
+        . '<!--#config timefmt="IF" -->'
+        . '<!--#set var="v" value="$date_gmt" -->'
+        . '<!--#echo var="v" -->'
+    . '<!--#else -->'
+        . '<!--#config timefmt="ELSE" -->'
+        . '<!--#set var="v" value="$date_gmt" -->'
+        . '<!--#echo var="v" -->'
+    . '<!--#endif -->x');
+
+like(http_get('/if_config_set_echo.html?if=1'), qr/^xIFx$/m,
+    'if config-set-echo');
+like(http_get('/if_config_set_echo.html'), qr/^xELSEx$/m,
+    'else config-set-echo');
+
+
+$t->write_file('if_include.html',
+    'x<!--#if expr="$arg_if" -->'
+        . '<!--#include virtual="/if.html?if=1" -->'
+    . '<!--#else -->'
+        . '<!--#include virtual="/if.html" -->'
+    . '<!--#endif -->x');
+
+like(http_get('/if_include.html?if=1'), qr/^xxIFxx$/m,
+    'if include');
+like(http_get('/if_include.html'), qr/^xxELSExx$/m,
+    'else include');
+
+
+$t->write_file('if_block.html',
+    '<!--#if expr="$arg_if" -->'
+        . '<!--#block name="one" -->IF<!--#endblock -->'
+    . '<!--#else -->'
+        . '<!--#block name="one" -->ELSE<!--#endblock -->'
+    . '<!--#endif -->'
+    . 'x<!--#include virtual="/404" stub="one" -->x');
+
+like(http_get('/if_block.html?if=1'), qr/^xIFx$/m, 'if block');
+like(http_get('/if_block.html'), qr/^xELSEx$/m, 'else block');
+
+
+TODO: {
+local $TODO = 'support for nested ifs';
+
+$t->write_file('ifif.html',
+    'x<!--#if expr="$arg__if" -->IFx' . $if_elif_else
+    . '<!--#elif expr="$arg__elif" -->ELIFx' . $if_elif_else
+    . '<!--#else -->ELSEx' . $if_elif_else
+    . '<!--#endif -->x');
+
+like(http_get('/ifif.html?_if=1&if=1'), qr/^xIFxIFx$/m, 'if if');
+like(http_get('/ifif.html?_if=1&elif=1'), qr/^xIFxELIFx$/m, 'if elif');
+like(http_get('/ifif.html?_if=1'), qr/^xIFxELSEx$/m, 'if else');
+
+like(http_get('/ifif.html?_elif=1&if=1'), qr/^xELIFxIFx$/m, 'elif if');
+like(http_get('/ifif.html?_elif=1&elif=1'), qr/^xELIFxELIFx$/m, 'elif elif');
+like(http_get('/ifif.html?_elif=1'), qr/^xELIFxELSEx$/m, 'elif else');
+
+like(http_get('/ifif.html?if=1'), qr/^xELSExIFx$/m, 'else if');
+like(http_get('/ifif.html?elif=1'), qr/^xELSExELIFx$/m, 'else elif');
+like(http_get('/ifif.html'), qr/^xELSExELSEx$/m, 'else else');
+
+
+$t->write_file('zigzag.html',
+    "x<!--#if expr='\$arg_0' -->$zig<!--#else -->$zag<!--#endif -->x");
+
+like(http_get('/zigzag.html?0=t&2=t&4=t&6=t&8=t&10=t&12=t&14=t'),
+    qr/^xGOODx$/m, 'zigzag');
+like(http_get('/zigzag.html?1=t&3=t&5=t&7=t&9=t&11=t&13=t&15=t'),
+    qr/^xGOODx$/m, 'zagzig');
+
+
+$t->write_file('zigzag_block.html',
+    '<!--#block name="one" -->'
+    . "x<!--#if expr='\$arg_0' -->$zig<!--#else -->$zag<!--#endif -->x"
+    . '<!--#endblock -->'
+    . 'x<!--#include virtual="/404?$args" stub="one" -->x');
+
+like(http_get('/zigzag_block.html?0=t&2=t&4=t&6=t&8=t&10=t&12=t&14=t'),
+    qr/^xGOODx$/m, 'zigzag block');
+like(http_get('/zigzag_block.html?1=t&3=t&5=t&7=t&9=t&11=t&13=t&15=t'),
+    qr/^xGOODx$/m, 'zagzig block');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssi_include_big.t ../asynch_mode_nginx/test/nginx-tests/ssi_include_big.t
--- nginx-release-1.20.1/test/nginx-tests/ssi_include_big.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssi_include_big.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx ssi bug with big includes.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT :gzip /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi rewrite gzip proxy/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    output_buffers  2 512;
+    ssi on;
+    gzip on;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /proxy/ {
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location = /local/blah {
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('c1.html', 'X' x 1023);
+$t->write_file('c2.html', 'X' x 1024);
+$t->write_file('c3.html', 'X' x 1025);
+$t->write_file('test1.html', '<!--#include virtual="/proxy/blah" -->'
+    . '<!--#include virtual="/c1.html" -->');
+$t->write_file('test2.html', '<!--#include virtual="/proxy/blah" -->'
+    . '<!--#include virtual="/c2.html" -->');
+$t->write_file('test3.html', '<!--#include virtual="/proxy/blah" -->'
+    . '<!--#include virtual="/c3.html" -->');
+$t->write_file('test4.html', '<!--#include virtual="/proxy/blah" -->'
+    . ('X' x 1025));
+
+$t->run();
+
+###############################################################################
+
+my $t1 = http_gzip_request('/test1.html');
+ok(defined $t1, 'small included file (less than output_buffers)');
+http_gzip_like($t1, qr/^X{1023}\Z/, 'small included file content');
+
+my $t2 = http_gzip_request('/test2.html');
+ok(defined $t2, 'small included file (equal to output_buffers)');
+http_gzip_like($t2, qr/^X{1024}\Z/, 'small included file content');
+
+my $t3 = http_gzip_request('/test3.html');
+ok(defined $t3, 'big included file (more than output_buffers)');
+http_gzip_like($t3, qr/^X{1025}\Z/, 'big included file content');
+
+my $t4 = http_gzip_request('/test4.html');
+ok(defined $t4, 'big ssi main file');
+http_gzip_like($t4, qr/^X{1025}\Z/, 'big ssi main file content');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssi.t ../asynch_mode_nginx/test/nginx-tests/ssi.t
--- nginx-release-1.20.1/test/nginx-tests/ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssi.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,194 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx ssi module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi cache proxy rewrite/)
+    ->plan(27);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    proxy_cache_path       %%TESTDIR%%/cache levels=1:2
+                           keys_zone=NAME:1m;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        if ($args = "found") {
+            return 204;
+        }
+
+        location / {
+            ssi on;
+        }
+        location /proxy/ {
+            ssi on;
+            proxy_pass http://127.0.0.1:8080/local/;
+        }
+        location /cache/ {
+            proxy_pass http://127.0.0.1:8080/local/;
+            proxy_cache NAME;
+            proxy_cache_valid 200 1h;
+        }
+        location /local/ {
+            ssi off;
+            alias %%TESTDIR%%/;
+        }
+        location = /test-empty-postpone.html {
+            ssi on;
+            postpone_output 0;
+        }
+        location /var {
+            ssi on;
+            add_header X-Var x${date_gmt}x;
+        }
+        location /var_noformat {
+            ssi on;
+            add_header X-Var x${date_gmt}x;
+            return 200;
+        }
+        location /var_nossi {
+            add_header X-Var x${date_gmt}x;
+            return 200;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test1.html', 'X<!--#echo var="arg_test" -->X');
+$t->write_file('test2.html',
+    'X<!--#include virtual="/test1.html?test=test" -->X');
+$t->write_file('test3.html',
+    'X<!--#set var="blah" value="test" --><!--#echo var="blah" -->X');
+$t->write_file('test-args-rewrite.html',
+    'X<!--#include virtual="/check?found" -->X');
+$t->write_file('test-empty1.html', 'X<!--#include virtual="/empty.html" -->X');
+$t->write_file('test-empty2.html',
+    'X<!--#include virtual="/local/empty.html" -->X');
+$t->write_file('test-empty3.html',
+    'X<!--#include virtual="/cache/empty.html" -->X');
+$t->write_file('test-empty-postpone.html',
+    'X<!--#include virtual="/proxy/empty.html" -->X');
+$t->write_file('empty.html', '');
+
+$t->write_file('unescape.html?', 'SEE-THIS') unless $^O eq 'MSWin32';
+$t->write_file('unescape1.html',
+    'X<!--#include virtual="/tes%741.html?test=test" -->X');
+$t->write_file('unescape2.html',
+    'X<!--#include virtual="/unescape.html%3f" -->X');
+$t->write_file('unescape3.html',
+    'X<!--#include virtual="/test1.html%3ftest=test" -->X');
+
+$t->write_file('var_format.html',
+    'x<!--#if expr="$arg_custom" -->'
+        . '<!--#config timefmt="%A, %H:%M:%S" -->'
+        . '<!--#set var="v" value="$date_gmt" -->'
+        . '<!--#echo var="v" -->'
+    . '<!--#else -->'
+        . '<!--#set var="v" value="$date_gmt" -->'
+        . '<!--#echo var="v" -->'
+    . '<!--#endif -->x');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/test1.html'), qr/^X\(none\)X$/m, 'echo no argument');
+like(http_get('/test1.html?test='), qr/^XX$/m, 'empty argument');
+like(http_get('/test1.html?test=test'), qr/^XtestX$/m, 'argument');
+like(http_get('/test1.html?test=test&a=b'), qr/^XtestX$/m, 'argument 2');
+like(http_get('/test1.html?a=b&test=test'), qr/^XtestX$/m, 'argument 3');
+like(http_get('/test1.html?a=b&test=test&d=c'), qr/^XtestX$/m, 'argument 4');
+like(http_get('/test1.html?atest=a&testb=b&ctestc=c&test=test'), qr/^XtestX$/m,
+    'argument 5');
+
+like(http_get('/test2.html'), qr/^XXtestXX$/m, 'argument via include');
+
+like(http_get('/test3.html'), qr/^XtestX$/m, 'set');
+
+# args should be in subrequest even if original request has no args and that
+# was queried somehow (e.g. by server rewrites)
+
+like(http_get('/test-args-rewrite.html'), qr/^XX$/m, 'args only subrequest');
+
+like(http_get('/test-args-rewrite.html?wasargs'), qr/^XX$/m,
+    'args was in main request');
+
+# Last-Modified and Accept-Ranges headers should be cleared
+
+unlike(http_get('/test1.html'), qr/Last-Modified|Accept-Ranges/im,
+    'cleared headers');
+unlike(http_get('/proxy/test1.html'), qr/Last-Modified|Accept-Ranges/im,
+    'cleared headers from proxy');
+
+# empty subrequests
+
+like(http_get('/test-empty1.html'), qr/HTTP/, 'empty with ssi');
+like(http_get('/test-empty2.html'), qr/HTTP/, 'empty without ssi');
+like(http_get('/test-empty3.html'), qr/HTTP/, 'empty with proxy');
+like(http_get('/test-empty3.html'), qr/HTTP/, 'empty with proxy cached');
+
+like(http_get('/test-empty-postpone.html'), qr/HTTP.*XX/ms,
+    'empty with postpone_output 0');
+
+# handling of escaped URIs
+
+like(http_get('/unescape1.html'), qr/^XXtestXX$/m, 'escaped in path');
+
+SKIP: {
+skip 'incorrect filename on win32', 2 if $^O eq 'MSWin32';
+
+like(http_get('/unescape2.html'), qr/^XSEE-THISX$/m,
+    'escaped question in path');
+like(http_get('/unescape3.html'), qr/404 Not Found/,
+    'escaped query separator');
+
+}
+
+# handling of embedded date variables
+
+my $re_date_gmt = qr/X-Var: x.+, \d\d-.+-\d{4} \d\d:\d\d:\d\d .+x/;
+
+like(http_get('/var_nossi.html'), $re_date_gmt, 'no ssi');
+like(http_get('/var_noformat.html'), $re_date_gmt, 'no format');
+
+like(http_get('/var_format.html?custom=1'), $re_date_gmt, 'custom header');
+like(http_get('/var_format.html'), $re_date_gmt, 'default header');
+
+like(http_get('/var_format.html?custom=1'),
+    qr/x.+, \d\d:\d\d:\d\dx/, 'custom ssi');
+like(http_get('/var_format.html'),
+    qr/x.+, \d\d-.+-\d{4} \d\d:\d\d:\d\d .+x/, 'default ssi');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssi_waited.t ../asynch_mode_nginx/test/nginx-tests/ssi_waited.t
--- nginx-release-1.20.1/test/nginx-tests/ssi_waited.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssi_waited.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,63 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx ssi module, waited subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http ssi/)->plan(1);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        location / {
+            ssi on;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'x<!--#include virtual="/first.html" -->' .
+    'x<!--#include virtual="/second.html" -->x');
+$t->write_file('first.html', 'FIRST');
+$t->write_file('second.html',
+    '<!--#include virtual="/waited.html" wait="yes"-->xSECOND');
+$t->write_file('waited.html', 'WAITED');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/^xFIRSTxWAITEDxSECONDx$/m, 'waited non-active');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_certificate_chain.t ../asynch_mode_nginx/test/nginx-tests/ssl_certificate_chain.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_certificate_chain.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_certificate_chain.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with certificate chain.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+    ->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key end.key;
+        ssl_certificate end.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key int.key;
+        ssl_certificate int.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key end.key;
+        ssl_certificate end-int.crt;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+EOF
+
+foreach my $name ('root') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+    system("openssl req -new "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for end: $!\n";
+
+$t->write_file('end-int.crt',
+    $t->read_file('end.crt') . $t->read_file('int.crt'));
+
+$t->run();
+
+###############################################################################
+
+is(get_ssl_socket(port(8080)), undef, 'incomplete chain');
+ok(get_ssl_socket(port(8081)), 'intermediate');
+ok(get_ssl_socket(port(8082)), 'intermediate server');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($port) = @_;
+    my ($s, $verify);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => $port,
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_PEER(),
+            SSL_ca_file => "$d/root.crt",
+            SSL_verify_callback => sub {
+                my ($ok) = @_;
+                $verify = $ok;
+                return $ok;
+            },
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $verify;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_certificate_perl.t ../asynch_mode_nginx/test/nginx-tests/ssl_certificate_perl.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_certificate_perl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_certificate_perl.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, loading certificates from memory with perl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl perl/)->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    perl_set $pem '
+        sub {
+            my $r = shift;
+            local $/;
+            my $sni = $r->variable("ssl_server_name");
+            open my $fh, "<", "%%TESTDIR%%/$sni.crt";
+            my $content = <$fh>;
+            close $fh;
+            return $content;
+        }
+    ';
+
+    server {
+        listen       127.0.0.1:8080 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate data:$pem;
+        ssl_certificate_key data:$pem;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.crt "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(cert('one', 8080), qr/CN=one/, 'certificate');
+like(cert('two', 8080), qr/CN=two/, 'certificate 2');
+
+###############################################################################
+
+sub cert {
+    my ($host, $port) = @_;
+    my ($s, $ssl) = get_ssl_socket($host, $port) or return;
+    Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+    my ($host, $port) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_host_name($ssl, $host);
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_certificates.t ../asynch_mode_nginx/test/nginx-tests/ssl_certificates.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_certificates.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_certificates.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,157 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with multiple certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+    Net::SSLeay::SSLeay();
+};
+plan(skip_all => 'Net::SSLeay not installed or too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+plan(skip_all => 'no multiple certificates') if $t->has_module('BoringSSL');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key rsa.key;
+    ssl_certificate rsa.crt;
+    ssl_ciphers DEFAULT:ECCdraft;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key ec.key;
+        ssl_certificate ec.crt;
+
+        ssl_certificate_key rsa.key;
+        ssl_certificate rsa.crt;
+
+        ssl_certificate_key rsa.key;
+        ssl_certificate rsa.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+system("openssl ecparam -genkey -out $d/ec.key -name prime256v1 "
+    . ">>$d/openssl.out 2>&1") == 0 or die "Can't create EC pem: $!\n";
+system("openssl genrsa -out $d/rsa.key 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create RSA pem: $!\n";
+
+foreach my $name ('ec', 'rsa') {
+    system("openssl req -x509 -new -key $d/$name.key "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+like(get_cert('RSA'), qr/CN=rsa/, 'ssl cert RSA');
+like(get_cert('ECDSA'), qr/CN=ec/, 'ssl cert ECDSA');
+
+###############################################################################
+
+sub get_version {
+    my ($s, $ssl) = get_ssl_socket();
+    return Net::SSLeay::version($ssl);
+}
+
+sub get_cert {
+    my ($type) = @_;
+    $type = 'PSS' if $type eq 'RSA' && get_version() > 0x0303;
+    my ($s, $ssl) = get_ssl_socket($type);
+    my $cipher = Net::SSLeay::get_cipher($ssl);
+    Test::Nginx::log_core('||', "cipher: $cipher");
+    return Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+    my ($type) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::INET->new('127.0.0.1:' . port(8080));
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+    if (defined $type) {
+        my $ssleay = Net::SSLeay::SSLeay();
+        if ($ssleay < 0x1000200f || $ssleay == 0x20000000) {
+            Net::SSLeay::CTX_set_cipher_list($ctx, $type)
+                or die("Failed to set cipher list");
+        } else {
+            # SSL_CTRL_SET_SIGALGS_LIST
+            Net::SSLeay::CTX_ctrl($ctx, 98, 0, $type . '+SHA256')
+                or die("Failed to set sigalgs");
+        }
+    }
+
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_certificate.t ../asynch_mode_nginx/test/nginx-tests/ssl_certificate.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_certificate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_certificate.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,232 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with dynamic certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl geo/)
+    ->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    geo $one {
+        default one;
+    }
+
+    geo $two {
+        default two;
+    }
+
+    geo $pass {
+        default pass;
+    }
+
+    add_header X-SSL $ssl_server_name:$ssl_session_reused;
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080 ssl %%SSL_ASYNCH%%;
+        server_name  default;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl %%SSL_ASYNCH%%;
+        server_name  virtual;
+
+        # found in key
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8080 ssl %%SSL_ASYNCH%%;
+        server_name  no_ctx;
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl %%SSL_ASYNCH%%;
+        server_name  password;
+
+        # found in key
+        ssl_certificate pass.crt;
+        ssl_certificate_key $pass.key;
+        ssl_password_file password_file;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  default;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl %%SSL_ASYNCH%%;
+        server_name  default;
+
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key $ssl_server_name.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('pass') {
+    system("openssl genrsa -out $d/$name.key -passout pass:pass "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create $name key: $!\n";
+    system("openssl req -x509 -new -config $d/openssl.conf "
+        . "-subj /CN=$name/ -out $d/$name.crt -key $d/$name.key "
+        . "-passin pass:pass >>$d/openssl.out 2>&1") == 0
+        or die "Can't create $name certificate: $!\n";
+}
+
+$t->write_file('password_file', 'pass');
+$t->write_file('index.html', '');
+
+$t->run()->plan(11);
+
+###############################################################################
+
+like(cert('default', 8080), qr/CN=one/, 'default certificate');
+like(get('default', 8080), qr/default/, 'default context');
+
+like(cert('virtual', 8080), qr/CN=two/, 'virtual server certificate');
+like(get('virtual', 8080), qr/virtual/, 'virtual server context');
+
+like(cert('no_ctx', 8080), qr/CN=one/, 'certificate - no context');
+like(get('no_ctx', 8080), qr/no_ctx/, 'virtual server - no context');
+
+like(get('password', 8083), qr/password/, 'ssl_password_file');
+
+# session reuse
+
+my ($s, $ssl) = get('default', 8080);
+my $ses = Net::SSLeay::get_session($ssl);
+
+like(get('default', 8080, $ses), qr/default:r/, 'session reused');
+like(get('default', 8081, $ses), qr/default:r/, 'session id context match');
+like(get('default', 8082, $ses), qr/default:\./, 'session id context distinct');
+
+# errors
+
+Net::SSLeay::ERR_clear_error();
+get_ssl_socket('nx', 8084);
+ok(Net::SSLeay::ERR_peek_error(), 'no certificate');
+
+###############################################################################
+
+sub get {
+    my ($host, $port, $ctx) = @_;
+    my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF . CRLF);
+    my $r = Net::SSLeay::read($ssl);
+    Net::SSLeay::shutdown($ssl);
+    $s->close();
+    return $r unless wantarray();
+    return ($s, $ssl);
+}
+
+sub cert {
+    my ($host, $port, $ctx) = @_;
+    my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+    Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+    my ($host, $port, $ses) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_host_name($ssl, $host);
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl);
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_client_escaped_cert.t ../asynch_mode_nginx/test/nginx-tests/ssl_client_escaped_cert.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_client_escaped_cert.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_client_escaped_cert.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,128 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, $ssl_client_escaped_cert variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite/)
+    ->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_verify_client optional_no_ca;
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        location /cert {
+            return 200 $ssl_client_raw_cert;
+        }
+        location /escaped {
+            return 200 $ssl_client_escaped_cert;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($cert) = cert('/cert') =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+my ($escaped) = cert('/escaped') =~ /\x0d\x0a?\x0d\x0a?(.*)/ms;
+
+ok($cert, 'ssl_client_raw_cert');
+ok($escaped, 'ssl_client_escaped_cert');
+
+$escaped =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+is($escaped, $cert, 'ssl_client_escaped_cert unescape match');
+
+###############################################################################
+
+sub cert {
+    my ($uri) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => port(8443),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_cert_file => "$d/localhost.crt",
+            SSL_key_file => "$d/localhost.key",
+            SSL_error_trap => sub { die $_[1] },
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    http_get($uri, socket => $s);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_conf_command.t ../asynch_mode_nginx/test/nginx-tests/ssl_conf_command.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_conf_command.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_conf_command.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_conf_command.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8443 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_protocols TLSv1.2;
+
+        ssl_session_tickets off;
+        ssl_conf_command Options SessionTicket;
+
+        ssl_prefer_server_ciphers on;
+        ssl_conf_command Options -ServerPreference;
+        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+        ssl_conf_command Certificate override.crt;
+        ssl_conf_command PrivateKey override.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'override') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->try_run('no ssl_conf_command')->plan(3);
+
+###############################################################################
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+my ($s, $ssl) = get_ssl_socket();
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=override/, 'Certificate');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(ses => $ses);
+ok(Net::SSLeay::session_reused($ssl), 'SessionTicket');
+
+($s, $ssl) = get_ssl_socket(ciphers =>
+    'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384');
+is(Net::SSLeay::get_cipher($ssl),
+    'ECDHE-RSA-AES128-GCM-SHA256', 'ServerPreference');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my (%extra) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port(8443));
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $extra{ses}) if $extra{ses};
+    Net::SSLeay::set_cipher_list($ssl, $extra{ciphers}) if $extra{ciphers};
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_crl.t ../asynch_mode_nginx/test/nginx-tests/ssl_crl.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_crl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_crl.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,207 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_crl directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+    ->has_daemon('openssl')->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key  localhost.key;
+    ssl_certificate localhost.crt;
+
+    ssl_verify_client on;
+    ssl_client_certificate int-root.crt;
+
+    add_header X-Verify $ssl_client_verify always;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_client_certificate root.crt;
+        ssl_crl empty.crl;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_client_certificate root.crt;
+        ssl_crl root.crl;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_verify_depth 2;
+        ssl_crl root.crl;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+
+[ myca_policy ]
+commonName = supplied
+EOF
+
+foreach my $name ('root', 'localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+    system("openssl req -new "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for end: $!\n";
+
+system("openssl ca -gencrl -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-out $d/empty.crl -crldays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create empty crl: $!\n";
+
+system("openssl ca -config $d/ca.conf -revoke $d/int.crt "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't revoke int.crt: $!\n";
+
+system("openssl ca -gencrl -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-out $d/root.crl -crldays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't update crl: $!\n";
+
+$t->write_file('int-root.crt',
+    $t->read_file('int.crt') . $t->read_file('root.crt'));
+
+$t->write_file('t', '');
+$t->run();
+
+###############################################################################
+
+like(get(8080, 'int'), qr/SUCCESS/, 'crl - no revoked certs');
+like(get(8081, 'int'), qr/FAILED/, 'crl - client cert revoked');
+like(get(8082, 'end'), qr/FAILED/, 'crl - intermediate cert revoked');
+
+###############################################################################
+
+sub get {
+    my ($port, $cert) = @_;
+    my $s = get_ssl_socket($port, $cert) or return;
+    http_get('/t', socket => $s);
+}
+
+sub get_ssl_socket {
+    my ($port, $cert) = @_;
+    my ($s);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => port($port),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_cert_file => "$d/$cert.crt",
+            SSL_key_file => "$d/$cert.key",
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_engine_keys.t ../asynch_mode_nginx/test/nginx-tests/ssl_engine_keys.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_engine_keys.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_engine_keys.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,150 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, loading "engine:..." keys.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+plan(skip_all => 'may not work, leaves coredump')
+    unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+    ->has_daemon('softhsm')->has_daemon('pkcs11-tool')->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key engine:pkcs11:slot_0-id_00;
+
+        location / {
+            # index index.html by default
+        }
+
+        location /proxy {
+            proxy_pass https://127.0.0.1:8081/;
+        }
+
+        location /var {
+            proxy_pass https://127.0.0.1:8082/;
+            proxy_ssl_name localhost;
+            proxy_ssl_server_name on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key engine:pkcs11:slot_0-id_00;
+
+        location / {
+            # index index.html by default
+        }
+    }
+}
+
+EOF
+
+# Create a SoftHSM token with a secret key, and configure OpenSSL
+# to access it using the pkcs11 engine, see detailed example
+# posted by Dmitrii Pichulin here:
+#
+# http://mailman.nginx.org/pipermail/nginx-devel/2014-October/006151.html
+#
+# Note that library paths may differ on different systems,
+# and may need to be adjusted.
+
+$t->write_file('openssl.conf', <<EOF);
+openssl_conf = openssl_def
+
+[openssl_def]
+engines = engine_section
+
+[engine_section]
+pkcs11 = pkcs11_section
+
+[pkcs11_section]
+engine_id = pkcs11
+dynamic_path = /usr/local/lib/engines/pkcs11.so
+MODULE_PATH = /usr/local/lib/softhsm/libsofthsm.so
+init = 1
+PIN = 1234
+
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('softhsm.conf', <<EOF);
+0:$d/slot0.db
+EOF
+
+$ENV{SOFTHSM_CONF} = "$d/softhsm.conf";
+$ENV{OPENSSL_CONF} = "$d/openssl.conf";
+
+foreach my $name ('localhost') {
+    system('softhsm --init-token --slot 0 --label "NginxZero" '
+        . '--pin 1234 --so-pin 1234 '
+        . ">>$d/openssl.out 2>&1");
+
+    system('pkcs11-tool --module=/usr/local/lib/softhsm/libsofthsm.so '
+        . '-p 1234 -l -k -d 0 -a nx_key_0 --key-type rsa:2048 '
+        . ">>$d/openssl.out 2>&1");
+
+    system('openssl req -x509 -new -engine pkcs11 '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyform engine -text -key id_00 "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+$t->write_file('index.html', '');
+
+###############################################################################
+
+like(http_get('/proxy'), qr/200 OK/, 'ssl engine keys');
+like(http_get('/var'), qr/200 OK/, 'ssl_certificate with variable');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_ocsp.t ../asynch_mode_nginx/test/nginx-tests/ssl_ocsp.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_ocsp.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_ocsp.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,556 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for OCSP with client certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64 qw/ decode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+    Net::SSLeay::SSLeay();
+    defined &Net::SSLeay::set_tlsext_status_type or die;
+};
+plan(skip_all => 'Net::SSLeay not installed or too old') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni/)->has_daemon('openssl');
+
+plan(skip_all => 'no OCSP stapling') if $t->has_module('BoringSSL');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_ocsp leaf;
+    ssl_verify_client on;
+    ssl_verify_depth 2;
+    ssl_client_certificate trusted.crt;
+
+    ssl_ciphers DEFAULT:ECCdraft;
+
+    ssl_certificate_key ec.key;
+    ssl_certificate ec.crt;
+
+    ssl_certificate_key rsa.key;
+    ssl_certificate rsa.crt;
+
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    add_header X-Verify x${ssl_client_verify}:${ssl_session_reused}x always;
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        server_name  localhost;
+    }
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        server_name  sni;
+
+        ssl_ocsp_responder http://127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        server_name  resolver;
+
+        ssl_ocsp on;
+    }
+
+    server {
+        listen       127.0.0.1:8444 ssl;
+        server_name  localhost;
+
+        ssl_ocsp_responder http://127.0.0.1:8081;
+        ssl_ocsp on;
+    }
+
+    server {
+        listen       127.0.0.1:8445 ssl;
+        server_name  localhost;
+
+        ssl_ocsp_responder http://127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8446 ssl;
+        server_name  localhost;
+
+        ssl_ocsp_cache shared:OCSP:1m;
+    }
+
+    server {
+        listen       127.0.0.1:8447 ssl;
+        server_name  localhost;
+
+        ssl_ocsp_responder http://127.0.0.1:8082;
+        ssl_client_certificate root.crt;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+my $p = port(8081);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+authorityInfoAccess = OCSP;URI:http://127.0.0.1:$p
+EOF
+
+# variant for int.crt to trigger missing resolver
+
+$t->write_file('ca2.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+authorityInfoAccess = OCSP;URI:http://localhost:$p
+EOF
+
+foreach my $name ('root') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+    system("openssl req -new "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('ec-end') {
+    system("openssl ecparam -genkey -out $d/$name.key -name prime256v1 "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create EC param: $!\n";
+    system("openssl req -new -key $d/$name.key "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca2.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=ec-end/ -in $d/ec-end.csr -out $d/ec-end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for ec-end: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for end: $!\n";
+
+# RFC 6960, serialNumber
+
+system("openssl x509 -in $d/int.crt -serial -noout "
+    . ">>$d/serial_int 2>>$d/openssl.out") == 0
+    or die "Can't obtain serial for end: $!\n";
+
+my $serial_int = pack("n2", 0x0202, hex $1)
+    if $t->read_file('serial_int') =~ /(\d+)/;
+
+system("openssl x509 -in $d/end.crt -serial -noout "
+    . ">>$d/serial 2>>$d/openssl.out") == 0
+    or die "Can't obtain serial for end: $!\n";
+
+my $serial = pack("n2", 0x0202, hex $1) if $t->read_file('serial') =~ /(\d+)/;
+
+# ocsp end
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/end.crt "
+    . "-reqout $d/req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/int.crt -rkey $d/int.key "
+    . "-reqin $d/req.der -respout $d/resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP response: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/ec-end.crt "
+    . "-reqout $d/ec-req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create EC OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/root.crt -rkey $d/root.key "
+    . "-reqin $d/ec-req.der -respout $d/ec-resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create EC OCSP response: $!\n";
+
+$t->write_file('trusted.crt',
+    $t->read_file('int.crt') . $t->read_file('root.crt'));
+
+# server cert/key
+
+system("openssl ecparam -genkey -out $d/ec.key -name prime256v1 "
+    . ">>$d/openssl.out 2>&1") == 0 or die "Can't create EC pem: $!\n";
+system("openssl genrsa -out $d/rsa.key 2048 >>$d/openssl.out 2>&1") == 0
+    or die "Can't create RSA pem: $!\n";
+
+foreach my $name ('ec', 'rsa') {
+    system("openssl req -x509 -new -key $d/$name.key "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&http_daemon, $t, port(8081));
+$t->run_daemon(\&http_daemon, $t, port(8082));
+$t->try_run('no ssl_ocsp')->plan(14);
+
+$t->waitforsocket("127.0.0.1:" . port(8081));
+$t->waitforsocket("127.0.0.1:" . port(8082));
+
+my $version = get_version();
+
+###############################################################################
+
+like(get('RSA', 'end'), qr/200 OK.*SUCCESS/s, 'ocsp leaf');
+
+# demonstrate that ocsp int request is failed due to missing resolver
+
+TODO: {
+todo_skip 'leaves coredump', 1 unless $t->has_version('1.19.1')
+    or $ENV{TEST_NGINX_UNSAFE};
+
+like(get('RSA', 'end', sni => 'resolver'),
+    qr/400 Bad.*FAILED:certificate status request failed/s,
+    'ocsp many failed request');
+
+}
+
+# demonstrate that ocsp int request is actually made by failing ocsp response
+
+like(get('RSA', 'end', port => 8444),
+    qr/400 Bad.*FAILED:certificate status request failed/s,
+    'ocsp many failed');
+
+# now prepare valid ocsp int response
+
+system("openssl ocsp -issuer $d/root.crt -cert $d/int.crt "
+    . "-reqout $d/int-req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/root.crt "
+    . "-rsigner $d/root.crt -rkey $d/root.key "
+    . "-reqin $d/int-req.der -respout $d/int-resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP response: $!\n";
+
+like(get('RSA', 'end', port => 8444), qr/200 OK.*SUCCESS/s, 'ocsp many');
+
+# store into ssl_ocsp_cache
+
+like(get('RSA', 'end', port => 8446), qr/200 OK.*SUCCESS/s, 'cache store');
+
+# revoke
+
+system("openssl ca -config $d/ca.conf -revoke $d/end.crt "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't revoke end.crt: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/end.crt "
+    . "-reqout $d/req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/int.crt -rkey $d/int.key "
+    . "-reqin $d/req.der -respout $d/revoked.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP response: $!\n";
+
+like(get('RSA', 'end'), qr/400 Bad.*FAILED:certificate revoked/s, 'revoked');
+
+# with different responder where it's still valid
+
+like(get('RSA', 'end', port => 8445), qr/200 OK.*SUCCESS/s, 'ocsp responder');
+
+# with different context to responder where it's still valid
+
+like(get('RSA', 'end', sni => 'sni'), qr/200 OK.*SUCCESS/s, 'ocsp context');
+
+# with cached ocsp response it's still valid
+
+like(get('RSA', 'end', port => 8446), qr/200 OK.*SUCCESS/s, 'cache lookup');
+
+# ocsp end response signed with invalid (root) cert, expect HTTP 400
+
+like(get('ECDSA', 'ec-end'),
+    qr/400 Bad.*FAILED:certificate status request failed/s,
+    'root ca not trusted');
+
+# now sign ocsp end response with valid int cert
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/int.crt -rkey $d/int.key "
+    . "-reqin $d/ec-req.der -respout $d/ec-resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create EC OCSP response: $!\n";
+
+like(get('ECDSA', 'ec-end'), qr/200 OK.*SUCCESS/s, 'ocsp ecdsa');
+
+my ($s, $ssl) = get('ECDSA', 'ec-end');
+my $ses = Net::SSLeay::get_session($ssl);
+
+like(get('ECDSA', 'ec-end', ses => $ses),
+    qr/200 OK.*SUCCESS:r/s, 'session reused');
+
+# revoke with saved session
+
+system("openssl ca -config $d/ca.conf -revoke $d/ec-end.crt "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't revoke end.crt: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/ec-end.crt "
+    . "-reqout $d/ec-req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/int.crt -rkey $d/int.key "
+    . "-reqin $d/ec-req.der -respout $d/ec-resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP response: $!\n";
+
+# reusing session with revoked certificate
+
+like(get('ECDSA', 'ec-end', ses => $ses),
+    qr/400 Bad.*FAILED:certificate revoked:r/s, 'session reused - revoked');
+
+# regression test for self-signed
+
+like(get('RSA', 'root', port => 8447), qr/200 OK.*SUCCESS/s, 'ocsp one');
+
+###############################################################################
+
+sub get {
+    my ($type, $cert, %extra) = @_;
+    $type = 'PSS' if $type eq 'RSA' && $version > 0x0303;
+    my ($s, $ssl) = get_ssl_socket($type, $cert, %extra);
+    my $cipher = Net::SSLeay::get_cipher($ssl);
+    Test::Nginx::log_core('||', "cipher: $cipher");
+    my $host = $extra{sni} ? $extra{sni} : 'localhost';
+    Net::SSLeay::write($ssl, "GET /serial HTTP/1.0\nHost: $host\n\n");
+    my $r = Net::SSLeay::read($ssl);
+    Test::Nginx::log_core($r);
+    $s->close();
+    return $r unless wantarray();
+    return ($s, $ssl);
+}
+
+sub get_ssl_socket {
+    my ($type, $cert, %extra) = @_;
+    my $ses = $extra{ses};
+    my $sni = $extra{sni};
+    my $port = $extra{port} || 8443;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+    if (defined $type) {
+        my $ssleay = Net::SSLeay::SSLeay();
+        if ($ssleay < 0x1000200f || $ssleay == 0x20000000) {
+            Net::SSLeay::CTX_set_cipher_list($ctx, $type)
+                or die("Failed to set cipher list");
+        } else {
+            # SSL_CTRL_SET_SIGALGS_LIST
+            Net::SSLeay::CTX_ctrl($ctx, 98, 0, $type . '+SHA256')
+                or die("Failed to set sigalgs");
+        }
+    }
+
+    Net::SSLeay::set_cert_and_key($ctx, "$d/$cert.crt", "$d/$cert.key")
+        or die if $cert;
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_tlsext_host_name($ssl, $sni) if $sni;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+sub get_version {
+    my ($s, $ssl) = get_ssl_socket();
+    return Net::SSLeay::version($ssl);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($t, $port) = @_;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => "127.0.0.1:$port",
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+        my $resp;
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+\/([^ ]+)\s+HTTP/i;
+        next unless $uri;
+
+        $uri =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+        my $req = decode_base64($uri);
+
+        if (index($req, $serial_int) > 0) {
+            $resp = 'int-resp';
+
+        } elsif (index($req, $serial) > 0) {
+            $resp = 'resp';
+
+            # used to differentiate ssl_ocsp_responder
+
+            if ($port == port(8081) && -e "$d/revoked.der") {
+                $resp = 'revoked';
+            }
+
+        } else {
+            $resp = 'ec-resp';
+        }
+
+        next unless -s "$d/$resp.der";
+
+        # ocsp dummy handler
+
+        select undef, undef, undef, 0.02;
+
+        $headers = <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+Content-Type: application/ocsp-response
+
+EOF
+
+        local $/;
+        open my $fh, '<', "$d/$resp.der"
+            or die "Can't open $resp.der: $!";
+        binmode $fh;
+        my $content = <$fh>;
+        close $fh;
+
+        print $client $headers . $content;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_password_file.t ../asynch_mode_nginx/test/nginx-tests/ssl_password_file.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_password_file.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_password_file.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,170 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for ssl_password_file directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use POSIX qw/ mkfifo /;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite/)
+    ->has_daemon('openssl');
+
+$t->plan(3)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    # inherited by server "inherits"
+    ssl_password_file password_http;
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_password_file password;
+
+        location / {
+            return 200 "$scheme";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  two_entries;
+
+        ssl_password_file password_many;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  file_is_fifo;
+
+        ssl_password_file password_fifo;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  inherits;
+
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+mkfifo("$d/password_fifo", 0700);
+
+foreach my $name ('localhost', 'inherits') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('password', 'localhost');
+$t->write_file('password_many', "wrong$CRLF" . "localhost$CRLF");
+$t->write_file('password_http', 'inherits');
+
+my $p = fork();
+exec("echo localhost > $d/password_fifo") if $p == 0;
+
+# do not mangle with try_run()
+# we need to distinguish ssl_password_file support vs its brokenness
+
+eval {
+    open OLDERR, ">&", \*STDERR; close STDERR;
+    $t->run();
+    open STDERR, ">&", \*OLDERR;
+};
+kill 'INT', $p if $@;
+
+###############################################################################
+
+is($@, '', 'ssl_password_file works');
+
+# simple tests to ensure that nothing broke with ssl_password_file directive
+
+like(http_get('/'), qr/200 OK.*http/ms, 'http');
+like(http_get('/', socket => get_ssl_socket()), qr/200 OK.*https/ms, 'https');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1:' . port(8081),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_proxy_protocol.t ../asynch_mode_nginx/test/nginx-tests/ssl_proxy_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_proxy_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_proxy_protocol.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,182 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl access realip/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF')->plan(18);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format pp '$remote_addr $request';
+
+    server {
+        listen       127.0.0.1:8080 proxy_protocol ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        set_real_ip_from  127.0.0.1/32;
+        add_header X-IP $remote_addr;
+        add_header X-PP $proxy_protocol_addr;
+
+        location /pp {
+            real_ip_header proxy_protocol;
+            error_page 404 =200 /t1;
+            access_log %%TESTDIR%%/pp.log pp;
+
+            location /pp_4 {
+                deny 192.0.2.1/32;
+            }
+            location /pp_6 {
+                deny 2001:DB8::1/128;
+            }
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('t1', 'SEE-THIS');
+$t->run();
+
+###############################################################################
+
+my $tcp4 = 'PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678' . CRLF;
+my $tcp6 = 'PROXY TCP6 2001:Db8::1 2001:Db8::2 1234 5678' . CRLF;
+my $unk1 = 'PROXY UNKNOWN' . CRLF;
+my $unk2 = 'PROXY UNKNOWN 1 2 3 4 5 6' . CRLF;
+my $r;
+
+# no realip, just PROXY header parsing
+
+$r = pp_get('/t1', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request');
+like($r, qr/X-PP: 192.0.2.1/, 'tcp4 proxy');
+unlike($r, qr/X-IP: 192.0.2.1/, 'tcp4 client');
+
+$r = pp_get('/t1', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request');
+like($r, qr/X-PP: 2001:DB8::1/i, 'tcp6 proxy');
+unlike($r, qr/X-IP: 2001:DB8::1/i, 'tcp6 client');
+
+like(pp_get('/t1', $unk1), qr/SEE-THIS/, 'unknown request 1');
+like(pp_get('/t1', $unk2), qr/SEE-THIS/, 'unknown request 2');
+
+# realip
+
+$r = pp_get('/pp', $tcp4);
+like($r, qr/SEE-THIS/, 'tcp4 request realip');
+like($r, qr/X-PP: 192.0.2.1/, 'tcp4 proxy realip');
+like($r, qr/X-IP: 192.0.2.1/, 'tcp4 client realip');
+
+$r = pp_get('/pp', $tcp6);
+like($r, qr/SEE-THIS/, 'tcp6 request realip');
+like($r, qr/X-PP: 2001:DB8::1/i, 'tcp6 proxy realip');
+like($r, qr/X-IP: 2001:DB8::1/i, 'tcp6 client realip');
+
+# access
+
+$r = pp_get('/pp_4', $tcp4);
+like($r, qr/403 Forbidden/, 'tcp4 access');
+
+$r = pp_get('/pp_6', $tcp6);
+like($r, qr/403 Forbidden/, 'tcp6 access');
+
+# client address in access.log
+
+$t->stop();
+
+my $log = $t->read_file('pp.log');
+like($log, qr!^192\.0\.2\.1 GET /pp_4!m, 'tcp4 access log');
+like($log, qr!^2001:DB8::1 GET /pp_6!mi, 'tcp6 access log');
+
+###############################################################################
+
+sub pp_get {
+    my ($url, $proxy) = @_;
+
+    my $s = http($proxy, start => 1);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        IO::Socket::SSL->start_SSL($s,
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return http(<<EOF, socket => $s);
+GET $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_proxy_upgrade.t ../asynch_mode_nginx/test/nginx-tests/ssl_proxy_upgrade.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_proxy_upgrade.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_proxy_upgrade.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,369 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http proxy upgrade support with http ssl module.
+# In contrast to proxy_websocket.t, this test doesn't try to use binary
+# WebSocket protocol, but uses simple plain text protocol instead.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Poll;
+use IO::Select;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl/)->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF')->plan(30);
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    log_format test "$bytes_sent $body_bytes_sent";
+    access_log %%TESTDIR%%/cc.log test;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade $http_upgrade;
+            proxy_set_header Connection "Upgrade";
+            proxy_read_timeout 2s;
+            send_timeout 2s;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&upgrade_fake_daemon);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start test backend";
+
+###############################################################################
+
+# establish connection
+
+my @r;
+my $s = upgrade_connect();
+ok($s, "handshake");
+
+SKIP: {
+    skip "handshake failed", 22 unless $s;
+
+    # send a frame
+
+    upgrade_write($s, 'foo');
+    is(upgrade_read($s), 'bar', "upgrade response");
+
+    # send some big frame
+
+    upgrade_write($s, 'foo' x 16384);
+    like(upgrade_read($s), qr/^(bar){16384}$/, "upgrade big response");
+
+    # send multiple frames
+
+    for my $i (1 .. 10) {
+        upgrade_write($s, ('foo' x 16384) . $i, continue => 1);
+        upgrade_write($s, 'bazz' . $i, continue => $i != 10);
+    }
+
+    for my $i (1 .. 10) {
+        like(upgrade_read($s), qr/^(bar){16384}\d+$/, "upgrade $i");
+        is(upgrade_read($s), 'bazz' . $i, "upgrade small $i");
+    }
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# establish connection with some pipelined data
+# and make sure they are correctly passed upstream
+
+$s = upgrade_connect(message => "foo");
+ok($s, "handshake pipelined");
+
+SKIP: {
+    skip "handshake failed", 2 unless $s;
+
+    is(upgrade_read($s), "bar", "response pipelined");
+
+    upgrade_write($s, "foo");
+    is(upgrade_read($s), "bar", "next to pipelined");
+}
+
+push @r, $s ? ${*$s}->{_upgrade_private}->{r} : 'failed';
+undef $s;
+
+# connection should not be upgraded unless upgrade was actually
+# requested and allowed by configuration
+
+$s = upgrade_connect(noheader => 1);
+ok(!$s, "handshake noupgrade");
+
+# bytes sent on upgraded connection, fixed in c2f309fb7ad2 (1.7.11)
+# verify with 1) data actually read by client, 2) expected data from backend
+
+$t->stop();
+
+open my $f, '<', "$d/cc.log" or die "Can't open cc.log: $!";
+
+is($f->getline(), shift (@r) . " 540793\n", 'log - bytes');
+is($f->getline(), shift (@r) . " 22\n", 'log - bytes pipelined');
+like($f->getline(), qr/\d+ 0\n/, 'log - bytes noupgrade');
+
+###############################################################################
+
+sub upgrade_connect {
+    my (%opts) = @_;
+
+    my $s = IO::Socket::SSL->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1:' . port(8080),
+        SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    # send request, $h->to_string
+
+    my $buf = "GET / HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . ($opts{noheader} ? '' : "Upgrade: foo" . CRLF)
+        . "Connection: Upgrade" . CRLF . CRLF;
+
+    $buf .= $opts{message} . CRLF . 'FIN' if defined $opts{message};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    log_out($buf);
+    $s->syswrite($buf);
+
+    # read response
+
+    my $got = '';
+    $buf = '';
+
+    while (1) {
+        $buf = upgrade_getline($s);
+        last unless defined $buf and length $buf;
+        log_in($buf);
+        $got .= $buf;
+        last if $got =~ /\x0d?\x0a\x0d?\x0a$/;
+    }
+
+    # parse server response
+
+    return if $got !~ m!HTTP/1.1 101!;
+
+    # make sure next line is "handshaked"
+
+    $buf = upgrade_read($s);
+
+    return if !defined $buf or $buf ne 'handshaked';
+    return $s;
+}
+
+sub upgrade_getline {
+    my ($s) = @_;
+    my ($h, $buf);
+
+    ${*$s}->{_upgrade_private} ||= { b => '', r => 0 };
+    $h = ${*$s}->{_upgrade_private};
+
+    if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+        $h->{b} = $2;
+        return $1;
+    }
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_read(3)) {
+        my $n = $s->sysread($buf, 16384);
+        if (!defined $n) {
+            next if $s->errstr() == IO::Socket::SSL->SSL_WANT_READ;
+            last;
+
+        } elsif (!$n) {
+            last;
+        }
+
+        $h->{b} .= $buf;
+        $h->{r} += $n;
+
+        if ($h->{b} =~ /^(.*?\x0a)(.*)/ms) {
+            $h->{b} = $2;
+            return $1;
+        }
+    };
+}
+
+sub upgrade_write {
+    my ($s, $message, %extra) = @_;
+
+    $message = $message . CRLF;
+    $message = $message . 'FIN' unless $extra{continue};
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    $s->blocking(0);
+    while (IO::Select->new($s)->can_write(1.5)) {
+        my $n = $s->syswrite($message);
+        unless ($n) {
+            next if $s->errstr() == IO::Socket::SSL->SSL_WANT_WRITE;
+            last;
+        }
+        $message = substr($message, $n);
+        last unless length $message;
+    }
+
+    if (length $message) {
+        $s->close();
+    }
+}
+
+sub upgrade_read {
+    my ($s) = @_;
+    my $m = upgrade_getline($s);
+    $m =~ s/\x0d?\x0a// if defined $m;
+    log_in($m);
+    return $m;
+}
+
+###############################################################################
+
+sub upgrade_fake_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    while (my $client = $server->accept()) {
+        upgrade_handle_client($client);
+    }
+}
+
+sub upgrade_handle_client {
+    my ($client) = @_;
+
+    $client->autoflush(1);
+    $client->blocking(0);
+
+    my $poll = IO::Poll->new;
+
+    my $handshake = 1;
+    my $unfinished = '';
+    my $buffer = '';
+    my $n;
+
+    log2c("(new connection $client)");
+
+    while (1) {
+        $poll->mask($client => ($buffer ? POLLIN|POLLOUT : POLLIN));
+        my $p = $poll->poll(0.5);
+        log2c("(poll $p)");
+
+        foreach ($poll->handles(POLLIN)) {
+            $n = $client->sysread(my $chunk, 65536);
+            return unless $n;
+
+            log2i($chunk);
+
+            if ($handshake) {
+                $buffer .= $chunk;
+                next unless $buffer =~ /\x0d?\x0a\x0d?\x0a$/;
+
+                log2c("(handshake done)");
+
+                $handshake = 0;
+                $buffer = 'HTTP/1.1 101 Switching' . CRLF
+                    . 'Upgrade: foo' . CRLF
+                    . 'Connection: Upgrade' . CRLF . CRLF
+                    . 'handshaked' . CRLF;
+
+                log2o($buffer);
+
+                next;
+            }
+
+            $unfinished .= $chunk;
+
+            if ($unfinished =~ m/\x0d?\x0aFIN\z/) {
+                $unfinished =~ s/FIN\z//;
+                $unfinished =~ s/foo/bar/g;
+                log2o($unfinished);
+                $buffer .= $unfinished;
+                $unfinished = '';
+            }
+        }
+
+        foreach my $writer ($poll->handles(POLLOUT)) {
+            next unless length $buffer;
+            $n = $writer->syswrite($buffer);
+            substr $buffer, 0, $n, '';
+        }
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_sni_reneg.t ../asynch_mode_nginx/test/nginx-tests/ssl_sni_reneg.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_sni_reneg.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_sni_reneg.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,179 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module with SNI and renegotiation.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        location / { }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost2;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+{
+    my (undef, $ssl) = get_ssl_socket(8080);
+    plan(skip_all => "TLS 1.3 forbids renegotiation")
+        if Net::SSLeay::version($ssl) > 0x0303;
+}
+
+$t->plan(8);
+
+###############################################################################
+
+my ($s, $ssl) = get_ssl_socket(8080);
+ok($s, 'connection');
+
+SKIP: {
+skip 'connection failed', 3 unless $s;
+
+local $SIG{PIPE} = 'IGNORE';
+
+Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF);
+
+ok(Net::SSLeay::renegotiate($ssl), 'renegotiation');
+ok(Net::SSLeay::set_tlsext_host_name($ssl, 'localhost'), 'SNI');
+
+Net::SSLeay::write($ssl, 'Host: localhost' . CRLF . CRLF);
+
+ok(!Net::SSLeay::read($ssl), 'response');
+
+}
+
+# virtual servers
+
+($s, $ssl) = get_ssl_socket(8081);
+ok($s, 'connection 2');
+
+SKIP: {
+skip 'connection failed', 3 unless $s;
+
+local $SIG{PIPE} = 'IGNORE';
+
+Net::SSLeay::write($ssl, 'GET / HTTP/1.0' . CRLF);
+
+ok(Net::SSLeay::renegotiate($ssl), 'renegotiation');
+ok(Net::SSLeay::set_tlsext_host_name($ssl, 'localhost'), 'SNI');
+
+Net::SSLeay::write($ssl, 'Host: localhost' . CRLF . CRLF);
+
+ok(!Net::SSLeay::read($ssl), 'virtual servers');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($port) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::set_tlsext_host_name($ssl, 'localhost');
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_sni_sessions.t ../asynch_mode_nginx/test/nginx-tests/ssl_sni_sessions.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_sni_sessions.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_sni_sessions.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,222 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for SSL session resumption with SNI.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni rewrite/);
+
+$t->has_daemon('openssl')->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  default;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_session_tickets off;
+        ssl_session_cache shared:cache1:1m;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused:$ssl_protocol;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  nocache;
+
+        ssl_session_tickets off;
+        ssl_session_cache shared:cache2:1m;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  default;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_session_ticket_key ticket1.key;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  tickets;
+
+        ssl_session_ticket_key ticket2.key;
+
+        location / {
+            return 200 $ssl_server_name:$ssl_session_reused;
+        }
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+    if (IO::Socket::SSL->can('can_client_sni')) {
+        IO::Socket::SSL->can_client_sni() or die;
+    }
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('ticket1.key', '1' x 48);
+$t->write_file('ticket2.key', '2' x 48);
+
+$t->run();
+
+plan(skip_all => 'no TLS 1.3 sessions')
+    if get('default', port(8080), get_ssl_context()) =~ /TLSv1.3/
+    && ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+$t->plan(6);
+
+###############################################################################
+
+# check that everything works fine with default server
+
+my $ctx = get_ssl_context();
+
+like(get('default', port(8080), $ctx), qr!default:\.!, 'default server');
+like(get('default', port(8080), $ctx), qr!default:r!, 'default server reused');
+
+# check that sessions are still properly saved and restored
+# when using an SNI-based virtual server with different session cache;
+# as session resumption happens before SNI, only default server
+# settings are expected to matter
+
+# this didn't work before nginx 1.9.6 (and caused segfaults if no session
+# cache was configured the SNI-based virtual server), because OpenSSL, when
+# creating new sessions, uses callbacks from the default server context, but
+# provides access to the SNI-selected server context only (ticket #235)
+
+$ctx = get_ssl_context();
+
+like(get('nocache', port(8080), $ctx), qr!nocache:\.!, 'without cache');
+like(get('nocache', port(8080), $ctx), qr!nocache:r!, 'without cache reused');
+
+# make sure tickets can be used if an SNI-based virtual server
+# uses a different set of session ticket keys explicitly set
+
+$ctx = get_ssl_context();
+
+like(get('tickets', port(8081), $ctx), qr!tickets:\.!, 'tickets');
+like(get('tickets', port(8081), $ctx), qr!tickets:r!, 'tickets reused');
+
+###############################################################################
+
+sub get_ssl_context {
+    return IO::Socket::SSL::SSL_Context->new(
+        SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+        SSL_session_cache_size => 100
+    );
+}
+
+sub get_ssl_socket {
+    my ($host, $port, $ctx) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => $port,
+            SSL_hostname => $host,
+            SSL_reuse_ctx => $ctx,
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+sub get {
+    my ($host, $port, $ctx) = @_;
+
+    my $s = get_ssl_socket($host, $port, $ctx) or return;
+    my $r = http(<<EOF, socket => $s);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+
+    $s->close();
+    return $r;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_sni.t ../asynch_mode_nginx/test/nginx-tests/ssl_sni.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_sni.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_sni.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,219 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Valentin Bartenev
+
+# Tests for Server Name Indication (SNI) TLS extension
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni rewrite/)
+    ->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $server_name;
+        }
+
+        location /protocol {
+            return 200 $ssl_protocol;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  example.com;
+
+        ssl_certificate_key example.com.key;
+        ssl_certificate example.com.crt;
+
+        location / {
+            return 200 $server_name;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            return 200 $ssl_session_reused:$ssl_server_name;
+        }
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+    if (IO::Socket::SSL->can('can_client_sni')) {
+        IO::Socket::SSL->can_client_sni() or die;
+    }
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->plan(8);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(get_cert_cn(), qr!/CN=localhost!, 'default cert');
+like(get_cert_cn('example.com'), qr!/CN=example.com!, 'sni cert');
+
+like(https_get_host('example.com'), qr!example.com!,
+    'host exists, sni exists, and host is equal sni');
+
+like(https_get_host('example.com', 'example.org'), qr!example.com!,
+    'host exists, sni not found');
+
+TODO: {
+local $TODO = 'sni restrictions';
+
+like(https_get_host('example.com', 'localhost'), qr!400 Bad Request!,
+    'host exists, sni exists, and host is not equal sni');
+
+like(https_get_host('example.org', 'example.com'), qr!400 Bad Request!,
+    'host not found, sni exists');
+
+}
+
+# $ssl_server_name in sessions
+
+my $ctx = new IO::Socket::SSL::SSL_Context(
+    SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+    SSL_session_cache_size => 100);
+
+like(get('/', 'localhost', 8081, $ctx), qr/^\.:localhost$/m, 'ssl server name');
+
+SKIP: {
+skip 'no TLS 1.3 sessions', 1 if get('/protocol', 'localhost') =~ /TLSv1.3/
+    && ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+like(get('/', 'localhost', 8081, $ctx), qr/^r:localhost$/m,
+    'ssl server name - reused');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($host, $port, $ctx) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1:' . port($port || 8080),
+            SSL_hostname => $host,
+            SSL_reuse_ctx => $ctx,
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+sub get_cert_cn {
+    my ($host) = @_;
+    my $s = get_ssl_socket($host);
+
+    return $s->dump_peer_certificate();
+}
+
+sub https_get_host {
+    my ($host, $sni) = @_;
+    my $s = get_ssl_socket($sni ? $sni : $host);
+
+    return http(<<EOF, socket => $s);
+GET / HTTP/1.0
+Host: $host
+
+EOF
+}
+
+sub get {
+    my ($uri, $host, $port, $ctx) = @_;
+    my $s = get_ssl_socket($host, $port, $ctx) or return;
+    my $r = http_get($uri, socket => $s);
+    $s->close();
+    return $r;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_stapling.t ../asynch_mode_nginx/test/nginx-tests/ssl_stapling.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_stapling.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_stapling.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,414 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for OCSP stapling.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64 qw/ decode_base64 /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+    Net::SSLeay::SSLeay();
+    defined &Net::SSLeay::set_tlsext_status_type or die;
+};
+plan(skip_all => 'Net::SSLeay not installed or too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)->has_daemon('openssl');
+
+plan(skip_all => 'no OCSP stapling') if $t->has_module('BoringSSL');
+
+$t->plan(9)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_stapling on;
+    ssl_trusted_certificate trusted.crt;
+
+    ssl_certificate ec-end-int.crt;
+    ssl_certificate_key ec-end.key;
+
+    ssl_certificate end-int.crt;
+    ssl_certificate_key end.key;
+
+    ssl_ciphers DEFAULT:ECCdraft;
+
+    server {
+        listen       127.0.0.1:8443 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+    }
+
+    server {
+        listen       127.0.0.1:8444 ssl;
+        server_name  localhost;
+
+        ssl_stapling_responder http://127.0.0.1:8081/;
+    }
+
+    server {
+        listen       127.0.0.1:8445 ssl;
+        server_name  localhost;
+
+        ssl_stapling_verify on;
+    }
+
+    server {
+        listen       127.0.0.1:8446 ssl;
+        server_name  localhost;
+
+        ssl_certificate ec-end.crt;
+        ssl_certificate_key ec-end.key;
+    }
+
+    server {
+        listen       127.0.0.1:8447 ssl;
+        server_name  localhost;
+
+        ssl_certificate end-int.crt;
+        ssl_certificate_key end.key;
+
+        ssl_stapling_file %%TESTDIR%%/resp.der;
+    }
+
+    server {
+        listen       127.0.0.1:8448 ssl;
+        server_name  localhost;
+
+        ssl_certificate ec-end-int.crt;
+        ssl_certificate_key ec-end.key;
+
+        ssl_stapling_file %%TESTDIR%%/ec-resp.der;
+    }
+
+    server {
+        listen       127.0.0.1:8449 ssl;
+        server_name  localhost;
+
+        ssl_stapling_responder http://127.0.0.1:8080/;
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+my $p = port(8081);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+authorityInfoAccess = OCSP;URI:http://127.0.0.1:$p
+EOF
+
+foreach my $name ('root') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+    system("openssl req -new "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('ec-end') {
+    system("openssl ecparam -genkey -out $d/$name.key -name prime256v1 "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create EC param: $!\n";
+    system("openssl req -new -key $d/$name.key "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=ec-end/ -in $d/ec-end.csr -out $d/ec-end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for ec-end: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for end: $!\n";
+
+# RFC 6960, serialNumber
+
+system("openssl x509 -in $d/end.crt -serial -noout "
+    . ">>$d/serial 2>>$d/openssl.out") == 0
+    or die "Can't obtain serial for end: $!\n";
+
+my $serial = pack("n2", 0x0202, hex $1) if $t->read_file('serial') =~ /(\d+)/;
+
+system("openssl ca -config $d/ca.conf -revoke $d/end.crt "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't revoke end.crt: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/end.crt "
+    . "-reqout $d/req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/root.crt -rkey $d/root.key "
+    . "-reqin $d/req.der -respout $d/resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create OCSP response: $!\n";
+
+system("openssl ocsp -issuer $d/int.crt -cert $d/ec-end.crt "
+    . "-reqout $d/ec-req.der >>$d/openssl.out 2>&1") == 0
+    or die "Can't create EC OCSP request: $!\n";
+
+system("openssl ocsp -index $d/certindex -CA $d/int.crt "
+    . "-rsigner $d/root.crt -rkey $d/root.key "
+    . "-reqin $d/ec-req.der -respout $d/ec-resp.der -ndays 1 "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create EC OCSP response: $!\n";
+
+$t->write_file('trusted.crt',
+    $t->read_file('int.crt') . $t->read_file('root.crt'));
+$t->write_file('end-int.crt',
+    $t->read_file('end.crt') . $t->read_file('int.crt'));
+$t->write_file('ec-end-int.crt',
+    $t->read_file('ec-end.crt') . $t->read_file('int.crt'));
+
+$t->run_daemon(\&http_daemon, $t);
+$t->run();
+
+$t->waitforsocket("127.0.0.1:" . port(8081));
+
+###############################################################################
+
+my $version = get_version();
+
+staple(8443, 'RSA');
+staple(8443, 'ECDSA');
+staple(8444, 'RSA');
+staple(8444, 'ECDSA');
+staple(8445, 'ECDSA');
+staple(8446, 'ECDSA');
+staple(8449, 'ECDSA');
+
+sleep 1;
+
+ok(!staple(8443, 'RSA'), 'staple revoked');
+ok(staple(8443, 'ECDSA'), 'staple success');
+
+ok(!staple(8444, 'RSA'), 'responder revoked');
+ok(staple(8444, 'ECDSA'), 'responder success');
+
+ok(!staple(8445, 'ECDSA'), 'verify - root not trusted');
+
+ok(staple(8446, 'ECDSA', "$d/int.crt"), 'cert store');
+
+is(staple(8447, 'RSA'), '1 1', 'file revoked');
+is(staple(8448, 'ECDSA'), '1 0', 'file success');
+
+ok(!staple(8449, 'ECDSA'), 'ocsp error');
+
+###############################################################################
+
+sub staple {
+    my ($port, $ciphers, $ca) = @_;
+    my (@resp);
+
+    my $staple_cb = sub {
+        my ($ssl, $resp) = @_;
+        push @resp, !!$resp;
+        return 1 unless $resp;
+        my $cert = Net::SSLeay::get_peer_certificate($ssl);
+        my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl, $cert) }
+            or do { die "no OCSP_CERTID for certificate: $@"; };
+
+        my @res = Net::SSLeay::OCSP_response_results($resp, $certid);
+        push @resp, $res[0][2]->{'statusType'};
+    };
+
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+    my $ssleay = Net::SSLeay::SSLeay();
+    if ($ssleay < 0x1000200f || $ssleay == 0x20000000) {
+        Net::SSLeay::CTX_set_cipher_list($ctx, $ciphers)
+            or die("Failed to set cipher list");
+    } else {
+        # SSL_CTRL_SET_SIGALGS_LIST
+        $ciphers = 'PSS' if $ciphers eq 'RSA' && $version > 0x0303;
+        Net::SSLeay::CTX_ctrl($ctx, 98, 0, $ciphers . '+SHA256')
+            or die("Failed to set sigalgs");
+    }
+
+    Net::SSLeay::CTX_load_verify_locations($ctx, $ca || '', '');
+    Net::SSLeay::CTX_set_tlsext_status_cb($ctx, $staple_cb);
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_status_type($ssl,
+        Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+
+    return join ' ', @resp;
+}
+
+sub get_version {
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::INET->new('127.0.0.1:' . port(8443));
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+
+    Net::SSLeay::version($ssl);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($t) = shift;
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => "127.0.0.1:" . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+\/([^ ]+)\s+HTTP/i;
+        next unless $uri;
+
+        $uri =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
+        my $req = decode_base64($uri);
+        my $resp = index($req, $serial) > 0 ? 'resp' : 'ec-resp';
+
+        # ocsp dummy handler
+
+        select undef, undef, undef, 0.02;
+
+        $headers = <<"EOF";
+HTTP/1.1 200 OK
+Connection: close
+Content-Type: application/ocsp-response
+
+EOF
+
+        local $/;
+        open my $fh, '<', "$d/$resp.der"
+            or die "Can't open $resp.der: $!";
+        binmode $fh;
+        my $content = <$fh>;
+        close $fh;
+
+        print $client $headers . $content;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl.t ../asynch_mode_nginx/test/nginx-tests/ssl.t
--- nginx-release-1.20.1/test/nginx-tests/ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,429 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl rewrite proxy/)
+    ->has_daemon('openssl')->plan(26);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    log_format ssl $ssl_protocol;
+
+    server {
+        listen       127.0.0.1:8085 ssl;
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        %%TEST_GLOBALS_HTTPS%%
+        ssl_certificate_key inner.key;
+        ssl_certificate inner.crt;
+        ssl_session_cache shared:SSL:1m;
+        ssl_verify_client optional_no_ca;
+
+        keepalive_requests 1000;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+        location /id {
+            return 200 "body $ssl_session_id";
+        }
+        location /cipher {
+            return 200 "body $ssl_cipher";
+        }
+        location /ciphers {
+            return 200 "body $ssl_ciphers";
+        }
+        location /client_verify {
+            return 200 "body $ssl_client_verify";
+        }
+        location /protocol {
+            return 200 "body $ssl_protocol";
+        }
+        location /issuer {
+            return 200 "body $ssl_client_i_dn:$ssl_client_i_dn_legacy";
+        }
+        location /subject {
+            return 200 "body $ssl_client_s_dn:$ssl_client_s_dn_legacy";
+        }
+        location /time {
+            return 200 "body $ssl_client_v_start!$ssl_client_v_end!$ssl_client_v_remain";
+        }
+
+        location /body {
+            add_header X-Body $request_body always;
+            proxy_pass http://127.0.0.1:8080/;
+
+            access_log %%TESTDIR%%/ssl.log ssl;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        # Special case for enabled "ssl" directive.
+
+        ssl on;
+        %%TEST_GLOBALS_HTTPS%%
+        ssl_session_cache builtin;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_session_cache builtin:1000;
+        %%TEST_GLOBALS_HTTPS%%
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl;
+        server_name  localhost;
+
+        ssl_session_cache none;
+        %%TEST_GLOBALS_HTTPS%%
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        server_name  localhost;
+
+        ssl_session_cache off;
+        %%TEST_GLOBALS_HTTPS%%
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8086 ssl;
+        server_name  localhost;
+        %%TEST_GLOBALS_HTTPS%%
+
+        ssl_session_cache shared:SSL:1m;
+        ssl_session_timeout 1;
+
+        location / {
+            return 200 "body $ssl_session_reused";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 3
+
+[ myca_policy ]
+commonName = supplied
+EOF
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system('openssl req -x509 -new '
+    . "-config $d/openssl.conf -subj /CN=issuer/ "
+    . "-out $d/issuer.crt -keyout $d/issuer.key "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create certificate for issuer: $!\n";
+
+system("openssl req -new "
+    . "-config $d/openssl.conf -subj /CN=subject/ "
+    . "-out $d/subject.csr -keyout $d/subject.key "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't create certificate for subject: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/issuer.key -cert $d/issuer.crt "
+    . "-subj /CN=subject/ -in $d/subject.csr -out $d/subject.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for subject: $!\n";
+
+foreach my $name ('localhost', 'inner') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+# suppress deprecation warning
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run();
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+my $ctx;
+
+SKIP: {
+skip 'no TLS 1.3 sessions', 6 if get('/protocol', 8085) =~ /TLSv1.3/
+    && ($Net::SSLeay::VERSION < 1.88 || $IO::Socket::SSL::VERSION < 2.061);
+
+$ctx = get_ssl_context();
+
+like(get('/', 8085, $ctx), qr/^body \.$/m, 'cache shared');
+like(get('/', 8085, $ctx), qr/^body r$/m, 'cache shared reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8081, $ctx), qr/^body \.$/m, 'cache builtin');
+like(get('/', 8081, $ctx), qr/^body r$/m, 'cache builtin reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8082, $ctx), qr/^body \.$/m, 'cache builtin size');
+like(get('/', 8082, $ctx), qr/^body r$/m, 'cache builtin size reused');
+
+}
+
+$ctx = get_ssl_context();
+
+like(get('/', 8083, $ctx), qr/^body \.$/m, 'cache none');
+like(get('/', 8083, $ctx), qr/^body \.$/m, 'cache none not reused');
+
+$ctx = get_ssl_context();
+
+like(get('/', 8084, $ctx), qr/^body \.$/m, 'cache off');
+like(get('/', 8084, $ctx), qr/^body \.$/m, 'cache off not reused');
+
+# ssl certificate inheritance
+
+my $s = get_ssl_socket(8081);
+like($s->dump_peer_certificate(), qr/CN=localhost/, 'CN');
+
+$s->close();
+
+$s = get_ssl_socket(8085);
+like($s->dump_peer_certificate(), qr/CN=inner/, 'CN inner');
+
+$s->close();
+
+# session timeout
+
+$ctx = get_ssl_context();
+
+get('/', 8086, $ctx);
+select undef, undef, undef, 2.1;
+
+like(get('/', 8086, $ctx), qr/^body \.$/m, 'session timeout');
+
+# embedded variables
+
+like(get('/id', 8085), qr/^body \w{64}$/m, 'session id');
+unlike(http_get('/id'), qr/body \w/, 'session id no ssl');
+like(get('/cipher', 8085), qr/^body [\w-]+$/m, 'cipher');
+
+SKIP: {
+skip 'BoringSSL', 1 if $t->has_module('BoringSSL');
+
+like(get('/ciphers', 8085), qr/^body [:\w-]+$/m, 'ciphers');
+
+}
+
+like(get('/client_verify', 8085), qr/^body NONE$/m, 'client verify');
+like(get('/protocol', 8085), qr/^body (TLS|SSL)v(\d|\.)+$/m, 'protocol');
+like(cert('/issuer', 8085), qr!^body CN=issuer:/CN=issuer$!m, 'issuer');
+like(cert('/subject', 8085), qr!^body CN=subject:/CN=subject$!m, 'subject');
+like(cert('/time', 8085), qr/^body [:\s\w]+![:\s\w]+![23]$/m, 'time');
+
+# c->read->ready handling bug in ngx_ssl_recv(), triggered with chunked body
+
+like(get_body('/body', '0123456789', 20, 5), qr/X-Body: (0123456789){100}/,
+    'request body chunked');
+
+# pipelined requests
+
+$s = get_ssl_socket(8085);
+my $req = <<EOF;
+GET / HTTP/1.1
+Host: localhost
+
+EOF
+
+$req x= 1000;
+
+my $r = http($req, socket => $s) || "";
+is(() = $r =~ /(200 OK)/g, 1000, 'pipelined requests');
+
+# close_notify is sent before lingering close
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.5');
+
+is(get_ssl_shutdown(8085), 1, 'ssl shutdown on lingering close');
+
+}
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' if $t->has_version('1.19.5');
+
+like($t->read_file('ssl.log'), qr/^(TLS|SSL)v(\d|\.)+$/m,
+    'log ssl variable on lingering close');
+
+}
+
+###############################################################################
+
+sub get {
+    my ($uri, $port, $ctx) = @_;
+    my $s = get_ssl_socket($port, $ctx) or return;
+    my $r = http_get($uri, socket => $s);
+    $s->close();
+    return $r;
+}
+
+sub get_body {
+    my ($uri, $body, $len, $n) = @_;
+    my $s = get_ssl_socket(8085) or return;
+    http("GET /body HTTP/1.1" . CRLF
+        . "Host: localhost" . CRLF
+        . "Connection: close" . CRLF
+        . "Transfer-Encoding: chunked" . CRLF . CRLF,
+        socket => $s, start => 1);
+    my $chs = unpack("H*", pack("C", length($body) * $len));
+    http($chs . CRLF . $body x $len . CRLF, socket => $s, start => 1)
+        for 1 .. $n;
+    my $r = http("0" . CRLF . CRLF, socket => $s);
+    $s->close();
+    return $r;
+}
+
+sub cert {
+    my ($uri, $port) = @_;
+    my $s = get_ssl_socket($port, undef,
+        SSL_cert_file => "$d/subject.crt",
+        SSL_key_file => "$d/subject.key") or return;
+    http_get($uri, socket => $s);
+}
+
+sub get_ssl_context {
+    return IO::Socket::SSL::SSL_Context->new(
+        SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+        SSL_session_cache_size => 100
+    );
+}
+
+sub get_ssl_socket {
+    my ($port, $ctx, %extra) = @_;
+    my $s;
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => port($port),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_reuse_ctx => $ctx,
+            SSL_error_trap => sub { die $_[1] },
+            %extra
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+sub get_ssl_shutdown {
+    my ($port) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    Net::SSLeay::write($ssl, 'GET /' . CRLF . 'extra');
+    Net::SSLeay::read($ssl);
+    Net::SSLeay::set_shutdown($ssl, 1);
+    Net::SSLeay::shutdown($ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_verify_client.t ../asynch_mode_nginx/test/nginx-tests/ssl_verify_client.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_verify_client.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_verify_client.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,213 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl sni/)
+    ->has_daemon('openssl')->plan(13);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    add_header X-Verify x$ssl_client_verify:${ssl_client_cert}x;
+
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  on;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  optional;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  off;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client off;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  optional.no.ca;
+
+        ssl_certificate_key 1.example.com.key;
+        ssl_certificate 1.example.com.crt;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  no.context;
+
+        ssl_verify_client on;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('t', 'SEE-THIS');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/t'), qr/x:x/, 'plain connection');
+like(get('on'), qr/400 Bad Request/, 'no cert');
+like(get('no.context'), qr/400 Bad Request/, 'no server cert');
+like(get('optional'), qr/NONE:x/, 'no optional cert');
+like(get('optional', '1.example.com'), qr/400 Bad/, 'bad optional cert');
+like(get('optional.no.ca', '1.example.com'), qr/FAILED.*BEGIN/,
+    'bad optional_no_ca cert');
+like(get('off', '2.example.com'), qr/NONE/, 'off cert');
+like(get('off', '3.example.com'), qr/NONE/, 'off cert trusted');
+
+like(get('localhost', '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert');
+like(get('optional', '2.example.com'), qr/SUCCESS.*BEGI/, 'good cert optional');
+like(get('optional', '3.example.com'), qr/SUCCESS.*BEGIN/, 'good cert trusted');
+
+SKIP: {
+skip 'Net::SSLeay version >= 1.36 required', 1 if $Net::SSLeay::VERSION < 1.36;
+
+my $ca = join ' ', get('optional', '3.example.com');
+is($ca, '/CN=2.example.com', 'no trusted sent');
+
+}
+
+like(get('optional', undef, 'localhost'), qr/421 Misdirected/, 'misdirected');
+
+###############################################################################
+
+sub get {
+    my ($sni, $cert, $host) = @_;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    $host = $sni if !defined $host;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port(8081));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    Net::SSLeay::set_cert_and_key($ctx, "$d/$cert.crt", "$d/$cert.key")
+        or die if $cert;
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_host_name($ssl, $sni) == 1 or die;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+
+    Net::SSLeay::write($ssl, 'GET /t HTTP/1.0' . CRLF);
+    Net::SSLeay::write($ssl, "Host: $host" . CRLF . CRLF);
+    my $buf = Net::SSLeay::read($ssl);
+    log_in($buf);
+    return $buf unless wantarray();
+
+    my $list = Net::SSLeay::get_client_CA_list($ssl);
+    my @names;
+    for my $i (0 .. Net::SSLeay::sk_X509_NAME_num($list) - 1) {
+        my $name = Net::SSLeay::sk_X509_NAME_value($list, $i);
+        push @names, Net::SSLeay::X509_NAME_oneline($name);
+    }
+    return @names;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/ssl_verify_depth.t ../asynch_mode_nginx/test/nginx-tests/ssl_verify_depth.t
--- nginx-release-1.20.1/test/nginx-tests/ssl_verify_depth.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/ssl_verify_depth.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,215 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http ssl module, ssl_verify_depth.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl/)
+    ->has_daemon('openssl')->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    ssl_certificate localhost.crt;
+    ssl_certificate_key localhost.key;
+
+    ssl_verify_client on;
+    ssl_client_certificate root-int.crt;
+
+    add_header X-Client $ssl_client_s_dn always;
+    add_header X-Verify $ssl_client_verify always;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+        ssl_verify_depth 0;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+        ssl_verify_depth 1;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+        ssl_verify_depth 2;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('ca.conf', <<EOF);
+[ ca ]
+default_ca = myca
+
+[ myca ]
+new_certs_dir = $d
+database = $d/certindex
+default_md = sha256
+policy = myca_policy
+serial = $d/certserial
+default_days = 1
+x509_extensions = myca_extensions
+
+[ myca_policy ]
+commonName = supplied
+
+[ myca_extensions ]
+basicConstraints = critical,CA:TRUE
+EOF
+
+foreach my $name ('root', 'localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('int', 'end') {
+    system("openssl req -new "
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.csr -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('certserial', '1000');
+$t->write_file('certindex', '');
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/root.key -cert $d/root.crt "
+    . "-subj /CN=int/ -in $d/int.csr -out $d/int.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for int: $!\n";
+
+system("openssl ca -batch -config $d/ca.conf "
+    . "-keyfile $d/int.key -cert $d/int.crt "
+    . "-subj /CN=end/ -in $d/end.csr -out $d/end.crt "
+    . ">>$d/openssl.out 2>&1") == 0
+    or die "Can't sign certificate for end: $!\n";
+
+$t->write_file('root-int.crt', $t->read_file('root.crt')
+    . $t->read_file('int.crt'));
+
+$t->write_file('t', '');
+$t->run();
+
+###############################################################################
+
+# with verify depth 0, only self-signed certificates should
+# be allowed
+
+# OpenSSL 1.1.0+ instead limits the number of intermediate certs allowed;
+# as a result, it is not possible to limit certificate checking
+# to self-signed certificates only when using OpenSSL 1.1.0+
+
+like(get(8080, 'root'), qr/SUCCESS/, 'verify depth 0 - root');
+like(get(8080, 'int'),  qr/FAI|SUC/, 'verify depth 0 - no int');
+like(get(8080, 'end'),  qr/FAILED/,  'verify depth 0 - no end');
+
+# with verify depth 1 (the default), one signature is
+# expected to be checked, so certificates directly signed
+# by the root cert are allowed, but nothing more
+
+# OpenSSL 1.1.0+ instead limits the number of intermediate certs allowed;
+# so with depth 1 it is possible to validate not only directly signed
+# certificates, but also chains with one intermediate certificate
+
+like(get(8081, 'root'), qr/SUCCESS/, 'verify depth 1 - root');
+like(get(8081, 'int'),  qr/SUCCESS/, 'verify depth 1 - int');
+like(get(8081, 'end'),  qr/FAI|SUC/, 'verify depth 1 - no end');
+
+# with verify depth 2 it is also possible to validate up to two signatures,
+# so chains with one intermediate certificate are allowed
+
+like(get(8082, 'root'), qr/SUCCESS/, 'verify depth 2 - root');
+like(get(8082, 'int'),  qr/SUCCESS/, 'verify depth 2 - int');
+like(get(8082, 'end'),  qr/SUCCESS/, 'verify depth 2 - end');
+
+###############################################################################
+
+sub get {
+    my ($port, $cert) = @_;
+    my $s = get_ssl_socket($port, $cert) or return;
+    http_get("/t?$cert", socket => $s);
+}
+
+sub get_ssl_socket {
+    my ($port, $cert) = @_;
+    my ($s);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        $s = IO::Socket::SSL->new(
+            Proto => 'tcp',
+            PeerAddr => '127.0.0.1',
+            PeerPort => port($port),
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_cert_file => "$d/$cert.crt",
+            SSL_key_file => "$d/$cert.key",
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_access_log_escape.t ../asynch_mode_nginx/test/nginx-tests/stream_access_log_escape.t
--- nginx-release-1.20.1/test/nginx-tests/stream_access_log_escape.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_access_log_escape.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,71 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for access_log with escape parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $pid $a {
+        default '" \ "';
+    }
+    map $pid $b {
+        default "foo";
+    }
+
+    log_format json     escape=json     $a$b$upstream_addr;
+    log_format default  escape=default  $a$b$upstream_addr;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       ok;
+
+        access_log %%TESTDIR%%/json.log json;
+        access_log %%TESTDIR%%/test.log default;
+    }
+}
+
+EOF
+
+$t->run()->plan(2);
+
+###############################################################################
+
+http_get('/');
+
+$t->stop();
+
+is($t->read_file('json.log'), '\" \\\\ \"foo' . "\n", 'json');
+is($t->read_file('test.log'), '\x22 \x5C \x22foo-' . "\n", 'default');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_access_log_none.t ../asynch_mode_nginx/test/nginx-tests/stream_access_log_none.t
--- nginx-release-1.20.1/test/nginx-tests/stream_access_log_none.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_access_log_none.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,68 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for access_log with escape parameter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $pid $a {
+        default '" \ "';
+    }
+    map $pid $b {
+        default "foo";
+    }
+
+    log_format none     escape=none     $a$b$upstream_addr;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       ok;
+
+        access_log %%TESTDIR%%/none.log none;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+http_get('/');
+
+$t->stop();
+
+is($t->read_file('none.log'), '" \\ "foo' . "\n", 'none');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_access_log.t ../asynch_mode_nginx/test/nginx-tests/stream_access_log.t
--- nginx-release-1.20.1/test/nginx-tests/stream_access_log.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_access_log.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream access_log module and variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Sys::Hostname;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map gzip/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format  test  $server_addr;
+    log_format  vars  $connection:$nginx_version:$hostname:$pid;
+    log_format  addr  $binary_remote_addr:$remote_addr:$remote_port:
+                      $server_addr:$server_port:$upstream_addr;
+    log_format  date  $msec!$time_local!$time_iso8601;
+    log_format  byte  $bytes_received:$bytes_sent:
+                      $upstream_bytes_sent:$upstream_bytes_received;
+    log_format  time  $upstream_connect_time:$upstream_first_byte_time:
+                      $upstream_session_time:$session_time;
+
+    access_log  %%TESTDIR%%/off.log test;
+
+    map $server_port $logme {
+        %%PORT_8083%%  1;
+        default        0;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8080;
+        access_log  off;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+        proxy_download_rate 2;
+        access_log  %%TESTDIR%%/time.log time;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/filtered.log test if=$logme;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/complex.log test if=$logme$logme;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/compressed.log test
+                    gzip buffer=1m flush=100ms;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/varlog_$bytes_sent.log test;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  127.0.0.1:8080;
+        access_log  %%TESTDIR%%/vars.log vars;
+        access_log  %%TESTDIR%%/addr.log addr;
+        access_log  %%TESTDIR%%/date.log date;
+        access_log  %%TESTDIR%%/byte.log byte;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->plan(10);
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+stream('127.0.0.1:' . port(8081))->io($str);
+stream('127.0.0.1:' . port(8082))->io($str);
+stream('127.0.0.1:' . port(8083))->io($str);
+stream('127.0.0.1:' . port(8084))->io($str);
+stream('127.0.0.1:' . port(8085))->io($str);
+stream('127.0.0.1:' . port(8086))->io($str);
+stream('127.0.0.1:' . port(8087))->io($str);
+
+my $dport = port(8088);
+my $s = stream("127.0.0.1:$dport");
+my $lhost = $s->sockhost();
+my $escaped = $s->sockaddr();
+$escaped =~ s/([^\x20-\x7e])/sprintf('\\x%02X', ord($1))/gmxe;
+my $lport = $s->sockport();
+my $uport = port(8080);
+
+$s->io($str);
+
+# wait for file to appear with nonzero size thanks to the flush parameter
+
+for (1 .. 10) {
+    last if -s $t->testdir() . '/compressed.log';
+    select undef, undef, undef, 0.1;
+}
+
+# verify that "gzip" parameter turns on compression
+
+SKIP: {
+    eval { require IO::Uncompress::Gunzip; };
+    skip("IO::Uncompress::Gunzip not installed", 1) if $@;
+
+    my $gzipped = $t->read_file('compressed.log');
+    my $log;
+    IO::Uncompress::Gunzip::gunzip(\$gzipped => \$log);
+    like($log, qr/^127.0.0.1/, 'compressed log - flush time');
+}
+
+# now verify all other logs
+
+$t->stop();
+
+is($t->read_file('off.log'), '', 'log off');
+is($t->read_file('filtered.log'), "127.0.0.1\n", 'log filtering');
+ok($t->read_file('complex.log'), 'if with complex value');
+ok($t->read_file('varlog_3.log'), 'variable in file');
+
+my $hostname = lc hostname();
+like($t->read_file('vars.log'), qr/^\d+:[\d.]+:$hostname:\d+$/, 'log vars');
+is($t->read_file('addr.log'),
+    "$escaped:$lhost:$lport:127.0.0.1:$dport:127.0.0.1:$uport\n",
+    'log addr');
+like($t->read_file('date.log'), qr#^\d+.\d+![-+\w/: ]+![-+\dT:]+$#, 'log date');
+is($t->read_file('byte.log'), "8:3:8:3\n", 'log bytes');
+like($t->read_file('time.log'), qr/0\.\d+:0\.\d+:1\.\d+:1\.\d+/, 'log time');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => port(8080),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        $buffer = "ack";
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_access.t ../asynch_mode_nginx/test/nginx-tests/stream_access.t
--- nginx-release-1.20.1/test/nginx-tests/stream_access.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_access.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,230 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream access module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_access unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen       127.0.0.1:8082;
+        proxy_pass   [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen       127.0.0.1:8083;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.0;
+    }
+
+    server {
+        listen       127.0.0.1:8085;
+        proxy_pass   [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen       127.0.0.1:8086;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.1;
+    }
+
+    server {
+        listen       127.0.0.1:8088;
+        proxy_pass   [::1]:%%PORT_8082%%;
+    }
+
+    server {
+        listen       127.0.0.1:8089;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.2;
+    }
+
+    server {
+        listen       127.0.0.1:8091;
+        proxy_pass   [::1]:%%PORT_8083%%;
+    }
+
+    server {
+        listen       127.0.0.1:8092;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.3;
+    }
+
+    server {
+        listen       127.0.0.1:8094;
+        proxy_pass   [::1]:%%PORT_8084%%;
+    }
+
+    server {
+        listen       127.0.0.1:8095;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.4;
+    }
+
+    server {
+        listen       127.0.0.1:8097;
+        proxy_pass   [::1]:%%PORT_8085%%;
+    }
+
+    server {
+        listen       127.0.0.1:8098;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock.5;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       [::1]:%%PORT_8080%%;
+        listen       unix:%%TESTDIR%%/unix.sock.0;
+        proxy_pass   127.0.0.1:8080;
+        allow        all;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        listen       [::1]:%%PORT_8081%%;
+        listen       unix:%%TESTDIR%%/unix.sock.1;
+        proxy_pass   127.0.0.1:8080;
+        deny         all;
+    }
+
+    server {
+        listen       127.0.0.1:8087;
+        listen       [::1]:%%PORT_8082%%;
+        listen       unix:%%TESTDIR%%/unix.sock.2;
+        proxy_pass   127.0.0.1:8080;
+        allow        unix:;
+    }
+
+    server {
+        listen       127.0.0.1:8090;
+        listen       [::1]:%%PORT_8083%%;
+        listen       unix:%%TESTDIR%%/unix.sock.3;
+        proxy_pass   127.0.0.1:8080;
+        deny         127.0.0.1;
+    }
+
+    server {
+        listen       127.0.0.1:8093;
+        listen       [::1]:%%PORT_8084%%;
+        listen       unix:%%TESTDIR%%/unix.sock.4;
+        proxy_pass   127.0.0.1:8080;
+        deny         ::1;
+    }
+
+    server {
+        listen       127.0.0.1:8096;
+        listen       [::1]:%%PORT_8085%%;
+        listen       unix:%%TESTDIR%%/unix.sock.5;
+        proxy_pass   127.0.0.1:8080;
+        deny         unix:;
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(18);
+$t->run_daemon(\&stream_daemon);
+$t->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+# allow all
+
+is(stream('127.0.0.1:' . port(8081))->io($str), $str, 'inet allow all');
+is(stream('127.0.0.1:' . port(8082))->io($str), $str, 'inet6 allow all');
+is(stream('127.0.0.1:' . port(8083))->io($str), $str, 'unix allow all');
+
+# deny all
+
+is(stream('127.0.0.1:' . port(8084))->io($str), '', 'inet deny all');
+is(stream('127.0.0.1:' . port(8085))->io($str), '', 'inet6 deny all');
+is(stream('127.0.0.1:' . port(8086))->io($str), '', 'unix deny all');
+
+# allow unix
+
+is(stream('127.0.0.1:' . port(8087))->io($str), $str, 'inet allow unix');
+is(stream('127.0.0.1:' . port(8088))->io($str), $str, 'inet6 allow unix');
+is(stream('127.0.0.1:' . port(8089))->io($str), $str, 'unix allow unix');
+
+# deny inet
+
+is(stream('127.0.0.1:' . port(8090))->io($str), '', 'inet deny inet');
+is(stream('127.0.0.1:' . port(8091))->io($str), $str, 'inet6 deny inet');
+is(stream('127.0.0.1:' . port(8092))->io($str), $str, 'unix deny inet');
+
+# deny inet6
+
+is(stream('127.0.0.1:' . port(8093))->io($str), $str, 'inet deny inet6');
+is(stream('127.0.0.1:' . port(8094))->io($str), '', 'inet6 deny inet6');
+is(stream('127.0.0.1:' . port(8095))->io($str), $str, 'unix deny inet6');
+
+# deny unix
+
+is(stream('127.0.0.1:' . port(8096))->io($str), $str, 'inet deny unix');
+is(stream('127.0.0.1:' . port(8097))->io($str), $str, 'inet6 deny unix');
+is(stream('127.0.0.1:' . port(8098))->io($str), '', 'unix deny unix');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8080),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_error_log.t ../asynch_mode_nginx/test/nginx-tests/stream_error_log.t
--- nginx-release-1.20.1/test/nginx-tests/stream_error_log.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_error_log.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,313 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for error_log.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Sys::Hostname;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(34);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log %%TESTDIR%%/e_glob.log info;
+error_log %%TESTDIR%%/e_glob2.log info;
+error_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% info;
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u {
+        server 127.0.0.1:%%PORT_8983_UDP%% down;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+
+        error_log %%TESTDIR%%/e_debug.log debug;
+        error_log %%TESTDIR%%/e_info.log info;
+        error_log %%TESTDIR%%/e_emerg.log emerg;
+        error_log stderr info;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8081;
+
+        error_log %%TESTDIR%%/e_stream.log info;
+        error_log syslog:server=127.0.0.1:%%PORT_8985_UDP%% info;
+        error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% info;
+    }
+}
+
+EOF
+
+open OLDERR, ">&", \*STDERR;
+open STDERR, '>', $t->testdir() . '/stderr' or die "Can't reopen STDERR: $!";
+open my $stderr, '<', $t->testdir() . '/stderr'
+    or die "Can't open stderr file: $!";
+
+$t->run_daemon(\&stream_daemon);
+$t->run_daemon(\&syslog_daemon, port(8983), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8984), $t, 's_stream.log');
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_stream.log');
+
+$t->run();
+
+open STDERR, ">&", \*OLDERR;
+
+###############################################################################
+
+stream('127.0.0.1:' . port(8080))->io('data');
+
+# error_log levels
+
+SKIP: {
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(lines($t, 'e_debug.log', '[debug]'), 0, 'file debug in debug');
+
+}
+
+isnt(lines($t, 'e_info.log', '[info]'), 0, 'file info in info');
+is(lines($t, 'e_info.log', '[debug]'), 0, 'file debug in info');
+isnt(lines($t, 'stderr', '[info]'), 0, 'stderr info in info');
+is(lines($t, 'stderr', '[debug]'), 0, 'stderr debug in info');
+
+# multiple error_log
+
+like($t->read_file('e_glob.log'), qr!nginx/[.0-9]+!, 'error global');
+like($t->read_file('e_glob2.log'), qr!nginx/[.0-9]+!, 'error global 2');
+is_deeply(levels($t, 'e_glob.log'), levels($t, 'e_glob2.log'),
+    'multiple error global');
+
+# syslog
+
+parse_syslog_message('syslog', get_syslog('data2', '127.0.0.1:' . port(8082),
+    port(8985)));
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'e_glob.log'),
+    'global syslog messages');
+is_deeply(levels($t, 's_stream.log'), levels($t, 'e_stream.log'),
+    'stream syslog messages');
+
+# error_log context
+
+SKIP: {
+skip "relies on error log contents", 5 unless $ENV{TEST_NGINX_UNSAFE};
+
+my $msg = 'no live upstreams while connecting to upstream, '
+    . 'client: 127.0.0.1, server: 127.0.0.1:' . port(8080)
+    . ', upstream: "u"';
+
+unlike($t->read_file('e_glob.log'), qr/$msg/ms, 'stream error in global');
+like($t->read_file('e_info.log'), qr/$msg/ms, 'stream error in info');
+like($t->read_file('stderr'), qr/$msg/ms, 'stream error in info stderr');
+unlike($t->read_file('e_emerg.log'), qr/$msg/ms, 'stream error in emerg');
+
+$msg = "bytes from/to client:5/4, bytes from/to upstream:4/5";
+
+like($t->read_file('e_stream.log'), qr/$msg/ms, 'stream byte counters');
+
+}
+
+###############################################################################
+
+sub lines {
+    my ($t, $file, $pattern) = @_;
+
+    if ($file eq 'stderr') {
+        return map { $_ =~ /\Q$pattern\E/ } (<$stderr>);
+    }
+
+    my $path = $t->testdir() . '/' . $file;
+    open my $fh, '<', $path or return "$!";
+    my $value = map { $_ =~ /\Q$pattern\E/ } (<$fh>);
+    close $fh;
+    return $value;
+}
+
+sub levels {
+    my ($t, $file) = @_;
+    my %levels_hash;
+
+    map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+    return \%levels_hash;
+}
+
+sub get_syslog {
+    my ($data, $peer, $port) = @_;
+    my ($s);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(1);
+        $s = IO::Socket::INET->new(
+            Proto => 'udp',
+            LocalAddr => "127.0.0.1:$port"
+        );
+        alarm(0);
+    };
+    alarm(0);
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    stream($peer)->io($data);
+    $data = '';
+
+    IO::Select->new($s)->can_read(1.5);
+    while (IO::Select->new($s)->can_read(0.1)) {
+        my $buffer;
+        sysread($s, $buffer, 4096);
+        $data .= $buffer;
+    }
+    $s->close();
+    return $data;
+}
+
+sub parse_syslog_message {
+    my ($desc, $line) = @_;
+
+    ok($line, $desc);
+
+SKIP: {
+    skip "$desc timeout", 18 unless $line;
+
+    my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+        'Sep', 'Oct', 'Nov', 'Dec');
+
+    my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+        $line =~ /^<(\d{1,3})>                # PRI
+            ([A-Z][a-z]{2})\s            # mon
+            ([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s    # date
+            ([\S]*)\s                # host
+            (\w{1,32}):\s                # tag
+            (.*)/x;                    # MSG
+
+    my $sev = $pri & 0x07;
+    my $fac = ($pri & 0x03f8) >> 3;
+
+    ok(defined($pri), "$desc has PRI");
+    ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+    ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+    ok(defined($mon), "$desc has month");
+    ok((grep $mon, @months), "$desc valid month");
+
+    ok(defined($mday), "$desc has day");
+    ok($mday <= 31, "$desc valid day");
+
+    ok(defined($hour), "$desc has hour");
+    ok($hour < 24, "$desc valid hour");
+
+    ok(defined($minute), "$desc has minutes");
+    ok($minute < 60, "$desc valid minutes");
+
+    ok(defined($sec), "$desc has seconds");
+    ok($sec < 60, "$desc valid seconds");
+
+    ok(defined($host), "$desc has host");
+    is($host, lc(hostname()), "$desc valid host");
+
+    ok(defined($tag), "$desc has tag");
+    like($tag, qr'\w+', "$desc valid tag");
+
+    ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+}
+
+###############################################################################
+
+sub syslog_daemon {
+    my ($port, $t, $file) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$port"
+    );
+
+    open my $fh, '>', $t->testdir() . '/' . $file;
+    select $fh; $| = 1;
+
+    while (1) {
+        my $buffer;
+        $s->recv($buffer, 4096);
+        print $fh $buffer . "\n";
+    }
+}
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        $buffer = $client->sockport();
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_geo_binary.t ../asynch_mode_nginx/test/nginx-tests/stream_geo_binary.t
--- nginx-release-1.20.1/test/nginx-tests/stream_geo_binary.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_geo_binary.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,75 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module with binary base.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'long configuration parsing') unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    geo $geo_base_create {
+        ranges;
+        include  base.conf;
+    }
+
+    geo $geo_base_include {
+        ranges;
+        include  base.conf;
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  "geo_base_create:$geo_base_create
+                 geo_base_include:$geo_base_include";
+    }
+}
+
+EOF
+
+$t->write_file('base.conf', join('', map {
+    "127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." . $_ % 256 .
+    "-127." . $_/256/256 % 256 . "." . $_/256 % 256 . "." .$_ % 256 . " " .
+    ($_ == 1 ? "loopback" : "range$_") . ";" } (0 .. 100000)));
+
+$t->run()->plan(2);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo_base_create}, 'loopback', 'geo binary base create');
+is($data{geo_base_include}, 'loopback', 'geo binary base include');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_geoip.t ../asynch_mode_nginx/test/nginx-tests/stream_geoip.t
--- nginx-release-1.20.1/test/nginx-tests/stream_geoip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_geoip.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,196 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geoip module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_geoip stream_return/)
+    ->has('stream_realip');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    set_real_ip_from  127.0.0.1/32;
+
+    geoip_country  %%TESTDIR%%/country.dat;
+    geoip_city     %%TESTDIR%%/city.dat;
+    geoip_org      %%TESTDIR%%/org.dat;
+
+    server {
+        listen  127.0.0.1:8080 proxy_protocol;
+        return  "country_code:$geoip_country_code
+                 country_code3:$geoip_country_code3
+                 country_name:$geoip_country_name
+
+                 area_code:$geoip_area_code
+                 city_continent_code:$geoip_city_continent_code
+                 city_country_code:$geoip_city_country_code
+                 city_country_code3:$geoip_city_country_code3
+                 city_country_name:$geoip_city_country_name
+                 dma_code:$geoip_dma_code
+                 latitude:$geoip_latitude
+                 longitude:$geoip_longitude
+                 region:$geoip_region
+                 region_name:$geoip_region_name
+                 city:$geoip_city
+                 postal_code:$geoip_postal_code
+
+                 org:$geoip_org";
+    }
+}
+
+EOF
+
+my $d = $t->testdir();
+
+# country database:
+#
+# "10.0.0.1","10.0.0.1","RU","Russian Federation"
+# "2001:db8::","2001:db8::","US","United States"
+
+my $data = '';
+
+for my $i (0 .. 156) {
+    # skip to offset 32 if 1st bit set in ipv6 address wins
+    $data .= pack_node($i + 1) . pack_node(32), next if $i == 2;
+    # otherwise default to RU
+    $data .= pack_node(0xffffb9) . pack_node(0xffff00), next if $i == 31;
+    # continue checking bits set in ipv6 address
+    $data .= pack_node(0xffff00) . pack_node($i + 1), next
+        if grep $_ == $i, (44, 49, 50, 52, 53, 55, 56, 57);
+    # last bit set in ipv6 address
+    $data .= pack_node(0xffffe1) . pack_node(0xffff00), next if $i == 156;
+    $data .= pack_node($i + 1) . pack_node(0xffff00);
+}
+
+$data .= chr(0x00) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(12);
+
+$t->write_file('country.dat', $data);
+
+# city database:
+#
+# "167772161","167772161","RU","48","Moscow","119034","55.7543",37.6202",,
+
+$data = '';
+
+for my $i (0 .. 31) {
+    $data .= pack_node(32) . pack_node($i + 1), next if $i == 4 or $i == 6;
+    $data .= pack_node(32) . pack_node($i + 2), next if $i == 31;
+    $data .= pack_node($i + 1) . pack_node(32);
+}
+
+$data .= chr(42);
+$data .= chr(185);
+$data .= pack('Z*', 48);
+$data .= pack('Z*', 'Moscow');
+$data .= pack('Z*', 119034);
+$data .= pack_node(int((55.7543 + 180) * 10000));
+$data .= pack_node(int((37.6202 + 180) * 10000));
+$data .= chr(0) x 3;
+$data .= chr(0xFF) x 3;
+$data .= chr(2);
+$data .= pack_node(32);
+
+$t->write_file('city.dat', $data);
+
+# organization database:
+#
+# "167772161","167772161","Nginx"
+
+$data = '';
+
+for my $i (0 .. 31) {
+    $data .= pack_org(32) . pack_org($i + 1), next if $i == 4 or $i == 6;
+    $data .= pack_org(32) . pack_org($i + 2), next if $i == 31;
+    $data .= pack_org($i + 1) . pack_org(32);
+}
+
+$data .= chr(42);
+$data .= pack('Z*', 'Nginx');
+$data .= chr(0xFF) x 3;
+$data .= chr(5);
+$data .= pack_node(32);
+
+$t->write_file('org.dat', $data);
+$t->try_run('no inet6 support')->plan(20);
+
+###############################################################################
+
+my %data = stream_pp('10.0.0.1') =~ /(\w+):(.*)/g;
+is($data{country_code}, 'RU', 'geoip country code');
+is($data{country_code3}, 'RUS', 'geoip country code 3');
+is($data{country_name}, 'Russian Federation', 'geoip country name');
+
+is($data{area_code}, 0, 'geoip area code');
+is($data{city_continent_code}, 'EU', 'geoip city continent code');
+is($data{city_country_code}, 'RU', 'geoip city country code');
+is($data{city_country_code3}, 'RUS', 'geoip city country code 3');
+is($data{city_country_name}, 'Russian Federation', 'geoip city country name');
+is($data{dma_code}, 0, 'geoip dma code');
+is($data{latitude}, 55.7543, 'geoip latitude');
+is($data{longitude}, 37.6202, 'geoip longitude');
+is($data{region}, 48, 'geoip region');
+is($data{region_name}, 'Moscow City', 'geoip region name');
+is($data{city}, 'Moscow', 'geoip city');
+is($data{postal_code}, 119034, 'geoip postal code');
+
+is($data{org}, 'Nginx', 'geoip org');
+
+like(stream_pp('::ffff:10.0.0.1'), qr/org:Nginx/, 'geoip ipv6 ipv4-mapped');
+
+%data = stream_pp('2001:db8::') =~ /(\w+):(.*)/g;
+is($data{country_code}, 'US', 'geoip ipv6 country code');
+is($data{country_code3}, 'USA', 'geoip ipv6 country code 3');
+is($data{country_name}, 'United States', 'geoip ipv6 country name');
+
+###############################################################################
+
+sub stream_pp {
+    my ($ip) = @_;
+    my $type = ($ip =~ ':' ? 'TCP6' : 'TCP4');
+    return stream('127.0.0.1:' . port(8080))
+        ->io("PROXY $type $ip 127.0.0.1 8080 8080${CRLF}");
+}
+
+sub pack_node {
+    substr pack('V', shift), 0, 3;
+}
+
+sub pack_org {
+    pack('V', shift);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_geo_ipv6.t ../asynch_mode_nginx/test/nginx-tests/stream_geo_ipv6.t
--- nginx-release-1.20.1/test/nginx-tests/stream_geo_ipv6.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_geo_ipv6.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,106 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Stream tests for geo module with IPv6.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map stream_geo/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    geo $geo {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+    }
+
+    geo $geo_delete {
+        ::1/128         loopback;
+        2001:0db8::/32  test;
+        ::/0            world;
+        delete          ::1/128;
+    }
+
+    map $server_port $var {
+        %%PORT_8080%%  "::1";
+        %%PORT_8081%%  "::ffff:192.0.2.1";
+    }
+
+    geo $var $geo_var {
+        default    default;
+        192.0.2.1  test;
+    }
+
+    geo $var $geo_var_ranges {
+        ranges;
+        default              default;
+        127.0.0.1-127.0.0.2  loopback;
+        192.0.2.0-192.0.2.1  test;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen  [::1]:%%PORT_8080%%;
+        return  "geo:$geo
+                 geo_delete:$geo_delete
+                 geo_var:$geo_var
+                 geo_var_ranges:$geo_var_ranges";
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  "geo_var:$geo_var
+                 geo_var_ranges:$geo_var_ranges";
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(6);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'loopback', 'geo ipv6');
+is($data{geo_delete}, 'world', 'geo ipv6 delete');
+is($data{geo_var}, 'default', 'geo ipv6 from variable');
+is($data{geo_var_ranges}, 'default', 'geo ipv6 from variable range');
+
+%data = stream('127.0.0.1:' . port(8081))->read() =~ /(\w+):(\w+)/g;
+is($data{geo_var}, 'test', 'geo ipv6 ipv4-mapped from variable');
+is($data{geo_var_ranges}, 'test', 'geo ipv6 ipv4-mapped from variable range');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_geo.t ../asynch_mode_nginx/test/nginx-tests/stream_geo.t
--- nginx-release-1.20.1/test/nginx-tests/stream_geo.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_geo.t	2022-03-15 13:23:40.584403226 -0500
@@ -0,0 +1,256 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map stream_geo/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    geo $geo {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_include {
+        include       geo.conf;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_delete {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+        delete        127.0.0.0/8;
+    }
+
+    geo $remote_addr $geo_from_addr {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    map $server_port $var {
+        %%PORT_8080%%  "192.0.2.1";
+        %%PORT_8081%%  "10.0.0.1";
+        %%PORT_8085%%  "10.11.2.1";
+        %%PORT_8086%%  "loopback";
+        %%PORT_8087%%  "10.13.2.1";
+    }
+
+    geo $var $geo_from_var {
+        default       default;
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+    }
+
+    geo $var $geo_var_ranges {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+
+        # ranges with two /16 networks
+        # the latter network has greater two least octets
+        # (see 1301a58b5dac for details)
+        10.10.3.0-10.11.2.255  foo;
+        10.12.3.0-10.13.2.255  foo2;
+        delete                 10.10.3.0-10.11.2.255;
+    }
+
+    geo $var $geo_world {
+        127.0.0.0/8   loopback;
+        192.0.2.0/24  test;
+        0.0.0.0/0     world;
+    }
+
+    geo $geo_ranges {
+        ranges;
+        default                    default;
+        127.0.0.0-127.255.255.255  loopback;
+        192.0.2.0-192.0.2.255      test;
+    }
+
+    geo $geo_ranges_include {
+        ranges;
+        default                default;
+        include                geo-ranges.conf;
+        192.0.2.0-192.0.2.255  test;
+    }
+
+    geo $geo_ranges_delete {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.1    loopback;
+        delete                 127.0.0.0-127.0.0.0;
+        delete                 127.0.0.2-127.0.0.255;
+        delete                 127.0.0.1-127.0.0.1;
+    }
+
+    # delete range with two /16
+    geo $geo_ranges_delete_2 {
+        ranges;
+        default              default;
+        127.0.0.0-127.1.0.0  loopback;
+        delete               127.0.0.0-127.1.0.0;
+    }
+
+    geo $geo_before {
+        ranges;
+        default                default;
+        127.0.0.1-127.0.0.255  loopback;
+        127.0.0.0-127.0.0.0    test;
+    }
+
+    geo $geo_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.1    loopback;
+        127.0.0.2-127.0.0.255  test;
+    }
+
+    geo $geo_insert {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.2    test2;
+        127.0.0.1-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_before {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.0-127.0.0.1    loopback;
+    }
+
+    geo $geo_insert_after {
+        ranges;
+        default                default;
+        127.0.0.0-127.0.0.255  test;
+        127.0.0.1-127.0.0.255  loopback;
+     }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  "geo:$geo
+                 geo_include:$geo_include
+                 geo_delete:$geo_delete
+                 geo_ranges:$geo_ranges
+                 geo_ranges_include:$geo_ranges_include
+                 geo_before:$geo_before
+                 geo_after:$geo_after
+                 geo_insert:$geo_insert
+                 geo_insert_before:$geo_insert_before
+                 geo_insert_after:$geo_insert_after
+                 geo_from_addr:$geo_from_addr
+                 geo_from_var:$geo_from_var";
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $geo_from_var;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $geo_world;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  $geo_ranges_delete;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $geo_ranges_delete_2;
+    }
+
+    server {
+        listen  127.0.0.1:8085;
+        return  $geo_var_ranges;
+    }
+
+    server {
+        listen  127.0.0.1:8086;
+        return  $geo_var_ranges;
+    }
+
+    server {
+        listen  127.0.0.1:8087;
+        return  $geo_var_ranges;
+    }
+}
+
+EOF
+
+$t->write_file('geo.conf', '127.0.0.0/8  loopback;');
+$t->write_file('geo-ranges.conf', '127.0.0.0-127.255.255.255  loopback;');
+
+$t->run()->plan(19);
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'loopback', 'geo');
+is($data{geo_include}, 'loopback', 'geo include');
+is($data{geo_delete}, 'world', 'geo delete');
+is($data{geo_ranges}, 'loopback', 'geo ranges');
+is($data{geo_ranges_include}, 'loopback', 'geo ranges include');
+
+is(stream('127.0.0.1:' . port(8083))->read(), 'default', 'geo ranges delete');
+is(stream('127.0.0.1:' . port(8084))->read(), 'default', 'geo ranges delete 2');
+
+is($data{geo_before}, 'loopback', 'geo ranges add before');
+is($data{geo_after}, 'loopback', 'geo ranges add after');
+is($data{geo_insert}, 'loopback', 'geo ranges insert');
+is($data{geo_insert_before}, 'loopback', 'geo ranges insert before');
+is($data{geo_insert_after}, 'loopback', 'geo ranges insert after');
+
+is($data{geo_from_addr}, 'loopback', 'geo from addr');
+is($data{geo_from_var}, 'test', 'geo from var');
+
+is(stream('127.0.0.1:' . port(8085))->read(), 'default',
+    'geo delete range from variable');
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'default', 'geo default');
+is(stream('127.0.0.1:' . port(8082))->read(), 'world', 'geo world');
+is(stream('127.0.0.1:' . port(8086))->read(), 'default', 'geo ranges default');
+is(stream('127.0.0.1:' . port(8087))->read(), 'foo2', 'geo ranges add');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_geo_unix.t ../asynch_mode_nginx/test/nginx-tests/stream_geo_unix.t
--- nginx-release-1.20.1/test/nginx-tests/stream_geo_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_geo_unix.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,88 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream geo module with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_geo stream_return unix/)
+    ->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    geo $geo {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $remote_addr $geora {
+        default                  default;
+        255.255.255.255          none;
+    }
+
+    geo $geor {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    geo $remote_addr $georra {
+        ranges;
+        0.0.0.0-255.255.255.254  test;
+        default                  none;
+    }
+
+    server {
+        listen      unix:%%TESTDIR%%/unix.sock;
+        return      "geo:$geo geora:$geora geor:$geor georra:$georra";
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  unix:%%TESTDIR%%/unix.sock;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my %data = stream('127.0.0.1:' . port(8080))->read() =~ /(\w+):(\w+)/g;
+is($data{geo}, 'none', 'geo unix');
+is($data{geor}, 'none', 'geo unix ranges');
+is($data{geora}, 'none', 'geo unix remote addr');
+is($data{georra}, 'none', 'geo unix ranges remote addr');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_buffer.t ../asynch_mode_nginx/test/nginx-tests/stream_js_buffer.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_buffer.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_buffer.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,181 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, buffer properties.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+
+        location /p/ {
+            proxy_pass http://127.0.0.1:8085/;
+        }
+
+        location /return {
+            return 200 'RETURN:$http_foo';
+        }
+    }
+}
+
+stream {
+    js_import test.js;
+
+    js_set $type        test.type;
+    js_set $binary_var  test.binary_var;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $type;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $binary_var;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        js_preread  test.cb_mismatch;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        js_preread  test.cb_mismatch2;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        js_filter   test.header_inject;
+        proxy_pass  127.0.0.1:8080;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function type(s) {
+        var v = s.rawVariables.remote_addr;
+        var type = Buffer.isBuffer(v) ? 'buffer' : (typeof v);
+        return type;
+    }
+
+    function binary_var(s) {
+        var test = s.rawVariables
+                   .binary_remote_addr.equals(Buffer.from([127,0,0,1]));
+        return test;
+    }
+
+    function cb_mismatch(s) {
+        try {
+            s.on('upload', () => {});
+            s.on('downstream', () => {});
+        } catch (e) {
+            throw new Error(`cb_mismatch:\${e.message}`)
+        }
+    }
+
+    function cb_mismatch2(s) {
+        try {
+            s.on('upstream', () => {});
+            s.on('download', () => {});
+        } catch (e) {
+            throw new Error(`cb_mismatch2:\${e.message}`)
+        }
+    }
+
+    function header_inject(s) {
+        var req = Buffer.from([]);
+
+        s.on('upstream', function(data, flags) {
+            req = Buffer.concat([req, data]);
+
+            var n = req.indexOf('\\n');
+            if (n != -1) {
+                var rest = req.slice(n + 1);
+                req = req.slice(0, n + 1);
+
+                s.send(req, flags);
+                s.send('Foo: foo\\r\\n', flags);
+                s.send(rest, flags);
+
+                s.off('upstream');
+            }
+        });
+    }
+
+    export default {njs: test_njs, type, binary_var, cb_mismatch, cb_mismatch2,
+                    header_inject};
+
+EOF
+
+$t->try_run('no njs ngx')->plan(5);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'buffer', 'var type');
+is(stream('127.0.0.1:' . port(8082))->read(), 'true', 'binary var');
+
+stream('127.0.0.1:' . port(8083))->io('x');
+stream('127.0.0.1:' . port(8084))->io('x');
+
+like(http_get('/p/return'), qr/RETURN:foo/, 'injected header');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'cb_mismatch:mixing string and buffer')
+   > 0, 'cb mismatch');
+ok(index($t->read_file('error.log'), 'cb_mismatch2:mixing string and buffer')
+   > 0, 'cb mismatch');
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_exit.t ../asynch_mode_nginx/test/nginx-tests/stream_js_exit.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_exit.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_exit.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,156 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, exit hook.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+    }
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_import test.js;
+
+    server {
+        listen      127.0.0.1:8081;
+        js_access   test.access;
+        js_filter   test.filter;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        js_access   test.access;
+        proxy_pass  127.0.0.1:1;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function access(s) {
+        njs.on('exit', () => {
+            var v = s.variables;
+            var c = `\${v.bytes_received}/\${v.bytes_sent}`;
+            var u = `\${v.upstream_bytes_received}/\${v.upstream_bytes_sent}`;
+            s.error(`s:\${s.status} C: \${c} U: \${u}`);
+        });
+
+        s.allow();
+    }
+
+    function filter(s) {
+        s.on('upload', (data, flags) => {
+            s.send(`@\${data}`, flags);
+        });
+
+        s.on('download', (data, flags) => {
+            s.send(data.slice(2), flags);
+        });
+    }
+
+    export default {njs: test_njs, access, filter};
+EOF
+
+$t->try_run('no stream njs available')->plan(2);
+
+$t->run_daemon(\&stream_daemon, port(8090));
+$t->waitforsocket('127.0.0.1:' . port(8090));
+
+###############################################################################
+
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.2';
+
+stream('127.0.0.1:' . port(8081))->io('###');
+stream('127.0.0.1:' . port(8082))->io('###');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 's:200 C: 3/6 U: 8/4') > 0, 'normal');
+ok(index($t->read_file('error.log'), 's:502 C: 0/0 U: 0/0') > 0, 'failed conn');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8090),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        $buffer = $buffer . $buffer;
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_fetch.t ../asynch_mode_nginx/test/nginx-tests/stream_js_fetch.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_fetch.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_fetch.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,159 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, fetch method.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  aaa;
+
+        location /validate {
+            js_content test.validate;
+        }
+    }
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_import test.js;
+
+    server {
+        listen      127.0.0.1:8081;
+        js_preread  test.preread_verify;
+        proxy_pass  127.0.0.1:8090;
+    }
+}
+
+EOF
+
+my $p = port(8080);
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function validate(r) {
+        r.return((r.requestText == 'QZ') ? 200 : 403);
+    }
+
+    function preread_verify(s) {
+        var collect = Buffer.from([]);
+
+        s.on('upstream', function (data, flags) {
+            collect = Buffer.concat([collect, data]);
+
+            if (collect.length >= 4 && collect.readUInt16BE(0) == 0xabcd) {
+                s.off('upstream');
+                ngx.fetch('http://127.0.0.1:$p/validate',
+                          {body: collect.slice(2,4), headers: {Host:'aaa'}})
+                .then(reply => (reply.status == 200) ? s.done(): s.deny())
+
+            } else if (collect.length) {
+                s.deny();
+            }
+        });
+    }
+
+    export default {njs: test_njs, validate, preread_verify}
+EOF
+
+$t->try_run('no stream njs available')->plan(4);
+
+$t->run_daemon(\&stream_daemon, port(8090));
+$t->waitforsocket('127.0.0.1:' . port(8090));
+
+###############################################################################
+
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.1';
+
+is(stream('127.0.0.1:' . port(8081))->io('###'), '', 'preread not enough');
+is(stream('127.0.0.1:' . port(8081))->io("\xAB\xCDQZ##"), "\xAB\xCDQZ##",
+    'preread validated');
+is(stream('127.0.0.1:' . port(8081))->io("\xAC\xCDQZ##"), '',
+    'preread invalid magic');
+is(stream('127.0.0.1:' . port(8081))->io("\xAB\xCDQQ##"), '',
+    'preread validation failed');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8090),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_import.t ../asynch_mode_nginx/test/nginx-tests/stream_js_import.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_import.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_import.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,118 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, js_import directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_set $test foo.bar.p;
+
+    js_import lib.js;
+    js_import foo from ./main.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        js_access   lib.access;
+        js_preread  lib.preread;
+        js_filter   lib.filter;
+        proxy_pass  127.0.0.1:8083;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  "x";
+    }
+}
+
+EOF
+
+$t->write_file('lib.js', <<EOF);
+    var res = '';
+
+    function access(s) {
+        res += '1';
+        s.allow();
+    }
+
+    function preread(s) {
+        s.on('upload', function (data) {
+            res += '2';
+            if (res.length >= 3) {
+                s.done();
+            }
+        });
+    }
+
+    function filter(s) {
+        s.on('upload', function(data, flags) {
+            s.send(data);
+            res += '3';
+        });
+
+        s.on('download', function(data, flags) {
+            if (!flags.last) {
+                res += '4';
+                s.send(data);
+
+            } else {
+                res += '5';
+                s.send(res, {last:1});
+                s.off('download');
+            }
+        });
+    }
+
+    export default {access, preread, filter};
+
+EOF
+
+$t->write_file('main.js', <<EOF);
+    export default {bar: {p(s) {return "P-TEST"}}};
+
+EOF
+
+$t->try_run('no njs available')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'P-TEST', 'foo.bar.p');
+is(stream('127.0.0.1:' . port(8082))->io('0'), 'x122345', 'lib.access');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_ngx.t ../asynch_mode_nginx/test/nginx-tests/stream_js_ngx.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_ngx.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_ngx.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,99 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, ngx object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_import test.js;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /njs {
+            js_content test.njs;
+        }
+    }
+}
+
+stream {
+    js_import test.js;
+
+    js_set $log     test.log;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $log;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function log(s) {
+        ngx.log(ngx.INFO, `ngx.log:FOO`);
+        ngx.log(ngx.WARN, `ngx.log:BAR`);
+        ngx.log(ngx.ERR, `ngx.log:BAZ`);
+        return 'OK';
+    }
+
+    export default {njs: test_njs, log};
+
+EOF
+
+$t->try_run('no njs ngx')->plan(4);
+
+###############################################################################
+
+TODO: {
+local $TODO = 'not yet'
+    unless http_get('/njs') =~ /^([.0-9]+)$/m && $1 ge '0.5.0';
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'OK', 'log var');
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/\[info\].*ngx.log:FOO/, 'ngx.log info');
+like($t->read_file('error.log'), qr/\[warn\].*ngx.log:BAR/, 'ngx.log warn');
+like($t->read_file('error.log'), qr/\[error\].*ngx.log:BAZ/, 'ngx.log err');
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_object.t ../asynch_mode_nginx/test/nginx-tests/stream_js_object.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_object.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_object.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,97 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, stream session object.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_set $test     test;
+
+    js_include test.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test$status;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function to_string(s) {
+        return s.toString() === '[object Stream Session]';
+    }
+
+    function define_prop(s) {
+        Object.defineProperty(s.variables, 'status', {value:400});
+        return s.variables.status == 400;
+    }
+
+    function in_operator(s) {
+        return ['status', 'unknown']
+               .map(v=>v in s.variables)
+               .toString() === 'true,false';
+    }
+
+    function redefine_proto(s) {
+        s[0] = 'a';
+        s[1] = 'b';
+        s.length = 2;
+        Object.setPrototypeOf(s, Array.prototype);
+        return s.join('|') === 'a|b';
+    }
+
+    function get_own_prop_descs(s) {
+        return Object.getOwnPropertyDescriptors(s)['on'].value === s.on;
+    }
+
+    function test(s) {
+        return [ to_string,
+                 define_prop,
+                 in_operator,
+                 redefine_proto,
+                 get_own_prop_descs,
+               ].every(v=>v(s));
+    }
+
+EOF
+
+$t->try_run('no njs stream session object')->plan(1);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'true400', 'var set');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js.t ../asynch_mode_nginx/test/nginx-tests/stream_js.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,454 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite stream stream_return udp/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    js_include test.js;
+
+    server {
+        listen       127.0.0.1:8079;
+        server_name  localhost;
+
+        location /njs {
+            js_content test_njs;
+        }
+
+        location /p/ {
+            proxy_pass http://127.0.0.1:8095/;
+
+        }
+
+        location /return {
+            return 200 $http_foo;
+        }
+    }
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_set $js_addr      js_addr;
+    js_set $js_var       js_var;
+    js_set $js_log       js_log;
+    js_set $js_unk       js_unk;
+    js_set $js_req_line  js_req_line;
+    js_set $js_sess_unk  js_sess_unk;
+
+    js_include test.js;
+
+    log_format status $server_port:$status;
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $js_addr;
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $js_log;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $js_var;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  $js_unk;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $js_sess_unk;
+    }
+
+    server {
+        listen  127.0.0.1:%%PORT_8985_UDP%% udp;
+        return  $js_addr;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        js_access   js_access_step;
+        js_preread  js_preread_step;
+        js_filter   js_filter_step;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        js_access   js_access_undecided;
+        return      OK;
+        access_log  %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        js_access   js_access_allow;
+        return      OK;
+        access_log  %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        js_access   js_access_deny;
+        return      OK;
+        access_log  %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        js_preread  js_preread_async;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        js_preread  js_preread_data;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8093;
+        js_preread  js_preread_req_line;
+        return      $js_req_line;
+    }
+
+    server {
+        listen      127.0.0.1:8094;
+        js_filter   js_filter_empty;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8095;
+        js_filter   js_filter_header_inject;
+        proxy_pass  127.0.0.1:8079;
+    }
+
+    server {
+        listen      127.0.0.1:8096;
+        js_filter   js_filter_search;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8097;
+        js_access   js_access_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8098;
+        js_preread  js_preread_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+
+    server {
+        listen      127.0.0.1:8099;
+        js_filter   js_filter_except;
+        proxy_pass  127.0.0.1:8090;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_njs(r) {
+        r.return(200, njs.version);
+    }
+
+    function js_addr(s) {
+        return 'addr=' + s.remoteAddress;
+    }
+
+    function js_var(s) {
+        return 'variable=' + s.variables.remote_addr;
+    }
+
+    function js_sess_unk(s) {
+        return 'sess_unk=' + s.unk;
+    }
+
+    function js_log(s) {
+        s.log("SEE-THIS");
+    }
+
+    var res = '';
+
+    function js_access_step(s) {
+        res += '1';
+
+        setTimeout(function() {
+            if (s.remoteAddress.match('127.0.0.1')) {
+                s.allow();
+            }
+        }, 1);
+    }
+
+    function js_preread_step(s) {
+        s.on('upload', function (data) {
+            res += '2';
+            if (res.length >= 3) {
+                s.done();
+            }
+        });
+    }
+
+    function js_filter_step(s) {
+        s.on('upload', function(data, flags) {
+            s.send(data);
+            res += '3';
+        });
+
+        s.on('download', function(data, flags) {
+
+            if (!flags.last) {
+                res += '4';
+                s.send(data);
+
+            } else {
+                res += '5';
+                s.send(res, {last:1});
+                s.off('download');
+            }
+        });
+    }
+
+    function js_access_undecided(s) {
+        s.decline();
+    }
+
+    function js_access_allow(s) {
+        if (s.remoteAddress.match('127.0.0.1')) {
+            s.done();
+            return;
+        }
+
+        s.deny();
+    }
+
+    function js_access_deny(s) {
+        if (s.remoteAddress.match('127.0.0.1')) {
+            s.deny();
+            return;
+        }
+
+        s.allow();
+    }
+
+
+    function js_preread_async(s) {
+        setTimeout(function() {
+            s.done();
+        }, 1);
+    }
+
+    function js_preread_data(s) {
+        s.on('upload', function (data, flags) {
+            if (data.indexOf('z') != -1) {
+                s.done();
+            }
+        });
+    }
+
+    var line = '';
+
+    function js_preread_req_line(s) {
+        s.on('upload', function (data, flags) {
+            var n = data.indexOf('\\n');
+            if (n != -1) {
+                line = data.substr(0, n);
+                s.done();
+            }
+        });
+    }
+
+    function js_req_line(s) {
+        return line;
+    }
+
+    function js_filter_empty(s) {
+    }
+
+    function js_filter_header_inject(s) {
+        var req = '';
+
+        s.on('upload', function(data, flags) {
+            req += data;
+
+            var n = req.search('\\n');
+            if (n != -1) {
+                var rest = req.substr(n + 1);
+                req = req.substr(0, n + 1);
+
+                s.send(req + 'Foo: foo' + '\\r\\n' + rest, flags);
+
+                s.off('upload');
+            }
+        });
+    }
+
+    function js_filter_search(s) {
+        s.on('download', function(data, flags) {
+            var n = data.search('y');
+            if (n != -1) {
+                s.send('z');
+            }
+        });
+
+        s.on('upload', function(data, flags) {
+            var n = data.search('x');
+            if (n != -1) {
+                s.send('y');
+            }
+        });
+    }
+
+    function js_access_except(s) {
+        function done() {return s.a.a};
+
+        setTimeout(done, 1);
+        setTimeout(done, 2);
+    }
+
+    function js_preread_except(s) {
+        var fs = require('fs');
+        fs.readFileSync();
+    }
+
+    function js_filter_except(s) {
+        s.on('unknown', function() {});
+    }
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8090));
+$t->try_run('no stream njs available')->plan(22);
+$t->waitforsocket('127.0.0.1:' . port(8090));
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), 'addr=127.0.0.1',
+    's.remoteAddress');
+is(dgram('127.0.0.1:' . port(8985))->io('.'), 'addr=127.0.0.1',
+    's.remoteAddress udp');
+is(stream('127.0.0.1:' . port(8081))->read(), 'undefined', 's.log');
+is(stream('127.0.0.1:' . port(8082))->read(), 'variable=127.0.0.1',
+    's.variables');
+is(stream('127.0.0.1:' . port(8083))->read(), '', 'stream js unknown function');
+is(stream('127.0.0.1:' . port(8084))->read(), 'sess_unk=undefined', 's.unk');
+
+is(stream('127.0.0.1:' . port(8086))->io('0'), '0122345',
+    'async handlers order');
+is(stream('127.0.0.1:' . port(8087))->io('#'), 'OK', 'js_access_undecided');
+is(stream('127.0.0.1:' . port(8088))->io('#'), 'OK', 'js_access_allow');
+is(stream('127.0.0.1:' . port(8089))->io('#'), '', 'js_access_deny');
+
+is(stream('127.0.0.1:' . port(8091))->io('#'), '#', 'js_preread_async');
+is(stream('127.0.0.1:' . port(8092))->io('#z'), '#z', 'js_preread_async_data');
+is(stream('127.0.0.1:' . port(8093))->io("xy\na"), 'xy', 'js_preread_req_line');
+
+is(stream('127.0.0.1:' . port(8094))->io('x'), 'x', 'js_filter_empty');
+like(get('/p/return'), qr/foo/, 'js_filter_injected_header');
+is(stream('127.0.0.1:' . port(8096))->io('x'), 'z', 'js_filter_search');
+
+stream('127.0.0.1:' . port(8097))->io('x');
+stream('127.0.0.1:' . port(8098))->io('x');
+stream('127.0.0.1:' . port(8099))->io('x');
+
+$t->stop();
+
+ok(index($t->read_file('error.log'), 'SEE-THIS') > 0, 'stream js log');
+ok(index($t->read_file('error.log'), 'at fs.readFileSync') > 0,
+    'stream js_preread backtrace');
+ok(index($t->read_file('error.log'), 'at js_filter_except') > 0,
+    'stream js_filter backtrace');
+
+my @p = (port(8087), port(8088), port(8089));
+like($t->read_file('status.log'), qr/$p[0]:200/, 'status undecided');
+like($t->read_file('status.log'), qr/$p[1]:200/, 'status allow');
+like($t->read_file('status.log'), qr/$p[2]:403/, 'status deny');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8090),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+sub get {
+    my ($url, %extra) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1:' . port(8079)
+    ) or die "Can't connect to nginx: $!\n";
+
+    return http_get($url, socket => $s);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_variables.t ../asynch_mode_nginx/test/nginx-tests/stream_js_variables.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_variables.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, setting nginx variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_set $test_var       test_var;
+    js_set $test_not_found test_not_found;
+
+    js_include test.js;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $test_var$status;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $test_not_found;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function test_var(s) {
+        s.variables.status = 400;
+        return 'test_var';
+    }
+
+    function test_not_found(s) {
+        try {
+            s.variables.unknown = 1;
+        } catch (e) {
+            return 'not_found';
+        }
+    }
+
+EOF
+
+$t->try_run('no stream njs available')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), 'test_var400', 'var set');
+is(stream('127.0.0.1:' . port(8082))->read(), 'not_found', 'not found set');
+
+$t->stop();
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_js_var.t ../asynch_mode_nginx/test/nginx-tests/stream_js_var.t
--- nginx-release-1.20.1/test/nginx-tests/stream_js_var.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_js_var.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,76 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for stream njs module, js_var directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    js_import test.js;
+
+    js_var $foo;
+    js_var $bar a:$remote_addr;
+    js_set $var test.varr;
+
+    server {
+        listen  127.0.0.1:8081;
+        return  $bar$foo;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $var$foo;
+    }
+}
+
+EOF
+
+$t->write_file('test.js', <<EOF);
+    function varr(s) {
+        s.variables.foo = 'xxx';
+        return '';
+    }
+
+    export default {varr};
+EOF
+
+$t->try_run('no stream js_var')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->io('###'), 'a:127.0.0.1',
+    'default value');
+is(stream('127.0.0.1:' . port(8082))->io('###'), 'xxx', 'value set');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_limit_conn_complex.t ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn_complex.t
--- nginx-release-1.20.1/test/nginx-tests/stream_limit_conn_complex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn_complex.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_limit_conn/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    limit_conn_zone  $binary_remote_addr$server_port  zone=zone:1m;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run()->plan(4);
+
+###############################################################################
+
+like(get(port(8080)), qr/200 OK/, 'passed');
+
+my $s = http(<<EOF, start => 1, sleep => 0.2);
+GET / HTTP/1.0
+EOF
+
+ok($s, 'long connection');
+
+is(get(port(8080)), undef, 'rejected same key');
+like(get(port(8081)), qr/200 OK/, 'passed different key');
+
+###############################################################################
+
+sub get {
+    my $port = shift;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => "127.0.0.1:$port"
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    my $r = http_get('/', socket => $s);
+    if (!$r) {
+        $r = undef;
+    }
+
+    return $r;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_limit_conn_dry_run.t ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn_dry_run.t
--- nginx-release-1.20.1/test/nginx-tests/stream_limit_conn_dry_run.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn_dry_run.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,113 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for limit_conn_dry_run directive, limit_conn_status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_limit_conn http/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    log_format test $server_port:$limit_conn_status;
+    access_log %%TESTDIR%%/test.log test;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+
+        proxy_timeout 5s;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8084;
+        limit_conn  zone 1;
+
+        limit_conn_dry_run on;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8084;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'OK');
+$t->try_run('no limit_conn_dry_run/limit_conn_status')->plan(9);
+
+###############################################################################
+
+my ($p, $p1, $p2, $p3) = (port(8080), port(8081), port(8082), port(8083));
+
+is(stream("127.0.0.1:$p")->io("GET /\n"), 'OK', 'passed');
+
+my $s = stream('127.0.0.1:' . port(8080));
+$s->write("GET");
+
+is(stream("127.0.0.1:$p1")->io("GET /\n"), '', 'rejected');
+is(stream("127.0.0.1:$p2")->io("GET /\n"), 'OK', 'rejected dry run');
+is(stream("127.0.0.1:$p3")->io("GET /\n"), 'OK', 'no limit');
+
+undef $s;
+
+$t->stop();
+
+like($t->read_file('error.log'), qr/limiting connections, dry/, 'log dry run');
+like($t->read_file('test.log'), qr|$p:PASSED|, 'log passed');
+like($t->read_file('test.log'), qr|$p1:REJECTED$|m, 'log rejected');
+like($t->read_file('test.log'), qr|$p2:REJECTED_DRY_RUN|, 'log rejected dry');
+like($t->read_file('test.log'), qr|$p3:-|, 'log not found');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_limit_conn.t ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn.t
--- nginx-release-1.20.1/test/nginx-tests/stream_limit_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_limit_conn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,139 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stream stream_limit_conn/)
+    ->plan(8)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+
+    server {
+        listen           127.0.0.1:8080;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone 1;
+    }
+
+    server {
+        listen           127.0.0.1:8085;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone 5;
+    }
+
+    server {
+        listen           127.0.0.1:8081;
+        proxy_pass       127.0.0.1:8084;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:8082;
+        proxy_pass       127.0.0.1:8080;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:8083;
+        proxy_pass       127.0.0.1:8080;
+        limit_conn       zone 1;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(get(), qr/200 OK/, 'passed');
+
+# same and other zones
+
+my $s = http(<<EOF, start => 1, sleep => 0.2);
+GET / HTTP/1.0
+EOF
+
+ok($s, 'long connection');
+
+is(get(), undef, 'rejected same zone');
+like(get('127.0.0.1:' . port(8081)), qr/200 OK/, 'passed different zone');
+like(get('127.0.0.1:' . port(8085)), qr/200 OK/, 'passed same zone unlimited');
+
+ok(http(<<EOF, socket => $s), 'long connection closed');
+Host: localhost
+
+EOF
+
+# zones proxy chain
+
+like(get('127.0.0.1:' . port(8082)), qr/200 OK/, 'passed proxy');
+is(get('127.0.0.1:' . port(8083)), undef, 'rejected proxy');
+
+###############################################################################
+
+sub get {
+    my $peer = shift;
+
+    my $r = http_get('/', socket => getconn($peer));
+    if (!$r) {
+        $r = undef;
+    }
+
+    return $r;
+}
+
+sub getconn {
+    my $peer = shift;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => $peer || '127.0.0.1:' . port(8080)
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_limit_rate2.t ../asynch_mode_nginx/test/nginx-tests/stream_limit_rate2.t
--- nginx-release-1.20.1/test/nginx-tests/stream_limit_rate2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_limit_rate2.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,230 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, limit rate directives, variables support.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    # download and upload rates are set equal to the maximum
+    # number of bytes transmitted
+
+    # proxy_download_rate value comes from following calculations:
+    # test string length (1000) + whitespace (1) + time string length (10)
+
+    map $server_port $down {
+        default        1011;
+        %%PORT_8082%%  0;
+        %%PORT_8083%%  1;
+        %%PORT_8085%%  250;
+    }
+
+    map $server_port $up {
+        default        1000;
+        %%PORT_8082%%  0;
+        %%PORT_8084%%  1;
+        %%PORT_8086%%  250;
+    }
+
+    proxy_download_rate      $down;
+    proxy_upload_rate        $up;
+
+    server {
+        listen               127.0.0.1:8081;
+        proxy_pass           127.0.0.1:8080;
+    }
+
+    server {
+        listen               127.0.0.1:8082;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+        proxy_upload_rate    $up;
+    }
+
+    server {
+        listen               127.0.0.1:8083;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+    }
+
+    server {
+        listen               127.0.0.1:8084;
+        proxy_pass           127.0.0.1:8080;
+        proxy_upload_rate    $up;
+    }
+
+    server {
+        listen               127.0.0.1:8085;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  $down;
+    }
+
+    server {
+        listen               127.0.0.1:8086;
+        proxy_pass           127.0.0.1:8087;
+        proxy_upload_rate    $up;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8080));
+$t->run_daemon(\&stream_daemon, port(8087));
+$t->try_run('no proxy_download_rate variables')->plan(9);
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+$t->waitforsocket('127.0.0.1:' . port(8087));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+my %r = response($str, peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'exact limit');
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8082));
+is($r{'data'}, $str . 'extra', 'unlimited');
+
+SKIP: {
+skip 'unsafe on VM', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if interaction between backend and client is slow then proxy can add extra
+# bytes to upload/download data
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'limited');
+
+%r = response($str, peer => '127.0.0.1:' . port(8083), readonce => 1);
+is($r{'data'}, '1', 'download - one byte');
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8084));
+is($r{'data'}, '1', 'upload - one byte');
+
+}
+
+# Five chunks are split with four 1s delays:
+# the first four chunks are quarters of test string
+# and the fifth one is some extra data from backend.
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8085));
+my $diff = time() - $r{'time'};
+cmp_ok($diff, '>=', 4, 'download - time');
+is($r{'data'}, $str, 'download - data');
+
+my $time = time();
+%r = response($str . 'close', peer => '127.0.0.1:' . port(8086));
+$diff = time() - $time;
+cmp_ok($diff, '>=', 4, 'upload - time');
+is($r{'data'}, $str . 'close', 'upload - data');
+
+###############################################################################
+
+sub response {
+    my ($data, %extra) = @_;
+
+    my $s = stream($extra{peer});
+    $s->write($data);
+
+    $data = '';
+    while (1) {
+        my $buf = $s->read();
+        last unless length($buf);
+
+        $data .= $buf;
+
+        last if $extra{'readonce'};
+    }
+    $data =~ /([\S]*)\s?(\d+)?/;
+
+    return ('data' => $1, 'time' => $2)
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my $port = shift;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    $buffer .= " " . time() if $client->sockport() eq port(8080);
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $client->sockport() eq port(8080) ? 1 : $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_limit_rate.t ../asynch_mode_nginx/test/nginx-tests/stream_limit_rate.t
--- nginx-release-1.20.1/test/nginx-tests/stream_limit_rate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_limit_rate.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,216 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, limit rate directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    # download and upload rates are set equal to the maximum
+    # number of bytes transmitted
+
+    # proxy_download_rate value comes from following calculations:
+    # test string length (1000) + whitespace (1) + time string length (10)
+
+    proxy_download_rate      1011;
+    proxy_upload_rate        1000;
+
+    server {
+        listen               127.0.0.1:8081;
+        proxy_pass           127.0.0.1:8080;
+    }
+
+    server {
+        listen               127.0.0.1:8082;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  0;
+        proxy_upload_rate    0;
+    }
+
+    server {
+        listen               127.0.0.1:8083;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  1;
+    }
+
+    server {
+        listen               127.0.0.1:8084;
+        proxy_pass           127.0.0.1:8080;
+        proxy_upload_rate    1;
+    }
+
+    server {
+        listen               127.0.0.1:8085;
+        proxy_pass           127.0.0.1:8080;
+        proxy_download_rate  250;
+    }
+
+    server {
+        listen               127.0.0.1:8086;
+        proxy_pass           127.0.0.1:8087;
+        proxy_upload_rate    250;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8080));
+$t->run_daemon(\&stream_daemon, port(8087));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8080));
+$t->waitforsocket('127.0.0.1:' . port(8087));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+my %r = response($str, peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'exact limit');
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8082));
+is($r{'data'}, $str . 'extra', 'unlimited');
+
+SKIP: {
+skip 'unsafe on VM', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+# if interaction between backend and client is slow then proxy can add extra
+# bytes to upload/download data
+
+%r = response($str . 'extra', peer => '127.0.0.1:' . port(8081));
+is($r{'data'}, $str, 'limited');
+
+%r = response($str, peer => '127.0.0.1:' . port(8083), readonce => 1);
+is($r{'data'}, '1', 'download - one byte');
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8084));
+is($r{'data'}, '1', 'upload - one byte');
+
+}
+
+# Five chunks are split with four 1s delays:
+# the first four chunks are quarters of test string
+# and the fifth one is some extra data from backend.
+
+%r = response($str, peer =>  '127.0.0.1:' . port(8085));
+my $diff = time() - $r{'time'};
+cmp_ok($diff, '>=', 4, 'download - time');
+is($r{'data'}, $str, 'download - data');
+
+my $time = time();
+%r = response($str . 'close', peer => '127.0.0.1:' . port(8086));
+$diff = time() - $time;
+cmp_ok($diff, '>=', 4, 'upload - time');
+is($r{'data'}, $str . 'close', 'upload - data');
+
+###############################################################################
+
+sub response {
+    my ($data, %extra) = @_;
+
+    my $s = stream($extra{peer});
+    $s->write($data);
+
+    $data = '';
+    while (1) {
+        my $buf = $s->read();
+        last unless length($buf);
+
+        $data .= $buf;
+
+        last if $extra{'readonce'};
+    }
+    $data =~ /([\S]*)\s?(\d+)?/;
+
+    return ('data' => $1, 'time' => $2)
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my $port = shift;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    $buffer .= " " . time() if $client->sockport() eq port(8080);
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $client->sockport() eq port(8080) ? 1 : $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_map.t ../asynch_mode_nginx/test/nginx-tests/stream_map.t
--- nginx-release-1.20.1/test/nginx-tests/stream_map.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_map.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,75 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream map module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_map/)
+    ->has(qw/http rewrite/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $server_port $x {
+        %%PORT_8080%%             literal;
+        default                   default;
+        ~(%%PORT_8082%%)          $1;
+        ~(?P<ncap>%%PORT_8083%%)  $ncap;
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        listen  127.0.0.1:8081;
+        listen  127.0.0.1:8082;
+        listen  127.0.0.1:8083;
+        return  $x;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        return  $x:${x};
+    }
+}
+
+EOF
+
+$t->run()->plan(5);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), 'literal', 'literal');
+is(stream('127.0.0.1:' . port(8081))->read(), 'default', 'default');
+is(stream('127.0.0.1:' . port(8082))->read(), port(8082), 'capture');
+is(stream('127.0.0.1:' . port(8083))->read(), port(8083), 'named capture');
+is(stream('127.0.0.1:' . port(8084))->read(), 'default:default', 'braces');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_bind.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_bind.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_bind.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_bind.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,80 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Test for stream proxy_bind directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+my $t = Test::Nginx->new()->has(qw/http proxy stream/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen            127.0.0.1:8081;
+        proxy_bind        127.0.0.2;
+        proxy_pass        127.0.0.1:8082;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen          127.0.0.1:8080;
+        server_name     localhost;
+
+        location / {
+            proxy_pass  http://127.0.0.1:8081;
+        }
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+
+        location / {
+            add_header   X-IP $remote_addr;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/X-IP: 127.0.0.2/, 'bind');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_complex.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_complex.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_complex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_complex.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,82 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream %%PORT_8081%% {
+        server 127.0.0.1:8091;
+    }
+
+    upstream %%PORT_8082%% {
+        server 127.0.0.1:8092;
+        server 127.0.0.1:8093;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        proxy_pass  $server_port;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  $server_addr:%%PORT_8093%%;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        listen      127.0.0.1:8092;
+        listen      127.0.0.1:8093;
+        return      $server_port;
+    }
+}
+
+EOF
+
+$t->run()->plan(5);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), port(8091), 'upstream');
+is(stream('127.0.0.1:' . port(8081))->read(), port(8091), 'upstream again');
+
+is(stream('127.0.0.1:' . port(8082))->read(), port(8092), 'upstream 2');
+is(stream('127.0.0.1:' . port(8082))->read(), port(8093), 'upstream second');
+
+is(stream('127.0.0.1:' . port(8083))->read(), port(8093), 'implicit');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_next_upstream.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_next_upstream.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_next_upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_next_upstream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,153 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, proxy_next_upstream directive and friends.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u {
+        server 127.0.0.1:8083 max_fails=0;
+        server 127.0.0.1:8084 max_fails=0;
+        server 127.0.0.1:8085 backup;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8083;
+        server 127.0.0.1:8085 backup;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:8083;
+        server 127.0.0.1:8085 down;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+        proxy_next_upstream off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u2;
+        proxy_next_upstream on;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u;
+        proxy_next_upstream on;
+        proxy_next_upstream_tries 2;
+    }
+
+    log_format test "$upstream_addr";
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  u3;
+        proxy_next_upstream on;
+        access_log  %%TESTDIR%%/test.log test;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->io('.'), '', 'next off');
+is(stream('127.0.0.1:' . port(8081))->io('.'), 'SEE-THIS', 'next on');
+
+# make sure backup is not tried
+
+is(stream('127.0.0.1:' . port(8082))->io('.'), '', 'next tries');
+
+# make sure backend marked as down doesn't count towards "no live upstreams"
+
+is(stream('127.0.0.1:' . port(8086))->io('.'), '', 'next down');
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.6');
+
+is($t->read_file('test.log'), '127.0.0.1:' . port(8083) . "\n",
+    'next down log');
+
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8085),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        $buffer = 'SEE-THIS';
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+    } continue {
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol_ipv6.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol_ipv6.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol_ipv6.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol_ipv6.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with IPv6 haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      [::1]:%%PORT_8080%%;
+    }
+
+    server {
+        listen          127.0.0.1:8081;
+        proxy_pass      [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen          [::1]:%%PORT_8080%%;
+        proxy_pass      127.0.0.1:8082;
+        proxy_protocol  on;
+    }
+
+    server {
+        listen          [::1]:%%PORT_8081%%;
+        proxy_pass      127.0.0.1:8082;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->try_run('no inet6 support')->plan(2);
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my $dp = port(8080);
+
+like(stream('127.0.0.1:' . $dp)->io('close'),
+    qr/PROXY TCP6 ::1 ::1 \d+ $dp$CRLF/, 'protocol on');
+unlike(stream('127.0.0.1:' . port(8081))->io('close'), qr/PROXY/,
+    'protocol off');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8082),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol_ssl.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,185 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with haproxy protocol to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CR LF CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl/)->has_daemon('openssl')
+    ->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl       on;
+    proxy_protocol  on;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      127.0.0.1:8081;
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+        proxy_pass      127.0.0.1:8083;
+        proxy_protocol  off;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run_daemon(\&stream_daemon_ssl, port(8081), path => $d, pp => 1);
+$t->run_daemon(\&stream_daemon_ssl, port(8083), path => $d, pp => 0);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+my $dp = port(8080);
+
+my %r = pp_get('test', '127.0.0.1:' . $dp);
+is($r{'data'}, "PROXY TCP4 127.0.0.1 127.0.0.1 $r{'sp'} $dp" . CRLF . 'test',
+    'protocol on');
+
+%r = pp_get('test', '127.0.0.1:' . port(8082));
+is($r{'data'}, 'test', 'protocol off');
+
+###############################################################################
+
+sub pp_get {
+    my ($data, $peer) = @_;
+
+    my $s = http($data, socket => getconn($peer), start => 1);
+    my $sockport = $s->sockport();
+    $data = http_end($s);
+    return ('data' => $data, 'sp' => $sockport);
+}
+
+sub getconn {
+    my $peer = shift;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => $peer
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    return $s;
+}
+
+###############################################################################
+
+sub stream_daemon_ssl {
+    my ($port, %extra) = @_;
+    my $d = $extra{path};
+    my $pp = $extra{pp};
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => "127.0.0.1:$port",
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        my ($buffer, $data) = ('', '');
+        $client->autoflush(1);
+
+        log2c("(new connection $client on $port)");
+
+        # read no more than haproxy header of variable length
+
+        while ($pp) {
+            my $prev = $buffer;
+            $client->sysread($buffer, 1) or last;
+            $data .= $buffer;
+            last if $prev eq CR && $buffer eq LF;
+        }
+
+        log2i("$client $data");
+
+        # would fail on waitforsocket
+
+        eval {
+            IO::Socket::SSL->start_SSL($client,
+                SSL_server => 1,
+                SSL_cert_file => "$d/localhost.crt",
+                SSL_key_file => "$d/localhost.key",
+                SSL_error_trap => sub { die $_[1] }
+            );
+        };
+        next if $@;
+
+        $client->sysread($buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        $data .= $buffer;
+
+        log2o("$client $data");
+
+        $client->syswrite($data);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_protocol.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,123 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with haproxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_protocol on;
+
+    server {
+        listen          127.0.0.1:8080;
+        proxy_pass      127.0.0.1:8081;
+    }
+
+    server {
+        listen          127.0.0.1:8082;
+        proxy_pass      127.0.0.1:8081;
+        proxy_protocol  off;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run();
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $dp = port(8080);
+my $s = stream('127.0.0.1:' . $dp);
+my $data = $s->io('close');
+my $sp = $s->sockport();
+is($data, "PROXY TCP4 127.0.0.1 127.0.0.1 $sp $dp${CRLF}close", 'protocol on');
+
+is(stream('127.0.0.1:' . port(8082))->io('close'), 'close', 'protocol off');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_certificate.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_certificate.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_certificate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_certificate.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,175 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with proxy certificate to ssl backend.
+# The proxy_ssl_certificate and proxy_ssl_password_file directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl/)
+    ->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+
+        proxy_ssl_certificate 1.example.com.crt;
+        proxy_ssl_certificate_key 1.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8080;
+
+        proxy_ssl_certificate 2.example.com.crt;
+        proxy_ssl_certificate_key 2.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8081;
+
+        proxy_ssl_certificate 3.example.com.crt;
+        proxy_ssl_certificate_key 3.example.com.key;
+        proxy_ssl_password_file password;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+    qr/X-Verify: SUCCESS/ms, 'verify certificate');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+    qr/X-Verify: FAILED/ms, 'fail certificate');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8084))),
+    qr/X-Verify: SUCCESS/ms, 'with encrypted key');
+
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+    qr!X-Name: /?CN=1.example!, 'valid certificate');
+unlike(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+    qr!X-Name: /?CN=1.example!, 'invalid certificate');
+
+###############################################################################
+
+sub getconn {
+    my $peer = shift;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => $peer
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_certificate_vars.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_certificate_vars.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_certificate_vars.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_certificate_vars.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,163 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with variables in ssl certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_map http http_ssl/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $server_port $cert {
+        %%PORT_8082%% 1;
+        %%PORT_8083%% 2;
+        %%PORT_8084%% 3;
+        %%PORT_8085%% "";
+    }
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+
+    server {
+        listen      127.0.0.1:8082;
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8080;
+
+        proxy_ssl_certificate $cert.example.com.crt;
+        proxy_ssl_certificate_key $cert.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8081;
+
+        proxy_ssl_certificate $cert.example.com.crt;
+        proxy_ssl_certificate_key $cert.example.com.key;
+        proxy_ssl_password_file password;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  127.0.0.1:8081;
+
+        proxy_ssl_certificate $cert;
+        proxy_ssl_certificate_key $cert;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+            add_header X-Name   $ssl_client_s_dn;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        location / {
+            add_header X-Verify $ssl_client_verify;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->try_run('no upstream ssl_certificate variables')->plan(4);
+
+###############################################################################
+
+like(http_get('/', socket => IO::Socket::INET->new('127.0.0.1:' . port(8082))),
+    qr/X-Verify: SUCCESS/ms, 'variable - verify certificate');
+like(http_get('/', socket => IO::Socket::INET->new('127.0.0.1:' . port(8083))),
+    qr/X-Verify: FAILED/ms, 'variable - fail certificate');
+like(http_get('/', socket => IO::Socket::INET->new('127.0.0.1:' . port(8084))),
+    qr/X-Verify: SUCCESS/ms, 'variable - with encrypted key');
+like(http_get('/', socket => IO::Socket::INET->new('127.0.0.1:' . port(8085))),
+    qr/X-Verify: NONE/ms, 'variable - no certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_conf_command.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_conf_command.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_conf_command.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_conf_command.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,92 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy to ssl backend, proxy_ssl_conf_command.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen       127.0.0.1:8080;
+        proxy_pass   127.0.0.1:8081;
+        proxy_ssl    on;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        proxy_ssl_certificate localhost.crt;
+        proxy_ssl_certificate_key localhost.key;
+        proxy_ssl_conf_command Certificate override.crt;
+        proxy_ssl_conf_command PrivateKey override.key;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl  %%SSL_ASYNCH%%;
+        return       $ssl_client_s_dn;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+        ssl_verify_client optional_no_ca;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'override') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+$t->try_run('no proxy_ssl_conf_command')->plan(1);
+
+###############################################################################
+
+like(stream('127.0.0.1:' . port(8080))->read(), qr/CN=override/,
+    'Certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_name_complex.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_name_complex.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_name_complex.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_name_complex.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,95 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives) with complex value.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return sni/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name x${server_port}x;
+    }
+
+    server {
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        listen  127.0.0.1:8085 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return  $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(2);
+
+###############################################################################
+
+my ($p1, $p2) = (port(8081), port(8082));
+
+is(stream("127.0.0.1:$p1")->read(), "x${p1}x", 'name 1');
+is(stream("127.0.0.1:$p2")->read(), "x${p2}x", 'name 2');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_name.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_name.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_name.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_name.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, use of Server Name Indication
+# (proxy_ssl_name, proxy_ssl_server_name directives).
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl sni/)
+    ->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse off;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    upstream u {
+        server 127.0.0.1:8085;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+
+        proxy_ssl_server_name off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u;
+
+        proxy_ssl_server_name on;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name example.com;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8085;
+
+        proxy_ssl_server_name on;
+        proxy_ssl_name example.com:123;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8085 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+
+        location / {
+            add_header X-Name $ssl_server_name,;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/'), qr/200 OK.*X-Name: ,/s, 'no name');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8081))),
+    qr/200 OK.*X-Name: u,/s, 'name default');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8082))),
+    qr/200 OK.*X-Name: example.com,/s, 'name override');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8083))),
+    qr/200 OK.*X-Name: ,/s, 'no ip');
+like(http_get('/', socket => getconn('127.0.0.1:' . port(8084))),
+    qr/200 OK.*X-Name: example.com,/s, 'no port in name');
+
+###############################################################################
+
+sub getconn {
+    my $peer = shift;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => $peer
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    return $s;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl http http_ssl/)
+    ->has(qw/stream_return/)
+    ->has_daemon('openssl')->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse on;
+    proxy_connect_timeout 2s;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8083;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8083;
+    }
+
+    server {
+        listen      127.0.0.1:8083 ssl;
+        return      $ssl_session_reused;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8084;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        server_name  localhost;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl');
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl 2');
+
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'ssl session new');
+is(stream('127.0.0.1:' . port(8082))->read(), 'r', 'ssl session reused');
+is(stream('127.0.0.1:' . port(8082))->read(), 'r', 'ssl session reused 2');
+
+my $s = http('', start => 1);
+
+sleep 3;
+
+like(http_get('/', socket => $s), qr/200 OK/, 'proxy connect timeout');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_verify.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_verify.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy_ssl_verify.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy_ssl_verify.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,182 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for proxy to ssl backend, backend certificate verification.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has_daemon('openssl')->plan(6);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    %%PROXY_ASYNCH_ENABLE%%
+    proxy_ssl_verify on;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name foo.example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8086;
+
+        proxy_ssl_name no.match.example.com;
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_name 2.example.com;
+        proxy_ssl_trusted_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_name bad.example.com;
+        proxy_ssl_trusted_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  127.0.0.1:8087;
+
+        proxy_ssl_trusted_certificate 1.example.com.crt;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8086 ssl;
+        proxy_ssl   off;
+        %%PROXY_ASYNCH_DISABLE%%
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return      OK;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+    }
+
+    server {
+        listen      127.0.0.1:8087 ssl;
+        proxy_ssl   off;
+        %%PROXY_ASYNCH_DISABLE%%
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return      OK;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.1.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+x509_extensions = v3_req
+
+[ req_distinguished_name ]
+commonName=no.match.example.com
+
+[ v3_req ]
+subjectAltName = DNS:example.com,DNS:*.example.com
+EOF
+
+$t->write_file('openssl.2.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+
+[ req_distinguished_name ]
+commonName=2.example.com
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.$name.conf "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->run();
+
+###############################################################################
+
+# subjectAltName
+
+is(get(8080), 'OK', 'verify');
+is(get(8081), 'OK', 'verify wildcard');
+isnt(get(8082), 'OK', 'verify fail');
+
+# commonName
+
+is(get(8083), 'OK', 'verify cn');
+isnt(get(8084), 'OK', 'verify cn fail');
+
+# untrusted
+
+isnt(get(8085), 'OK', 'untrusted');
+
+###############################################################################
+
+sub get {
+    stream('127.0.0.1:' . port(shift))->read();
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_proxy.t ../asynch_mode_nginx/test/nginx-tests/stream_proxy.t
--- nginx-release-1.20.1/test/nginx-tests/stream_proxy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_proxy.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  127.0.0.1:8081;
+        proxy_connect_timeout 2s;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = stream('127.0.0.1:' . port(8080));
+
+is($s->io('foo1', length => 4), 'bar1', 'proxy connection');
+is($s->io('foo3', length => 4), 'bar3', 'proxy connection again');
+is($s->io('close'), 'close', 'proxy connection close');
+is($s->io('test'), '', 'proxy connection closed');
+
+$s = stream('127.0.0.1:' . port(8080));
+
+sleep 3;
+
+is($s->io('foo', length => 3), 'bar', 'proxy connect timeout');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    $buffer =~ s/foo/bar/g;
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_realip_hostname.t ../asynch_mode_nginx/test/nginx-tests/stream_realip_hostname.t
--- nginx-release-1.20.1/test/nginx-tests/stream_realip_hostname.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_realip_hostname.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,103 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, 'unix:' and hostname in set_real_ip_from.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip unix/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen      unix:%%TESTDIR%%/unix.sock proxy_protocol;
+        listen      127.0.0.1:8080;
+        listen      127.0.0.1:8082 proxy_protocol;
+        return      $remote_addr;
+
+        set_real_ip_from unix:;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen      127.0.0.1:8085 proxy_protocol;
+        listen      unix:%%TESTDIR%%/unix2.sock proxy_protocol;
+        return      $remote_addr;
+
+        set_real_ip_from localhost;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  127.0.0.1:8085;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  unix:%%TESTDIR%%/unix2.sock;
+    }
+}
+
+EOF
+
+$t->run();
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') ne '127.0.0.1';
+
+$t->plan(4);
+
+###############################################################################
+
+is(pp_get(8081, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1', 'realip unix');
+isnt(pp_get(8082, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1', 'realip unix - no match');
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1', 'realip hostname');
+isnt(pp_get(8084, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1', 'realip hostname - no match');
+
+###############################################################################
+
+sub pp_get {
+    my ($port, $proxy) = @_;
+    stream(PeerPort => port($port))->io($proxy);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_realip.t ../asynch_mode_nginx/test/nginx-tests/stream_realip.t
--- nginx-release-1.20.1/test/nginx-tests/stream_realip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_realip.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, server side proxy protocol.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen      127.0.0.1:8083 proxy_protocol;
+        listen      127.0.0.1:8084;
+        return      $proxy_protocol_addr:$proxy_protocol_port;
+    }
+
+    server {
+        listen      127.0.0.1:8085 proxy_protocol;
+        proxy_pass  127.0.0.1:8081;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol;
+        listen      [::1]:%%PORT_8086%% proxy_protocol;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from ::1;
+        set_real_ip_from 127.0.0.2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  [::1]:%%PORT_8086%%;
+    }
+
+    server {
+        listen      127.0.0.1:8088 proxy_protocol;
+        listen      [::1]:%%PORT_8088%% proxy_protocol;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from 127.0.0.1;
+        set_real_ip_from ::2;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  [::1]:%%PORT_8088%%;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->try_run('no inet6 support')->plan(8);
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1:1234', 'server');
+
+is(stream('127.0.0.1:' . port(8084))->read(), ':', 'server off');
+
+is(pp_get(8085, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}close"),
+    'close', 'server payload');
+
+like(pp_get(8086, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server ipv6 realip - no match');
+
+like(pp_get(8087, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/\Q192.0.2.1:1234:\E\s+\Q::1:\E\d+/, 'server ipv6 realip');
+
+like(pp_get(8088, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/\Q192.0.2.1:1234:\E\s+\Q127.0.0.1:\E\d+/, 'server ipv4 realip');
+
+like(pp_get(8089, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(::1:\d+):\s+\1$/, 'server ipv4 realip - no match');
+
+like(pp_get(8088, "PROXY UNKNOWN TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server unknown');
+
+###############################################################################
+
+sub pp_get {
+    my ($port, $proxy) = @_;
+    stream(PeerPort => port($port))->io($proxy);
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $buffer =~ /close/;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_resolver.t ../asynch_mode_nginx/test/nginx-tests/stream_resolver.t
--- nginx-release-1.20.1/test/nginx-tests/stream_resolver.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_resolver.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,196 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream upstream name resolved, proxy_next_upstream_tries.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $server_port $upstream {
+        %%PORT_8081%%  a.example.com:%%PORT_8090%%;
+        %%PORT_8082%%  a.example.com;
+        %%PORT_8083%%  nx.example.com:%%PORT_8082%%;
+    }
+
+    map $server_port $many {
+        default  $server_port.many.example.com;
+    }
+
+    resolver  127.0.0.1:%%PORT_8980_UDP%%;
+
+    server {
+        listen      127.0.0.1:8081;
+        listen      127.0.0.1:8082;
+        listen      127.0.0.1:8083;
+        proxy_pass  $upstream;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 3;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 2;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  $many:%%PORT_8090%%;
+
+        proxy_next_upstream_tries 0;
+        proxy_connect_timeout 1s;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        return      SEE-THIS;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&dns_daemon, port(8980), $t);
+$t->run()->plan(8);
+
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+ok(stream('127.0.0.1:' . port(8081))->read(), 'resolver');
+ok(!stream('127.0.0.1:' . port(8082))->read(), 'upstream no port');
+ok(!stream('127.0.0.1:' . port(8083))->read(), 'name not found');
+
+ok(stream('127.0.0.1:' . port(8084))->read(), 'resolved tries');
+ok(!stream('127.0.0.1:' . port(8085))->read(), 'resolved tries limited');
+ok(stream('127.0.0.1:' . port(8086))->read(), 'resolved tries zero');
+
+$t->stop();
+
+SKIP: {
+skip "relies on error log contents", 2 unless $ENV{TEST_NGINX_UNSAFE};
+
+my $log = `grep -F '[error]' ${\($t->testdir())}/error.log`;
+like($log, qr/no port in upstream "a.example.com"/, 'log - no port');
+like($log, qr/nx.example.com could not be resolved/, 'log - not found');
+
+}
+
+###############################################################################
+
+sub reply_handler {
+    my ($recv_data, $port) = @_;
+
+    my (@name, @rdata);
+
+    use constant NOERROR    => 0;
+    use constant A          => 1;
+    use constant IN         => 1;
+
+    # default values
+
+    my ($hdr, $rcode, $ttl) = (0x8180, NOERROR, 3600);
+
+    # decode name
+
+    my ($len, $offset) = (undef, 12);
+    while (1) {
+        $len = unpack("\@$offset C", $recv_data);
+        last if $len == 0;
+        $offset++;
+        push @name, unpack("\@$offset A$len", $recv_data);
+        $offset += $len;
+    }
+
+    $offset -= 1;
+    my ($id, $type, $class) = unpack("n x$offset n2", $recv_data);
+
+    my $name = join('.', @name);
+    if ($name eq 'a.example.com' && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+
+    } elsif ($name =~ qr/many.example.com/ && $type == A) {
+        push @rdata, rd_addr($ttl, '127.0.0.2');
+        push @rdata, rd_addr($ttl, '127.0.0.2');
+        push @rdata, rd_addr($ttl, '127.0.0.1');
+    }
+
+    $len = @name;
+    pack("n6 (C/a*)$len x n2", $id, $hdr | $rcode, 1, scalar @rdata,
+        0, 0, @name, $type, $class) . join('', @rdata);
+}
+
+sub rd_addr {
+    my ($ttl, $addr) = @_;
+
+    my $code = 'split(/\./, $addr)';
+
+    return pack 'n3N', 0xc00c, A, IN, $ttl if $addr eq '';
+
+    pack 'n3N nC4', 0xc00c, A, IN, $ttl, eval "scalar $code", eval($code);
+}
+
+sub dns_daemon {
+    my ($port, $t) = @_;
+
+    my ($data, $recv_data);
+    my $socket = IO::Socket::INET->new(
+        LocalAddr    => '127.0.0.1',
+        LocalPort    => $port,
+        Proto        => 'udp',
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $socket->recv($recv_data, 65536);
+        $data = reply_handler($recv_data, $port);
+        $socket->send($data);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_set.t ../asynch_mode_nginx/test/nginx-tests/stream_set.t
--- nginx-release-1.20.1/test/nginx-tests/stream_set.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_set.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,69 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Vladimir Kokshenev
+# (C) Nginx, Inc.
+
+# Tests for stream set directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_set/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+
+    map 0 $map_var {
+        default "original";
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        return  $map_var:$set_var;
+
+        set $set_var $map_var;
+        set $map_var "new";
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        return  $set_var;
+    }
+}
+
+EOF
+
+$t->try_run('no stream set')->plan(2);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8082))->read(), 'new:original', 'set');
+is(stream('127.0.0.1:' . port(8083))->read(), '', 'uninitialized variable');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_split_clients.t ../asynch_mode_nginx/test/nginx-tests/stream_split_clients.t
--- nginx-release-1.20.1/test/nginx-tests/stream_split_clients.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_split_clients.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,80 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream split_client module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_split_clients stream_return/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    split_clients $connection $variant {
+        51.2%  "first";
+        10%    "second";
+        *      "third";
+    }
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $variant;
+    }
+}
+
+EOF
+
+$t->run();
+$t->plan(1);
+
+###############################################################################
+
+# NB: split_clients distribution is a subject to implementation details
+
+like(many('/', 20), qr/first: 12, second: 2, third: 6/, 'split');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count) = @_;
+    my %dist;
+
+    for (1 .. $count) {
+        if (my $data = stream('127.0.0.1:' . port(8080))->read()) {
+            $dist{$data} = 0 unless defined $data;
+            $dist{$data}++;
+        }
+    }
+
+    return join ', ', map { $_ . ": " . $dist{$_} } sort keys %dist;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_certificate.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_certificate.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_certificate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_certificate.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,213 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module with dynamic certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_geo stream_return/)
+    ->has_daemon('openssl');
+
+$t->{_configure_args} =~ /OpenSSL ([\d\.]+)/;
+plan(skip_all => 'OpenSSL too old') unless defined $1 and $1 ge '1.0.2';
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    geo $one {
+        default one;
+    }
+
+    geo $two {
+        default two;
+    }
+
+    geo $pass {
+        default pass;
+    }
+
+    ssl_session_cache shared:SSL:1m;
+    ssl_session_tickets off;
+
+    server {
+        listen       127.0.0.1:8080 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8083 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return       $ssl_server_name:$ssl_session_reused;
+
+        # found in key
+        ssl_certificate pass.crt;
+        ssl_certificate_key $pass.key;
+        ssl_password_file password_file;
+    }
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $one.crt;
+        ssl_certificate_key $one.key;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $two.crt;
+        ssl_certificate_key $two.key;
+    }
+
+    server {
+        listen       127.0.0.1:8084 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return       $ssl_server_name:$ssl_session_reused;
+
+        ssl_certificate $ssl_server_name.crt;
+        ssl_certificate_key $ssl_server_name.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('one', 'two') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('pass') {
+    system("openssl genrsa -out $d/$name.key -passout pass:pass "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create $name key: $!\n";
+    system("openssl req -x509 -new -config $d/openssl.conf "
+        . "-subj /CN=$name/ -out $d/$name.crt -key $d/$name.key "
+        . "-passin pass:pass >>$d/openssl.out 2>&1") == 0
+        or die "Can't create $name certificate: $!\n";
+}
+
+$t->write_file('password_file', 'pass');
+$t->write_file('index.html', '');
+
+$t->run()->plan(7);
+
+###############################################################################
+
+like(cert('default', 8080), qr/CN=one/, 'default certificate');
+like(get('default', 8080), qr/default/, 'default context');
+
+like(get('password', 8083), qr/password/, 'ssl_password_file');
+
+# session reuse
+
+my ($s, $ssl) = get_ssl_socket('default', 8080);
+my $ses = Net::SSLeay::get_session($ssl);
+
+like(get('default', 8080, $ses), qr/default:r/, 'session reused');
+like(get('default', 8081, $ses), qr/default:r/, 'session id context match');
+like(get('default', 8082, $ses), qr/default:\./, 'session id context distinct');
+
+# errors
+
+Net::SSLeay::ERR_clear_error();
+get_ssl_socket('nx', 8084);
+ok(Net::SSLeay::ERR_peek_error(), 'no certificate');
+
+###############################################################################
+
+sub get {
+    my ($host, $port, $ctx) = @_;
+    my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my $r = Net::SSLeay::read($ssl);
+    Net::SSLeay::shutdown($ssl);
+    $s->close();
+    return $r unless wantarray();
+    return ($s, $ssl);
+}
+
+sub cert {
+    my ($host, $port, $ctx) = @_;
+    my ($s, $ssl) = get_ssl_socket($host, $port, $ctx) or return;
+    Net::SSLeay::dump_peer_certificate($ssl);
+}
+
+sub get_ssl_socket {
+    my ($host, $port, $ses) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_host_name($ssl, $host);
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_conf_command.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_conf_command.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_conf_command.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_conf_command.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module, ssl_conf_command.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen       127.0.0.1:8443 ssl %%SSL_ASYNCH%%;
+        return       OK;
+
+        ssl_protocols TLSv1.2;
+
+        ssl_session_tickets off;
+        ssl_conf_command Options SessionTicket;
+
+        ssl_prefer_server_ciphers on;
+        ssl_conf_command Options -ServerPreference;
+        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256;
+
+        ssl_certificate localhost.crt;
+        ssl_certificate_key localhost.key;
+        ssl_conf_command Certificate override.crt;
+        ssl_conf_command PrivateKey override.key;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost', 'override') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->try_run('no ssl_conf_command')->plan(3);
+
+###############################################################################
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+my ($s, $ssl) = get_ssl_socket();
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=override/, 'Certificate');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(ses => $ses);
+ok(Net::SSLeay::session_reused($ssl), 'SessionTicket');
+
+($s, $ssl) = get_ssl_socket(ciphers =>
+    'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384');
+is(Net::SSLeay::get_cipher($ssl),
+    'ECDHE-RSA-AES128-GCM-SHA256', 'ServerPreference');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my (%extra) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port(8443));
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $extra{ses}) if $extra{ses};
+    Net::SSLeay::set_cipher_list($ssl, $extra{ciphers}) if $extra{ciphers};
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread_alpn.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread_alpn.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread_alpn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread_alpn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module, ALPN preread.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_ssl_preread/)
+    ->has(qw/stream_ssl stream_return/)->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    map $ssl_preread_alpn_protocols $name {
+        ""       127.0.0.1:8093;
+        default  $ssl_preread_alpn_protocols;
+    }
+
+    upstream foo {
+        server 127.0.0.1:8091;
+    }
+
+    upstream bar {
+        server 127.0.0.1:8092;
+    }
+
+    upstream foo,bar {
+        server 127.0.0.1:8093;
+    }
+
+    ssl_preread  on;
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   $name;
+    }
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8091 ssl %%SSL_ASYNCH%%;
+        listen       127.0.0.1:8092 ssl %%SSL_ASYNCH%%;
+        listen       127.0.0.1:8093 ssl %%SSL_ASYNCH%%;
+        ssl_preread  off;
+        return       $server_port;
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval { IO::Socket::SSL->can_alpn() or die; };
+plan(skip_all => 'IO::Socket::SSL with OpenSSL ALPN support required') if $@;
+
+eval { exists &Net::SSLeay::P_alpn_selected or die; };
+plan(skip_all => 'Net::SSLeay with OpenSSL ALPN support required') if $@;
+
+$t->plan(5);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2, $p3) = (port(8091), port(8092), port(8093));
+
+is(get_ssl(8081, 'foo'), $p1, 'alpn');
+is(get_ssl(8081, 'foo'), $p1, 'alpn again');
+
+is(get_ssl(8081, 'bar'), $p2, 'alpn 2');
+is(get_ssl(8081, 'bar'), $p2, 'alpn 2 again');
+
+is(get_ssl(8081, 'foo', 'bar'), $p3, 'alpn many');
+
+get_ssl(8081, '');
+
+###############################################################################
+
+sub get_ssl {
+    my ($port, @alpn) = @_;
+    my $s = stream('127.0.0.1:' . port($port));
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        IO::Socket::SSL->start_SSL($s->{_socket},
+            SSL_alpn_protocols => [ @alpn ],
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s->read();
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread_protocol.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread_protocol.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread_protocol.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread_protocol.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,104 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module, protocol preread.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl_preread stream_return/)
+    ->write_file_expand('nginx.conf', <<'EOF')->plan(7)->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen       127.0.0.1:8080;
+        ssl_preread  on;
+        return       $ssl_preread_protocol;
+    }
+}
+
+EOF
+
+###############################################################################
+
+is(get('SSLv3'), 'SSLv3', 'client hello SSLv3');
+is(get('TLSv1'), 'TLSv1', 'client hello TLSv1');
+is(get('TLSv1.1'), 'TLSv1.1', 'client hello TLSv1.1');
+is(get('TLSv1.2'), 'TLSv1.2', 'client hello TLSv1.2');
+
+is(get_tls13(), 'TLSv1.3', 'client hello supported_versions');
+
+is(get_ssl2('SSLv2'), 'SSLv2', 'client hello version 2');
+is(get_ssl2('TLSv1'), 'TLSv1', 'client hello version 2 - TLSv1');
+
+###############################################################################
+
+sub get {
+    my $v = shift;
+    my ($re, $ch);
+
+    $re = 0x0300, $ch = 0x0300 if $v eq 'SSLv3';
+    $re = 0x0301, $ch = 0x0301 if $v eq 'TLSv1';
+    $re = 0x0301, $ch = 0x0302 if $v eq 'TLSv1.1';
+    $re = 0x0301, $ch = 0x0303 if $v eq 'TLSv1.2';
+
+    my $r = pack("CnNn2C", 0x16, $re, 0x00380100, 0x0034, $ch, 0xeb);
+    $r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+    $r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+    $r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+    $r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+    http($r);
+}
+
+sub get_tls13 {
+    my $r = pack("N*", 0x16030100, 0x33010000, 0x2f0303eb);
+    $r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+    $r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+    $r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+    $r .= pack("CNCn", 0x07, 0x002b0007, 0x02, 0x7f1c);
+
+    http($r);
+}
+
+sub get_ssl2 {
+    my $v = shift;
+    my $ch;
+
+    $ch = 0x0002 if $v eq 'SSLv2';
+    $ch = 0x0301 if $v eq 'TLSv1';
+
+    my $r = pack("nCn4", 0x801c, 0x01, $ch, 0x0003, 0x0000, 0x0010);
+    $r .= pack("C3", 0x01, 0x00, 0x80);
+    $r .= pack("N4", 0x322dd95c, 0x4749ef17, 0x3d5f0916, 0xf0b730f8);
+
+    http($r);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_preread.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_preread.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,248 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream_ssl_preread module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_map stream_ssl_preread/)
+    ->has(qw/stream_ssl stream_return/)->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format status $status;
+
+    map $ssl_preread_server_name $name {
+        ""       127.0.0.1:8093;
+        default  $ssl_preread_server_name;
+    }
+
+    upstream foo {
+        server 127.0.0.1:8091;
+    }
+
+    upstream bar {
+        server 127.0.0.1:8092;
+    }
+
+    upstream next {
+        server 127.0.0.1:8094;
+        server 127.0.0.1:8080;
+    }
+
+    ssl_preread  on;
+
+    server {
+        listen       127.0.0.1:8080;
+        return       $name;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   $name;
+    }
+
+    server {
+        listen       127.0.0.1:8082;
+        proxy_pass   $name;
+        ssl_preread  off;
+    }
+
+    server {
+        listen       127.0.0.1:8083;
+        proxy_pass   $name;
+
+        preread_timeout      2s;
+        preread_buffer_size  42;
+
+        access_log %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        proxy_pass   next;
+
+        proxy_connect_timeout  2s;
+        preread_buffer_size    8;
+    }
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen       127.0.0.1:8091 ssl;
+        listen       127.0.0.1:8092 ssl;
+        listen       127.0.0.1:8093 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        ssl_preread  off;
+        return       $server_port;
+    }
+}
+
+EOF
+
+eval { require IO::Socket::SSL; die if $IO::Socket::SSL::VERSION < 1.56; };
+plan(skip_all => 'IO::Socket::SSL version >= 1.56 required') if $@;
+
+eval {
+    if (IO::Socket::SSL->can('can_client_sni')) {
+        IO::Socket::SSL->can_client_sni() or die;
+    }
+};
+plan(skip_all => 'IO::Socket::SSL with OpenSSL SNI support required') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+$t->plan(13);
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+my ($p1, $p2, $p3, $p4) = (port(8091), port(8092), port(8093), port(8084));
+
+is(get_ssl('foo', 8081), $p1, 'sni');
+is(get_ssl('foo', 8081), $p1, 'sni again');
+
+is(get_ssl('bar', 8081), $p2, 'sni 2');
+is(get_ssl('bar', 8081), $p2, 'sni 2 again');
+
+# fallback to an empty value for some reason
+
+is(get_ssl('', 8081), $p3, 'no sni');
+is(get_ssl('foo', 8082), $p3, 'preread off');
+is(get_ssl('foo', 8083), undef, 'preread buffer full');
+is(stream('127.0.0.1:' . port(8080))->io('x' x 1000), "127.0.0.1:$p3",
+    'not a handshake');
+
+# ticket #1317
+
+is(stream("127.0.0.1:$p4")->io('x' x 16), "127.0.0.1:$p3",
+    'pending buffers on next upstream');
+
+# no junk in variable due to short ClientHello length value
+
+is(get_short(), "127.0.0.1:$p3", 'short client hello');
+
+# allow record with older SSL version, such as 3.0
+
+is(get_oldver(), 'foo', 'older version in ssl record');
+
+# SNI "foo|f" fragmented across TLS records
+
+is(get_frag(), 'foof', 'handshake fragment split on SNI');
+
+$t->stop();
+
+is($t->read_file('status.log'), "400\n", 'preread buffer full - log');
+
+###############################################################################
+
+sub get_frag {
+    my $r = pack("N*", 0x16030100, 0x3b010000, 0x380303ac,
+        0x8c8678a0, 0xaa1e7eed, 0x3644eed6, 0xc3bd2c69,
+        0x7bc7deda, 0x249db0e3, 0x0c339eba, 0xa80b7600,
+        0x00020000, 0x0100000d, 0x00000009, 0x00070000,
+        0x04666f6f, 0x16030100);
+    $r .= pack("n", 0x0166);
+
+    http($r);
+}
+
+sub get_short {
+    my $r = pack("N*", 0x16030100, 0x38010000, 0x330303eb);
+    $r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+    $r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+    $r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+    $r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+    http($r);
+}
+
+sub get_oldver {
+    my $r = pack("N*", 0x16030000, 0x38010000, 0x340303eb);
+    $r .= pack("N*", 0x6357cdba, 0xa6b8d853, 0xf1f6ac0f);
+    $r .= pack("N*", 0xdf03178c, 0x0ae41824, 0xe7643682);
+    $r .= pack("N*", 0x3c1b273f, 0xbfde4b00, 0x00000000);
+    $r .= pack("CN3", 0x0c, 0x00000008, 0x00060000, 0x03666f6f);
+
+    http($r);
+}
+
+sub get_ssl {
+    my ($host, $port) = @_;
+    my $s = stream('127.0.0.1:' . port($port));
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        IO::Socket::SSL->start_SSL($s->{_socket},
+            SSL_hostname => $host,
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    return $s->read();
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_realip.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_realip.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_realip.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_realip.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,156 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream realip module, server side proxy protocol with ssl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::SSL; };
+plan(skip_all => 'IO::Socket::SSL not installed') if $@;
+eval { IO::Socket::SSL::SSL_VERIFY_NONE(); };
+plan(skip_all => 'IO::Socket::SSL too old') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_realip/)
+    ->has(qw/stream_ssl/)->has_daemon('openssl')
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+
+    server {
+        listen      127.0.0.1:8083 proxy_protocol ssl;
+        return      $proxy_protocol_addr:$proxy_protocol_port;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol ssl;
+        listen      [::1]:%%PORT_8086%% proxy_protocol ssl;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from ::1;
+        set_real_ip_from 127.0.0.2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  [::1]:%%PORT_8086%%;
+    }
+
+    server {
+        listen      127.0.0.1:8088 proxy_protocol ssl;
+        listen      [::1]:%%PORT_8088%% proxy_protocol ssl;
+        return      "$remote_addr:$remote_port:
+                     $realip_remote_addr:$realip_remote_port";
+
+        set_real_ip_from 127.0.0.1;
+        set_real_ip_from ::2;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  [::1]:%%PORT_8088%%;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->try_run('no inet6 support')->plan(6);
+
+###############################################################################
+
+is(pp_get(8083, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    '192.0.2.1:1234', 'server');
+
+like(pp_get(8086, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server ipv6 realip - no match');
+
+like(pp_get(8087, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/\Q192.0.2.1:1234:\E\s+\Q::1:\E\d+/, 'server ipv6 realip');
+
+like(pp_get(8088, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/\Q192.0.2.1:1234:\E\s+\Q127.0.0.1:\E\d+/, 'server ipv4 realip');
+
+like(pp_get(8089, "PROXY TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(::1:\d+):\s+\1$/, 'server ipv4 realip - no match');
+
+like(pp_get(8088, "PROXY UNKNOWN TCP4 192.0.2.1 192.0.2.2 1234 5678${CRLF}"),
+    qr/^(\Q127.0.0.1:\E\d+):\s+\1$/, 'server unknown');
+
+###############################################################################
+
+sub pp_get {
+    my ($port, $proxy) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port)) or return;
+    http($proxy, start => 1, socket => $s);
+
+    eval {
+        local $SIG{ALRM} = sub { die "timeout\n" };
+        local $SIG{PIPE} = sub { die "sigpipe\n" };
+        alarm(8);
+        IO::Socket::SSL->start_SSL($s,
+            SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_NONE(),
+            SSL_error_trap => sub { die $_[1] }
+        );
+        alarm(0);
+    };
+    alarm(0);
+
+    if ($@) {
+        log_in("died: $@");
+        return undef;
+    }
+
+    http_end($s);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,229 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use POSIX qw/ mkfifo /;
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl/)->has_daemon('openssl');
+
+$t->plan(7)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_tickets off;
+
+    # inherited by server "inherits"
+    ssl_password_file password_stream;
+
+    server {
+        listen      127.0.0.1:8080 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache builtin;
+        ssl_password_file password;
+    }
+
+    server {
+        listen      127.0.0.1:8082 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache off;
+        ssl_password_file password_many;
+    }
+
+    server {
+        listen      127.0.0.1:8083 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache builtin:1000;
+        ssl_password_file password_fifo;
+    }
+
+    server {
+        listen      127.0.0.1:8084 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        proxy_pass  127.0.0.1:8081;
+
+        ssl_session_cache shared:SSL:1m;
+        ssl_certificate_key inherits.key;
+        ssl_certificate inherits.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+mkfifo("$d/password_fifo", 0700);
+
+foreach my $name ('localhost', 'inherits') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+
+my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+
+$t->write_file('password', 'localhost');
+$t->write_file('password_many', "wrong$CRLF" . "localhost$CRLF");
+$t->write_file('password_stream', 'inherits');
+
+my $p = fork();
+exec("echo localhost > $d/password_fifo") if $p == 0;
+
+$t->run_daemon(\&http_daemon);
+
+eval {
+    open OLDERR, ">&", \*STDERR; close STDERR;
+    $t->run();
+    open STDERR, ">&", \*OLDERR;
+};
+kill 'INT', $p if $@;
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my ($s, $ssl, $ses);
+
+($s, $ssl) = get_ssl_socket(port(8080));
+Net::SSLeay::write($ssl, "GET / HTTP/1.0$CRLF$CRLF");
+like(Net::SSLeay::read($ssl), qr/200 OK/, 'ssl');
+
+# ssl_session_cache
+
+($s, $ssl) = get_ssl_socket(port(8080));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8080), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin session reused');
+
+($s, $ssl) = get_ssl_socket(port(8082));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8082), $ses);
+isnt(Net::SSLeay::session_reused($ssl), 1, 'session not reused');
+
+($s, $ssl) = get_ssl_socket(port(8083));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8083), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'builtin size session reused');
+
+($s, $ssl) = get_ssl_socket(port(8084));
+$ses = Net::SSLeay::get_session($ssl);
+
+($s, $ssl) = get_ssl_socket(port(8084), $ses);
+is(Net::SSLeay::session_reused($ssl), 1, 'shared session reused');
+
+# ssl_certificate inheritance
+
+($s, $ssl) = get_ssl_socket(port(8080));
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=localhost/, 'CN');
+
+($s, $ssl) = get_ssl_socket(port(8084));
+like(Net::SSLeay::dump_peer_certificate($ssl), qr/CN=inherits/, 'CN inner');
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($port, $ses) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . $port);
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_variables.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_variables.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_variables.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,144 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module with variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+eval {
+    my $ctx = Net::SSLeay::CTX_new() or die;
+    my $ssl = Net::SSLeay::new($ctx) or die;
+    Net::SSLeay::set_tlsext_host_name($ssl, 'example.org') == 1 or die;
+};
+plan(skip_all => 'Net::SSLeay with OpenSSL SNI support required') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    ssl_certificate_key localhost.key;
+    ssl_certificate localhost.crt;
+    ssl_session_cache builtin;
+    %%PROXY_ASYNCH_ENABLE%%
+
+    server {
+        listen  127.0.0.1:8080;
+        listen  127.0.0.1:8081 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+
+        return  $ssl_session_reused:$ssl_session_id:$ssl_cipher:$ssl_protocol;
+    }
+
+    server {
+        listen  127.0.0.1:8082 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return  $ssl_server_name;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(6);
+
+###############################################################################
+
+my ($s, $ssl);
+
+is(stream('127.0.0.1:' . port(8080))->read(), ':::', 'no ssl');
+
+($s, $ssl) = get_ssl_socket(port(8081));
+like(Net::SSLeay::read($ssl), qr/^\.:(\w{64})?:[\w-]+:(TLS|SSL)v(\d|\.)+$/,
+    'ssl variables');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(port(8081), $ses);
+like(Net::SSLeay::read($ssl), qr/^r:\w{64}:[\w-]+:(TLS|SSL)v(\d|\.)+$/,
+    'ssl variables - session reused');
+
+SKIP: {
+skip 'no sni', 3 unless $t->has_module('sni');
+
+($s, $ssl) = get_ssl_socket(port(8082), undef, 'example.com');
+is(Net::SSLeay::ssl_read_all($ssl), 'example.com', 'ssl server name');
+
+my $ses = Net::SSLeay::get_session($ssl);
+($s, $ssl) = get_ssl_socket(port(8082), $ses, 'example.com');
+is(Net::SSLeay::ssl_read_all($ssl), 'example.com', 'ssl server name - reused');
+
+($s, $ssl) = get_ssl_socket(port(8082));
+is(Net::SSLeay::ssl_read_all($ssl), '', 'ssl server name empty');
+
+}
+
+###############################################################################
+
+sub get_ssl_socket {
+    my ($port, $ses, $name) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . $port);
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_tlsext_host_name($ssl, $name) if defined $name;
+    Net::SSLeay::set_session($ssl, $ses) if defined $ses;
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+    return ($s, $ssl);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_ssl_verify_client.t ../asynch_mode_nginx/test/nginx-tests/stream_ssl_verify_client.t
--- nginx-release-1.20.1/test/nginx-tests/stream_ssl_verify_client.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_ssl_verify_client.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,169 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream ssl module, ssl_verify_client.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval {
+    require Net::SSLeay;
+    Net::SSLeay::load_error_strings();
+    Net::SSLeay::SSLeay_add_ssl_algorithms();
+    Net::SSLeay::randomize();
+};
+plan(skip_all => 'Net::SSLeay not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format  status  $status;
+
+    %%PROXY_ASYNCH_ENABLE%%
+    ssl_certificate_key 1.example.com.key;
+    ssl_certificate 1.example.com.crt;
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+    }
+
+    server {
+        listen  127.0.0.1:8081 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client on;
+        ssl_client_certificate 2.example.com.crt;
+
+        access_log %%TESTDIR%%/status.log status;
+    }
+
+    server {
+        listen  127.0.0.1:8082 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client optional;
+        ssl_client_certificate 2.example.com.crt;
+        ssl_trusted_certificate 3.example.com.crt;
+    }
+
+    server {
+        listen  127.0.0.1:8083 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return  $ssl_client_verify:$ssl_client_cert;
+
+        ssl_verify_client optional_no_ca;
+        ssl_client_certificate 2.example.com.crt;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com', '3.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run()->plan(10);
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), ':', 'plain connection');
+
+is(get(8081), '', 'no cert');
+is(get(8082, '1.example.com'), '', 'bad optional cert');
+is(get(8082), 'NONE:', 'no optional cert');
+like(get(8083, '1.example.com'), qr/FAILED.*BEGIN/, 'bad optional_no_ca cert');
+
+like(get(8081, '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert');
+like(get(8082, '2.example.com'), qr/SUCCESS.*BEGIN/, 'good cert optional');
+like(get(8082, '3.example.com'), qr/SUCCESS.*BEGIN/, 'good cert trusted');
+
+SKIP: {
+skip 'Net::SSLeay version >= 1.36 required', 1 if $Net::SSLeay::VERSION < 1.36;
+
+my $ca = join ' ', get(8082, '3.example.com');
+is($ca, '/CN=2.example.com', 'no trusted sent');
+
+}
+
+$t->stop();
+
+is($t->read_file('status.log'), "500\n200\n", 'log');
+
+###############################################################################
+
+sub get {
+    my ($port, $cert) = @_;
+
+    my $s = IO::Socket::INET->new('127.0.0.1:' . port($port));
+    my $ctx = Net::SSLeay::CTX_new() or die("Failed to create SSL_CTX $!");
+    Net::SSLeay::set_cert_and_key($ctx, "$d/$cert.crt", "$d/$cert.key")
+        or die if $cert;
+    my $ssl = Net::SSLeay::new($ctx) or die("Failed to create SSL $!");
+    Net::SSLeay::set_fd($ssl, fileno($s));
+    Net::SSLeay::connect($ssl) or die("ssl connect");
+
+    my $buf = Net::SSLeay::read($ssl);
+    log_in($buf);
+    return $buf unless wantarray();
+
+    my $list = Net::SSLeay::get_client_CA_list($ssl);
+    my @names;
+    for my $i (0 .. Net::SSLeay::sk_X509_NAME_num($list) - 1) {
+        my $name = Net::SSLeay::sk_X509_NAME_value($list, $i);
+        push @names, Net::SSLeay::X509_NAME_oneline($name);
+    }
+    return @names;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_status_variable.t ../asynch_mode_nginx/test/nginx-tests/stream_status_variable.t
--- nginx-release-1.20.1/test/nginx-tests/stream_status_variable.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_status_variable.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,111 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream status variable.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_access/)
+    ->has(qw/stream_limit_conn/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format  status  $status;
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+
+    server {
+        listen      127.0.0.1:8080;
+        return      SEE-THIS;
+        access_log  %%TESTDIR%%/200.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        return      SEE-THIS;
+        deny        all;
+        access_log  %%TESTDIR%%/403.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8083;
+        access_log  %%TESTDIR%%/502.log status;
+
+        proxy_connect_timeout 0;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  example.com:$remote_port;
+        access_log  %%TESTDIR%%/500.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        limit_conn  zone 1;
+        proxy_pass  127.0.0.1:8086;
+        access_log  %%TESTDIR%%/503.log status;
+    }
+
+    server {
+        listen      127.0.0.1:8086 proxy_protocol;
+        return      SEE-THIS;
+        access_log  %%TESTDIR%%/400.log status;
+    }
+}
+
+EOF
+
+$t->run()->plan(6);
+
+###############################################################################
+
+stream('127.0.0.1:' . port(8080))->read();
+stream('127.0.0.1:' . port(8081))->read();
+stream('127.0.0.1:' . port(8082))->read();
+stream('127.0.0.1:' . port(8084))->read();
+
+my $s = stream('127.0.0.1:' . port(8085));
+stream('127.0.0.1:' . port(8085))->read();
+$s->io('PROXY INVALID');
+
+$t->stop();
+
+is($t->read_file('200.log'), "200\n", 'stream status 200');
+is($t->read_file('400.log'), "400\n", 'stream status 400');
+is($t->read_file('403.log'), "403\n", 'stream status 403');
+is($t->read_file('500.log'), "500\n", 'stream status 500');
+is($t->read_file('502.log'), "502\n", 'stream status 502');
+is($t->read_file('503.log'), "503\n200\n", 'stream status 503');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_tcp_nodelay.t ../asynch_mode_nginx/test/nginx-tests/stream_tcp_nodelay.t
--- nginx-release-1.20.1/test/nginx-tests/stream_tcp_nodelay.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_tcp_nodelay.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for tcp_nodelay.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/);
+
+$t->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_buffer_size 1;
+    tcp_nodelay off;
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  127.0.0.1:8080;
+    }
+
+    server {
+        tcp_nodelay on;
+        listen      127.0.0.1:8082;
+        proxy_pass  127.0.0.1:8080;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8080));
+
+###############################################################################
+
+my $str = '1234567890' x 10 . 'F';
+my $length = length($str);
+
+is(stream('127.0.0.1:' . port(8081))->io($str, length => $length), $str,
+    'tcp_nodelay off');
+is(stream('127.0.0.1:' . port(8082))->io($str, length => $length), $str,
+    'tcp_nodelay on');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8080),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    my $close = $buffer =~ /F/;
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $close;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_limit_conn.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_limit_conn.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_limit_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_limit_conn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,138 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stream limit_conn module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_limit_conn udp/)->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    limit_conn_zone  $binary_remote_addr  zone=zone:1m;
+    limit_conn_zone  $binary_remote_addr  zone=zone2:1m;
+
+    proxy_responses  1;
+    proxy_timeout    1s;
+
+    server {
+        listen           127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+
+        limit_conn       zone 1;
+        proxy_responses  2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8980_UDP%%;
+        limit_conn       zone 5;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+        limit_conn       zone2 1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8985_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+        limit_conn       zone 1;
+    }
+}
+
+EOF
+
+$t->run();
+$t->run_daemon(\&udp_daemon, $t);
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+# same and other zones
+
+my $s = dgram('127.0.0.1:' . port(8981));
+
+is($s->io('1'), '1', 'passed');
+
+# regardless of incomplete responses, new requests in the same
+# socket will be treated as requests in existing session
+
+is($s->io('1', read_timeout => 0.4), '1', 'passed new request');
+
+is(dgram('127.0.0.1:' . port(8981))->io('1', read_timeout => 0.1), '',
+    'rejected new session');
+is(dgram('127.0.0.1:' . port(8982))->io('1'), '1', 'passed different zone');
+is(dgram('127.0.0.1:' . port(8983))->io('1'), '1', 'passed same zone unlimited');
+
+sleep 1;    # waiting for proxy_timeout to expire
+
+is($s->io('2', read => 2), '12', 'new session after proxy_timeout');
+
+is(dgram('127.0.0.1:' . port(8981))->io('2', read => 2), '12', 'passed 2');
+
+# zones proxy chain
+
+is(dgram('127.0.0.1:' . port(8984))->io('1'), '1', 'passed proxy');
+is(dgram('127.0.0.1:' . port(8985))->io('1', read_timeout => 0.1), '',
+    'rejected proxy');
+
+###############################################################################
+
+sub udp_daemon {
+    my $t = shift;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => '127.0.0.1:' . port(8980),
+        Reuse => 1,
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . port(8980);
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+        $server->send($_) for (1 .. $buffer);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_limit_rate.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_limit_rate.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_limit_rate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_limit_rate.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams, limit rate directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_requests           2;
+    proxy_responses          1;
+    proxy_timeout            3s;
+
+    server {
+        listen               127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+    }
+
+    server {
+        listen               127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+        proxy_download_rate  500;
+    }
+
+    server {
+        listen               127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass           127.0.0.1:%%PORT_8980_UDP%%;
+        proxy_upload_rate    500;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8980), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8980));
+
+###############################################################################
+
+my $str = '1234567890' x 100;
+
+# unlimited
+
+my $s = dgram('127.0.0.1:' . port(8982));
+is($s->io($str), $str, 'unlimited');
+is($s->io($str), $str, 'unlimited 2');
+
+# datagram doesn't get split
+
+$s = dgram('127.0.0.1:' . port(8983));
+is($s->io($str), $str, 'download');
+my $t1 = time();
+is($s->io($str), $str, 'download 2');
+my $t2 = time();
+cmp_ok($t1, '<', $t2, 'download 2 delayed');
+
+# infinite event report before 1.15.9
+
+$s = dgram('127.0.0.1:' . port(8984));
+is($s->io($str), $str, 'upload');
+is($s->io($str, read_timeout => 0.5), '', 'upload limited');
+
+select undef, undef, undef, 1.6;
+is($s->io($str), $str, 'upload passed');
+
+###############################################################################
+
+sub udp_daemon {
+    my ($port, $t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$port",
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . "/$port";
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+        log2i("$server $buffer");
+
+        log2o("$server $buffer");
+        $server->send($buffer);
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_proxy_requests.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_proxy_requests.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_proxy_requests.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_proxy_requests.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,215 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module, the proxy_requests directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(26)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_timeout  2100ms;
+
+    log_format status $status;
+
+    server {
+        listen           127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   0;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   1;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8984_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8991_UDP%%;
+
+        proxy_requests   2;
+        access_log       %%TESTDIR%%/s.log status;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8985_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8990_UDP%%;
+
+        proxy_requests   2;
+        proxy_responses  2;
+        access_log       %%TESTDIR%%/s2.log status;
+    }
+}
+
+EOF
+
+
+$t->run_daemon(\&udp_daemon, $t, port(8990));
+$t->run_daemon(\&udp_daemon, $t, port(8991));
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8990));
+$t->waitforfile($t->testdir . '/' . port(8991));
+
+###############################################################################
+
+# proxy_requests 0, binding is not dropped across streams
+
+my $s = dgram('127.0.0.1:' . port(8980));
+my $n = $s->io('1', read => 1);
+ok($n, 'requests 0 create');
+is($s->read(), '1', 'requests 0 create - response');
+
+is($s->io('1', read => 1), $n, 'requests 0 second - binding saved');
+is($s->read(), '1', 'requests 0 second - response');
+
+is($s->io('1', read => 1), $n, 'requests 0 follow - binding saved');
+is($s->read(), '1', 'requests 0 follow - response');
+
+# proxy_requests 1, binding is dropped on every next stream
+
+$s = dgram('127.0.0.1:' . port(8981));
+$n = $s->io('1', read => 1);
+ok($n, 'requests 1 create');
+is($s->read(), '1', 'requests 1 create - response');
+
+isnt($s->io('1', read => 1), $n, 'requests 1 second - binding lost');
+is($s->read(), '1', 'requests 1 second - response');
+
+# proxy_requests 2, binding is dropped on every second stream
+
+$s = dgram('127.0.0.1:' . port(8982));
+$n = $s->io('1', read => 1);
+ok($n, 'requests 2 create');
+is($s->read(), '1', 'requests 2 create - response');
+
+is($s->io('1', read => 1), $n, 'requests 2 second - binding saved');
+is($s->read(), '1', 'requests 2 second - response');
+
+isnt($s->io('1', read => 1), $n, 'requests 2 follow - binding lost');
+is($s->read(), '1', 'requests 2 follow - response');
+
+# proxy_requests unset, binding is not dropped across streams
+
+$s = dgram('127.0.0.1:' . port(8983));
+$n = $s->io('1', read => 1);
+ok($n, 'requests unset create');
+is($s->read(), '1', 'requests unset create - response');
+
+is($s->io('1', read => 1), $n, 'requests unset second - binding saved');
+is($s->read(), '1', 'requests unset second - response');
+
+is($s->io('1', read => 1), $n, 'requests unset follow - binding saved');
+is($s->read(), '1', 'requests unset follow - response');
+
+# proxy_requests 2, with slow backend
+# client sends 5 packets, each responded with 3 packets
+# expects all packets proxied from backend, the last (uneven) session succeed
+
+$s = dgram('127.0.0.1:' . port(8984));
+$s->write('2') for 1 .. 5;
+my $b = join ' ', map { $s->read() } (1 .. 15);
+like($b, qr/^(\d+ 1 2) \1 (?!\1)(\d+ 1 2) \2 (?!\2)\d+ 1 2$/, 'slow backend');
+
+# proxy_requests 2, proxy_responses 2
+# client sends 5 packets, each responded with 2 packets
+# expects all packets proxied from backend, the last (uneven) session succeed
+
+$s = dgram('127.0.0.1:' . port(8985));
+$s->write('1') for 1 .. 5;
+$b = join ' ', map { $s->read() } (1 .. 10);
+
+SKIP: {
+skip 'session could early terminate', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+like($b, qr/^(\d+ 1) \1 (?!\1)(\d+ 1) \2 (?!\2)\d+ 1$/, 'requests - responses');
+
+}
+
+$t->stop();
+
+is($t->read_file('s.log'), <<EOF, 'uneven session status - slow backend');
+200
+200
+200
+EOF
+
+is($t->read_file('s2.log'), <<EOF, 'uneven session status - responses');
+200
+200
+200
+EOF
+
+###############################################################################
+
+sub udp_daemon {
+    my ($t, $port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$port",
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . "/$port";
+    close $fh;
+
+    my $slp = 1 if $port == port(8991);
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+        sleep 1, $slp = 0 if $slp;
+
+        $server->send($server->peerport());
+        $server->send($_) for (1 .. $buffer);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_proxy.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_proxy.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_proxy.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_proxy.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,128 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_timeout        1s;
+
+    server {
+        listen           127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+
+        proxy_responses  0;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+
+        proxy_responses  2;
+    }
+
+    server {
+        listen           127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass       127.0.0.1:%%PORT_8981_UDP%%;
+    }
+}
+
+EOF
+
+
+$t->run_daemon(\&udp_daemon, port(8981), $t);
+$t->run();
+$t->waitforfile($t->testdir . '/' . port(8981));
+
+###############################################################################
+
+my $s = dgram('127.0.0.1:' . port(8980));
+is($s->io('1', read => 1, read_timeout => 0.5), '', 'proxy responses 0');
+
+$s = dgram('127.0.0.1:' . port(8982));
+is($s->io('1'), '1', 'proxy responses 1');
+$s = dgram('127.0.0.1:' . port(8982));
+is($s->io('2', read => 2), '12', 'proxy responses 2');
+
+$s = dgram('127.0.0.1:' . port(8983));
+is($s->io('3', read => 3), '123', 'proxy responses default');
+
+# zero-length payload
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.1');
+
+$s = dgram('127.0.0.1:' . port(8982));
+$s->write('');
+is($s->read(), 'zero', 'upstream read zero bytes');
+is($s->read(), '', 'upstream sent zero bytes');
+
+$s->write('');
+is($s->read(), 'zero', 'upstream read zero bytes again');
+is($s->read(), '', 'upstream sent zero bytes again');
+
+}
+
+###############################################################################
+
+sub udp_daemon {
+    my ($port, $t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => '127.0.0.1:' . port(8981),
+        Reuse => 1,
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . port(8981);
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+
+        if (length($buffer) > 0) {
+        $server->send($_) for (1 .. $buffer);
+
+        } else {
+            $server->send('zero');
+            select undef, undef, undef, 0.2;
+            $server->send('');
+        }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_stream.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_stream.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_stream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_stream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,78 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for UDP stream.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/)->plan(8)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_timeout   1s;
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  127.0.0.1:%%PORT_8981_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        return      $remote_port;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $s = dgram('127.0.0.1:' . port(8980));
+my $data = $s->io('1', read_timeout => 0.5);
+isnt($data, '', 'udp_stream response 1');
+
+my $s2 = dgram('127.0.0.1:' . port(8980));
+my $data2 = $s2->io('1', read_timeout => 0.5);
+isnt($data2, '', 'udp_stream response 2');
+
+isnt($data, $data2, 'udp_stream two sessions');
+
+is($s->io('1'), $data, 'udp_stream session 1');
+is($s->io('1'), $data, 'udp_stream session 2');
+
+is($s2->io('1'), $data2, 'udp_stream another session 1');
+is($s2->io('1'), $data2, 'udp_stream another session 2');
+
+select undef, undef, undef, 1.1;
+
+isnt($s->io('1'), $data, 'udp_stream new session');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream_hash.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream_hash.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream_hash.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream_hash.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,124 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream hash balancer module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_hash udp/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream hash {
+        hash $remote_addr;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+        server 127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    upstream cons {
+        hash $remote_addr consistent;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+        server 127.0.0.1:%%PORT_8983_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  hash;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass  cons;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8982), $t);
+$t->run_daemon(\&udp_daemon, port(8983), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8982));
+$t->waitforfile($t->testdir . '/' . port(8983));
+
+###############################################################################
+
+my @ports = my ($port2, $port3) = (port(8982), port(8983));
+
+is(many(10, port(8980)), "$port3: 10", 'hash');
+like(many(10, port(8981)), qr/($port2|$port3): 10/, 'hash consistent');
+
+###############################################################################
+
+sub many {
+    my ($count, $port) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (dgram("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+    my ($port, $t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => '127.0.0.1:' . $port,
+        Reuse => 1,
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+        $buffer = $server->sockport();
+        $server->send($buffer);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream_least_conn.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream_least_conn.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream_least_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream_least_conn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,130 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream least_conn balancer module with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn udp/)
+    ->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream u {
+        least_conn;
+        server 127.0.0.1:%%PORT_8981_UDP%%;
+        server 127.0.0.1:%%PORT_8982_UDP%%;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  u;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8981), $t);
+$t->run_daemon(\&udp_daemon, port(8982), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8981));
+$t->waitforfile($t->testdir . '/' . port(8982));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8981), port(8982));
+
+is(many(10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+for (1 .. 2) {
+    my $s = dgram('127.0.0.1:' . port(8980));
+    $s->write('w');
+    push @sockets, $s;
+}
+
+select undef, undef, undef, 0.2;
+
+is(many(10), "$port2: 10", 'least_conn');
+
+###############################################################################
+
+sub many {
+    my ($count) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (dgram('127.0.0.1:' . port(8980))->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+    my ($port, $t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => '127.0.0.1:' . $port,
+        Reuse => 1,
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+
+        my $port = $server->sockport();
+
+        if ($buffer =~ /w/ && $port == port(8981)) {
+            select undef, undef, undef, 2.5;
+        }
+
+        $buffer = $port;
+
+        $server->send($buffer);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_upstream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,151 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream module and balancers with datagrams.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream udp/)->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_responses      1;
+    proxy_timeout        1s;
+
+    upstream u {
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:%%PORT_8986_UDP%% down;
+        server 127.0.0.1:%%PORT_8986_UDP%%;
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%%;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:%%PORT_8984_UDP%%;
+        server 127.0.0.1:%%PORT_8985_UDP%% weight=2;
+    }
+
+    upstream u4 {
+        server 127.0.0.1:%%PORT_8986_UDP%% down;
+        server 127.0.0.1:%%PORT_8984_UDP%% backup;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8980_UDP%% udp;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8981_UDP%% udp;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8982_UDP%% udp;
+        proxy_pass  u3;
+    }
+
+    server {
+        listen      127.0.0.1:%%PORT_8983_UDP%% udp;
+        proxy_pass  u4;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&udp_daemon, port(8984), $t);
+$t->run_daemon(\&udp_daemon, port(8985), $t);
+$t->run();
+
+$t->waitforfile($t->testdir . '/' . port(8984));
+$t->waitforfile($t->testdir . '/' . port(8985));
+
+###############################################################################
+
+my @ports = my ($port4, $port5) = (port(8984), port(8985));
+
+is(many(10, port(8980)), "$port4: 5, $port5: 5", 'balanced');
+
+is(dgram('127.0.0.1:' . port(8981))->io('.', read_timeout => 0.5), '',
+    'no next upstream for dgram');
+
+
+is(many(10, port(8981)), "$port4: 5, $port5: 5", 'failures');
+
+is(many(9, port(8982)), "$port4: 3, $port5: 6", 'weight');
+is(many(10, port(8983)), "$port4: 10", 'backup');
+
+###############################################################################
+
+sub many {
+    my ($count, $port) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (dgram("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub udp_daemon {
+    my ($port, $t) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => '127.0.0.1:' . $port,
+        Reuse => 1,
+    )
+        or die "Can't create listening socket: $!\n";
+
+    # signal we are ready
+
+    open my $fh, '>', $t->testdir() . '/' . $port;
+    close $fh;
+
+    while (1) {
+        $server->recv(my $buffer, 65536);
+        $buffer = $server->sockport();
+        $server->send($buffer);
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_udp_wildcard.t ../asynch_mode_nginx/test/nginx-tests/stream_udp_wildcard.t
--- nginx-release-1.20.1/test/nginx-tests/stream_udp_wildcard.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_udp_wildcard.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,65 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream proxy module with datagrams, source address selection.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => '127.0.0.2 local address required')
+    unless defined IO::Socket::INET->new( LocalAddr => '127.0.0.2' );
+
+plan(skip_all => 'listen on wildcard address')
+    unless $ENV{TEST_NGINX_UNSAFE};
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/)->plan(1)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen  %%PORT_8999_UDP%% udp;
+        return  $server_addr;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my $s = dgram(
+    LocalAddr => '127.0.0.1',
+    PeerAddr  => '127.0.0.2:' . port(8999)
+);
+
+is($s->io('test'), '127.0.0.2', 'stream udp wildcard');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_unix.t ../asynch_mode_nginx/test/nginx-tests/stream_unix.t
--- nginx-release-1.20.1/test/nginx-tests/stream_unix.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_unix.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Simple tests for stream with unix socket.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require IO::Socket::UNIX; };
+plan(skip_all => 'IO::Socket::UNIX not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/stream unix/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u {
+        server unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        proxy_pass   unix:%%TESTDIR%%/unix.sock;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        proxy_pass   u;
+    }
+}
+
+EOF
+
+my $path = $t->testdir() . '/unix.sock';
+
+$t->run_daemon(\&stream_daemon, $path);
+$t->run();
+
+# wait for unix socket to appear
+
+for (1 .. 50) {
+    last if -S $path;
+    select undef, undef, undef, 0.1;
+}
+
+###############################################################################
+
+my $str = 'SEE-THIS';
+
+is(stream('127.0.0.1:' . port(8080))->io($str), $str, 'proxy');
+is(stream('127.0.0.1:' . port(8081))->io($str), $str, 'upstream');
+
+###############################################################################
+
+sub stream_daemon {
+    my $server = IO::Socket::UNIX->new(
+        Proto => 'tcp',
+        Local => shift,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        log2c("(new connection $client)");
+
+        $client->sysread(my $buffer, 65536) or next;
+
+        log2i("$client $buffer");
+
+        log2o("$client $buffer");
+
+        $client->syswrite($buffer);
+
+        close $client;
+    }
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_hash.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_hash.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_hash.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_hash.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,186 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream hash balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_hash/)->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream hash {
+        hash $remote_addr;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cons {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream empty {
+        hash $proxy_protocol_addr;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cempty {
+        hash $proxy_protocol_addr consistent;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  hash;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  cons;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  empty;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  cempty;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8082));
+$t->run_daemon(\&stream_daemon, port(8083));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8083));
+
+###############################################################################
+
+my @ports = my ($port2, $port3) = (port(8082), port(8083));
+
+is(many(10, port(8080)), "$port3: 10", 'hash');
+like(many(10, port(8081)), qr/($port2|$port3): 10/, 'hash consistent');
+
+# fallback to round-robin
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.1');
+
+like(many(4, port(8084)), qr/$port2: 2, $port3: 2/, 'empty key');
+like(many(4, port(8085)), qr/$port2: 2, $port3: 2/, 'empty key - consistent');
+
+}
+
+###############################################################################
+
+sub many {
+    my ($count, $port) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (stream("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    $buffer = $client->sockport();
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return 1;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_least_conn.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_least_conn.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_least_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_least_conn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,159 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream least_conn balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u {
+        least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8081));
+$t->run_daemon(\&stream_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many(10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+for (1 .. 2) {
+    my $s = stream('127.0.0.1:' . port(8080));
+    $s->write('w');
+    push @sockets, $s;
+}
+
+select undef, undef, undef, 0.2;
+
+is(many(10), "$port2: 10", 'least_conn');
+
+###############################################################################
+
+sub many {
+    my ($count) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (stream('127.0.0.1:' . port(8080))->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    my $port = $client->sockport();
+
+    if ($buffer =~ /w/ && $port == port(8081)) {
+        Test::Nginx::log_core('||', "$port: sleep(2.5)");
+        select undef, undef, undef, 2.5;
+    }
+
+    $buffer = $port;
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return 1;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_max_conns.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_max_conns.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_max_conns.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_max_conns.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,408 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+# (C) Sergey Kandaurov
+
+# Tests for stream upstream module with max_conns feature.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_upstream_least_conn/)
+    ->has(qw/stream_upstream_hash/)->plan(14);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u_unlim {
+        server 127.0.0.1:8081 max_conns=0;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lim {
+        server 127.0.0.1:8081 max_conns=3;
+    }
+
+    upstream u_backup {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_backup_lim {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_two {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+    upstream u_some {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_many {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_weight {
+        server 127.0.0.1:8081 weight=2 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_lc {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lc_backup {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_lc_backup_lim {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_hash {
+        hash $remote_addr;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+    upstream u_chash {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  u_unlim;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  u_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  u_backup;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  u_backup_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        proxy_pass  u_two;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  u_some;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  u_many;
+    }
+
+    server {
+        listen      127.0.0.1:8093;
+        proxy_pass  u_weight;
+    }
+
+    server {
+        listen      127.0.0.1:8094;
+        proxy_pass  u_lc;
+    }
+
+    server {
+        listen      127.0.0.1:8095;
+        proxy_pass  u_lc_backup;
+    }
+
+    server {
+        listen      127.0.0.1:8096;
+        proxy_pass  u_lc_backup_lim;
+    }
+
+    server {
+        listen      127.0.0.1:8097;
+        proxy_pass  u_hash;
+    }
+
+    server {
+        listen      127.0.0.1:8098;
+        proxy_pass  u_chash;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081), port(8082), port(8085));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+# two peers without max_conns
+
+is(parallel(8086, '/u_unlim?delay=0', 4), "$p1: 2, $p2: 2", 'unlimited');
+
+# reopen connection to test connection subtraction
+
+my @s = http_get_multi(8087, '/u_lim', 2, 1.1);
+get(8087, '/close');
+push @s, http_get_multi(8087, '/u_lim', 1, 1.1);
+get(8085, '/closeall');
+
+is(http_end_multi(\@s), "$p1: 3", 'conn subtraction');
+
+# simple test with limited peer
+
+is(parallel(8087, '/u_lim', 4), "$p1: 3", 'single');
+
+# limited peer with backup peer
+
+is(peers(8088, '/u_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'backup');
+
+# peer and backup peer, both limited
+
+is(peers(8089, '/u_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ", 'backup limited');
+
+# all peers limited
+
+is(parallel(8090, '/u_two', 4), "$p1: 1, $p2: 1", 'all peers');
+
+# subset of peers limited
+
+is(parallel(8091, '/u_some', 4), "$p1: 1, $p2: 3", 'some peers');
+
+# ensure that peer "weight" does not affect its max_conns limit
+
+is(parallel(8093, '/u_weight', 4), "$p1: 1, $p2: 3", 'weight');
+
+# peers with equal server value aggregate max_conns limit
+
+is(parallel(8092, '/u_many', 6), "$p1: 2, $p2: 4", 'equal peer');
+
+# least_conn balancer tests
+
+is(parallel(8094, '/u_lc', 4), "$p1: 1, $p2: 3", 'least_conn');
+is(peers(8095, '/u_lc_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2",
+    'least_conn backup');
+is(peers(8096, '/u_lc_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ",
+    'least_conn backup limited');
+
+# hash balancer tests
+
+is(parallel(8097, '/u_hash', 4), "$p1: 1, $p2: 2", 'hash');
+is(parallel(8098, '/u_chash', 4), "$p1: 1, $p2: 2", 'hash consistent');
+
+###############################################################################
+
+sub peers {
+    my ($port, $uri, $count) = @_;
+
+    my @sockets = http_get_multi($port, $uri, $count, 1.1);
+    get(8085, '/closeall');
+
+    join ' ', map { defined $_ && /X-Port: (\d+)/ && $1 }
+        map { http_end $_ } (@sockets);
+}
+
+sub parallel {
+    my ($port, $uri, $count) = @_;
+
+    my @sockets = http_get_multi($port, $uri, $count);
+    for (1 .. 20) {
+        last if IO::Select->new(@sockets)->can_read(3) == $count;
+        select undef, undef, undef, 0.01;
+    }
+    get(8085, '/closeall');
+    return http_end_multi(\@sockets);
+}
+
+sub get {
+    my ($port, $uri, %opts) = @_;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1',
+        PeerPort => port($port),
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    http_get($uri, socket => $s, %opts);
+}
+
+sub http_get_multi {
+    my ($port, $uri, $count, $wait) = @_;
+    my @sockets;
+
+    for (0 .. $count - 1) {
+        $sockets[$_] = get($port, $uri, start => 1);
+        IO::Select->new($sockets[$_])->can_read($wait) if $wait;
+    }
+
+    return @sockets;
+}
+
+sub http_end_multi {
+    my ($sockets) = @_;
+    my %ports;
+
+    for my $sock (@$sockets) {
+        my $r = http_end($sock);
+        if ($r && $r =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+        close $sock;
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my (@ports) = @_;
+    my (@socks, @clients);
+
+    for my $port (@ports) {
+        my $server = IO::Socket::INET->new(
+            Proto => 'tcp',
+            LocalHost => "127.0.0.1:$port",
+            Listen => 42,
+            Reuse => 1
+        )
+            or die "Can't create listening socket: $!\n";
+        push @socks, $server;
+    }
+
+    my $sel = IO::Select->new(@socks);
+    my $skip = 4;
+    my $count = 0;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+OUTER:
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if (grep $_ == $fh, @socks) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+                $count++;
+
+            } else {
+                my @busy = grep { $_->sockport() } @ready;
+
+                # finish other handles
+                if ($fh->sockport() == port(8085) && @busy > 1
+                    && grep $_->sockport() != port(8085),
+                    @busy)
+                {
+                    next;
+                }
+
+                # late events in other handles
+                if ($fh->sockport() == port(8085) && @busy == 1
+                    && $count > 1 && $skip-- > 0)
+                {
+                    select undef, undef, undef, 0.1;
+                    next OUTER;
+                }
+
+                my $rv = process_socket($fh, \@clients);
+                if ($rv == 1) {
+                    $sel->remove($fh);
+                    $fh->close;
+                }
+                if ($rv == 2) {
+                    for (@clients) {
+                        $sel->remove($_);
+                        $_->close;
+                    }
+                    $sel->remove($fh);
+                    $fh->close;
+                    $skip = 4;
+                }
+                $count--;
+            }
+        }
+    }
+}
+
+# Returns true to close connection
+
+sub process_socket {
+    my ($client, $saved) = @_;
+    my $port = $client->sockport();
+
+    my $headers = '';
+    my $uri = '';
+
+    while (<$client>) {
+        $headers .= $_;
+        last if (/^\x0d?\x0a?$/);
+    }
+    return 1 if $headers eq '';
+
+    $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+    return 1 if $uri eq '';
+
+    Test::Nginx::log_core('||', "$port: response, 200");
+    print $client <<EOF;
+HTTP/1.1 200 OK
+X-Port: $port
+
+OK
+EOF
+
+    return 2 if $uri =~ /closeall/;
+    return 1 if $uri =~ /close/;
+
+    push @$saved, $client;
+    return 0;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_random.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_random.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_random.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_random.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,313 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream random balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()
+    ->has(qw/stream stream_upstream_zone stream_upstream_random/)->plan(12)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_processes 2;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    upstream u {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream lc {
+        zone lc 1m;
+        random two;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream w {
+        zone w 1m;
+        random two least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 weight=2;
+    }
+
+    upstream mc {
+        zone mc 1m;
+        random;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream mc2 {
+        zone mc 1m;
+        random two;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream one {
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream two {
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream zone {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream ztwo {
+        zone z 1m;
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream fail {
+        zone fail 1m;
+        random;
+        server 127.0.0.1:8096;
+        server 127.0.0.1:8083 down;
+        server 127.0.0.1:8082;
+    }
+
+    upstream fail2 {
+        zone fail2 1m;
+        random two;
+        server 127.0.0.1:8096;
+        server 127.0.0.1:8083 down;
+        server 127.0.0.1:8082;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  lc;
+    }
+
+    server {
+        listen      127.0.0.1:8084;
+        proxy_pass  w;
+    }
+
+    server {
+        listen      127.0.0.1:8085;
+        proxy_pass  mc;
+    }
+
+    server {
+        listen      127.0.0.1:8086;
+        proxy_pass  mc2;
+    }
+
+    server {
+        listen      127.0.0.1:8087;
+        proxy_pass  one;
+    }
+
+    server {
+        listen      127.0.0.1:8088;
+        proxy_pass  two;
+    }
+
+    server {
+        listen      127.0.0.1:8089;
+        proxy_pass  zone;
+    }
+
+    server {
+        listen      127.0.0.1:8090;
+        proxy_pass  ztwo;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  fail;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  fail2;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+like(get(8080, '/'), qr/X-Port: ($port1|$port2)/, 'random');
+like(get(8083, '/'), qr/X-Port: ($port1|$port2)/, 'random two');
+
+my $s = get(8083, '/w', start => 1, sleep => 0.5);
+my $r = get(8083, '/');
+my ($p) = http_end($s) =~ /X-Port: (\d+)/;
+like($r, qr/X-Port: (?!$p)/, 'random wait');
+
+SKIP: {
+skip 'long test', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+is(parallel(8084, '/w', 3), "$port1: 1, $port2: 2", 'random weight');
+
+is(parallel(8085, '/w', 4), "$port1: 2, $port2: 1", 'max_conns');
+is(parallel(8086, '/w', 4), "$port1: 2, $port2: 1", 'max_conns two');
+
+}
+
+# single variants
+
+like(get(8087, '/'), qr/X-Port: $port1/, 'single one');
+like(get(8088, '/'), qr/X-Port: $port1/, 'single two');
+like(get(8089, '/'), qr/X-Port: $port1/, 'zone one');
+like(get(8090, '/'), qr/X-Port: $port1/, 'zone two');
+
+like(many(8091, '/', 10), qr/$port2: 10/, 'failures');
+like(many(8092, '/', 10), qr/$port2: 10/, 'failures two');
+
+###############################################################################
+
+sub get {
+    my ($port, $uri, %opts) = @_;
+    my $s = IO::Socket::INET->new(
+        Proto => 'tcp',
+        PeerAddr => '127.0.0.1',
+        PeerPort => port($port),
+    )
+        or die "Can't connect to nginx: $!\n";
+
+    http_get($uri, socket => $s, %opts);
+}
+
+sub many {
+    my ($port, $uri, $count, %opts) = @_;
+    my %ports;
+
+    for (1 .. $count) {
+        if (get($port, $uri) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+
+        select undef, undef, undef, $opts{delay} if $opts{delay};
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+    my ($port, $uri, $n) = @_;
+    my %ports;
+
+    my @s = map { get($port, $uri, start => 1, sleep => 0.1) } (1 .. $n);
+
+    for (@s) {
+            my $r = http_end($_);
+            if ($r && $r =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/w') {
+            Test::Nginx::log_core('||', "$port: sleep(2.5)");
+            select undef, undef, undef, 2.5;
+        }
+
+        if ($uri eq '/close' && $port == port(8081)) {
+            next;
+        }
+
+        Test::Nginx::log_core('||', "$port: response, 200");
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,215 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream module and balancers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format bytes $upstream_addr!
+                     $upstream_bytes_sent!$upstream_bytes_received;
+
+    upstream u {
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8086 down;
+        server 127.0.0.1:8086;
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085;
+    }
+
+    upstream u3 {
+        server 127.0.0.1:8084;
+        server 127.0.0.1:8085 weight=2;
+    }
+
+    upstream u4 {
+        server 127.0.0.1:8086 fail_timeout=1s;
+        server 127.0.0.1:8084 backup;
+    }
+
+    proxy_connect_timeout 2;
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u3;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  u4;
+        access_log  %%TESTDIR%%/u.log bytes;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&stream_daemon, port(8084));
+$t->run_daemon(\&stream_daemon, port(8085));
+$t->run()->plan(6);
+
+$t->waitforsocket('127.0.0.1:' . port(8084));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($port4, $port5, $port6) = (port(8084), port(8085), port(8086));
+
+is(many(30, port(8080)), "$port4: 15, $port5: 15", 'balanced');
+is(many(30, port(8081)), "$port4: 15, $port5: 15", 'failures');
+is(many(30, port(8082)), "$port4: 10, $port5: 20", 'weight');
+is(many(30, port(8083)), "$port4: 30", 'backup');
+
+$t->run_daemon(\&stream_daemon, port(8086));
+$t->waitforsocket('127.0.0.1:' . port(8086));
+
+sleep 2;    # wait till fail_timeout passes
+is(parallel(30, port(8083)), "$port6: 30", 'recovery');
+
+$t->stop();
+
+like($t->read_file('u.log'), qr/127.0.0.1:$port6, 127.0.0.1:$port4!0, 1!0, 4/,
+    'per-upstream variables');
+
+###############################################################################
+
+sub many {
+    my ($count, $port) = @_;
+    my (%ports);
+
+    for (1 .. $count) {
+        if (stream("127.0.0.1:$port")->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+    my ($count, $port) = @_;
+    my (%ports, @s);
+
+    for (1 .. $count) {
+        my $s = stream("127.0.0.1:$port");
+        $s->write('keep');
+        $s->read();
+        push @s, $s;
+    }
+
+    for (1 .. $count) {
+        if ((pop @s)->io('.') =~ /(\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub stream_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    my $sel = IO::Select->new($server);
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if ($server == $fh) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+
+            } elsif (stream_handle_client($fh)) {
+                $sel->remove($fh);
+                $fh->close;
+            }
+        }
+    }
+}
+
+sub stream_handle_client {
+    my ($client) = @_;
+
+    log2c("(new connection $client)");
+
+    $client->sysread(my $buffer, 65536) or return 1;
+
+    log2i("$client $buffer");
+
+    my $close = $buffer ne 'keep';
+    $buffer = $client->sockport();
+
+    log2o("$client $buffer");
+
+    $client->syswrite($buffer);
+
+    return $close;
+}
+
+sub log2i { Test::Nginx::log_core('|| <<', @_); }
+sub log2o { Test::Nginx::log_core('|| >>', @_); }
+sub log2c { Test::Nginx::log_core('||', @_); }
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_zone_ssl.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_zone_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_zone_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_zone_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,126 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream zone with ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_ssl stream_return/)
+    ->has(qw/stream_upstream_zone/)->has_daemon('openssl')->plan(9);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    proxy_ssl on;
+    proxy_ssl_session_reuse on;
+    %%PROXY_ASYNCH_ENABLE%%
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8084;
+    }
+
+    upstream u2 {
+        zone u2 1m;
+        server 127.0.0.1:8084 backup;
+        server 127.0.0.1:8085 down;
+    }
+
+    server {
+        listen      127.0.0.1:8080;
+        proxy_pass  u;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        proxy_pass  u;
+    }
+
+    server {
+        listen      127.0.0.1:8082;
+        proxy_pass  u2;
+        proxy_ssl_session_reuse off;
+    }
+
+    server {
+        listen      127.0.0.1:8083;
+        proxy_pass  u2;
+    }
+
+    server {
+        listen      127.0.0.1:8084 ssl;
+        %%TEST_NGINX_GLOBALS_HTTPS%%
+        return      $ssl_session_reused;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+is(stream('127.0.0.1:' . port(8080))->read(), '.', 'ssl');
+is(stream('127.0.0.1:' . port(8080))->read(), '.', 'ssl 2');
+
+is(stream('127.0.0.1:' . port(8081))->read(), '.', 'ssl session new');
+is(stream('127.0.0.1:' . port(8081))->read(), 'r', 'ssl session reused');
+is(stream('127.0.0.1:' . port(8081))->read(), 'r', 'ssl session reused 2');
+
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'backup ssl');
+is(stream('127.0.0.1:' . port(8082))->read(), '.', 'backup ssl 2');
+
+is(stream('127.0.0.1:' . port(8083))->read(), '.', 'backup ssl session new');
+is(stream('127.0.0.1:' . port(8083))->read(), 'r', 'backup ssl session reused');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_upstream_zone.t ../asynch_mode_nginx/test/nginx-tests/stream_upstream_zone.t
--- nginx-release-1.20.1/test/nginx-tests/stream_upstream_zone.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_upstream_zone.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,90 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Stream tests for upstream zone.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return stream_upstream_zone/)
+    ->plan(2)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    log_format test $upstream_addr;
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 down;
+        server 127.0.0.1:8081 backup down;
+    }
+
+    server {
+        listen      127.0.0.1:8081;
+        return      OK;
+    }
+
+    server {
+        listen      127.0.0.1:8091;
+        proxy_pass  u;
+
+        access_log %%TESTDIR%%/access1.log test;
+    }
+
+    server {
+        listen      127.0.0.1:8092;
+        proxy_pass  u2;
+
+        access_log %%TESTDIR%%/access2.log test;
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+
+stream('127.0.0.1:' . port(8091))->read();
+stream("127.0.0.1:" . port(8092))->read();
+
+$t->stop();
+
+is($t->read_file('access1.log'), "127.0.0.1:$p\n", 'upstream name');
+is($t->read_file('access2.log'), "u2\n", 'no live upstreams');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stream_variables.t ../asynch_mode_nginx/test/nginx-tests/stream_variables.t
--- nginx-release-1.20.1/test/nginx-tests/stream_variables.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stream_variables.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,112 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for stream variables.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Sys::Hostname;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::Stream qw/ stream dgram /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/stream stream_return udp/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen  127.0.0.1:8080;
+        return  $connection:$nginx_version:$hostname:$pid:$bytes_sent;
+    }
+
+    server {
+        listen  127.0.0.1:8081;
+        listen  [::1]:%%PORT_8081%%;
+        return  $remote_addr:$remote_port:$server_addr:$server_port;
+    }
+
+    server {
+        listen  127.0.0.1:8082;
+        proxy_pass  [::1]:%%PORT_8081%%;
+    }
+
+    server {
+        listen  127.0.0.1:8083;
+        listen  [::1]:%%PORT_8083%%;
+        return  $binary_remote_addr;
+    }
+
+    server {
+        listen  127.0.0.1:8084;
+        proxy_pass  [::1]:%%PORT_8083%%;
+    }
+
+    server {
+        listen  127.0.0.1:8085;
+        return  $msec!$time_local!$time_iso8601;
+    }
+
+    server {
+        listen  127.0.0.1:8086;
+        listen  127.0.0.1:%%PORT_8987_UDP%% udp;
+        return  $protocol;
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support')->plan(8);
+
+###############################################################################
+
+my $hostname = lc hostname();
+like(stream('127.0.0.1:' . port(8080))->read(),
+    qr/^\d+:[\d.]+:$hostname:\d+:0$/, 'vars');
+
+my $dport = port(8081);
+my $s = stream("127.0.0.1:$dport");
+my $lport = $s->sockport();
+is($s->read(), "127.0.0.1:$lport:127.0.0.1:$dport", 'addr');
+
+my $data = stream('127.0.0.1:' . port(8082))->read();
+like($data, qr/^::1:\d+:::1:\d+$/, 'addr ipv6');
+
+$data = stream('127.0.0.1:' . port(8083))->read();
+is(unpack("H*", $data), '7f000001', 'binary addr');
+
+$data = stream('127.0.0.1:' . port(8084))->read();
+is(unpack("H*", $data), '0' x 31 . '1', 'binary addr ipv6');
+
+$data = stream('127.0.0.1:' . port(8085))->read();
+like($data, qr#^\d+.\d+![-+\w/: ]+![-+\dT:]+$#, 'time');
+
+is(stream('127.0.0.1:' . port(8086))->read(), 'TCP', 'protocol TCP');
+is(dgram('127.0.0.1:' . port(8987))->io('.'), 'UDP', 'protocol UDP');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/stub_status.t ../asynch_mode_nginx/test/nginx-tests/stub_status.t
--- nginx-release-1.20.1/test/nginx-tests/stub_status.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/stub_status.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,188 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for stub status module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http stub_status/)->plan(34);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Active $connections_active;
+        add_header X-Reading $connections_reading;
+        add_header X-Writing $connections_writing;
+        add_header X-Waiting $connections_waiting;
+
+        location / { }
+        location /rate {
+            limit_rate 15;
+        }
+        location /stub {
+            stub_status;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my %status = status('/stub');
+like(http_get('/stub'), qr/200 OK/, 'get request');
+is($status{'active'}, 1, 'open connection');
+is($status{'requests'}, 1, 'first request');
+is($status{'accepts'}, 1, 'first request accepted');
+is($status{'handled'}, 1, 'first request handled');
+is($status{'writing'}, 1, 'first response');
+is($status{'reading'}, 0, 'not reading');
+
+# pipelined requests
+
+http(<<EOF);
+GET / HTTP/1.1
+Host: localhost
+
+GET / HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+
+%status = status('/stub');
+is($status{'requests'}, 5, 'requests increased by 2');
+is($status{'accepts'}, 4, 'accepts increased by 1');
+
+# states
+
+my $s = http('', start => 1);
+
+%status = status('/stub');
+is($status{'active'}, 2, 'active');
+is($status{'waiting'}, 1, 'waiting state');
+is($status{'reading'}, 0, 'waiting state - not reading');
+is($status{'writing'}, 1, 'waiting state - not writing');
+
+http(<<EOF, start => 1, socket => $s, sleep => 0.2);
+GET /rate HTTP/1.0
+EOF
+
+%status = status('/stub');
+is($status{'waiting'}, 0, 'reading state - not waiting');
+is($status{'reading'}, 1, 'reading state');
+is($status{'writing'}, 1, 'reading state - not writing');
+
+http(<<EOF, start => 1, socket => $s, sleep => 0.2);
+Host: localhost
+
+EOF
+
+%status = status('/stub');
+is($status{'waiting'}, 0, 'writing state - not waiting');
+is($status{'reading'}, 0, 'writing state - not reading');
+is($status{'writing'}, 2, 'writing state');
+
+$s->close();
+
+# head and post requests
+
+like(http_head('/stub'), qr/200 OK/, 'head request');
+like(http_post('/stub'), qr/405 Not Allowed/, 'post request');
+
+# embedded variables in headers
+
+my $r = http_get('/stub');
+like($r, qr/X-Active: 1/, 'get - var active');
+like($r, qr/X-Reading: 0/, 'get - var reading');
+like($r, qr/X-Writing: 1/, 'get - var writing');
+like($r, qr/X-Waiting: 0/, 'get - var waiting');
+
+$r = http_head('/stub');
+like($r, qr/X-Active: 1/, 'head - var active');
+like($r, qr/X-Reading: 0/, 'head - var reading');
+like($r, qr/X-Writing: 1/, 'head - var writing');
+like($r, qr/X-Waiting: 0/, 'head - var waiting');
+is(get_body($r), '', 'head - empty body');
+
+$r = http_get('/');
+like($r, qr/X-Active: 1/, 'no stub - var active');
+like($r, qr/X-Reading: 0/, 'no stub - var reading');
+like($r, qr/X-Writing: 1/, 'no stub - var writing');
+like($r, qr/X-Waiting: 0/, 'no stub - var waiting');
+
+###############################################################################
+
+sub get_body {
+    my ($r) = @_;
+    $r =~ /.*?\x0d\x0a?\x0d\x0a?(.*)/ms;
+    return $1;
+}
+
+sub http_post {
+    my ($url) = @_;
+    return http(<<EOF);
+POST $url HTTP/1.0
+Host: localhost
+
+EOF
+}
+
+sub status {
+    my ($url) = @_;
+    my $r = http_get($url);
+
+    $r =~ /
+        Active\ connections:\ +(\d+)
+        \s+server\ accepts\ handled\ requests
+        \s+(\d+)\ +(\d+)\ +(\d+)
+        \s+Reading:\ +(\d+)
+        \s+Writing:\ +(\d+)
+        \s+Waiting:\ +(\d+)
+    /sx;
+
+    return ('active' => $1,
+        'accepts' => $2,
+        'handled' => $3,
+        'requests' => $4,
+        'reading' => $5,
+        'writing' => $6,
+        'waiting' => $7,
+    );
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_buffering.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_buffering.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_buffering.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_buffering.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,104 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for sub_filter buffering.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub proxy/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_buffering off;
+        proxy_http_version 1.1;
+
+        sub_filter_types *;
+
+        location /partial {
+            proxy_pass http://127.0.0.1:8081;
+            sub_filter za ZA;
+        }
+
+        location /negative {
+            proxy_pass http://127.0.0.1:8081;
+            sub_filter ab AB;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+# partial match: the last byte matching pattern is buffered
+
+like(http_get('/partial'), qr/xy$/, 'partial match');
+
+# no partial match: an entire buffer is sent as is without buffering
+
+like(http_get('/negative'), qr/xyz/, 'negative match');
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) {
+            last if /^\x0d?\x0a?$/;
+        }
+
+        print $client
+            "HTTP/1.1 200 OK" . CRLF .
+            "Content-Length: 10" . CRLF . CRLF .
+            "xyz";
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_merge.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_merge.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_merge.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_merge.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,59 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Test for sub_filter inheritance from http context.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub/);
+
+$t->plan(1)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    sub_filter foo bar;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('foo.html', 'foo');
+$t->run();
+
+###############################################################################
+
+like(http_get('/foo.html'), qr/bar/, 'sub_filter inheritance');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_multi2.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_multi2.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_multi2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_multi2.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,83 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for sub filter with variables in search patterns.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub/)->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+
+        location /var/replacement {
+            sub_filter_once off;
+            sub_filter '${arg_a}' '${arg_a}+';
+            sub_filter '${arg_b}' '${arg_b}-';
+            return 200 $arg_c;
+        }
+
+        location /var/replacement2 {
+            sub_filter_once off;
+            sub_filter '${arg_a}A${arg_b}'  +;
+            sub_filter '${arg_c}AA${arg_d}' -;
+            return 200 $arg_e;
+        }
+    }
+
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/var/replacement?a=a&b=b&c=abXYaXbZ'),
+    qr/a\+b-XYa\+Xb-Z/, 'complex');
+like(http_get('/var/replacement?a=patt&b=abyz&c=pattabyzXYpattXabyzZpatt'),
+    qr/patt\+abyz-XYpatt\+Xabyz-Zpatt\+/, 'complex 2');
+like(http_get('/var/replacement?a=a&b=b&c=ABXYAXBZ'),
+    qr/a\+b-XYa\+Xb-Z/, 'case insensivity');
+like(http_get('/var/replacement?b=b&c=abXYaXbZ'),
+    qr/ab-XYaXb-Z/, 'one search string is empty');
+like(http_get('/var/replacement?c=abXYaXbZ'),
+    qr/abXYaXbZ/, 'all search strings are empty');
+like(http_get('/var/replacement2?a=aaa&b=bbb&c=yy&d=zz&e=AaaaAbbbZyyAAzzY'),
+    qr/A\+Z-Y/, 'multiple variables');
+like(http_get('/var/replacement2?b=bbb&c=yy&e=AAbbbZyyAAY'),
+    qr/A\+Z-Y/, 'multiple variables 2');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_multi.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_multi.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_multi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_multi.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,381 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Dmitry Volyntsev
+# (C) Nginx, Inc.
+
+# Tests for multiple patterns in sub filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub proxy/)->plan(42);
+
+my $long_pattern = '0123456789abcdef' x 17;
+
+(my $conf = <<'EOF') =~ s/%%LONG_PATTERN%%/$long_pattern/g;
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foo bar;
+
+        location /multi {
+            sub_filter_once off;
+            sub_filter aab +;
+            sub_filter yyz -;
+            return 200 $arg_a;
+        }
+
+        location /multi2 {
+            sub_filter_once off;
+            sub_filter aabb  +;
+            sub_filter aaabb -;
+            return 200 $arg_a;
+        }
+
+        location /multi3 {
+            sub_filter_once off;
+            sub_filter aacbb +;
+            sub_filter aadbb -;
+            return 200 $arg_a;
+        }
+
+        location /case {
+            sub_filter_once off;
+            sub_filter AAB +;
+            sub_filter YYZ -;
+            return 200 $arg_a;
+        }
+
+        location /case2 {
+            sub_filter_once off;
+            sub_filter ABCDEFGHIJKLMNOPQRSTUVWXYZ +;
+            return 200 $arg_a;
+        }
+
+        location /case3 {
+            sub_filter_once off;
+            sub_filter abcdefghijklmnopqrstuvwxyz +;
+            return 200 $arg_a;
+        }
+
+        location /minimal {
+            sub_filter_once off;
+            sub_filter ab +;
+            sub_filter cd -;
+            sub_filter ef *;
+            sub_filter gh !;
+            sub_filter x  _;
+            return 200 $arg_a;
+        }
+
+        location /once {
+            sub_filter aab +;
+            sub_filter yyz -;
+            return 200 $arg_a;
+        }
+
+        location /table/inheritance {
+            sub_filter_once off;
+            return 200 $arg_a;
+        }
+
+        location /utf8 {
+            sub_filter_once off;
+            sub_filter 模様 замена1;
+            sub_filter पैटर्न замена2;
+            sub_filter паттерн replaced;
+            return 200 $arg_a;
+        }
+
+        location /var/replacement/multi {
+            sub_filter_once off;
+            sub_filter aab '${arg_a}_replaced';
+            sub_filter yyz '${arg_b}_replaced';
+            return 200 $arg_c;
+        }
+
+        location /crossbuf/match1 {
+            sub_filter_once off;
+            sub_filter abpattyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match2 {
+            sub_filter_once off;
+            sub_filter abpattrnyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match3 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match4 {
+            sub_filter_once off;
+            sub_filter abpattternyz +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match5-01 {
+            sub_filter_once off;
+            sub_filter abyz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match5-02 {
+            sub_filter_once off;
+            sub_filter abpayz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/match6 {
+            sub_filter_once off;
+            sub_filter abpattxernyz +;
+            sub_filter abpattternyz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match1 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match2 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter yz -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match3 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter 01ef -;
+            alias %%TESTDIR%%/;
+        }
+
+        location /crossbuf/superlong/match4 {
+            sub_filter_once off;
+            sub_filter %%LONG_PATTERN%% +;
+            sub_filter 01ef -;
+            sub_filter _ *;
+            alias %%TESTDIR%%/;
+        }
+
+        location /shortbuf/match1 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match2 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpaernyz -;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match3 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpaernyz -;
+            sub_filter _ *;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match4 {
+            sub_filter_once off;
+            sub_filter patt +;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+
+        location /shortbuf/match5 {
+            sub_filter_once off;
+            sub_filter abpatternyz +;
+            sub_filter abpa -;
+            sub_filter tter *;
+
+            proxy_pass http://127.0.0.1:8081/;
+            proxy_buffering off;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+
+        limit_rate 4;
+        limit_rate_after 160;
+
+        location / {
+            return 200 $arg_a;
+        }
+    }
+}
+
+EOF
+
+$t->write_file_expand('nginx.conf', $conf);
+
+$t->write_file('huge1.html', 'abpattyz' x 6000);
+$t->write_file('huge2.html', 'abpattrnyz' x 5000);
+$t->write_file('huge3.html', 'abpatternyz' x 4000);
+$t->write_file('huge4.html', 'abpattternyz' x 4000);
+
+$t->write_file('huge5-01.html', 'abpatternyzA' x 4000);
+$t->write_file('huge5-02.html', 'abpatternyzABCDEFGHIJ' x 4000);
+$t->write_file('huge5-03.html', 'abpatternyzABCDEFGHIJK' x 4000);
+$t->write_file('huge5-04.html', 'abpatternyzABCDEFGHIJKL' x 4000);
+
+$t->write_file('huge6-01.html', 'abyzAabpattternyz' x 3000);
+$t->write_file('huge6-02.html', 'abpayzAabpattternyz' x 3000);
+
+$t->write_file('huge7-01.html', 'abpattxernyzabpattternyz' x 3000);
+$t->write_file('huge7-02.html', 'abpattxernyzAabpattternyz' x 3000);
+$t->write_file('huge7-03.html', 'abpattxernyzABCDEFGHIJabpattternyz' x 3000);
+$t->write_file('huge7-04.html', 'abpattxernyzABCDEFGHIJKabpattternyz' x 3000);
+$t->write_file('huge7-05.html', 'abpattxernyzABCDEFGHIJKLabpattternyz' x 3000);
+
+$t->write_file('huge8.html', scalar ('ABC' . $long_pattern . 'XYZ') x 1000);
+$t->write_file('huge9.html', scalar ('ABC' . $long_pattern . 'yz') x 1000);
+$t->write_file('huge10-01.html', scalar ($long_pattern . 'ABC01ef') x 1000);
+$t->write_file('huge10-02.html', scalar ('01efABC' . $long_pattern) x 1000);
+$t->write_file('huge11.html', scalar ('01efA_Z' . $long_pattern) x 1000);
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/multi?a=aabAyyzBaab'), qr/\+A-B\+/, 'simple match');
+like(http_get('/multi2?a=aabbaaabbaabb'), qr/\+-\+/, 'partial match');
+like(http_get('/multi3?a=aadbbaacbb'), qr/-\+/, 'exact match');
+
+like(http_get('/multi?a=AABYYZAAB'), qr/\+-\+/, 'case insensivity 1');
+like(http_get('/case?a=aabyyzaab'), qr/\+-\+/, 'case insensivity 2');
+like(http_get('/case2?a=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
+    qr/\+\+/, 'case insensivity 3');
+like(http_get('/case3?a=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),
+    qr/\+\+/, 'case insensivity 4');
+
+like(http_get('/minimal?a=AAabcdefghBxBabCxCcdDDefEEghFF'),
+    qr/AA\+-\*!B_B\+C_C-DD\*EE!FF/, 'minimal match');
+
+like(http_get('/utf8?a=ТЕКСТ模様ТЕКСТ2पैटर्नТЕКСТ3паттерн'),
+    qr/ТЕКСТзамена1ТЕКСТ2замена2ТЕКСТ3replaced/, 'utf8 match');
+
+like(http_get('/once?a=aabyyzaab'), qr/\+-aab/, 'once 1');
+like(http_get('/once?a=yyzaabyyz'), qr/-\+yyz/, 'once 2');
+like(http_get('/once?a=yyzyyzaabaabyyz'), qr/-yyz\+aabyyz/, 'once 3');
+
+like(http_get('/table/inheritance?a=foofoo'), qr/barbar/, 'table inheritance');
+
+like(http_get('/var/replacement/multi?a=A&b=B&c=aabyyzaab'),
+    qr/A_replacedB_replacedA_replaced/, 'complex multiple replace');
+
+like(http_get('/crossbuf/match1/huge1.html'), qr/\+{6000}/,
+    'crossbuf match 1 (simple match len 8)');
+like(http_get('/crossbuf/match2/huge2.html'), qr/\+{5000}/,
+    'crossbuf match 2 (simple match len 9)');
+like(http_get('/crossbuf/match3/huge3.html'), qr/\+{4000}/,
+    'crossbuf match 3 (simple match len 10)');
+like(http_get('/crossbuf/match4/huge4.html'), qr/\+{4000}/,
+    'crossbuf match 4 (simple match len 11)');
+
+like(http_get('/crossbuf/match3/huge5-01.html'), qr/(\+A){4000}/,
+    'crossbuf match 5.1');
+like(http_get('/crossbuf/match3/huge5-02.html'), qr/(\+ABCDEFGHIJ){4000}/,
+    'crossbuf match 5.2');
+like(http_get('/crossbuf/match3/huge5-03.html'), qr/(\+ABCDEFGHIJK){4000}/,
+    'crossbuf match 5.3');
+like(http_get('/crossbuf/match3/huge5-04.html'), qr/(\+ABCDEFGHIJKL){4000}/,
+    'crossbuf match 5.4');
+
+like(http_get('/crossbuf/match5-01/huge6-01.html'), qr/(\+A-){3000}/,
+    'crossbuf match 6.1 (multiple replace)');
+like(http_get('/crossbuf/match5-02/huge6-02.html'), qr/(\+A-){3000}/,
+    'crossbuf match 6.2 (multiple replace)');
+
+like(http_get('/crossbuf/match6/huge7-01.html'), qr/(\+-){3000}/,
+    'crossbuf match 7.1 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-02.html'), qr/(\+A-){3000}/,
+    'crossbuf match 7.2 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-03.html'), qr/(\+ABCDEFGHIJ-){3000}/,
+    'crossbuf match 7.3 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-04.html'), qr/(\+ABCDEFGHIJK-){3000}/,
+    'crossbuf match 7.4 (multiple replace)');
+like(http_get('/crossbuf/match6/huge7-05.html'), qr/(\+ABCDEFGHIJKL-){3000}/,
+    'crossbuf match 7.5 (multiple replace)');
+
+like(http_get('/crossbuf/superlong/match1/huge8.html'), qr/(ABC\+XYZ){1000}/,
+    'crossbuf superlong match 1');
+like(http_get('/crossbuf/superlong/match2/huge9.html'), qr/(ABC\+-){1000}/,
+    'crossbuf superlong match 2 (multiple replace)');
+like(http_get('/crossbuf/superlong/match3/huge10-01.html'), qr/(\+ABC-){1000}/,
+    'crossbuf superlong match 3.1 (multiple replace)');
+like(http_get('/crossbuf/superlong/match3/huge10-02.html'), qr/(-ABC\+){1000}/,
+    'crossbuf superlong match 3.2 (multiple replace)');
+like(http_get('/crossbuf/superlong/match4/huge11.html'), qr/(-A\*Z\+){1000}/,
+    'crossbuf superlong match 4 (1 byte search pattern)');
+
+SKIP: {
+skip 'long tests', 8 unless $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzA' x 3),
+    qr/(\+A){3}/, 'shortbuf match 1.1');
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzABCD' x 3),
+    qr/(\+ABCD){3}/, 'shortbuf match 1.2');
+like(http_get('/shortbuf/match1?a=' . 'abpatternyzABCDE' x 3),
+    qr/(\+ABCDE){3}/, 'shortbuf match 1.3');
+like(http_get('/shortbuf/match2?a=' . 'abpatternyzAabpaernyzB' x 2),
+    qr/(\+A-B){2}/, 'shortbuf match 2.1 (multiple replace)');
+like(http_get('/shortbuf/match2?a=' . 'abpatternyzAabpaernyz' x 2),
+    qr/(\+A-){2}/, 'shortbuf match 2.2 (multiple replace)');
+like(http_get('/shortbuf/match3?a=' . 'abpatternyzA_' x 3),
+    qr/(\+A\*){3}/, 'shortbuf match 3 (1 byte search pattern)');
+like(http_get('/shortbuf/match4?a=' . 'pattABCDEFGHI' x 3),
+    qr/(\+ABCDEFGHI){3}/, 'shortbuf match 4');
+like(http_get('/shortbuf/match5?a=abpatternyzABCDE' . 'abpatternyABCDE' x 2),
+    qr/\+ABCDE(-\*nyABCDE){2}/, 'shortbuf match 5');
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_perl.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_perl.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_perl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_perl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,124 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for sub filter, extended tests using embedded perl.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub perl/)->plan(22)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foobarbaz replaced;
+
+        location / {
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print("foo");
+                $r->flush();
+                $r->print("bar");
+                $r->flush();
+                $r->print("baz");
+                return OK;
+            }';
+        }
+
+        location /multi {
+            sub_filter aab _replaced;
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print($r->variable("arg_a"));
+                $r->print($r->variable("arg_b"));
+                return OK;
+            }';
+        }
+
+        location /short {
+            sub_filter ab _replaced;
+            perl 'sub {
+                my $r = shift;
+                $r->send_http_header("text/html");
+                return OK if $r->header_only;
+                $r->print($r->variable("arg_a"));
+                $r->print($r->variable("arg_b"));
+                return OK;
+            }';
+        }
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/flush'), qr/^replaced$/m, 'flush');
+
+like(http_get('/multi?a=a&b=ab'), qr/^_replaced$/m, 'aab in a + ab');
+like(http_get('/multi?a=a&b=aaab'), qr/^aa_replaced$/m, 'aab in a + aaab');
+like(http_get('/multi?a=a&b=aab'), qr/^a_replaced$/m, 'aab in a + aab');
+like(http_get('/multi?a=a&b=aaaab'), qr/^aaa_replaced$/m, 'aab in a + aaaab');
+like(http_get('/multi?a=aa&b=ab'), qr/^a_replaced$/m, 'aab in aa + ab');
+like(http_get('/multi?a=aa&b=aab'), qr/^aa_replaced$/m, 'aab in aa + aab');
+like(http_get('/multi?a=aa&b=aaab'), qr/^aaa_replaced$/m, 'aab in aa + aaab');
+like(http_get('/multi?a=aa&b=aaaab'), qr/^aaaa_replaced$/m, 'aab in aa + aaaab');
+
+# full backtracking
+
+like(http_get('/multi?a=aa&b=xaaab'), qr/^aaxa_replaced$/m, 'aab in aa + xaaab');
+like(http_get('/multi?a=aa&b=axaaab'), qr/^aaaxa_replaced$/m,
+    'aab in aa + axaaab');
+like(http_get('/multi?a=aa&b=aaxaaab'), qr/^aaaaxa_replaced$/m,
+    'aab in aa + aaxaaab');
+
+# short pattern
+
+like(http_get('/short?a=a&b=b'), qr/^_replaced$/m, 'ab in a + b');
+like(http_get('/short?a=a&b=ab'), qr/^a_replaced$/m, 'ab in a + ab');
+like(http_get('/short?a=a&b=aab'), qr/^aa_replaced$/m, 'ab in a + aab');
+like(http_get('/short?a=a&b=aaab'), qr/^aaa_replaced$/m, 'ab in a + aaab');
+like(http_get('/short?a=a&b=aaaab'), qr/^aaaa_replaced$/m, 'ab in a + aaaab');
+
+like(http_get('/short?a=aa&b=b'), qr/^a_replaced$/m, 'ab in aa + b');
+like(http_get('/short?a=aa&b=ab'), qr/^aa_replaced$/m, 'ab in aa + ab');
+like(http_get('/short?a=aa&b=aab'), qr/^aaa_replaced$/m, 'ab in aa + aab');
+like(http_get('/short?a=aa&b=aaab'), qr/^aaaa_replaced$/m, 'ab in aa + aaab');
+like(http_get('/short?a=aa&b=aaaab'), qr/^aaaaa_replaced$/m, 'ab in aa + aaaab');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_slice.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_slice.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_slice.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_slice.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,104 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for slice filter with sub filter.
+
+# A response is sent using chunked encoding.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_content /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy slice sub/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            sub_filter foo bar;
+            sub_filter_types *;
+
+            slice 2;
+
+            proxy_pass    http://127.0.0.1:8081/;
+
+            proxy_set_header   Range  $slice_range;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('t', '0123456789');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+# range filter in subrequests (subrequest_ranges)
+
+$r = get('/t', 'Range: bytes=2-4');
+unlike($r, qr/\x0d\x0a?0\x0d\x0a?\x0d\x0a?\w/, 'only final chunk');
+
+TODO: {
+local $TODO = 'not yet';
+
+# server is assumed to return the requested range
+
+$r = get('/t', 'Range: bytes=3-4');
+like($r, qr/ 206 /, 'range request - 206 partial reply');
+is(http_content($r), '34', 'range request - correct content');
+
+}
+
+###############################################################################
+
+sub get {
+    my ($url, $extra) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.1
+Host: localhost
+Connection: close
+$extra
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter_ssi.t ../asynch_mode_nginx/test/nginx-tests/sub_filter_ssi.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter_ssi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter_ssi.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for sub filter and subrequests.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http sub ssi xslt/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    types {
+        text/html html;
+        text/xml  xml;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            ssi on;
+            sub_filter notfoo bar;
+        }
+
+        location /xslt {
+            ssi on;
+            sub_filter_types *;
+            sub_filter root>foo bar;
+            xslt_stylesheet test.xslt;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '<!--#include virtual="/not.html" --> truncated');
+$t->write_file('not.html', 'response is not');
+
+$t->write_file('xslt.html', '<!--#include virtual="/xslt.xml" --> truncated');
+$t->write_file('xslt.xml', '<root>test</root>');
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+<xsl:output method="html"/>
+<xsl:strip-space elements="*"/>
+<xsl:template match="/">response is not</xsl:template>
+</xsl:stylesheet>
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/index.html'), qr/not truncated/, 'subrequest partial match');
+like(http_get('/xslt.html'), qr/not.*truncated/ms, 'partial match and xslt');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/sub_filter.t ../asynch_mode_nginx/test/nginx-tests/sub_filter.t
--- nginx-release-1.20.1/test/nginx-tests/sub_filter.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/sub_filter.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,155 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for sub filter.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite sub proxy/)->plan(30)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        sub_filter_types *;
+        sub_filter foo bar;
+
+        location / {
+        }
+
+        location /once {
+            return 200 $arg_b;
+        }
+
+        location /many {
+            sub_filter_once off;
+            return 200 $arg_b;
+        }
+
+        location /complex {
+            sub_filter abac _replaced;
+            return 200 $arg_b;
+        }
+
+        location /complex2 {
+            sub_filter ababX _replaced;
+            return 200 $arg_b;
+        }
+
+        location /complex3 {
+            sub_filter aab _replaced;
+            return 200 $arg_b;
+        }
+
+        location /single {
+            sub_filter A B;
+            return 200 $arg_b;
+        }
+
+        location /single/many {
+            sub_filter A B;
+            sub_filter_once off;
+            return 200 $arg_b;
+        }
+
+        location /var/string {
+            sub_filter X$arg_a _replaced;
+            return 200 $arg_b;
+        }
+
+        location /var/replacement {
+            sub_filter aab '${arg_a}_replaced';
+            return 200 $arg_b;
+        }
+
+        location /lm {
+            sub_filter_last_modified on;
+            proxy_pass http://127.0.0.1:8081/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+    }
+}
+
+EOF
+
+$t->write_file('foo.html', 'foo');
+$t->write_file('foo_uc.html', 'FOO');
+$t->write_file('foofoo.html', 'foofoo');
+$t->run();
+
+###############################################################################
+
+like(http_get('/foo.html'), qr/bar/, 'sub_filter');
+like(http_get('/foo_uc.html'), qr/bar/, 'sub_filter caseless');
+like(http_get('/foofoo.html'), qr/barfoo/, 'once default');
+
+like(http_get('/once?b=foofoo'), qr/barfoo/, 'once');
+like(http_get('/many?b=foofoo'), qr/barbar/, 'many');
+like(http_get('/many?b=fo'), qr/fo/, 'incomplete');
+like(http_get('/many?b=foofo'), qr/barfo/, 'incomplete long');
+
+like(http_get('/complex?b=abac'), qr/_replaced/, 'complex');
+like(http_get('/complex?b=abaabac'), qr/aba_replaced/, 'complex 1st char');
+like(http_get('/complex?b=ababac'), qr/replaced/, 'complex 2nd char');
+like(http_get('/complex2?b=ababX'), qr/_replaced/, 'complex2');
+like(http_get('/complex2?b=abababX'), qr/ab_replaced/, 'complex2 long');
+like(http_get('/complex3?b=aab'), qr/_replaced/, 'complex3 aab in aab');
+like(http_get('/complex3?b=aaab'), qr/a_replaced/, 'complex3 aab in aaab');
+like(http_get('/complex3?b=aaaab'), qr/aa_replaced/, 'complex3 aab in aaaab');
+
+like(http_get('/single?b=A'), qr/B/, 'single only');
+like(http_get('/single?b=AA'), qr/BA/, 'single begin');
+like(http_get('/single?b=CAAC'), qr/CBAC/, 'single middle');
+like(http_get('/single?b=CA'), qr/CB/, 'single end');
+
+like(http_get('/single/many?b=A'), qr/B/, 'single many only');
+like(http_get('/single/many?b=AA'), qr/BB/, 'single many begin');
+like(http_get('/single/many?b=CAAC'), qr/CBBC/, 'single many middle');
+like(http_get('/single/many?b=CA'), qr/CB/, 'single many end');
+
+like(http_get('/var/string?a=foo&b=Xfoo'), qr/_replaced/, 'complex string');
+like(http_get('/var/string?a=foo&b=XFOO'), qr/_replaced/,
+    'complex string caseless');
+like(http_get('/var/string?a=abcdefghijklmnopq&b=Xabcdefghijklmnopq'),
+    qr/_replaced/, 'complex string long');
+
+like(http_get('/var/replacement?a=ee&b=aaab'), qr/aee_replaced/,
+    'complex replacement');
+
+unlike(http_get('/foo.html'), qr/(Last-Modified|ETag)/, 'no last modified');
+like(http_get('/lm/foo.html'), qr/Last-Modified/, 'last modified');
+like(http_get('/lm/foo.html'), qr!ETag: W/"[^"]+"!, 'last modified weak');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/subrequest_output_buffer_size.t ../asynch_mode_nginx/test/nginx-tests/subrequest_output_buffer_size.t
--- nginx-release-1.20.1/test/nginx-tests/subrequest_output_buffer_size.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/subrequest_output_buffer_size.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for subrequest_output_buffer_size directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy ssi/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            subrequest_output_buffer_size 42;
+        }
+
+        location /longok {
+            proxy_pass http://127.0.0.1:8081/long;
+        }
+
+        location /ssi {
+            ssi on;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->write_file('ssi.html',
+    '<!--#include virtual="/$arg_c" set="x" -->' .
+    'set: <!--#echo var="x" -->');
+
+$t->write_file('length', 'TEST-OK-IF-YOU-SEE-THIS');
+$t->write_file('long', 'x' x 400);
+$t->write_file('empty', '');
+
+$t->run();
+
+###############################################################################
+
+my ($r, $n);
+
+like(http_get('/ssi.html?c=length'), qr/SEE-THIS/, 'request');
+like(http_get('/ssi.html?c=empty'), qr/set: $/, 'empty');
+unlike(http_get('/ssi.html?c=long'), qr/200 OK/, 'long');
+like(http_get('/ssi.html?c=longok'), qr/x{400}/, 'long ok');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/syslog.t ../asynch_mode_nginx/test/nginx-tests/syslog.t
--- nginx-release-1.20.1/test/nginx-tests/syslog.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/syslog.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,354 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for syslog.
+# Various log levels emitted with limit_req_log_level.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+use Sys::Hostname;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+plan(skip_all => 'win32') if $^O eq 'MSWin32';
+
+my $t = Test::Nginx->new()->has(qw/http limit_req/)->plan(62);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+error_log syslog:server=127.0.0.1:%%PORT_8981_UDP%% info;
+error_log %%TESTDIR%%/f_glob.log info;
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    limit_req_zone $binary_remote_addr zone=one:1m rate=1r/m;
+
+    log_format empty "";
+    log_format logf "$uri:$status";
+
+    error_log syslog:server=127.0.0.1:%%PORT_8982_UDP%% info;
+    error_log %%TESTDIR%%/f_http.log info;
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /e {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /ef {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,facility=user;
+        }
+        location /es {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,severity=alert;
+        }
+        location /et {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,tag=SEETHIS;
+        }
+        location /af {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,facility=user;
+        }
+        location /as {
+            # put severity inside to catch possible parsing programming errors
+            access_log syslog:severity=alert,server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /at {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,tag=SEETHIS;
+        }
+        location /e2 {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a2 {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /a_logf {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% logf;
+        }
+        location /if {
+            access_log syslog:server=127.0.0.1:%%PORT_8983_UDP%% logf
+                if=$arg_logme;
+        }
+
+        location /nohostname {
+            access_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%,nohostname;
+        }
+
+        location /debug {
+            limit_req zone=one;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% debug;
+        }
+        location /info {
+            limit_req zone=one;
+            limit_req_log_level info;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% info;
+        }
+        location /notice {
+            limit_req zone=one;
+            limit_req_log_level notice;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% notice;
+        }
+        location /warn {
+            limit_req zone=one;
+            limit_req_log_level warn;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% warn;
+        }
+        location /error {
+            limit_req zone=one;
+            limit_req_log_level error;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /low {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% warn;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /dup {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+        location /high {
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%% emerg;
+            error_log syslog:server=127.0.0.1:%%PORT_8984_UDP%%;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&syslog_daemon, port(8981), $t, 's_glob.log');
+$t->run_daemon(\&syslog_daemon, port(8982), $t, 's_http.log');
+$t->run_daemon(\&syslog_daemon, port(8983), $t, 's_if.log');
+
+$t->waitforfile($t->testdir . '/s_glob.log');
+$t->waitforfile($t->testdir . '/s_http.log');
+$t->waitforfile($t->testdir . '/s_if.log');
+
+$t->run();
+
+###############################################################################
+
+my $s = IO::Socket::INET->new(
+    Proto => 'udp',
+    LocalAddr => '127.0.0.1:' . port(8984)
+)
+    or die "Can't open syslog socket: $!";
+
+parse_syslog_message('error_log', get_syslog('/e'));
+parse_syslog_message('access_log', get_syslog('/a'));
+
+like(get_syslog('/ef'), qr/^<11>/, 'error_log facility');
+like(get_syslog('/es'), qr/^<187>/, 'error_log severity');
+like(get_syslog('/et'), qr/SEETHIS:/, 'error_log tag');
+
+like(get_syslog('/af'), qr/^<14>/, 'access_log facility');
+like(get_syslog('/as'), qr/^<185>/, 'access_log severity');
+like(get_syslog('/at'), qr/SEETHIS:/, 'access_log tag');
+
+
+like(get_syslog('/e'),
+    qr/nginx: \d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2} \[error\]/,
+    'error_log format');
+like(get_syslog('/a_logf'), qr/nginx: \/a_logf:404$/, 'access_log log_format');
+
+my @lines = split /<\d+>/, get_syslog('/a2');
+is($lines[1], $lines[2], 'access_log many');
+
+@lines = split /<\d+>/, get_syslog('/e2');
+is($lines[1], $lines[2], 'error_log many');
+
+# error_log log levels
+
+SKIP: {
+
+skip "no --with-debug", 1 unless $t->has_module('--with-debug');
+
+isnt(syslog_lines('/debug', '[debug]'), 0, 'debug');
+
+}
+
+# charge limit_req
+
+get_syslog('/info');
+
+is(syslog_lines('/info', '[info]'), 1, 'info');
+is(syslog_lines('/notice', '[notice]'), 1, 'notice');
+is(syslog_lines('/warn', '[warn]'), 1, 'warn');
+is(syslog_lines('/error', '[error]'), 1, 'error');
+
+# count log messages emitted with various error_log levels
+
+is(syslog_lines('/low', '[error]'), 2, 'low');
+is(syslog_lines('/dup', '[error]'), 2, 'dup');
+is(syslog_lines('/high', '[error]'), 1, 'high');
+
+# check for the presence of the syslog messages in the global and http contexts
+
+is_deeply(levels($t, 's_glob.log'), levels($t, 'f_glob.log'), 'master syslog');
+is_deeply(levels($t, 's_http.log'), levels($t, 'f_http.log'), 'http syslog');
+
+http_get('/if');
+http_get('/if/empty?logme=');
+http_get('/if/zero?logme=0');
+http_get('/if/good?logme=1');
+http_get('/if/work?logme=yes');
+
+get_syslog('/a');
+
+like($t->read_file('s_if.log'), qr/good:404/s, 'syslog if success');
+like($t->read_file('s_if.log'), qr/work:404/s, 'syslog if success 2');
+unlike($t->read_file('s_if.log'), qr/(if:|empty:|zero:)404/, 'syslog if fail');
+
+like(get_syslog('/nohostname'),
+    qr/^<(\d{1,3})>                         # PRI
+    ([A-Z][a-z]{2})\s                       # mon
+    ([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s    # date
+    (\w{1,32}):\s                           # tag
+    (.*)/x,                                 # MSG
+    'nohostname');
+
+# send error handling
+
+ok(get_syslog('/a'), 'send success');
+
+close $s;
+
+get_syslog('/a');
+get_syslog('/a');
+
+$s = IO::Socket::INET->new(
+    Proto => 'udp',
+    LocalAddr => '127.0.0.1:' . port(8984)
+)
+    or die "Can't open syslog socket: $!";
+
+ok(get_syslog('/a'), 'send error - recover');
+
+###############################################################################
+
+sub syslog_lines {
+    my ($uri, $pattern, $port) = @_;
+    return map { $_ =~ /\Q$pattern\E/g } (get_syslog($uri));
+}
+
+sub levels {
+    my ($t, $file) = @_;
+    my %levels_hash;
+
+    map { $levels_hash{$_}++; } ($t->read_file($file) =~ /(\[\w+\])/g);
+
+    return \%levels_hash;
+}
+
+sub get_syslog {
+    my ($uri) = @_;
+    my $data = '';
+
+    http_get($uri);
+
+    IO::Select->new($s)->can_read(1);
+    while (IO::Select->new($s)->can_read(0.1)) {
+        my $buffer;
+        sysread($s, $buffer, 4096);
+        $data .= $buffer;
+    }
+    return $data;
+}
+
+sub parse_syslog_message {
+    my ($desc, $line) = @_;
+
+    unless ($line) {
+        fail("$desc timeout in receiving syslog");
+    }
+
+    my @months = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug',
+        'Sep', 'Oct', 'Nov', 'Dec');
+
+    my ($pri, $mon, $mday, $hour, $minute, $sec, $host, $tag, $msg) =
+        $line =~ /^<(\d{1,3})>                      # PRI
+            ([A-Z][a-z]{2})\s                       # mon
+            ([ \d]\d)\s(\d{2}):(\d{2}):(\d{2})\s    # date
+            ([\S]*)\s                               # host
+            (\w{1,32}):\s                           # tag
+            (.*)/x;                                 # MSG
+
+    my $sev = $pri & 0x07;
+    my $fac = ($pri & 0x03f8) >> 3;
+
+    ok(defined($pri), "$desc has PRI");
+    ok($sev >= 0 && $sev <= 7, "$desc valid severity");
+    ok($fac >= 0 && $fac < 24, "$desc valid facility");
+
+    ok(defined($mon), "$desc has month");
+    ok((grep $mon, @months), "$desc valid month");
+
+    ok(defined($mday), "$desc has day");
+    ok($mday <= 31, "$desc valid day");
+
+    ok(defined($hour), "$desc has hour");
+    ok($hour < 24, "$desc valid hour");
+
+    ok(defined($minute), "$desc has minutes");
+    ok($minute < 60, "$desc valid minutes");
+
+    ok(defined($sec), "$desc has seconds");
+    ok($sec < 60, "$desc valid seconds");
+
+    ok(defined($host), "$desc has host");
+    is($host, lc(hostname()), "$desc valid host");
+
+    ok(defined($tag), "$desc has tag");
+    like($tag, qr'\w+', "$desc valid tag");
+
+    ok(length($msg) > 0, "$desc valid CONTENT");
+}
+
+###############################################################################
+
+sub syslog_daemon {
+    my ($port, $t, $file) = @_;
+
+    my $s = IO::Socket::INET->new(
+        Proto => 'udp',
+        LocalAddr => "127.0.0.1:$port"
+    );
+
+    open my $fh, '>', $t->testdir() . '/' . $file;
+    select $fh; $| = 1;
+
+    while (1) {
+        my $buffer;
+        $s->recv($buffer, 4096);
+        print $fh $buffer . "\n";
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/trailers.t ../asynch_mode_nginx/test/nginx-tests/trailers.t
--- nginx-release-1.20.1/test/nginx-tests/trailers.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/trailers.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,135 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for trailers in headers filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ $CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(17)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_trailer  X-Var $host;
+        add_trailer  X-Always $host always;
+        add_trailer  X-Empty '';
+        add_trailer  X-Sent-HTTP $sent_http_accept_ranges;
+        add_trailer  X-Sent-Trailer $sent_trailer_x_var;
+        add_trailer  X-Complex $host:$host;
+
+        location /t1 {
+        }
+
+        location /nx {
+        }
+
+        location /header {
+            add_header X-Var foo;
+        }
+
+        location /empty {
+            add_trailer X-Var $host;
+        }
+
+        location /not_chunked {
+            chunked_transfer_encoding off;
+        }
+
+        location /proxy {
+            proxy_pass http://127.0.0.1:8080/t1;
+            add_trailer X-Length $upstream_response_length;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('t1', 'SEE-THIS');
+$t->write_file('header', '');
+$t->run();
+
+###############################################################################
+
+my $r;
+
+$r = get('/t1');
+like($r, qr/8${CRLF}SEE-THIS${CRLF}0${CRLF}(.+${CRLF}){5}$CRLF/, 'trailers');
+unlike($r, qr/X-Var.*SEE-THIS/s, 'not in headers');
+like($r, qr/X-Var: localhost/, 'add_trailer');
+like($r, qr/X-Always/, 'add_trailer always');
+like($r, qr/X-Sent-HTTP: bytes/, 'add_trailer sent_http');
+like($r, qr/X-Sent-Trailer: localhost/, 'add_trailer sent_trailer');
+like($r, qr/X-Complex: localhost:localhost/, 'add_trailer complex');
+unlike($r, qr/X-Empty/, 'add_trailer empty');
+
+$r = get('/nx');
+unlike($r, qr/X-Var/, 'add_trailer bad');
+like($r, qr/X-Always/, 'add_trailer bad always');
+
+like(get('/header'), qr/foo.*^0$CRLF.*X-Var: localhost/ms, 'header name');
+
+like(http_get('/t1'), qr/${CRLF}SEE-THIS$/, 'no trailers - http10');
+unlike(get('/not_chunked'), qr/X-Always/, 'no trailers - not chunked');
+unlike(head('/t1'), qr/X-Always/, 'no trailers - head');
+
+unlike(get('/empty'), qr/X-Var/, 'no trailers expected');
+
+$r = get('/proxy');
+like($r, qr/SEE-THIS.*X-Length: 8/ms, 'upstream response variable');
+unlike($r, qr/X-Var/, 'inheritance');
+
+###############################################################################
+
+sub get {
+    my ($uri) = @_;
+    http(<<EOF);
+GET $uri HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+sub head {
+    my ($uri) = @_;
+    http(<<EOF);
+HEAD $uri HTTP/1.1
+Host: localhost
+Connection: close
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_hash_memcached.t ../asynch_mode_nginx/test/nginx-tests/upstream_hash_memcached.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_hash_memcached.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_hash_memcached.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,189 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream hash balancer module distribution consistency
+# with Cache::Memcached and Cache::Memcached::Fast.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+eval { require Cache::Memcached; };
+plan(skip_all => 'Cache::Memcached not installed') if $@;
+eval { require Cache::Memcached::Fast; };
+plan(skip_all => 'Cache::Memcached::Fast not installed') if $@;
+
+my $t = Test::Nginx->new()->has(qw/http rewrite memcached upstream_hash/)
+    ->has_daemon('memcached')->plan(4);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream memd {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_c {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_w {
+        hash $arg_a;
+        server 127.0.0.1:8081 weight=2;
+        server 127.0.0.1:8082 weight=3;
+        server 127.0.0.1:8083;
+    }
+
+    upstream memd_cw {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081 weight=2;
+        server 127.0.0.1:8082 weight=3;
+        server 127.0.0.1:8083;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set $memcached_key $arg_a;
+
+        location / {
+            memcached_pass memd;
+        }
+        location /c {
+            memcached_pass memd_c;
+        }
+        location /w {
+            memcached_pass memd_w;
+        }
+        location /cw {
+            memcached_pass memd_cw;
+        }
+    }
+}
+
+EOF
+
+my $memhelp = `memcached -h`;
+my @memopts = ();
+
+if ($memhelp =~ /repcached/) {
+    # repcached patch adds additional listen socket
+    push @memopts, '-X', '0';
+}
+if ($memhelp =~ /-U/) {
+    # UDP port is on by default in memcached 1.2.7+
+    push @memopts, '-U', '0';
+}
+
+$t->run_daemon('memcached', '-u', 'root', '-l', '127.0.0.1', '-p', port(8081), @memopts);
+$t->run_daemon('memcached', '-u', 'root', '-l', '127.0.0.1', '-p', port(8082), @memopts);
+$t->run_daemon('memcached', '-u', 'root', '-l', '127.0.0.1', '-p', port(8083), @memopts);
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081)) or die "Can't start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8082)) or die "Can't start memcached";
+$t->waitforsocket('127.0.0.1:' . port(8083)) or die "Can't start memcached";
+
+###############################################################################
+
+my $memd1 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8081) ],
+    connect_timeout => 1.0);
+my $memd2 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8082) ],
+    connect_timeout => 1.0);
+my $memd3 = Cache::Memcached->new(servers => [ '127.0.0.1:' . port(8083) ],
+    connect_timeout => 1.0);
+
+for my $i (1 .. 20) {
+    $memd1->set($i, port(8081)) or die "can't put value into memcached: $!";
+    $memd2->set($i, port(8082)) or die "can't put value into memcached: $!";
+    $memd3->set($i, port(8083)) or die "can't put value into memcached: $!";
+}
+
+my $memd = new Cache::Memcached(servers => [
+    '127.0.0.1:' . port(8081),
+    '127.0.0.1:' . port(8082),
+    '127.0.0.1:' . port(8083) ]);
+
+is_deeply(ngx('/'), mem($memd), 'cache::memcached');
+
+$memd = new Cache::Memcached::Fast({ ketama_points => 160, servers => [
+    '127.0.0.1:' . port(8081),
+    '127.0.0.1:' . port(8082),
+    '127.0.0.1:' . port(8083)] });
+
+# Cache::Memcached::Fast may be incompatible with recent Perl,
+# see https://github.com/JRaspass/Cache-Memcached-Fast/issues/12
+
+my $cmf_bug = ! keys %{$memd->server_versions};
+
+SKIP: {
+skip 'Cache::Memcached::Fast bug', 1 if $cmf_bug;
+
+is_deeply(ngx('/c'), mem($memd), 'cache::memcached::fast');
+
+}
+
+$memd = new Cache::Memcached(servers => [
+    [ '127.0.0.1:' . port(8081), 2 ],
+    [ '127.0.0.1:' . port(8082), 3 ],
+    [ '127.0.0.1:' . port(8083), 1 ]]);
+
+is_deeply(ngx('/w'), mem($memd), 'cache::memcached weight');
+
+$memd = new Cache::Memcached::Fast({ ketama_points => 160, servers => [
+    { address => '127.0.0.1:' . port(8081), weight => 2 },
+    { address => '127.0.0.1:' . port(8082), weight => 3 },
+    { address => '127.0.0.1:' . port(8083), weight => 1 }] });
+
+SKIP: {
+skip 'Cache::Memcached::Fast bug', 1 if $cmf_bug;
+
+is_deeply(ngx('/cw'), mem($memd), 'cache::memcached::fast weight');
+
+}
+
+###############################################################################
+
+sub ngx {
+    my ($uri) = @_;
+    [ map { http_get("/$uri?a=$_") =~ /^(\d+)/ms && $1; } (1 .. 20) ];
+}
+
+sub mem {
+    my ($memd) = @_;
+    [ map { $memd->get($_); } (1 .. 20) ];
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_hash.t ../asynch_mode_nginx/test/nginx-tests/upstream_hash.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_hash.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_hash.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,262 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream hash balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_hash/)->plan(15);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream u2 {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083;
+    }
+
+    upstream cw {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083 weight=10;
+    }
+
+    upstream cw2 {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083 weight=10;
+    }
+
+    upstream c {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream c2 {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8083;
+    }
+
+    upstream bad {
+        hash $arg_a;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8084;
+    }
+
+    upstream cbad {
+        hash $arg_a consistent;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8084;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /2 {
+            proxy_pass http://u2;
+        }
+        location /cw {
+            proxy_pass http://cw;
+        }
+        location /cw2 {
+            proxy_pass http://cw2;
+        }
+        location /c {
+            proxy_pass http://c;
+        }
+        location /c2 {
+            proxy_pass http://c2;
+        }
+        location /bad {
+            proxy_pass http://bad;
+        }
+        location /cbad {
+            proxy_pass http://cbad;
+        }
+        location /busy {
+            proxy_pass http://bad/busy;
+            add_header X-IP $upstream_addr always;
+        }
+        location /cbusy {
+            proxy_pass http://cbad/busy;
+            add_header X-IP $upstream_addr always;
+        }
+        location /pnu {
+            proxy_pass http://u/;
+            proxy_next_upstream http_502;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        listen       127.0.0.1:8083;
+        server_name  localhost;
+
+        add_header X-Port $server_port;
+
+        location / {
+            return 204;
+        }
+
+        location /502 {
+            if ($server_port = %%PORT_8083%%) {
+                return 502;
+            }
+            return 204;
+        }
+
+        location /busy {
+            return 444;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+        return 444;
+    }
+}
+
+EOF
+
+$t->run();
+
+###############################################################################
+
+my @ports = my ($p1, $p2, $p3) = (port(8081), port(8082), port(8083));
+
+# Only requests for absent peer are moved to other peers if hash is consistent.
+# Check this by comparing two upstreams with different number of peers.
+
+ok(!cmp_peers([iter('/', 20)], [iter('/2', 20)], $p2), 'inconsistent');
+ok(cmp_peers([iter('/c', 20)], [iter('/c2', 20)], $p2), 'consistent');
+ok(cmp_peers([iter('/cw', 20)], [iter('/cw2', 20)], $p2), 'consistent weight');
+
+like(many('/?a=1', 10), qr/($p1|$p2|$p3): 10/, 'stable hash');
+like(many('/c?a=1', 10), qr/($p1|$p2|$p3): 10/, 'stable hash - consistent');
+
+# fallback to round-robin
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.1');
+
+like(many('/?a=', 6), qr/$p1: 2, $p2: 2, $p3: 2/, 'empty key');
+like(many('/c?a=', 6), qr/$p1: 2, $p2: 2, $p3: 2/, 'empty key - consistent');
+
+}
+
+my @res = iter('/', 10);
+
+is(@res, 10, 'all hashed peers');
+
+@res = grep { $_ != $p3 } @res;
+my @res2 = iter('/502', 10);
+
+is_deeply(\@res, \@res2, 'no proxy_next_upstream');
+isnt(@res2, 10, 'no proxy_next_upstream peers');
+
+is(iter('/pnu/502', 10), 10, 'proxy_next_upstream peers');
+
+@res = grep { $_ == $p1 } iter('/bad', 20);
+is(@res, 20, 'all hashed peers - bad');
+
+@res = grep { $_ == $p1 } iter('/cbad', 20);
+is(@res, 20, 'all hashed peers - bad consistent');
+
+like(http_get('/busy'), qr/X-IP: 127.0.0.1:$p1, bad/,
+    'upstream name - busy');
+like(http_get('/cbusy'), qr/X-IP: 127.0.0.1:$p1, cbad/,
+    'upstream name - busy consistent');
+
+###############################################################################
+
+# Returns true if two arrays follow consistency, i.e., they may only differ
+# by @args present in $p, but absent in $p2, for the same indices.
+
+sub cmp_peers {
+    my ($p, $p2, @args) = @_;
+
+    for my $i (0 .. $#$p) {
+        next if @{$p}[$i] == @{$p2}[$i];
+        next if (grep $_ == @{$p}[$i], @args);
+        return 0;
+    }
+
+    return 1;
+}
+
+# series of requests, each with unique hash key
+
+sub iter {
+    my ($uri, $count) = @_;
+    my @res;
+
+    for my $i (1 .. $count) {
+        if (http_get("$uri/?a=$i") =~ /X-Port: (\d+)/) {
+            push @res, $1 if defined $1;
+        }
+    }
+
+    return @res;
+}
+
+sub many {
+    my ($uri, $count) = @_;
+    my %ports;
+
+    for (1 .. $count) {
+        if (http_get($uri) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_ip_hash_ipv6.t ../asynch_mode_nginx/test/nginx-tests/upstream_ip_hash_ipv6.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_ip_hash_ipv6.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_ip_hash_ipv6.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,154 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream ip_hash balancer with IPv6 and unix sockets.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_ip_hash realip unix/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-IP $remote_addr always;
+
+        location / {
+            set_real_ip_from 127.0.0.0/8;
+            proxy_pass http://u;
+        }
+
+        location /unix {
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock;
+            proxy_set_header X-Real-IP $http_x_real_ip;
+        }
+
+        location /ipv6 {
+            proxy_pass http://[::1]:%%PORT_8080%%;
+            proxy_set_header X-Real-IP $http_x_real_ip;
+        }
+    }
+
+    server {
+        listen       unix:%%TESTDIR%%/unix.sock;
+        listen       [::1]:%%PORT_8080%%;
+        server_name  localhost;
+
+        location / {
+            set_real_ip_from unix:;
+            set_real_ip_from ::1;
+            proxy_pass http://u;
+        }
+
+        location /unix/none {
+            proxy_pass http://u;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        server_name  localhost;
+
+        location / {
+            add_header X-Port $server_port always;
+        }
+    }
+}
+
+EOF
+
+$t->try_run('no inet6 support');
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(4);
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many('/unix', 30), "$port1: 15, $port2: 15", 'ip_hash realip via unix');
+is(many('/ipv6', 30), "$port1: 15, $port2: 15", 'ip_hash realip via ipv6');
+
+is(many_ip6('/', 30), "$port1: 15, $port2: 15", 'ip_hash ipv6');
+like(many('/unix/none', 30), qr/($port1|$port2): 30/, 'ip_hash unix');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count) = @_;
+    my %ports;
+
+    for my $i (1 .. $count) {
+        my $req = "GET $uri HTTP/1.0" . CRLF
+            . "X-Real-IP: 127.0.$i.2" . CRLF . CRLF;
+
+        if (http($req) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub many_ip6 {
+    my ($uri, $count) = @_;
+    my %ports;
+
+    for my $i (1 .. $count) {
+        my $req = "GET $uri HTTP/1.0" . CRLF
+            . "X-Real-IP: ::$i" . CRLF . CRLF;
+
+        if (http($req) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_ip_hash.t ../asynch_mode_nginx/test/nginx-tests/upstream_ip_hash.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_ip_hash.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_ip_hash.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,124 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for upstream ip_hash balancer.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_ip_hash realip rewrite/)
+    ->write_file_expand('nginx.conf', <<'EOF')->run();
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u2 {
+        ip_hash;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083;
+    }
+
+    upstream s {
+        ip_hash;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        set_real_ip_from 127.0.0.0/8;
+        add_header X-IP $remote_addr;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /u2 {
+            proxy_pass http://u2;
+        }
+        location /s {
+            proxy_pass http://s;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        listen       127.0.0.1:8082;
+        listen       127.0.0.1:8083;
+        server_name  localhost;
+
+        location / {
+            add_header X-Port $server_port;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+plan(skip_all => 'no 127.0.0.1 on host')
+    if http_get('/') !~ /X-IP: 127.0.0.1/m;
+
+$t->plan(3);
+
+###############################################################################
+
+my @ports = my ($port1, $port2, $port3) = (port(8081), port(8082), port(8083));
+
+is(many('/', 30), "$port1: 15, $port2: 15", 'ip_hash');
+is(many('/u2', 30), "$port1: 10, $port2: 10, $port3: 10", 'ip_hash 3 peers');
+is(many('/s', 30), "$port1: 30", 'ip_hash single peer');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count) = @_;
+    my %ports;
+
+    for my $i (1 .. $count) {
+        my $req = "GET $uri HTTP/1.0" . CRLF
+            . "X-Real-IP: 127.0.$i.2" . CRLF . CRLF;
+
+        if (http($req) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_keepalive.t ../asynch_mode_nginx/test/nginx-tests/upstream_keepalive.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_keepalive.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_keepalive.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,112 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream keepalive directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_keepalive/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream backend {
+        server 127.0.0.1:8081;
+        keepalive 1;
+        keepalive_requests 3;
+        keepalive_timeout 2s;
+    }
+
+    upstream time {
+        server 127.0.0.1:8081;
+        keepalive 1;
+        keepalive_time 2s;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection $args;
+
+        location / {
+            proxy_pass http://backend;
+        }
+
+        location /time {
+            proxy_pass http://time/;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {
+            add_header X-Connection $connection;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', 'SEE-THIS');
+$t->try_run('no keepalive_time')->plan(11);
+
+###############################################################################
+
+my ($r, $n, $m);
+
+# keepalive_requests
+
+like($r = http_get('/'), qr/SEE-THIS/, 'request');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive');
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive again');
+like(http_get('/'), qr/X-Connection: (?!$n).*SEE/ms, 'keepalive requests');
+http_get('/?close');
+
+# keepalive_timeout, keepalive_time
+
+like($r = http_get('/'), qr/SEE-THIS/, 'request timer');
+$r =~ m/X-Connection: (\d+)/; $n = $1;
+like($r = http_get('/time'), qr/SEE-THIS/, 'request time');
+$r =~ m/X-Connection: (\d+)/; $m = $1;
+
+like(http_get('/'), qr/X-Connection: $n.*SEE/ms, 'keepalive timer');
+like(http_get('/time'), qr/X-Connection: $m.*SEE/ms, 'keepalive time');
+
+select undef, undef, undef, 2.5;
+
+like(http_get('/'), qr/X-Connection: (?!$n).*SEE/ms, 'keepalive timeout');
+like(http_get('/time'), qr/X-Connection: $m.*SEE/ms, 'keepalive time last');
+like(http_get('/time'), qr/X-Connection: (?!$m).*SEE/ms, 'keepalive time new');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_least_conn.t ../asynch_mode_nginx/test/nginx-tests/upstream_least_conn.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_least_conn.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_least_conn.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,142 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for upstream least_conn balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_least_conn/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+is(many('/', 10), "$port1: 5, $port2: 5", 'balanced');
+
+my @sockets;
+push(@sockets, http_get('/w', start => 1));
+push(@sockets, http_get('/w', start => 1));
+
+select undef, undef, undef, 0.2;
+
+is(many('/w', 10), "$port2: 10", 'least conn');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count) = @_;
+    my %ports;
+
+    for (1 .. $count) {
+        if (http_get($uri) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/w' && $port == port(8081)) {
+            Test::Nginx::log_core('||', "$port: sleep(2.5)");
+            select undef, undef, undef, 2.5;
+        }
+
+        Test::Nginx::log_core('||', "$port: response, 200");
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_max_conns.t ../asynch_mode_nginx/test/nginx-tests/upstream_max_conns.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_max_conns.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_max_conns.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,376 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Nginx, Inc.
+
+# Tests for upstream module with max_conns feature.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy rewrite upstream_least_conn/)
+    ->has(qw/upstream_ip_hash upstream_hash/)->plan(16);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u_unlim {
+        server 127.0.0.1:8081 max_conns=0;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lim {
+        server 127.0.0.1:8081 max_conns=3;
+    }
+
+    upstream u_backup {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_backup_lim {
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_two {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+    upstream u_some {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_many {
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_weight {
+        server 127.0.0.1:8081 weight=2 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+
+    upstream u_pnu {
+        # special server to force next upstream
+        server 127.0.0.1:8084;
+
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    upstream u_lc {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082;
+    }
+    upstream u_lc_backup {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup;
+    }
+    upstream u_lc_backup_lim {
+        least_conn;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 backup max_conns=3;
+    }
+
+    upstream u_ih {
+        ip_hash;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    upstream u_hash {
+        hash $remote_addr;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+    upstream u_chash {
+        hash $remote_addr consistent;
+        server 127.0.0.1:8081 max_conns=1;
+        server 127.0.0.1:8082 max_conns=2;
+    }
+
+    server {
+        listen       127.0.0.1:8084;
+        server_name  localhost;
+
+        location / {
+            return 444;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        proxy_http_version 1.1;
+        proxy_set_header Connection "";
+        proxy_buffering off;
+
+        location /u {
+            proxy_pass http:/$uri;
+        }
+
+        location /close {
+            proxy_pass http://127.0.0.1:8085;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081), port(8082), port(8085));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+$t->waitforsocket('127.0.0.1:' . port(8085));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+# two peers without max_conns
+
+is(parallel('/u_unlim?delay=0', 4), "$p1: 2, $p2: 2", 'unlimited');
+
+# reopen connection to test connection subtraction
+
+my @s = http_get_multi('/u_lim', 2, 1.1);
+http_get('/u_lim/close');
+push @s, http_get_multi('/u_lim', 1, 1.1);
+http_get('/closeall');
+
+is(http_end_multi(\@s), "$p1: 3", 'conn subtraction');
+
+# simple test with limited peer
+
+is(parallel('/u_lim', 4), "$p1: 3", 'single');
+
+# limited peer with backup peer
+
+is(peers('/u_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'backup');
+
+# peer and backup peer, both limited
+
+is(peers('/u_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ", 'backup limited');
+
+# all peers limited
+
+is(parallel('/u_two', 4), "$p1: 1, $p2: 1", 'all peers');
+
+# subset of peers limited
+
+is(parallel('/u_some', 4), "$p1: 1, $p2: 3", 'some peers');
+
+# ensure that peer "weight" does not affect its max_conns limit
+
+is(parallel('/u_weight', 4), "$p1: 1, $p2: 3", 'weight');
+
+# peers with equal server value aggregate max_conns limit
+
+is(parallel('/u_many', 6), "$p1: 2, $p2: 4", 'equal peer');
+
+# connections to peer selected with proxy_next_upstream are counted
+
+is(parallel('/u_pnu', 4), "$p1: 1, $p2: 2", 'proxy_next_upstream');
+
+# least_conn balancer tests
+
+is(parallel('/u_lc', 4), "$p1: 1, $p2: 3", 'least_conn');
+is(peers('/u_lc_backup', 6), "$p1 $p1 $p2 $p2 $p2 $p2", 'least_conn backup');
+is(peers('/u_lc_backup_lim', 6), "$p1 $p1 $p2 $p2 $p2 ",
+    'least_conn backup limited');
+
+# ip_hash balancer tests
+
+is(parallel('/u_ih', 4), "$p1: 1, $p2: 2", 'ip_hash');
+
+# hash balancer tests
+
+is(parallel('/u_hash', 4), "$p1: 1, $p2: 2", 'hash');
+is(parallel('/u_chash', 4), "$p1: 1, $p2: 2", 'hash consistent');
+
+###############################################################################
+
+sub peers {
+    my ($uri, $count) = @_;
+
+    my @sockets = http_get_multi($uri, $count, 1.1);
+    http_get('/closeall');
+
+    join ' ', map { /X-Port: (\d+)/ && $1 }
+        map { http_end $_ } (@sockets);
+}
+
+sub parallel {
+    my ($uri, $count) = @_;
+
+    my @sockets = http_get_multi($uri, $count);
+    for (1 .. 20) {
+        last if IO::Select->new(@sockets)->can_read(3) == $count;
+        select undef, undef, undef, 0.01;
+    }
+    http_get('/closeall');
+    return http_end_multi(\@sockets);
+}
+
+sub http_get_multi {
+    my ($uri, $count, $wait) = @_;
+    my @sockets;
+
+    for (0 .. $count - 1) {
+        $sockets[$_] = http_get($uri, start => 1);
+        IO::Select->new($sockets[$_])->can_read($wait) if $wait;
+    }
+
+    return @sockets;
+}
+
+sub http_end_multi {
+    my ($sockets) = @_;
+    my %ports;
+
+    for my $sock (@$sockets) {
+        if (http_end($sock) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+        close $sock;
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my (@ports) = @_;
+    my (@socks, @clients);
+
+    for my $port (@ports) {
+        my $server = IO::Socket::INET->new(
+            Proto => 'tcp',
+            LocalHost => "127.0.0.1:$port",
+            Listen => 42,
+            Reuse => 1
+        )
+            or die "Can't create listening socket: $!\n";
+        push @socks, $server;
+    }
+
+    my $sel = IO::Select->new(@socks);
+    my $skip = 4;
+    my $count = 0;
+
+    local $SIG{PIPE} = 'IGNORE';
+
+OUTER:
+    while (my @ready = $sel->can_read) {
+        foreach my $fh (@ready) {
+            if (grep $_ == $fh, @socks) {
+                my $new = $fh->accept;
+                $new->autoflush(1);
+                $sel->add($new);
+                $count++;
+
+            } else {
+                my @busy = grep { $_->sockport() } @ready;
+
+                # finish other handles
+                if ($fh->sockport() == port(8085) && @busy > 1
+                    && grep $_->sockport() != port(8085),
+                    @busy)
+                {
+                    next;
+                }
+
+                # late events in other handles
+                if ($fh->sockport() == port(8085) && @busy == 1
+                    && $count > 1 && $skip-- > 0)
+                {
+                    select undef, undef, undef, 0.1;
+                    next OUTER;
+                }
+
+                my $rv = process_socket($fh, \@clients);
+                if ($rv == 1) {
+                    $sel->remove($fh);
+                    $fh->close;
+                }
+                if ($rv == 2) {
+                    for (@clients) {
+                        $sel->remove($_);
+                        $_->close;
+                    }
+                    $sel->remove($fh);
+                    $fh->close;
+                    $skip = 4;
+                }
+                $count--;
+            }
+        }
+    }
+}
+
+# Returns true to close connection
+
+sub process_socket {
+    my ($client, $saved) = @_;
+    my $port = $client->sockport();
+
+    my $headers = '';
+    my $uri = '';
+
+    while (<$client>) {
+        $headers .= $_;
+        last if (/^\x0d?\x0a?$/);
+    }
+    return 1 if $headers eq '';
+
+    $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+    return 1 if $uri eq '';
+
+    Test::Nginx::log_core('||', "$port: response, 200");
+    print $client <<EOF;
+HTTP/1.1 200 OK
+X-Port: $port
+
+OK
+EOF
+
+    return 2 if $uri =~ /closeall/;
+    return 1 if $uri =~ /close/;
+
+    push @$saved, $client;
+    return 0;
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_random.t ../asynch_mode_nginx/test/nginx-tests/upstream_random.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_random.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_random.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,268 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream random balancer module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx qw/ :DEFAULT http_end /;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_zone upstream_random/)
+    ->plan(12)->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_processes 2;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+        server 127.0.0.1:8083 down;
+    }
+
+    upstream lc {
+        zone lc 1m;
+        random two;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082;
+    }
+
+    upstream w {
+        zone w 1m;
+        random two least_conn;
+        server 127.0.0.1:8081;
+        server 127.0.0.1:8082 weight=2;
+    }
+
+    upstream mc {
+        zone mc 1m;
+        random;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream mc2 {
+        zone mc 1m;
+        random two;
+        server 127.0.0.1:8081 max_conns=2;
+        server 127.0.0.1:8082 max_conns=1;
+    }
+
+    upstream one {
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream two {
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    upstream zone {
+        zone z 1m;
+        random;
+        server 127.0.0.1:8081;
+    }
+
+    upstream ztwo {
+        zone z 1m;
+        random two;
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+
+        location /lc/ {
+            proxy_pass http://lc/;
+        }
+
+        location /w {
+            proxy_pass http://w;
+        }
+
+        location /mc/ {
+            proxy_pass http://mc/;
+        }
+
+        location /mc2/ {
+            proxy_pass http://mc2/;
+        }
+
+        location /one {
+            proxy_pass http://one;
+        }
+
+        location /two {
+            proxy_pass http://two;
+        }
+
+        location /zone {
+            proxy_pass http://zone;
+        }
+
+        location /ztwo {
+            proxy_pass http://ztwo;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($port1, $port2) = (port(8081), port(8082));
+
+like(http_get('/'), qr/X-Port: ($port1|$port2)/, 'random');
+like(http_get('/lc/'), qr/X-Port: ($port1|$port2)/, 'random two');
+
+my $s = http_get('/lc/w', start => 1, sleep => 0.5);
+my $r = http_get('/lc/');
+my ($p) = http_end($s) =~ /X-Port: (\d+)/;
+like($r, qr/X-Port: (?!$p)/, 'random wait');
+
+SKIP: {
+skip 'long test', 3 unless $ENV{TEST_NGINX_UNSAFE};
+
+is(parallel('/w', 3), "$port1: 1, $port2: 2", 'random weight');
+
+is(parallel('/mc/w', 4), "$port1: 2, $port2: 1", 'max_conns');
+is(parallel('/mc2/w', 4), "$port1: 2, $port2: 1", 'max_conns two');
+
+}
+
+# single variants
+
+like(http_get('/one'), qr/X-Port: $port1/, 'single one');
+like(http_get('/two'), qr/X-Port: $port1/, 'single two');
+like(http_get('/zone'), qr/X-Port: $port1/, 'zone one');
+like(http_get('/ztwo'), qr/X-Port: $port1/, 'zone two');
+
+like(many('/close', 10), qr/$port2: 10/, 'failures');
+like(many('/lc/close', 10), qr/$port2: 10/, 'failures two');
+
+###############################################################################
+
+sub many {
+    my ($uri, $count, %opts) = @_;
+    my %ports;
+
+    for (1 .. $count) {
+        if (http_get($uri) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+
+        select undef, undef, undef, $opts{delay} if $opts{delay};
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+sub parallel {
+    my ($uri, $n) = @_;
+    my %ports;
+
+    my @s = map { http_get($uri, start => 1, sleep => 0.1) } (1 .. $n);
+
+    for (@s) {
+        if (http_end($_) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri eq '/w') {
+            Test::Nginx::log_core('||', "$port: sleep(2.5)");
+            select undef, undef, undef, 2.5;
+        }
+
+        if ($uri eq '/close' && $port == port(8081)) {
+            next;
+        }
+
+        Test::Nginx::log_core('||', "$port: response, 200");
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream.t ../asynch_mode_nginx/test/nginx-tests/upstream.t
--- nginx-release-1.20.1/test/nginx-tests/upstream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,161 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for upstream module and balancers.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(3);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081 max_fails=3 fail_timeout=10s;
+        server 127.0.0.1:8082 max_fails=3 fail_timeout=10s;
+    }
+
+    upstream u2 {
+        server 127.0.0.1:8081 max_fails=3 fail_timeout=10s;
+        server 127.0.0.1:8082 max_fails=3 fail_timeout=10s;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://u;
+        }
+        location /close2 {
+            proxy_pass http://u2;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon, port(8081));
+$t->run_daemon(\&http_daemon, port(8082));
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081));
+$t->waitforsocket('127.0.0.1:' . port(8082));
+
+###############################################################################
+
+my @ports = my ($p1, $p2) = (port(8081), port(8082));
+
+is(many('/', 30), "$p1: 15, $p2: 15", 'balanced');
+
+# from 9 first requests to the first port, only 6 will be successful,
+# 3rd, 6th, and 9th requests will fail; after this the backend
+# will be considered down and won't be used till fail_timeout passes
+
+is(many('/close', 30), "$p1: 6, $p2: 24", 'failures');
+
+SKIP: {
+skip 'long test', 1 unless $ENV{TEST_NGINX_UNSAFE};
+
+# bug: failures counter is reset if first request in a second succeeds
+#
+# delay added to make sure first 9 requests will take more than 1s;
+# note that the test is racy and may unexpectedly succeed
+
+is(many('/close2', 30, delay => 0.2), "$p1: 6, $p2: 24", 'failures delay');
+
+}
+
+###############################################################################
+
+sub many {
+    my ($uri, $count, %opts) = @_;
+    my %ports;
+
+    for (1 .. $count) {
+        if (http_get($uri) =~ /X-Port: (\d+)/) {
+            $ports{$1} = 0 unless defined $ports{$1};
+            $ports{$1}++;
+        }
+
+        select undef, undef, undef, $opts{delay} if $opts{delay};
+    }
+
+    my @keys = map { my $p = $_; grep { $p == $_ } keys %ports } @ports;
+    return join ', ', map { $_ . ": " . $ports{$_} } @keys;
+}
+
+###############################################################################
+
+sub http_daemon {
+    my ($port) = @_;
+    my $count = 1;
+
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1',
+        LocalPort => $port,
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        $uri = $1 if $headers =~ /^\S+\s+([^ ]+)\s+HTTP/i;
+
+        if ($uri =~ 'close' && $port == port(8081) && $count++ % 3 == 0)
+        {
+            next;
+        }
+
+        print $client <<EOF;
+HTTP/1.1 200 OK
+Connection: close
+X-Port: $port
+
+OK
+EOF
+
+        close $client;
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_zone_ssl.t ../asynch_mode_nginx/test/nginx-tests/upstream_zone_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_zone_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_zone_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,127 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream zone with ssl backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy http_ssl upstream_zone/)
+    ->has_daemon('openssl')->plan(9)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 backup;
+        server 127.0.0.1:8082 down;
+    }
+
+    server {
+        listen 127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+
+        ssl_certificate_key localhost.key;
+        ssl_certificate localhost.crt;
+        ssl_session_cache builtin;
+
+        location / {
+            add_header X-Session $ssl_session_reused;
+        }
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+        %%PROXY_ASYNCH_ENABLE%%
+
+        proxy_ssl_session_reuse off;
+
+        location /ssl_reuse {
+            proxy_pass https://u/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /ssl {
+            proxy_pass https://u/;
+        }
+
+        location /backup_reuse {
+            proxy_pass https://u2/;
+            proxy_ssl_session_reuse on;
+        }
+
+        location /backup {
+            proxy_pass https://u2/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+$t->write_file('index.html', '');
+
+my $d = $t->testdir();
+
+foreach my $name ('localhost') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl');
+like(http_get('/ssl'), qr/200 OK.*X-Session: \./s, 'ssl 2');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: \./s, 'ssl session new');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused');
+like(http_get('/ssl_reuse'), qr/200 OK.*X-Session: r/s, 'ssl session reused 2');
+
+like(http_get('/backup'), qr/200 OK.*X-Session: \./s, 'backup');
+like(http_get('/backup'), qr/200 OK.*X-Session: \./s, 'backup 2');
+like(http_get('/backup_reuse'), qr/200 OK.*X-Session: \./s, 'backup new');
+like(http_get('/backup_reuse'), qr/200 OK.*X-Session: r/s, 'backup reused');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/upstream_zone.t ../asynch_mode_nginx/test/nginx-tests/upstream_zone.t
--- nginx-release-1.20.1/test/nginx-tests/upstream_zone.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/upstream_zone.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,85 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for upstream zone.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy upstream_zone/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        zone u 1m;
+        server 127.0.0.1:8081;
+    }
+
+    upstream u2 {
+        zone u;
+        server 127.0.0.1:8081 down;
+        server 127.0.0.1:8081 backup down;
+    }
+
+    server {
+        listen       127.0.0.1:8081;
+        server_name  localhost;
+
+        location / {}
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        add_header X-Name $upstream_addr always;
+
+        location / {
+            proxy_pass http://u/;
+        }
+
+        location /down {
+            proxy_pass http://u2/;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->run();
+
+###############################################################################
+
+my $p = port(8081);
+
+like(http_get('/'), qr/X-Name: 127.0.0.1:$p/, 'upstream name');
+like(http_get('/down'), qr/X-Name: u2/, 'no live upstreams');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/userid_flags.t ../asynch_mode_nginx/test/nginx-tests/userid_flags.t
--- nginx-release-1.20.1/test/nginx-tests/userid_flags.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/userid_flags.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,84 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for the userid_flags directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http userid/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        userid         on;
+        userid_name    test;
+        userid_path    /0123456789;
+        userid_domain  test.domain;
+
+        location / {
+            userid_flags samesite=strict;
+
+            location /many {
+                userid_flags httponly samesite=none secure;
+            }
+
+            location /off {
+                userid_flags off;
+            }
+        }
+
+        location /lax {
+            userid_flags samesite=lax;
+        }
+
+        location /unset { }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('lax', '');
+$t->write_file('many', '');
+$t->try_run('no userid_flags')->plan(5);
+
+###############################################################################
+
+like(http_get('/'), qr/samesite=strict/i, 'strict');
+like(http_get('/lax'), qr/samesite=lax/i, 'lax');
+like(http_get('/many'), qr/secure; httponly; samesite=none/i, 'many');
+unlike(http_get('/off'), qr/(secure|httponly|samesite)/i, 'off');
+unlike(http_get('/unset'), qr/(secure|httponly|samesite)/i, 'unset');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/userid.t ../asynch_mode_nginx/test/nginx-tests/userid.t
--- nginx-release-1.20.1/test/nginx-tests/userid.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/userid.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,296 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Andrey Zelenkov
+# (C) Nginx, Inc.
+
+# Tests for userid filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use Config;
+use MIME::Base64;
+use Time::Local;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http userid map unix/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    map $args $uid_reset {
+        default      0;
+        value        1;
+        log          log;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        listen       [::1]:%%PORT_8080%%;
+        listen       unix:%%TESTDIR%%/unix.sock;
+        server_name  localhost;
+
+        add_header X-Got $uid_got;
+        add_header X-Reset $uid_reset;
+        add_header X-Set $uid_set;
+        userid on;
+
+        location / {
+            error_log %%TESTDIR%%/error.log debug;
+            error_log %%TESTDIR%%/error_reset.log info;
+        }
+
+        location /name {
+            userid_name test;
+        }
+
+        location /path {
+            userid_path /0123456789;
+
+            location /path/r {
+                userid_path /9876543210;
+            }
+        }
+
+        location /domain {
+            userid_domain test.domain;
+        }
+
+        location /mark_off {
+            userid_mark off;
+        }
+        location /mark_eq {
+            userid_mark =;
+        }
+        location /mark_let {
+            userid_mark t;
+        }
+        location /mark_num {
+            userid_mark 9;
+        }
+
+        location /expires_time {
+            add_header X-Msec $msec;
+            userid_expires 100;
+        }
+        location /expires_max {
+            userid_expires max;
+
+            location /expires_max/off {
+                userid_expires off;
+            }
+        }
+        location /expires_off {
+            userid_expires off;
+        }
+
+        location /p3p {
+            userid_p3p policyref="/w3c/p3p.xml";
+        }
+
+        location /service {
+            userid_service 65534;
+        }
+
+        location /cv1 {
+            userid v1;
+            userid_mark t;
+        }
+
+        location /ip6 {
+            userid off;
+            proxy_pass http://[::1]:%%PORT_8080%%/;
+        }
+
+        location /unix {
+            userid off;
+            proxy_pass http://unix:%%TESTDIR%%/unix.sock:/;
+        }
+
+        location /clog {
+            userid log;
+        }
+
+        location /coff {
+            userid off;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('index.html', '');
+$t->write_file('expires_time', '');
+$t->write_file('service', '');
+$t->write_file('cv1', '');
+$t->write_file('clog', '');
+$t->write_file('coff', '');
+$t->try_run('no inet6 support')->plan(35);
+
+###############################################################################
+
+# userid
+
+like(http_get('/'), qr/Set-Cookie:/, 'cookie on');
+like(http_get('/cv1'), qr/Set-Cookie:/, 'cookie v1');
+unlike(http_get('/clog'), qr/Set-Cookie:/, 'cookie log');
+unlike(http_get('/coff'), qr/Set-Cookie:/, 'cookie off');
+
+# default
+
+my %cookie = get_cookie('/');
+isnt($cookie{'uid'}, undef, 'name default');
+is($cookie{'path'}, '/', 'path default');
+is($cookie{'domain'}, undef, 'domain default');
+is($cookie{'expires'}, undef, 'expires default');
+like($cookie{'uid'}, '/\w+={0,2}$/', 'mark default');
+unlike(http_get('/'), qr/^P3P/m, 'p3p default');
+like(http_get('/'), qr/X-Reset: 0/, 'uid reset variable default');
+
+# name, path, domain and p3p
+
+isnt(get_cookie('/name', 'test'), undef, 'name');
+is(get_cookie('/path', 'path'), '/0123456789', 'path');
+is(get_cookie('/domain', 'domain'), 'test.domain', 'domain');
+like(http_get('/p3p'), qr!P3P: policyref="/w3c/p3p.xml"!, 'p3p');
+
+# mark
+
+like(get_cookie('/mark_off', 'uid'), '/\w+={0,2}$/', 'mark off');
+like(get_cookie('/mark_eq', 'uid'), '/==$/', 'mark equal');
+like(get_cookie('/mark_let', 'uid'), '/t=$/', 'mark letter');
+like(get_cookie('/mark_num', 'uid'), '/9=$/', 'mark number');
+
+# expires
+
+my $r = http_get('/expires_time');
+my ($t1) = $r =~ /X-Msec: (\d+)/;
+is(expires2timegm(cookie($r, 'expires')), $t1 + 100, 'expires time');
+is(get_cookie('/expires_max', 'expires'), 'Thu, 31-Dec-37 23:55:55 GMT',
+    'expires max');
+is(get_cookie('/expires_off', 'expires'), undef, 'expires off');
+
+# redefinition
+
+unlike(http_get('/expires_max/off'), qr/expires/, 'redefine expires');
+like(http_get('/path/r'), qr!/9876543210!, 'redefine path');
+
+# requests
+
+$r = http_get('/');
+my ($uid) = uid_set($r);
+isnt($uid, undef, 'uid set variable');
+
+$r = send_uid('/', cookie($r, 'uid'));
+is(uid_got($r), $uid, 'uid got variable');
+unlike($r, qr/Set-Cookie:/, 'same path request');
+
+$r = send_uid('/coff', $uid);
+unlike($r, qr/Set-Cookie:/, 'other path request');
+
+$r = send_uid('/?value', $uid);
+like($r, qr/Set-Cookie:/, 'uid reset variable value');
+
+# service
+
+is(substr(uid_set(http_get('/cv1')), 0, 8), '00000000', 'service default v1');
+
+my $bigendian = $Config{byteorder} =~ '1234' ? 0 : 1;
+my $addr = $bigendian ? "7F000001" : "0100007F";
+is(substr(uid_set(http_get('/')), 0, 8), $addr, 'service default v2');
+
+$addr = $bigendian ? "0000FFFE" : "FEFF0000";
+is(substr(uid_set(http_get('/service')), 0, 8), $addr, 'service custom');
+
+$addr = $bigendian ? "00000001" : "01000000";
+is(substr(uid_set(http_get('/ip6')), 0, 8), $addr, 'service ipv6');
+
+is(substr(uid_set(http_get('/unix')), 0, 8), "00000000", 'service unix');
+
+# reset log
+
+send_uid('/?log', cookie($r, 'uid'));
+
+$t->stop();
+
+like($t->read_file('error_reset.log'),
+    '/userid cookie "uid=\w+" was reset/m', 'uid reset variable log');
+
+###############################################################################
+
+sub cookie {
+    my ($r, $key) = @_;
+    my %cookie;
+
+    $r =~ /(Set-Cookie:[^\x0d]*).*\x0d\x0a?\x0d/ms;
+    if ($1) {
+        %cookie = $1 =~ /(\w+)=([^;]+)/g;
+    }
+
+    return $cookie{$key} if defined $key;
+    return %cookie;
+}
+
+sub get_cookie {
+    my ($url, $key) = @_;
+    return cookie(http_get($url), $key);
+}
+
+sub expires2timegm {
+    my ($e) = @_;
+    my %months = (Jan => 0, Feb => 1, Mar => 2, Apr => 3, May =>4, Jun => 5,
+        Jul => 6, Aug => 7, Sep => 8, Oct => 9, Nov => 10, Dec => 11);
+
+    my ($w, $date, $time) = split(" ", $e);
+    my ($day, $month, $year) = split("-", $date);
+    my ($hour, $min, $sec) = split(":", $time);
+
+    return timegm($sec, $min, $hour, $day, $months{$month}, $year);
+}
+
+sub uid_set {
+    my ($r) = @_;
+    my ($uid) = $r =~ /X-Set: uid=(.*)\n/m;
+    return $uid;
+}
+
+sub uid_got {
+    my ($r) = @_;
+    my ($uid) = $r =~ /X-Got: uid=(.*)\n/m;
+    return $uid;
+}
+
+sub send_uid {
+    my ($url, $uid) = @_;
+    return http(<<EOF);
+GET $url HTTP/1.0
+Host: localhost
+Cookie: uid=$uid
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_certificate.t ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_certificate.t
--- nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_certificate.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_certificate.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,146 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http uwsgi module with client certificate to ssl backend.
+# The uwsgi_ssl_certificate and uwsgi_ssl_password_file directives.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl uwsgi/)
+    ->has_daemon('openssl')->plan(5);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        uwsgi_ssl_session_reuse off;
+
+        location /verify {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_certificate 1.example.com.crt;
+            uwsgi_ssl_certificate_key 1.example.com.key;
+        }
+
+        location /fail {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_certificate 2.example.com.crt;
+            uwsgi_ssl_certificate_key 2.example.com.key;
+        }
+
+        location /encrypted {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_certificate 3.example.com.crt;
+            uwsgi_ssl_certificate_key 3.example.com.key;
+            uwsgi_ssl_password_file password;
+        }
+    }
+
+    # stub to implement SSL logic for tests
+
+    server {
+        listen       127.0.0.1:8081 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        add_header X-Verify $ssl_client_verify always;
+        add_header X-Name   $ssl_client_s_dn   always;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl %%SSL_ASYNCH%%;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        add_header X-Verify $ssl_client_verify always;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->run();
+
+###############################################################################
+
+like(http_get('/verify'), qr/X-Verify: SUCCESS/ms, 'verify certificate');
+like(http_get('/fail'), qr/X-Verify: FAILED/ms, 'fail certificate');
+like(http_get('/encrypted'), qr/X-Verify: SUCCESS/ms, 'with encrypted key');
+
+like(http_get('/verify'), qr!X-Name: /?CN=1.example!, 'valid certificate');
+unlike(http_get('/fail'), qr!X-Name: /?CN=1.example!, 'invalid certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_certificate_vars.t ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_certificate_vars.t
--- nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_certificate_vars.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_certificate_vars.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for http uwsgi module with variables in ssl certificates.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl uwsgi/)
+    ->has_daemon('openssl');
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        uwsgi_ssl_session_reuse off;
+
+        location / {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_certificate $arg_cert.example.com.crt;
+            uwsgi_ssl_certificate_key $arg_cert.example.com.key;
+        }
+
+        location /encrypted {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_certificate $arg_cert.example.com.crt;
+            uwsgi_ssl_certificate_key $arg_cert.example.com.key;
+            uwsgi_ssl_password_file password;
+        }
+
+        location /none {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_certificate $arg_cert;
+            uwsgi_ssl_certificate_key $arg_cert;
+        }
+    }
+
+    # stub to implement SSL logic for tests
+
+    server {
+        listen       127.0.0.1:8081 ssl;
+        server_name  localhost;
+
+        ssl_certificate 2.example.com.crt;
+        ssl_certificate_key 2.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 1.example.com.crt;
+
+        add_header X-Verify $ssl_client_verify always;
+        add_header X-Name   $ssl_client_s_dn   always;
+    }
+
+    server {
+        listen       127.0.0.1:8082 ssl;
+        server_name  localhost;
+
+        ssl_certificate 1.example.com.crt;
+        ssl_certificate_key 1.example.com.key;
+
+        ssl_verify_client optional_no_ca;
+        ssl_trusted_certificate 3.example.com.crt;
+
+        add_header X-Verify $ssl_client_verify always;
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+foreach my $name ('3.example.com') {
+    system("openssl genrsa -out $d/$name.key -passout pass:$name "
+        . "-aes128 2048 >>$d/openssl.out 2>&1") == 0
+        or die "Can't create private key: $!\n";
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt "
+        . "-key $d/$name.key -passin pass:$name"
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+sleep 1 if $^O eq 'MSWin32';
+
+$t->write_file('password', '3.example.com');
+$t->write_file('index.html', '');
+
+$t->try_run('no upstream ssl_certificate variables')->plan(4);
+
+###############################################################################
+
+like(http_get('/?cert=1'),
+    qr/X-Verify: SUCCESS/ms, 'variable - verify certificate');
+like(http_get('/?cert=2'),
+    qr/X-Verify: FAILED/ms, 'variable - fail certificate');
+like(http_get('/encrypted?cert=3'),
+    qr/X-Verify: SUCCESS/ms, 'variable - with encrypted key');
+like(http_get('/none'),
+    qr/X-Verify: NONE/ms, 'variable - no certificate');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl.t ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl.t
--- nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,188 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Nginx, Inc.
+
+# Test for uwsgi backend with SSL.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+use Socket qw/ CRLF /;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http uwsgi http_ssl/)
+    ->has_daemon('uwsgi')->has_daemon('openssl')->plan(7)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+            uwsgi_param HTTP_X_BLAH "blah";
+            uwsgi_pass_request_body off;
+        }
+
+        location /var {
+            uwsgi_pass suwsgi://$arg_b;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.conf', <<EOF);
+[ req ]
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+[ req_distinguished_name ]
+EOF
+
+my $d = $t->testdir();
+my $crt = "$d/uwsgi.crt";
+my $key = "$d/uwsgi.key";
+
+foreach my $name ('uwsgi') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.conf -subj /CN=$name/ "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('uwsgi_test_app.py', <<END);
+
+def application(env, start_response):
+    start_response('200 OK', [('Content-Type','text/plain')])
+    return b"SEE-THIS"
+
+END
+
+my $uwsgihelp = `uwsgi -h`;
+my @uwsgiopts = ();
+
+if ($uwsgihelp !~ /--wsgi-file/) {
+    # uwsgi has no python support, maybe plugin load is necessary
+    push @uwsgiopts, '--plugin', 'python';
+    push @uwsgiopts, '--plugin', 'python3';
+}
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run_daemon('uwsgi', @uwsgiopts,
+    '--ssl-socket', '127.0.0.1:' . port(8081) . ",$crt,$key",
+    '--wsgi-file', $d . '/uwsgi_test_app.py',
+    '--logto', $d . '/uwsgi_log');
+open STDERR, ">&", \*OLDERR;
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start uwsgi";
+
+###############################################################################
+
+TODO: {
+todo_skip 'not yet', 7 unless $t->has_version('1.19.1');
+
+like(http_get('/'), qr/SEE-THIS/, 'uwsgi request');
+like(http_head('/head'), qr/200 OK(?!.*SEE-THIS)/s, 'no data in HEAD');
+
+like(http_get_headers('/headers'), qr/SEE-THIS/,
+    'uwsgi request with many ignored headers');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+    'uwsgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'uwsgi with variables to upstream');
+
+like(http_post('/'), qr/SEE-THIS/, 'uwsgi post');
+like(http_post_big('/'), qr/SEE-THIS/, 'uwsgi big post');
+
+}
+
+###############################################################################
+
+sub http_get_headers {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+sub http_post {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10" . CRLF .
+        CRLF .
+        "1234567890";
+
+    return http($p, %extra);
+}
+
+sub http_post_big {
+    my ($url, %extra) = @_;
+
+    my $p = "POST $url HTTP/1.0" . CRLF .
+        "Host: localhost" . CRLF .
+        "Content-Length: 10240" . CRLF .
+        CRLF .
+        ("1234567890" x 1024);
+
+    return http($p, %extra);
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_verify.t ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_verify.t
--- nginx-release-1.20.1/test/nginx-tests/uwsgi_ssl_verify.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/uwsgi_ssl_verify.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,183 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for uwsgi backend with SSL, backend certificate verification.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_ssl uwsgi/)
+    ->has_daemon('uwsgi')->has_daemon('openssl')->plan(6)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location /verify {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_name example.com;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /wildcard {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_name foo.example.com;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /fail {
+            uwsgi_pass suwsgi://127.0.0.1:8081;
+            uwsgi_ssl_name no.match.example.com;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 1.example.com.crt;
+        }
+
+        location /cn {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_name 2.example.com;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /cn/fail {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_name bad.example.com;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 2.example.com.crt;
+        }
+
+        location /untrusted {
+            uwsgi_pass suwsgi://127.0.0.1:8082;
+            uwsgi_ssl_verify on;
+            uwsgi_ssl_trusted_certificate 1.example.com.crt;
+            uwsgi_ssl_session_reuse off;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('openssl.1.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+x509_extensions = v3_req
+
+[ req_distinguished_name ]
+commonName=no.match.example.com
+
+[ v3_req ]
+subjectAltName = DNS:example.com,DNS:*.example.com
+EOF
+
+$t->write_file('openssl.2.example.com.conf', <<EOF);
+[ req ]
+prompt = no
+default_bits = 2048
+encrypt_key = no
+distinguished_name = req_distinguished_name
+
+[ req_distinguished_name ]
+commonName=2.example.com
+EOF
+
+my $d = $t->testdir();
+my $crt1 = "$d/1.example.com.crt";
+my $crt2 = "$d/2.example.com.crt";
+my $key1 = "$d/1.example.com.key";
+my $key2 = "$d/2.example.com.key";
+
+foreach my $name ('1.example.com', '2.example.com') {
+    system('openssl req -x509 -new '
+        . "-config $d/openssl.$name.conf "
+        . "-out $d/$name.crt -keyout $d/$name.key "
+        . ">>$d/openssl.out 2>&1") == 0
+        or die "Can't create certificate for $name: $!\n";
+}
+
+$t->write_file('uwsgi_test_app.py', <<END);
+
+def application(env, start_response):
+    start_response('200 OK', [('Content-Type','text/plain')])
+    return b"SEE-THIS"
+
+END
+
+my $uwsgihelp = `uwsgi -h`;
+my @uwsgiopts = ();
+
+if ($uwsgihelp !~ /--wsgi-file/) {
+    # uwsgi has no python support, maybe plugin load is necessary
+    push @uwsgiopts, '--plugin', 'python';
+    push @uwsgiopts, '--plugin', 'python3';
+}
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run_daemon('uwsgi', @uwsgiopts,
+    '--ssl-socket', '127.0.0.1:' . port(8081) . ",$crt1,$key1",
+    '--wsgi-file', $d . '/uwsgi_test_app.py',
+    '--logto', $d . '/uwsgi_log');
+$t->run_daemon('uwsgi', @uwsgiopts,
+    '--ssl-socket', '127.0.0.1:' . port(8082) . ",$crt2,$key2",
+    '--wsgi-file', $d . '/uwsgi_test_app.py',
+    '--logto', $d . '/uwsgi_log');
+open STDERR, ">&", \*OLDERR;
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start uwsgi";
+$t->waitforsocket('127.0.0.1:' . port(8082))
+    or die "Can't start uwsgi";
+
+###############################################################################
+
+# subjectAltName
+
+like(http_get('/verify'), qr/200 OK/ms, 'verify');
+like(http_get('/wildcard'), qr/200 OK/ms, 'verify wildcard');
+like(http_get('/fail'), qr/502 Bad/ms, 'verify fail');
+
+# commonName
+
+like(http_get('/cn'), qr/200 OK/ms, 'verify cn');
+like(http_get('/cn/fail'), qr/502 Bad/ms, 'verify cn fail');
+
+# untrusted
+
+like(http_get('/untrusted'), qr/502 Bad/ms, 'untrusted');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/uwsgi.t ../asynch_mode_nginx/test/nginx-tests/uwsgi.t
--- nginx-release-1.20.1/test/nginx-tests/uwsgi.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/uwsgi.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Test for uwsgi backend.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http uwsgi/)->has_daemon('uwsgi')->plan(5)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    upstream u {
+        server 127.0.0.1:8081;
+    }
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            uwsgi_pass 127.0.0.1:8081;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+            uwsgi_param HTTP_X_BLAH "blah";
+        }
+
+        location /var {
+            uwsgi_pass $arg_b;
+            uwsgi_param SERVER_PROTOCOL $server_protocol;
+        }
+    }
+}
+
+EOF
+
+$t->write_file('uwsgi_test_app.py', <<END);
+
+def application(env, start_response):
+    start_response('200 OK', [('Content-Type','text/plain')])
+    return b"SEE-THIS"
+
+END
+
+my $uwsgihelp = `uwsgi -h`;
+my @uwsgiopts = ();
+
+if ($uwsgihelp !~ /--wsgi-file/) {
+    # uwsgi has no python support, maybe plugin load is necessary
+    push @uwsgiopts, '--plugin', 'python';
+    push @uwsgiopts, '--plugin', 'python3';
+}
+
+open OLDERR, ">&", \*STDERR; close STDERR;
+$t->run_daemon('uwsgi', '--socket', '127.0.0.1:' . port(8081), @uwsgiopts,
+    '--wsgi-file', $t->testdir() . '/uwsgi_test_app.py',
+    '--logto', $t->testdir() . '/uwsgi_log');
+open STDERR, ">&", \*OLDERR;
+
+$t->run();
+
+$t->waitforsocket('127.0.0.1:' . port(8081))
+    or die "Can't start uwsgi";
+
+###############################################################################
+
+like(http_get('/'), qr/SEE-THIS/, 'uwsgi request');
+unlike(http_head('/head'), qr/SEE-THIS/, 'no data in HEAD');
+
+like(http_get_headers('/headers'), qr/SEE-THIS/,
+    'uwsgi request with many ignored headers');
+
+like(http_get('/var?b=127.0.0.1:' . port(8081)), qr/SEE-THIS/,
+    'uwsgi with variables');
+like(http_get('/var?b=u'), qr/SEE-THIS/, 'uwsgi with variables to upstream');
+
+###############################################################################
+
+sub http_get_headers {
+    my ($url, %extra) = @_;
+    return http(<<EOF, %extra);
+GET $url HTTP/1.0
+Host: localhost
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+X-Blah: ignored header
+
+EOF
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_h2.t ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_h2.t
--- nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_h2.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_h2.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout and HTTP/2 with proxy.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::HTTP2;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http http_v2 proxy/)->plan(2);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080 http2;
+        server_name  localhost;
+
+        location / {
+            proxy_pass http://127.0.0.1:8081;
+            proxy_read_timeout 5s;
+        }
+    }
+}
+EOF
+
+$t->run_daemon(\&http_silent_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = Test::Nginx::HTTP2->new();
+ok($s->new_stream(), 'new stream');
+
+$s->h2_ping('SEE-THIS');
+$s->read(all => [{ type => 'PING' }]);
+
+$t->stop();
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.17.4');
+
+like($t->read_file('access.log'), qr/ (?!504)\d{3} /, 'shutdown timeout');
+
+}
+
+$t->todo_alerts() unless $t->has_version('1.17.4');
+
+###############################################################################
+
+sub http_silent_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalAddr => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    while (my $client = $server->accept()) {
+        $client->autoflush(1);
+
+        while (<$client>) { }
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_mail.t ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_mail.t
--- nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_mail.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_mail.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive within the mail module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use MIME::Base64;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/mail imap http rewrite/)->plan(4)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+mail {
+    proxy_pass_error_message  on;
+    proxy_timeout  15s;
+    auth_http  http://127.0.0.1:8080/mail/auth;
+    xclient    off;
+
+    server {
+        listen     127.0.0.1:8025;
+        protocol   smtp;
+    }
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location = /mail/auth {
+            add_header Auth-Status OK;
+            add_header Auth-Server 127.0.0.1;
+            add_header Auth-Port %%PORT_8026%%;
+            add_header Auth-Wait 1;
+            return 204;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$s->send('AUTH PLAIN ' . encode_base64("\0test\@example.com\0secret", ''));
+$s->authok('auth plain');
+
+$t->reload();
+
+ok($s->can_read(), 'mail connection shutdown');
+
+undef $s;
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_proxy_upgrade.t ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_proxy_upgrade.t
--- nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_proxy_upgrade.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_proxy_upgrade.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,122 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive with http proxy upgrade stub.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http proxy/)->plan(2)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / {
+            proxy_pass    http://127.0.0.1:8081;
+            proxy_http_version 1.1;
+            proxy_set_header Upgrade foo;
+            proxy_set_header Connection Upgrade;
+        }
+    }
+}
+
+EOF
+
+$t->run_daemon(\&http_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8081));
+
+###############################################################################
+
+my $s = http(<<EOF, start => 1);
+GET / HTTP/1.1
+Host: localhost
+Upgrade: foo
+Connection: Upgrade
+
+EOF
+
+my ($sel, $buf) = IO::Select->new($s);
+if ($sel->can_read(5)) {
+    $s->sysread($buf, 1024);
+    log_in($buf);
+};
+
+like($buf, qr!HTTP/1.1 101!, 'upgraded connection');
+
+$t->reload();
+
+ok($sel->can_read(3), 'upgraded connection shutdown');
+
+undef $s;
+
+###############################################################################
+
+sub http_daemon {
+    my $server = IO::Socket::INET->new(
+        Proto => 'tcp',
+        LocalHost => '127.0.0.1:' . port(8081),
+        Listen => 5,
+        Reuse => 1
+    )
+        or die "Can't create listening socket: $!\n";
+
+    local $SIG{PIPE} = 'IGNORE';
+
+    my $client;
+
+    while ($client = $server->accept()) {
+        $client->autoflush(1);
+
+        my $headers = '';
+        my $uri = '';
+
+        while (<$client>) {
+            $headers .= $_;
+            last if (/^\x0d?\x0a?$/);
+        }
+
+        next if $headers eq '';
+
+        print $client <<'EOF';
+HTTP/1.1 101 Switching
+Upgrade: foo
+Connection: Upgrade
+
+EOF
+
+    }
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_stream.t ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_stream.t
--- nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout_stream.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout_stream.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,69 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive within the stream module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+use Test::Nginx::SMTP;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+local $SIG{PIPE} = 'IGNORE';
+
+my $t = Test::Nginx->new()->has(qw/stream/)->plan(3)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+stream {
+    %%TEST_GLOBALS_STREAM%%
+
+    server {
+        listen       127.0.0.1:8025;
+        proxy_pass   127.0.0.1:8026;
+    }
+}
+
+EOF
+
+$t->run_daemon(\&Test::Nginx::SMTP::smtp_test_daemon);
+$t->run()->waitforsocket('127.0.0.1:' . port(8026));
+
+###############################################################################
+
+my $s = Test::Nginx::SMTP->new();
+$s->check(qr/^220 /, "greeting");
+
+$s->send('EHLO example.com');
+$s->check(qr/^250 /, "ehlo");
+
+$t->reload();
+
+ok($s->can_read(), 'stream connection shutdown');
+
+undef $s;
+1;
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout.t ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout.t
--- nginx-release-1.20.1/test/nginx-tests/worker_shutdown_timeout.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/worker_shutdown_timeout.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,68 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Sergey Kandaurov
+# (C) Nginx, Inc.
+
+# Tests for worker_shutdown_timeout directive.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+use IO::Select;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http/)
+    ->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+worker_shutdown_timeout 10ms;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        location / { }
+    }
+}
+
+EOF
+
+$t->run()->plan(1);
+
+###############################################################################
+
+my $s = http('', start => 1);
+
+select undef, undef, undef, 0.2;
+
+$t->reload();
+
+if (IO::Select->new($s)->can_read(5)) {
+    Test::Nginx::log_core('||', "select: can_read");
+}
+
+is(http_get('/', socket => $s) || '', '', 'worker_shutdown_timeout');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/xslt_params.t ../asynch_mode_nginx/test/nginx-tests/xslt_params.t
--- nginx-release-1.20.1/test/nginx-tests/xslt_params.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/xslt_params.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,107 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx xslt filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http xslt/);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        default_type text/xml;
+
+        location /x1 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root param3='value%33';
+        }
+        location /x2 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+            xslt_param param1 "'value1'";
+            xslt_param param2 "/root";
+            xslt_string_param param3 "value3";
+        }
+        location /x3 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root;
+            xslt_string_param param3 "value3";
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="html"/>
+
+<xsl:param name="param1"/>
+<xsl:param name="param2"/>
+<xsl:param name="param3"/>
+
+<xsl:template match="/">
+param1=<xsl:value-of select="$param1"/>
+param2=<xsl:value-of select="$param2"/>
+param3=<xsl:value-of select="$param3"/>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('x1', '<root>data</root>');
+$t->write_file('x2', '<root>data</root>');
+$t->write_file('x3', '<root>data</root>');
+
+$t->run()->plan(4);
+
+###############################################################################
+
+like(http_get("/x1"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+    'params from xslt_stylesheet');
+
+# before 1.13.7, nginx used to overwrite xslt_stylesheet configuration data
+
+like(http_get("/x1"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+    'params from xslt_stylesheet again');
+
+like(http_get("/x2"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+    'params from xslt_param/xslt_string_param');
+like(http_get("/x3"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+    'mixed');
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-tests/xslt.t ../asynch_mode_nginx/test/nginx-tests/xslt.t
--- nginx-release-1.20.1/test/nginx-tests/xslt.t	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-tests/xslt.t	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,147 @@
+#!/usr/bin/perl
+
+# Copyright (C) Intel, Inc.
+# (C) Maxim Dounin
+
+# Tests for nginx xslt filter module.
+
+###############################################################################
+
+use warnings;
+use strict;
+
+use Test::More;
+
+BEGIN { use FindBin; chdir($FindBin::Bin); }
+
+use lib 'lib';
+use Test::Nginx;
+
+###############################################################################
+
+select STDERR; $| = 1;
+select STDOUT; $| = 1;
+
+my $t = Test::Nginx->new()->has(qw/http xslt/)->plan(8);
+
+$t->write_file_expand('nginx.conf', <<'EOF');
+
+%%TEST_GLOBALS%%
+
+daemon off;
+
+events {
+}
+
+http {
+    %%TEST_GLOBALS_HTTP%%
+
+    server {
+        listen       127.0.0.1:8080;
+        server_name  localhost;
+
+        default_type text/xml;
+
+        location /x1 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x2 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='value1':param2=/root param3='value%33';
+        }
+        location /x3 {
+            xml_entities %%TESTDIR%%/entities.dtd;
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x4 {
+            xslt_stylesheet %%TESTDIR%%/first.xslt;
+            xslt_stylesheet %%TESTDIR%%/test.xslt;
+        }
+        location /x5 {
+            xslt_stylesheet %%TESTDIR%%/test.xslt
+                            param1='$server_name';
+        }
+    }
+}
+
+EOF
+
+$t->write_file('test.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="html"/>
+
+<xsl:param name="param1"/>
+<xsl:param name="param2"/>
+<xsl:param name="param3"/>
+
+<xsl:template match="/">
+test xslt result
+param1=<xsl:value-of select="$param1"/>
+param2=<xsl:value-of select="$param2"/>
+param3=<xsl:value-of select="$param3"/>
+data=<xsl:value-of select="/root"/>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('first.xslt', <<'EOF');
+
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:template match="/">
+<root>other <xsl:value-of select="/root"/></root>
+</xsl:template>
+
+</xsl:stylesheet>
+
+EOF
+
+$t->write_file('entities.dtd', '<!ENTITY test "test entity">' . "\n");
+$t->write_file('x1', '<empty/>');
+$t->write_file('x2', '<root>data</root>');
+$t->write_file('x3', '<!DOCTYPE root><root>&test;</root>');
+$t->write_file('x4', '<root>data</root>');
+$t->write_file('x5', '<root>data</root>');
+
+$t->run();
+
+###############################################################################
+
+like(http_get("/x1"), qr!200 OK.*test xslt result!ms, 'simple');
+like(http_get("/x1"), qr!200 OK.*Content-Type: text/html!ms, 'content type');
+like(http_get("/x2"), qr!200 OK.*param1=value1.*param2=data.*param3=value3!ms,
+    'params');
+like(http_get("/x3"), qr!200 OK.*data=test entity!ms, 'entities');
+like(http_get("/x4"), qr!200 OK.*data=other data!ms, 'several stylesheets');
+
+TODO: {
+todo_skip 'heap-buffer-overflow', 1 unless $t->has_version('1.17.2')
+    or $ENV{TEST_NGINX_UNSAFE};
+
+like(http_get("/x5"), qr!200 OK.*param1=localhost!ms, 'params variable');
+
+}
+
+# xslt and ranges
+
+TODO: {
+local $TODO = 'not yet' unless $t->has_version('1.19.2');
+
+unlike(http_get("/x1"), qr!Accept-Ranges!, 'no Accept-Ranges');
+like(http(<<EOF), qr!200 OK.*test xslt result!ms, 'no ranges');
+GET /x1 HTTP/1.1
+Host: localhost
+Connection: close
+Range: bytes=-10
+
+EOF
+
+}
+
+###############################################################################
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/nginx-test.sh ../asynch_mode_nginx/test/nginx-test.sh
--- nginx-release-1.20.1/test/nginx-test.sh	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/nginx-test.sh	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,186 @@
+#!/bin/bash
+
+#***************************************************************************
+# Copyright (C) Intel, Inc
+#
+# To perform nginx tests we need following package installed:
+#     libxslt libxslt-devel gd-devel perl pcre-devel GeoIP.x86_64 GeoIP-devel
+#***************************************************************************
+
+SCRIPT=$(readlink -f "$0")
+SCRIPTPATH=`dirname "$SCRIPT"`
+
+if [ ! -d "$NGINX_INSTALL_DIR" ]; then
+    echo -e "NGINX_INSTALL_DIR not set. Run:\n\t export NGINX_INSTALL_DIR=<asynch_mode_nginx installation directory>\n"
+    exit 0
+fi
+
+if [ ! -d "$OPENSSL_ROOT" ]; then
+    echo -e "OPENSSL_ROOT not set. Run:\n\t export OPENSSL_ROOT=<openssl source code directory>\n"
+    exit 0
+fi
+
+if [ ! -d "$OPENSSL_LIB" ]; then
+    echo -e "OPENSSL_LIB not set. Run:\n\t export OPENSSL_LIB=<openssl installation directory>\n"
+    exit 0
+fi
+
+if [ ! -d "$OPENSSL_ENGINES" ]; then
+    echo -e "OPENSSL_ENGINES not set. Run:\n\t export OPENSSL_ENGINES=<openssl engine installation directory>\n"
+    exit 0
+fi
+
+if [ ! -d "$NGINX_SRC_DIR" ]; then
+    echo -e "NGINX_SRC_DIR not set. Run:\n\t export NGINX_SRC_DIR=<asynch_mode_nginx source code directory>\n"
+    exit 0
+fi
+
+if [ ! -d "$QZ_ROOT" ]; then
+    echo -e "QZ_ROOT not set. Run:\n\t export QZ_ROOT=<QATzip source code directory>\n"
+    exit 0
+fi
+
+function printHelp ()
+{
+    echo -e "Usage ./nginx-test.sh X\n" "X can be:\n" "\t qat -- qatengine\n" "\t dasync -- openssl async engine\n" "\t official -- original nginx-tests"
+}
+
+if [ "$#" == '1' ];then
+    if [[ $1 != 'qat' && $1 != 'dasync' && $1 != 'official' ]];then
+        printHelp
+        exit 0
+    fi
+else
+    printHelp
+    exit 0
+fi
+
+cd $NGINX_SRC_DIR
+./configure \
+--prefix=$NGINX_INSTALL_DIR \
+--user=root \
+--group=root \
+--with-file-aio \
+--with-http_realip_module \
+--with-http_addition_module \
+--with-http_xslt_module \
+--with-http_image_filter_module \
+--with-http_geoip_module \
+--with-http_sub_module \
+--with-http_dav_module \
+--with-http_flv_module \
+--with-http_mp4_module \
+--with-http_gzip_static_module \
+--with-http_random_index_module \
+--with-http_secure_link_module \
+--with-http_degradation_module \
+--with-http_stub_status_module \
+--with-http_perl_module \
+--with-http_auth_request_module \
+--with-mail \
+--with-mail_ssl_module \
+--with-debug \
+--with-http_gunzip_module \
+--with-http_ssl_module \
+--with-http_v2_module \
+--with-http_slice_module \
+--with-stream \
+--with-stream_ssl_module \
+--with-stream_ssl_preread_module \
+--add-dynamic-module=$NGINX_SRC_DIR/modules/nginx_qat_module \
+--add-dynamic-module=$NGINX_SRC_DIR/modules/nginx_qatzip_module \
+--with-cc-opt="-DNGX_SECURE_MEM -DNGX_INTEL_SDL -I$OPENSSL_LIB/include -I$ICP_ROOT/quickassist/include -I$ICP_ROOT/quickassist/include/dc -I$QZ_ROOT/include -Wno-error=deprecated-declarations" \
+--with-ld-opt="-Wl,-rpath=$OPENSSL_LIB/lib -L$OPENSSL_LIB/lib -L$QZ_ROOT/src -lqatzip -lz"
+
+make && make install
+
+#Only for Centos 7, prepare env..."
+
+NGINX_PERL_OBJS=$NGINX_SRC_DIR/objs/src/http/modules/perl
+NGINX_AUTO_OBJS=$NGINX_PERL_OBJS/blib/arch/auto/nginx
+NGINX_PERL_INSTALL_DIR=/usr/share/perl5/
+NGINX_AUTO_INSTALL_DIR=/usr/share/perl5/auto/nginx/
+mkdir -p $NGINX_AUTO_INSTALL_DIR
+cp $NGINX_PERL_OBJS/nginx.bs $NGINX_PERL_INSTALL_DIR
+cp $NGINX_AUTO_OBJS/nginx.so $NGINX_AUTO_INSTALL_DIR
+cp $NGINX_PERL_OBJS/nginx.pm $NGINX_PERL_INSTALL_DIR
+cp $OPENSSL_ROOT/engines/dasync.so $OPENSSL_ENGINES/
+cp $NGINX_SRC_DIR/objs/ngx_ssl_engine_qat_module.so $NGINX_INSTALL_DIR/modules/ngx_ssl_engine_qat_module_for_test.so;
+cp $NGINX_SRC_DIR/objs/ngx_http_qatzip_filter_module.so $NGINX_INSTALL_DIR/modules/ngx_http_qatzip_filter_module_for_test.so
+cp objs/nginx $NGINX_INSTALL_DIR/sbin/nginx-for-test;
+
+#Prepare envionment variables...
+
+if [ $1 == 'qat' ];then
+    # Enable async against QAT_Engine
+    export TEST_LOAD_NGINX_MODULE="load_module $NGINX_INSTALL_DIR/modules/ngx_ssl_engine_qat_module_for_test.so;"
+    export TEST_LOAD_QATZIP_MODULE="load_module $NGINX_INSTALL_DIR/modules/ngx_http_qatzip_filter_module_for_test.so;"
+    export TEST_NGINX_GLOBALS="
+    $TEST_LOAD_NGINX_MODULE
+    $TEST_LOAD_QATZIP_MODULE
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms ALL;
+        qat_engine {
+            qat_offload_mode async;
+            qat_notify_mode poll;
+            qat_poll_mode heuristic;
+        }
+    }
+    "
+    export TEST_NGINX_GLOBALS_HTTP="qatzip_sw only;"
+    export TEST_NGINX_GLOBALS_HTTPS="ssl_asynch on;"
+    export GRPC_ASYNCH_ENABLE="grpc_ssl_asynch on;"
+    export PROXY_ASYNCH_ENABLE="proxy_ssl_asynch on;"
+    export PROXY_ASYNCH_DISABLE="proxy_ssl_asynch off;"
+    export SSL_ASYNCH=" asynch"
+    export GZIP_MIN_LENGTH_0="gzip_min_length 0;"
+    export QATZIP_TYPES="qatzip_types text/plain;"
+    export QATZIP_ENABLE="qatzip_sw no;"
+    export QATZIP_DISABLE="qatzip_sw only;"
+    export QATZIP_MIN_LENGTH_0="qatzip_min_length 0;"
+elif [ $1 == 'dasync' ];then
+    # Enable async against dasync engine
+    export TEST_NGINX_GLOBALS="
+    ssl_engine {
+        use_engine dasync;
+    }
+    "
+    export TEST_NGINX_GLOBALS_HTTPS="ssl_asynch on;"
+    export GRPC_ASYNCH_ENABLE="grpc_ssl_asynch on;"
+    export PROXY_ASYNCH_ENABLE="proxy_ssl_asynch on;"
+    export PROXY_ASYNCH_DISABLE="proxy_ssl_asynch off;"
+    export SSL_ASYNCH=" asynch"
+    export GZIP_TYPES="gzip_types text/plain;"
+    export GZIP_MIN_LENGTH_0="gzip_min_length 0;"
+elif [ $1 == 'official' ]; then
+    # Original nginx tesets
+    export GZIP_TYPES="gzip_types text/plain;"
+    export GZIP_MIN_LENGTH_0="gzip_min_length 0;"
+fi
+
+# Start to platform tests...
+
+SELF=$$
+rm $SCRIPTPATH/nginx-test.log -f
+CASES=`find  $NGINX_SRC_DIR/ -name *.t`
+for CASE in $CASES
+do
+    TEST_NGINX_BINARY=$NGINX_INSTALL_DIR/sbin/nginx-for-test prove $CASE >> $SCRIPTPATH/nginx-test.log 2>&1 &
+    CASEPID=$!
+    ( sleep 60; kill -9 $CASEPID > /dev/null 2>&1 && echo "case $CASE failed" && echo -e "Nginx Official Test RESULT:FAIL" && kill -9 $SELF ) &
+    DOG=$!
+    DOGPPID=$PPID
+    wait $CASEPID
+    kill $DOGPPID
+    RESULT=`grep Failed $SCRIPTPATH/nginx-test.log`
+    if [ "$RESULT" != "" ]
+    then
+        echo "case $CASE failed"
+        echo -e "Nginx Official Test RESULT:FAIL"
+        exit 0
+    fi
+done
+
+echo -e "Nginx Official Test RESULT:PASS"
+
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/performance_bkm/README.md ../asynch_mode_nginx/test/performance_bkm/README.md
--- nginx-release-1.20.1/test/performance_bkm/README.md	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/performance_bkm/README.md	2022-03-15 13:23:40.588403261 -0500
@@ -0,0 +1,1344 @@
+# NGINX+OPENSSL+QATENGINE+QAT|CORE BENCHMARKING METHODOLOGY
+
+The purpose of this README is to configure NGINX with OpenSSL+QATEngine+QAT|CORE, and measure Transport Layer Security (TLS) <b>1.2</b> algorithmic performance.  Where applicable, the algorithms can be offloaded to either Intel(R) Quickassist Technology(R) or Intel(R) Xeon(R) or Atom(TM)) core.
+
+## System Topology
+
+The general layout of the testing is as follows:
+
+EACH NODE IS A PLATFORM. Ensure to use enough clients/backend systems to avoid being performance bound.
+
+WEBSERVER: Basic use case
+[CLIENT(s)][172.16.N.2/24]<------>[172.16.N.1/24][[port 4400]NGINX Server]
+
+WEBPROXY: Most demanding both compute and IO use case
+[CLIENT(s)][172.16.N.2/24]<------>[172.16.N.1/24][[port 4400]NGINX Server][192.168.N.1/24]<------>[192.168.N.2/24][[port 8210]Backend Server]
+
+<i>Where N is between 1-255</i>
+
+For these tests, we use subnet 172.16.<i>N</i>.<b>1</b> port 4400 for the DUT and 172.16.<i>N</i>.<b>2</b> for the client(s).
+
+The general rule, is to use a single IP each 10GbE of Ethernet.  So if you have a 25GbE NIC port, in order to saturate each the port, it will be necessary to use more than one(1) IP per-port. For example:
+```bash
+#ON CLIENT
+ifconfig eth0:1 172.16.1.2/24
+ifconfig eth0:2 172.16.2.2/24
+#ON DUT
+ifconfig eth0:1 172.16.1.1/24
+ifconfig eth0:2 172.16.2.1/24
+```
+Ensure to balance the total IO across the client(s) so as to get an even distribution of client compute power.
+
+<b>The reason CLIENT(s) consists of an "s" is to ensure that the Client(s) are not the bottleneck.  So ensure to use enough clients with enough compute power to push requests to the NGINX Server.  If not, you could become client bound.</b>
+
+<b>ENSURE THE THE SERVER AND CLIENT SYSTEMS CAN PING</b>
+```bash
+ping 172.16.1.2 #from the server (DUT) should return an ICMP Reply message
+```
+
+
+## Setup
+You will need the following
+1. HARDWARE
+   1. A Server capable of maximizing performance of the QAT device under test.  So If your goal is to saturate a QAT device's maximum symmetric performance, you need to ensure it has enough PCIe slots available for network Input/Output (IO).
+   1. Network Interface Cards.  Ideally you want optical network cards and not copper.  The number and type depends on what you are trying to test.  If you are trying to only test Public Key Encryption such as RSA and ECDSA, you need only a few Gigabit Ethernet (GbE).  But if you are trying to test symmetric performance such as CBC or GCM, you need at least 10% more GbE than what the QAT device is capable of.  For example, if the QAT device is capable of 100Gbps AES-128-CBC-HMAC-SHA1, then you want at least 110GbE. This is due to the nature of running Layer 4-7 applications, since the ACK mechanism in Transmission Control Protocol (TCP) will create bubbles of unused Ethernet capacity.
+1. SOFTWARE (Be aware that the NGINX, OpenSSL, QAT Engine, and QAT Driver steps will be provided below.  This is just F.Y.I)
+   1. Ubuntu Server [18.04](https://releases.ubuntu.com/18.04/ubuntu-18.04.4-live-server-amd64.iso) Operating System
+   1. [NGINX](https://github.com/intel/asynch_mode_nginx.git)
+   1. [OpenSSL](https://github.com/openssl/openssl.git)
+   1. [QAT Engine](https://github.com/intel/QAT_Engine.git)
+   1. [QAT Driver](https://01.org/intel-quickassist-technology): Look for "Intel(R) Quickassist Driver for Linux".
+
+## Installation
+* DUT SETUP
+   * Power on the DUT system, with all required peripherals connected.  Plug in the networing cables required to connect to the management Internet port (SSH Port) and to the Clients (High performance NICs).
+   * Set the correct date. The syntax is as follows: date -s "\<TIME DAY MONTH YEAR\>".  See example
+```bash
+date -s "0900 1 June 2020"
+```
+   * Log into the DUT via SSH as a root user.  Perform the following steps:
+```bash
+cd /root/
+
+mkdir -p server/scripts/
+mkdir -p server/sources/
+mkdir -p server/sources/tls_build/qat_install/
+mkdir -p server/sources/tls_build/certs/
+mkdir -p server/sources/tls_build/openssl_install/
+mkdir -p server/sources/tls_build/nginx_install/
+
+cd /root/server/sources/tls_build/
+git clone https://github.com/intel/asynch_mode_nginx.git
+mv asynch_mode_nginx/ nginx/
+cd nginx
+git checkout v0.4.0
+cd ../
+git clone https://github.com/openssl/openssl.git
+cd openssl
+git checkout OpenSSL_1_1_0l
+cd ../
+git clone https://github.com/intel/QAT_Engine.git
+mv QAT_Engine qat_engine
+cd qat_engine
+git checkout v0.5.44
+cd ../
+cd qat_install
+wget --no-check-certificate https://01.org/sites/default/files/downloads/qat1.7.l.4.9.0-00008.tar.gz
+tar xf qat1.7.l.4.9.0-00008.tar.gz
+cd /root/server/scripts/
+
+export KERNEL_SOURCE_ROOT=/usr/src/linux-headers-$(uname -r) #may change if using Red Hat
+export ICP_ROOT=/root/server/sources/tls_build/qat_install/
+export QAT_ENGINE=/root/server/sources/tls_build/qat_engine/
+export OPENSSL_SOURCE=/root/server/sources/tls_build/openssl/
+export OPENSSL_LIB=/root/server/sources/tls_build/openssl_install/
+export OPENSSL_ENGINES=/root/server/sources/tls_build/openssl_install/engines-1.1/
+export OPENSSL_ROOT=/root/server/sources/tls_build/openssl/
+export PERL5LIB=/root/server/sources/tls_build/penssl/
+export NGINX_SOURCE=/root/server/sources/tls_build/nginx/
+export NGINX_INSTALL_DIR=/root/server/sources/tls_build/nginx_install/
+export NGINX_CERTS=/root/server/sources/tls12_buid/certs/
+export LD_LIBRARY_PATH=$OPENSSL_SOURCE:$ICP_ROOT/build/:$OPENSSL_LIB:/lib64/
+export DISABLE_PARAM_CHECK=1
+export DISABLE_STATS=1
+export UPSTREAM_DRIVER=1
+export LD_BIND_NOW=1
+export ifaces="A list of your ethernet interface names such as eth0 or enps0f0" #ex) ifaces="eth0 eth1"
+export QAT_COUNTER0=qat_c6xx_0000:??:00.0 #Bus Device Function (BDF) names of your qat device in /sys/kernel/debug/ . You can use lspci |grep Co- to find BDF.
+export QAT_COUNTER1=qat_c6xx_0000:??:00.0
+export QAT_COUNTER2=qat_c6xx_0000:??:00.0
+export SIBLING_THREAD=`cat /sys/devices/system/cpu/cpu1/topology/thread_siblings_list |awk 'BEGIN{FS=",";}{print $2}'`
+
+
+cd $ICP_ROOT
+./configure --prefix=$ICP_ROOT
+make -j 10
+make install -j 10
+
+cd  $OPENSSL_SOURCE
+./config --prefix=$OPENSSL_LIB -Wl,-rpath,$OPENSSL_SOURCE
+make update
+make depend
+make -j 10
+make install -j 10
+
+cd $QAT_ENGINE
+./configure --with-qat_dir=$ICP_ROOT --with-openssl_dir=$OPENSSL_SOURCE --with-openssl_install_dir=$OPENSSL_LIB --enable-upstream_driver --enable-usdm  --disable-qat_lenstra_protection
+make -j 10
+make install -j 10
+
+cd $NGINX_SOURCE
+./configure --prefix=$NGINX_INSTALL_DIR --without-http_rewrite_module --with-http_ssl_module --add-dynamic-module=modules/nginx_qat_module  --with-cc-opt="-DNGX_SECURE_MEM -I$OPENSSL_LIB/include -Wno-error=deprecated-declarations -Wimplicit-fallthrough=0" --with-ld-opt="-Wl,-rpath=$OPENSSL_LIB/lib -L$OPENSSL_LIB/lib"
+make -j 10
+make install -j 10
+cd NGINX_INSTALL_DIR/html
+fallocate -l 10MB 10mb_file_1.html #You can add more than one if you want. for example 10mb_file_2.html 10mb_file_3.html... .  For our testing purposes, make 3000 10MB files.
+
+cd $NGINX_CERTS
+openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout server.key -out server.crt #RSA Cert
+openssl ecparam -genkey -out key.pem -name prime256v1 #DSA Cert
+openssl req -x509 -new -key key.pem -out cert.pem #finalize DSA Cert
+```
+   * Assuming everyting built correctly, you can now do a quick performance function check with QAT.  This step is known as "running OpenSSL Speed tests with QAT". The idea here is to ensure that QAT is functioning properly, and that expected performance is met before moving to a more complicated workload such as NGINX. Run the following:
+      * Please Copy and Paste the following script into your environment.  This script will help build QAT config files for you dynamically rather than having to manually edit them.
+```bash
+#!/bin/bash
+#This script was created by NPG Performance Measurement and Analysis Team.
+#written by Jon Strang <jon.strang@intel.com>
+main()
+{
+	parse_args $@
+	calculate_processes
+	create_configs
+}
+calculate_processes()
+{
+	PROCESES_PER_DEVICE=0
+	AVAILABLE_PROCESES_PER_DEVICE=$(($PROCESSES/$DEVICES+$PROCESSES%$DEVICES))
+
+	if [ $PROCESSES -lt $DEVICES ];
+	then
+		PROCESSES_PER_DEVICE=1
+	elif [ $PROCESSES -ge $DEVICES ];
+	then
+		for i in `seq 0 1 $(($AVAILABLE_PROCESES_PER_DEVICE-1))`
+		do
+			PROCESSES_PER_DEVICE=$((PROCESSES_PER_DEVICE+1))
+		done
+	fi
+}
+create_configs()
+{
+	CORE_LEFT_OFF_AT=0
+	CORE_STRING=""
+	for i in `seq 0 1 $((DEVICES-1))`;
+	do
+		echo "[GENERAL]	"								>>device_"$i".conf
+		echo "ServicesEnabled = cy,dc"							>>device_"$i".conf
+		echo "ConfigVersion = 2"							>>device_"$i".conf
+		echo "CyNumConcurrentSymRequests = 512"						>>device_"$i".conf
+		echo "CyNumConcurrentAsymRequests = 64"						>>device_"$i".conf
+		echo "statsGeneral = 1"								>>device_"$i".conf
+		echo "statsDh = 1"								>>device_"$i".conf
+		echo "statsDrbg = 1"								>>device_"$i".conf
+		echo "statsDsa = 1"								>>device_"$i".conf
+		echo "statsEcc = 1"								>>device_"$i".conf
+		echo "statsKeyGen = 1"								>>device_"$i".conf
+		echo "statsDc = 1"								>>device_"$i".conf
+		echo "statsLn = 1"								>>device_"$i".conf
+		echo "statsPrime = 1"								>>device_"$i".conf
+		echo "statsRsa = 1"								>>device_"$i".conf
+		echo "statsSym = 1"								>>device_"$i".conf
+		echo "StorageEnabled = 0"							>>device_"$i".conf
+		echo "PkeDisabled = 0"								>>device_"$i".conf
+		echo "InterBuffLogVal = 14"							>>device_"$i".conf
+		echo ""										>>device_"$i".conf
+		echo "[KERNEL]"									>>device_"$i".conf
+		echo "NumberCyInstances = 0"							>>device_"$i".conf
+		echo "NumberDcInstances = 0"							>>device_"$i".conf
+		echo "Cy0Name = "IPSec0""							>>device_"$i".conf
+		echo "Cy0IsPolled = 0"								>>device_"$i".conf
+		echo "Cy0CoreAffinity = 0"							>>device_"$i".conf
+		echo "Dc0Name = "IPComp0""							>>device_"$i".conf
+		echo "Dc0IsPolled = 0"								>>device_"$i".conf
+		echo "Dc0CoreAffinity = 0"							>>device_"$i".conf
+		echo ""										>>device_"$i".conf
+		echo "[SHIM]"									>>device_"$i".conf
+		echo "NumberCyInstances = 1"							>>device_"$i".conf
+		echo "NumberDcInstances = 1"							>>device_"$i".conf
+		echo "NumProcesses = $PROCESSES_PER_DEVICE"					>>device_"$i".conf
+		echo "LimitDevAccess = 1"							>>device_"$i".conf
+		echo "Cy0Name = "UserCY0""							>>device_"$i".conf
+		echo "Cy0IsPolled = 1"								>>device_"$i".conf
+
+		START_FROM=$(($OFFSET+$CORE_LEFT_OFF_AT))
+		if [ $HT = 'n' ];
+		then
+			if [ $(($PROCESSES%$DEVICES)) -eq 0 ];
+			then
+				for j in `seq 0 1 $(($PROCESSES/$DEVICES-1))`;
+				do
+					CORE_STRING+="$(($j+$START_FROM)),"
+					CORE_LEFT_OFF_AT=$(($CORE_LEFT_OFF_AT+1))
+				done
+			else
+				for j in `seq 0 1 $(($PROCESSES/$DEVICES))`;
+				do
+					CORE_STRING+="$(($j+$START_FROM)),"
+					CORE_LEFT_OFF_AT=$(($CORE_LEFT_OFF_AT+1))
+				done
+			fi
+		else
+			HT_CORES=""
+			HT_OFFSET=$(($NUM_CORES/$NUMA+$OFFSET))
+			if [ $(($PROCESSES%$DEVICES)) -eq 0 ];
+			then
+				for j in `seq 0 1 $((($PROCESSES/2)/$DEVICES))`;
+				do
+					HT_CORES+="$(($j+$START_FROM+$HT_OFFSET-1)),"
+					CORE_STRING+="$(($j+$START_FROM)),"
+					CORE_LEFT_OFF_AT=$(($CORE_LEFT_OFF_AT+1))
+				done
+			else
+				for j in `seq 0 1 $((($PROCESSES/2)/$DEVICES))`;
+				do
+					HT_CORES+="$(($j+$START_FROM+$HT_OFFSET-1)),"
+					CORE_STRING+="$(($j+$START_FROM)),"
+					CORE_LEFT_OFF_AT=$(($CORE_LEFT_OFF_AT+1))
+				done
+			fi
+			CORE_STRING+="$CORES_STRING$HT_CORES"
+		fi
+		echo "Cy0CoreAffinity = $CORE_STRING" |sed 's/,$//g'						>>device_"$i".conf
+		CORE_STRING=""
+		HT_CORES=""
+	done
+}
+usage()
+{
+	echo "./create_qat_files.sh -d <number of qat devices> -p <number of processes e.g. nginx or haproxy> -o <core offset> -ht <hyper-threads y|n>"
+	echo ""
+	echo "Ex.) 18 nginx workers with no HT used and 3 devices and you want to pin nginx beginning with core 1"
+	echo "./create_qat_files.sh -d 3 -p 18 -o 1 -ht n"
+	echo "Ex.) 18 nginx workers !with! HT used and 3 devices and you want to pin nginx beginning with core 1"
+	echo "./create_qat_files.sh -d 3 -p 36 -o 1 -ht y"
+}
+parse_args()
+{
+	CORRECTNESS=0
+	while true;
+	do
+		case "$1" in
+			-h)
+				usage
+				exit 0
+				shift;shift;;
+			-o)
+				if [ $2 ];
+				then
+					OFFSET=$2
+					CORRECTNESS=$((CORRECTNESS+1))
+				fi
+				shift;shift;;
+			-d)
+				if [ $2 ];
+				then
+					DEVICES=$2
+					CORRECTNESS=$((CORRECTNESS+1))
+				fi
+				shift;shift;;
+			-p)
+				if [ $2 ];
+				then
+					PROCESSES=$2
+					CORRECTNESS=$((CORRECTNESS+1))
+				fi
+				shift;shift;;
+			-ht)
+				if [ ! $2 = 'y' ] && [ ! $2 = 'n' ];
+				then
+					echo "Sorry, your -ht needs to be either y|n"
+					exit -1
+				fi
+				if [ $2 ];
+				then
+					HT=$2
+					CORRECTNESS=$((CORRECTNESS+1))
+				fi
+				NUMA=`lscpu |grep -i numa |grep -v ",\|-" |awk '{print $NF}'`
+				NUM_CORES=`nproc`
+				shift;shift;;
+			*)
+				break;
+		esac
+	done
+	if [ $CORRECTNESS -lt 4 ];
+	then
+		usage
+		exit -1
+	fi
+}
+main $@
+```
+   * Once you have the create_qat_files.sh.  Run the following commands to prime QAT for OpenSSL speed tests.
+```bash
+./create_qat_files.sh -d 3 -p 3 -o 1 -ht n
+```
+   * Rename each file to qat_xxx_bdf.conf.  Refer to vim $ICP_ROOT/README or $QAT_ENGINE/README.md for more information. An example is
+```bash
+mv qat_dev0.conf c6xx_dev0.conf
+mv c7xx_dev* /etc/  #This is where QAT looks for the QAT config files
+```
+   * Keep in mind that the name of this file is unique to the QAT device you are testing and will error out if your config file is not properly names.  Refer to $ICP_ROOT/README.md.
+```bash
+service qat_service restart
+cd $OPENSSL_INSTALL/bin
+taskset -c 1-3 ./openssl speed -elapsed -multi 3 rsa2048 #to run nonqat
+taskset -c 1-3 ./openssl speed -engine qat -elapsed -multi 3 -async_jobs 72 rsa2048 #to run with qat
+```
+      * Your non-QAT vs QAT for RSA2K should be apparent based on the QAT device you are testing.
+   * Once your data is matching expecations for the QAT device that is under test, it is now time to run full nginx application. Note that you can monitor your QAT, Ethernet, and OS TCP Time Wait stats with the below script. call this script stats.sh
+```bash
+#Written by Jon Strang jon.strang@intel.com
+
+
+#Code from ethstats.sh courtesy of Jason N
+net_snapshot ()
+{
+        rx=0;tx=0
+        for i in $ifaces;
+        do
+                cntr="bytes"
+                snap=`ethtool -S $i 2>/dev/null`
+                `echo "$snap" | grep -q ${cntr}_nic` && cntr="${cntr}_nic"
+                if [ -n "$snap" ];
+                then
+                        let rx+="`echo \"$snap\" | grep "^ *rx_$cntr:" | cut -f2 -d:`"
+                        let tx+="`echo \"$snap\" | grep "^ *tx_$cntr:" | cut -f2 -d:`"
+                fi
+        done
+}
+
+newtest=0
+oldtest=0
+newtest1=0
+oldtest1=0
+newtest2=0
+oldtest2=0
+old_interrupt=0
+new_interrupt=0
+old_perf=0
+new_perf=0
+old_err=0
+new_err=0
+
+net_snapshot
+while true; do
+        tstamp1=`date +%s.%N`
+	if [ $NUM_QAT_DEVICES -eq 1 ];
+	then
+	newtest=`cat /sys/kernel/debug/$QAT_COUNTER0/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	elif [ $NUM_QAT_DEVICES -eq 2 ];
+	then
+	newtest=`cat /sys/kernel/debug/$QAT_COUNTER0/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	newtest1=`cat /sys/kernel/debug/$QAT_COUNTER1/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	elif [ $NUM_QAT_DEVICES -eq 3 ];
+	then
+	newtest=`cat /sys/kernel/debug/$QAT_COUNTER0/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	newtest1=`cat /sys/kernel/debug/$QAT_COUNTER1/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	newtest2=`cat /sys/kernel/debug/$QAT_COUNTER2/fw_counters |grep "s\[AE" |awk '{print $5}' | awk 'BEGIN {s=0} {s+=$1} END {print s}'`
+	new_interrupt=`for j in $ifaces;do cat /proc/interrupts  |grep "$j-" |awk '{for(i=3;i<NF;++i)s+=$i} END {printf "%f\n",s}'; done |awk '{t+=$1}END{printf "%f",t}'`
+        waiting=`ss -a | grep TIME-WAIT | wc -l`
+        connections=`ss -tp |grep nginx |wc -l`
+        oldrx=$rx; oldtx=$tx;
+	sleep .9
+        tstamp2=`date +%s.%N`
+        net_snapshot
+        rx_avg=`echo "(8*($rx-$oldrx)/1000/1000/($tstamp2-$tstamp1))"|bc`
+        tx_avg=`echo "(8*($tx-$oldtx)/1000/1000/($tstamp2-$tstamp1))"|bc`
+	#calculate errors
+	echo "[RX=$rx_avg |TX=$tx_avg |QAT0=$((($newtest-$oldtest))) |QAT1=$((($newtest1-$oldtest1))) |QAT2=$((($newtest2-$oldtest2))) |CONN=$connections |WAIT=$waiting |IRUPTS=`bc -l <<<  $new_interrupt-$old_interrupt |awk '{printf("%d",$1)}'` |ERRS=$(($new_err-$old_err))]"
+        oldtest=$newtest
+        oldtest1=$newtest1
+        oldtest2=$newtest2
+        old_interrupt=$new_interrupt
+	old_err=$new_err
+done
+```
+   * You can now monitor the stats using the command:
+```bash
+./stats.sh
+```
+
+## Testing
+To begin testing, please do the following.
+```bash
+cd /root/server/sources/tls12_build/nginx_install/conf
+```
+   * Place the following NGINX configuration file into the folder and naming it nginx.conf
+```bash
+user root;  #The "user" directive must always be root for this bkm
+worker_processes 2;     #This will be set to the maximum number of logical cores you are going to use. So if you are using Intel(R) Hyper-Threading, you would use 2, 1 worker for each logical thread.  If you were using 6 cores plus their Hyper-Threads, you would have 12 worker_proceses. If you are on an Intel(R) Atom(TM) part, you would not have Hyper-Threads, so if you use 1 core, then you would only have 1 worker_process.
+
+ssl_engine{     #This directive enables the use of QAT offload. If "ssl_engine" is totally ommitted, then software will be used.
+   use_engine qatengine;
+   default_algorithms ALL;
+   qat_engine{
+      qat_notify_mode poll;
+      qat_offload_mode async;
+      qat_external_poll_interval 1;
+}}
+worker_rlimit_nofile 1000000;   #Set this to a high number, as this is an OS optimization that will ensure no file handle issues.
+
+events  #The events block is where you will tell NGINX what behaviors to exhibit when dealing with an event.
+{
+  use epoll;    #The epoll module is important for performance.  It set the behavior to poll on events coming from IO.
+
+  worker_connections 8192;  #This directive tells how many connections a worker_process can have.  Ensure to never set this too low or high. To low will prevent getting good performance, and too high may CPU starve connections.
+
+  multi_accept on;  #This directive allows worker_processes to handle multiple connections at a time rather than dealing with only one at a time.
+
+  accept_mutex on;  #This directive tells the worker_processes to get in a line rather than all rush for a new connection.
+}
+
+http    #This is the main HTTP block. This will have all HTTPS relevant directives.
+{
+          ssl_buffer_size 65536;    #This is telling nginx to use 64KB buffers when dealing with TLS records
+
+          include       mime.types; #Since file extensions are meaningless on the web, we ensure we specify what content type we are sending
+          default_type  application/octet-stream;   #This is the default value for a binary stream
+          sendfile on;  #An optimization that allows for file data to transfer within the kernel from file descriptor to file descriptor rather than leaving the kernel, heading to user space, and then going back into kernel space.
+          access_log off;   #Turns off logging, which consequently reduces operation latency to some degree.
+        server #Here is your main server block that has all IP specific directives and behaviors. YOU WILL HAVE TO DUPLICATE THIS BLOCK FOR EACH IP YOU USE.  So if you have 172.16.1.1 .... 172.16.12.1 , you will need 12 server blocks.
+        {
+                listen       172.16.1.1:4400 reuseport backlog=131072 so_keepalive=off ; #Listen is the IP:PORT to listen to. Reuseport will provide the kernel behavior of load balancing incoming connections to the available NGINX socket listeners.  There is an NGINX socket listener per server block, the block we currently are in now. So if you have one server block with one IP:PORT pair, then you have one socket listener. If you have two server blocks with two IP:PORT pairs, you have two socket listeners so on and so fort. The backlog parameter tells NGINX how many connections can be in a wait queue when it cannot service the connection immediately. These connections are still amidst TCP handshake.  The so_keepalive directive tell NGINX to close the TCP connection once it is finished.
+                sendfile on;  #Though already provided in parent block, continue to specify it.
+
+                keepalive_timeout 0s;  #Even though TCP keepalives are disabled, we still set it to a value of 0
+                tcp_nopush on;  #This directive tells NGINX to wait to send data once it has a payload the size of MSS or Max Segment Size.  This is a follow on to Nagles Algorithm.
+
+                tcp_nodelay on;  #This works opposite of tcp_nopush, where here we do not delay when sending data. We set this to ensure packets get sent without delaying for some period of time. This is to reduce latency.
+                ssl_verify_client off;  #Here we do not verify client certificates.
+                ssl_session_tickets off;    #We do not cache ssl session information to ensure freshness of connections.
+                access_log  off;  #turn off access log to reduce latency and overhead.
+                lingering_close off; #We immediately close the TCP connection without waiting.
+                lingering_time 1;  #We still set this even though we disabled lingering delay.
+                server_name  server_1;  #Name of the server.
+
+                ssl                  on;    #Ensure SSL is on
+                ssl_asynch           on;    #Ensure SSL works asynchronously
+                ssl_certificate      /root/server/sources/tls12_build/certs/server.crt;  #Path to your public certificate for RSA. For EC use cert.pem instead of server.crt
+                ssl_certificate_key  /root/server/sources/tls12_build/certs/server.key;  #Path to your private key for RSA. For EC use key.pem instead of server.key
+
+                ssl_session_timeout  300s;  #Even though we disable ssl session caching, we set a timeout for 300 seconds to preserve current productive sessions doing work.
+
+                ssl_protocols  TLSv1.2; #We use TLSv1.2
+
+                ssl_ciphers  AES128-SHA:AES256-SHA; #We specify the cipher to use.  AES128-SHA, AES128-GCM-SHA256, ECDHE-ECDSA-AES128-SHA, and ECDHE-RSA-AES128-SHA are the ciphers currently used.
+                ssl_prefer_server_ciphers   on;  #During SSL handshake we use this to ensure server ciphers have precedence.
+
+                location /  #Location of files to send. this location is relative to /root/server/sources/tls__build/nginx_install/html
+                {
+                          index  index.html index.htm;
+                }
+        }
+}
+```
+   * Ensure to set the worker_processes accordingly.  The <b> rule with QAT when on an Intel(R) Xeon(R) platform, is to use 2 NGINX workers where one(1) is pinned to the physical core and the other to the sibling Hyperthread.</b>  So if you are running 1 core tests plus the Hyperthread, then "worker_processes 2;" will be used.  If not using Hyperthreads, then use "worker_processes 1;".  To run a 1 core with Hyperthread test we would do the following.
+   * Create the necessary QAT config files.
+```bash
+./create_qat_files.sh -d 1 -p 1 -o 1 -ht y
+```
+   * Rename the qat_dev\*.conf files to the properly named files.  Then move to /etc/ for processing.
+   * Ensure to tune the DUT. Call this script tune.sh and place in /root/server/scripts/
+```bash
+#!/bin/bash
+ufw disable                                                                     #disable Debian firewall
+iptables -F                                                                     #flush the iptables rules
+#TCP Memory
+echo 16777216                > /proc/sys/net/core/rmem_max
+echo 16777216                > /proc/sys/net/core/wmem_max
+echo 16777216                > /proc/sys/net/core/rmem_default
+echo 16777216                > /proc/sys/net/core/wmem_default
+echo 16777216 16777216 16777216  > /proc/sys/net/ipv4/tcp_rmem
+echo 538750 538750 538750  > /proc/sys/net/ipv4/tcp_wmem
+echo 16777216            > /proc/sys/net/core/optmem_max
+echo 16777216 16777216  16777216 > /proc/sys/net/ipv4/tcp_mem
+echo 65536       > /proc/sys/vm/min_free_kbytes                                  #ensure there will always be free
+#TCP Behavior
+echo 0                     > /proc/sys/net/ipv4/tcp_timestamps
+echo 0                     > /proc/sys/net/ipv4/tcp_sack
+echo 0                     > /proc/sys/net/ipv4/tcp_fack
+echo 0                     > /proc/sys/net/ipv4/tcp_dsack
+echo 0                     > /proc/sys/net/ipv4/tcp_moderate_rcvbuf
+echo 1                     > /proc/sys/net/ipv4/tcp_rfc1337
+echo 600        > /proc/sys/net/core/netdev_budget
+echo 128                   > /proc/sys/net/core/dev_weight
+echo 1                     > /proc/sys/net/ipv4/tcp_syncookies
+echo 0                     > /proc/sys/net/ipv4/tcp_slow_start_after_idle
+echo 1                     > /proc/sys/net/ipv4/tcp_no_metrics_save
+echo 1                     > /proc/sys/net/ipv4/tcp_orphan_retries
+echo 0                     > /proc/sys/net/ipv4/tcp_fin_timeout
+echo 0                     > /proc/sys/net/ipv4/tcp_tw_reuse
+echo 0                     > /proc/sys/net/ipv4/tcp_tw_recycle
+echo 1                     > /proc/sys/net/ipv4/tcp_syncookies
+echo 2                       > /proc/sys/net/ipv4/tcp_synack_retries
+echo 2                     > /proc/sys/net/ipv4/tcp_syn_retries
+echo cubic                   > /proc/sys/net/ipv4/tcp_congestion_control
+echo 0                     > /proc/sys/net/ipv4/tcp_low_latency
+echo 1                     > /proc/sys/net/ipv4/tcp_window_scaling
+echo 1                     > /proc/sys/net/ipv4/tcp_adv_win_scale
+#TCP Queueing
+echo 0                > /proc/sys/net/ipv4/tcp_max_tw_buckets
+echo 1025 65535            > /proc/sys/net/ipv4/ip_local_port_range
+echo 131072                > /proc/sys/net/core/somaxconn
+echo 262144            > /proc/sys/net/ipv4/tcp_max_orphans
+echo 262144           > /proc/sys/net/core/netdev_max_backlog
+echo 262144        > /proc/sys/net/ipv4/tcp_max_syn_backlog
+echo 4000000             > /proc/sys/fs/nr_open
+
+echo 4194304     > /proc/sys/net/ipv4/ipfrag_high_thresh
+echo 3145728     > /proc/sys/net/ipv4/ipfrag_low_thresh
+echo 30      > /proc/sys/net/ipv4/ipfrag_time
+echo 0   > /proc/sys/net/ipv4/tcp_abort_on_overflow
+echo 1       > /proc/sys/net/ipv4/tcp_autocorking
+echo 31      > /proc/sys/net/ipv4/tcp_app_win
+echo 1       > /proc/sys/net/ipv4/tcp_mtu_probing
+set selinux=disabled
+ulimit -n 1000000
+```
+   * To tune run the following:
+```bash
+source tune.sh
+```
+
+```bash
+service qat_service restart
+cd $NGINX_INSTALL_DIR/sbin
+taskset -c 1-$SIBLING_THREAD ./nginx -c conf/nginx.conf
+netstat -tulpn #to verify nginx started and listening to port 4400
+```
+   * Now that NGINX is up and running with QAT, you can monitor the statistics. But before that, lets set up the client(s).
+```bash
+./stats.sh
+```
+## Client Setup
+Log into the client(s) and perform the following.
+
+```bash
+cd /root/
+mkdir -p client/
+mkdir -p client/sources/
+mkdir -p client/scripts/
+cd client/sources/
+git clone https://github.com/openssl/openssl.git
+cd openssl
+git checkout OpenSSL_1_1_0l
+./config -Wl,-rpath,/root/client/sources/openssl/
+make -j 10 #NO MAKE INSTALL NECESSARY
+cd /root/client/scripts/
+```
+Paste the following scripts into the scripts/ directory
+   * Client Tuning (call it tune.sh)
+```bash
+#!/bin/bash
+ufw disable
+iptables -F
+#TCP Memory
+echo 16777216                > /proc/sys/net/core/rmem_max
+echo 16777216                > /proc/sys/net/core/wmem_max
+echo 16777216                > /proc/sys/net/core/rmem_default
+echo 16777216                > /proc/sys/net/core/wmem_default
+echo 16777216 16777216 16777216  > /proc/sys/net/ipv4/tcp_rmem
+echo 538750 538750 538750  > /proc/sys/net/ipv4/tcp_wmem
+echo 16777216   		 > /proc/sys/net/core/optmem_max
+echo 16777216 16777216  16777216 > /proc/sys/net/ipv4/tcp_mem
+echo 65536		 > /proc/sys/vm/min_free_kbytes
+#TCP Behavior
+echo 0                     > /proc/sys/net/ipv4/tcp_timestamps
+echo 0                     > /proc/sys/net/ipv4/tcp_sack
+echo 0                     > /proc/sys/net/ipv4/tcp_fack
+echo 0                     > /proc/sys/net/ipv4/tcp_dsack
+echo 0                     > /proc/sys/net/ipv4/tcp_moderate_rcvbuf
+echo 1                     > /proc/sys/net/ipv4/tcp_rfc1337
+echo 600        > /proc/sys/net/core/netdev_budget
+echo 128                   > /proc/sys/net/core/dev_weight
+echo 1                     > /proc/sys/net/ipv4/tcp_syncookies
+echo 0                     > /proc/sys/net/ipv4/tcp_slow_start_after_idle
+echo 1                     > /proc/sys/net/ipv4/tcp_no_metrics_save
+echo 1                     > /proc/sys/net/ipv4/tcp_orphan_retries
+echo 0                     > /proc/sys/net/ipv4/tcp_fin_timeout
+echo 0                     > /proc/sys/net/ipv4/tcp_tw_reuse
+echo 0                     > /proc/sys/net/ipv4/tcp_tw_recycle
+echo 1                     > /proc/sys/net/ipv4/tcp_syncookies
+echo 2                   	 > /proc/sys/net/ipv4/tcp_synack_retries
+echo 2                     > /proc/sys/net/ipv4/tcp_syn_retries
+echo cubic                   > /proc/sys/net/ipv4/tcp_congestion_control
+echo 1                     > /proc/sys/net/ipv4/tcp_low_latency
+echo 1                     > /proc/sys/net/ipv4/tcp_window_scaling
+echo 1                     > /proc/sys/net/ipv4/tcp_adv_win_scale
+#TCP Queueing
+echo 0                > /proc/sys/net/ipv4/tcp_max_tw_buckets
+echo 1025 65535            > /proc/sys/net/ipv4/ip_local_port_range
+echo 131072                > /proc/sys/net/core/somaxconn
+echo 262144            > /proc/sys/net/ipv4/tcp_max_orphans
+echo 262144           > /proc/sys/net/core/netdev_max_backlog
+echo 262144        > /proc/sys/net/ipv4/tcp_max_syn_backlog
+echo 4000000	         > /proc/sys/fs/nr_open
+
+echo 4194304	 > /proc/sys/net/ipv4/ipfrag_high_thresh
+echo 3145728	 > /proc/sys/net/ipv4/ipfrag_low_thresh
+echo 30	 	 > /proc/sys/net/ipv4/ipfrag_time
+echo 0	 > /proc/sys/net/ipv4/tcp_abort_on_overflow
+echo 1	 	 > /proc/sys/net/ipv4/tcp_autocorking
+echo 31	 	 > /proc/sys/net/ipv4/tcp_app_win
+echo 0	 	 > /proc/sys/net/ipv4/tcp_mtu_probing
+set selinux=disabled
+ulimit -n 1000000
+```
+
+   * Client Connection-per-Second Script (call it connection.sh)
+```bash
+#!/bin/bash
+
+
+######################################
+############# USER INPUT #############
+######################################
+#STEP 1
+ip_address=YOUR_IP_HERE #Only one IP that maps to the DUT such as 172.16.1.1
+_time=$8
+clients=2000
+portbase=4400
+cipher=$4
+OPENSSL_DIR=/root/client/sources/openssl/
+######################################
+############# USER INPUT #############
+######################################
+
+#Check for OpenSSL Directory
+if [ ! -d $OPENSSL_DIR ];
+then
+    printf "\n$OPENSSL_DIR does not exist.\n\n"
+    printf "Please modify the OPENSSL_DIR variable in the User Input section!\n\n"
+    exit 0
+fi
+
+helpAndError () {
+    printf " ex.) ./connection.sh --servers 1 --cipher AES128-GCM-SHA256 --clients 2000 --time 30\n\n"
+    exit 0
+}
+
+#Check for h flag or no command line args
+if [[ $1 == *"h"* ]]; then
+    helpAndError
+    exit 0
+fi
+
+#Check for emulation flag
+if [[ $@ == **emulation** ]]
+then
+    emulation=1
+fi
+
+#cmd1 is the first part of the commandline and cmd2 is the second partrt
+#The total commandline will be cmd1 + "192.168.1.1:4400" + cmd2
+cmd1="$OPENSSL_DIR/apps/openssl s_time -connect"
+if [[ $cipher =~ "TLS" ]];
+then
+	cmd2="-new -ciphersuites $cipher  -time $_time "
+else
+	cmd2="-new -cipher $cipher  -time $_time "
+fi
+#Print out variables to check
+printf "\n Location of OpenSSL:           $OPENSSL_DIR\n"
+printf " IP Addresses:                  $ip_address\n"
+printf " Time:                          $_time\n"
+printf " Clients:                       $clients\n"
+printf " Port Base:                     $portbase\n"
+printf " Cipher:                        $cipher\n\n"
+
+printf "Press ENTER to continue"
+
+#read
+
+#Remove previous .test files
+rm -rf ./.test_*
+
+#Get starttime
+starttime=$(date +%s)
+
+#Kick off the tests after checking for emulation
+if [[ $emulation -eq 1 ]]
+then
+    for (( i = 0; i < ${clients}; i++ )); do
+        printf "$cmd1 $ip_address:$(($portbase)) $cmd2 > .test_$(($portbase))_$i &\n"
+    done
+    exit 0
+else
+    for (( i = 0; i < ${clients}; i++ )); do
+        $cmd1 $ip_address:$(($portbase)) $cmd2 > .test_$(($portbase))_$i &
+    done
+fi
+
+waitstarttime=$(date +%s)
+# wait until all processes complete
+while [ $(ps -ef | grep "openssl s_time" | wc -l) != 1 ];
+do
+    sleep 1
+done
+
+total=$(cat ./.test_$(($portbase))* | awk '(/^[0-9]* connections in [0-9]* real/){ total += $1/$4 } END {print total}')
+echo $total >> .test_sum
+sumTotal=$(cat .test_sum | awk '{total += $1 } END { print total }')
+printf "Connections per second:      $sumTotal CPS\n"
+printf "Finished in %d seconds (%d seconds waiting for procs to start)\n" $(($(date +%s) - $starttime)) $(($waitstarttime - $starttime))
+rm -rf ./.test_*
+```
+
+   * Client Bulk Throughput Script (call it bulk.pl)
+```bash
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use Getopt::Long;
+use Data::Dumper;
+$Data::Dumper::Indent = 1;
+
+######################################
+############# USER INPUT #############
+#####################################
+#STEP 1#
+my @ipaddresses = qw( YOUR IPS HERE ); #Example qw( 172.16.1.1 172.16.2.1 .... 172.16.12.1 )) where "...." is a sequence of IPS.
+my $time = 400 ;
+my $clients = 250;
+my $portbase = 4400;
+my $file = "10mb_file";
+my $cipher = "";
+my $STIME_OUTPUT_FILE;
+use constant OPENSSL_DIR => "/root/client/sources/openssl/";
+######################################
+############# USER INPUT #############
+######################################
+
+#Check OpenSSL Dir is set correctly.
+if(! -d "@{[OPENSSL_DIR]}") {
+    printf "\n\n@{[OPENSSL_DIR]} does not exist.\n\n";
+    printf "Please modify the OPENSSL_DIR variable in the User Input section!\n\n";
+    exit 1;
+}
+
+use constant STIME_APP                => "@{[OPENSSL_DIR]}/apps/openssl s_time";
+my @IPs              = ('127.0.0.1');
+
+###############################################################################
+sub printVariables {
+    my ($servers) = @_;
+
+    #Print out variables for check
+    printf "\n Location of OpenSSL:     @{[OPENSSL_DIR]}\n";
+    printf " IP Addresses:              @ipaddresses\n";
+    printf " Time:                      $time\n";
+    printf " Clients:                   $clients\n";
+    printf " Servers:                   $servers\n";
+    printf " Port Base:                 $portbase\n";
+    printf " File:                      $file\n";
+    printf " Cipher:                    $cipher\n\n";
+
+
+    print "Press ENTER to continue";
+    #<STDIN>;
+}
+
+###############################################################################
+sub usage {
+  print "Error: $_[0] \n" if defined $_[0];
+  print <<'EOF';
+Usage:
+
+  stimefork.pl [options]
+
+Options:
+
+  --emulation
+                  It performs a dry-run showing how many stime
+                  processes would be created and all its parameters.
+                  Optional.
+
+  --help
+                  Shows this help.
+
+  --servers=number
+                  Number of servers listening in the server side.
+                  Mandatory.
+
+  time=number
+                  Number minimum seconds to run the test.
+
+  portbase=number
+                  Starting port number where the web servers will
+                  be listening at.
+
+  clients=number
+                  Number of clients to be created per server. It all of them
+                  will be requesting to the same server.
+
+  file=filename
+                  Filename to be requested from the servers.
+
+  ip=filename
+                  Filename containing the list of IP adresses where
+                  the web server will be listening at.
+
+  cipher=string
+                  Cipher suite tag to be used by the clients.
+                  Run openssl ciphers -v to know more about this.
+
+  ex.) ./bulk.pl --servers 1 --cipher AES128-GCM-SHA256 --clients 2000 --time 30
+EOF
+
+  exit 1;
+}
+
+###############################################################################
+sub check_mandatory_args {
+  foreach (@_) {
+    return 0 unless defined ${$_};
+  }
+  return 1;
+}
+
+###############################################################################
+sub getStimeOutputFilename {
+  my ($server, $child) = @_;
+  return $STIME_OUTPUT_FILE . "_server${server}_child${child}.log";
+}
+
+###############################################################################
+sub myfork {
+  my $pid = fork();
+  die "fork() failed!" if (!defined $pid);
+  return $pid;
+}
+
+###############################################################################
+sub Kbps2Gbps {
+  return $_[0] * 8 / 1024 / 1024;
+}
+
+###############################################################################
+sub Bps2Gbps {
+  return $_[0] * 8 / 1024 / 1024 / 1024;
+}
+
+###############################################################################
+sub getServerPort {
+  my ($portbase, $servers, $child) = @_;
+  return $portbase + ( $child % $servers );
+}
+
+###############################################################################
+sub readCompleteFile {
+  my $filename = shift;
+  open my $FILE, "<", $filename;
+  local $/ = undef;
+  my $content = <$FILE>;
+  close $FILE;
+  return $content;
+}
+
+###############################################################################
+# -connect host:port - host:port to connect to (default is localhost:4433)
+# -nbio         - Run with non-blocking IO
+# -ssl2         - Just use SSLv2
+# -ssl3         - Just use SSLv3
+# -bugs         - Turn on SSL bug compatibility
+# -new          - Just time new connections
+# -reuse        - Just time connection reuse
+# -www page     - Retrieve 'page' from the site
+# -time arg     - max number of seconds to collect data, default 30
+# -verify arg   - turn on peer certificate verification, arg == depth
+# -cert arg     - certificate file to use, PEM format assumed
+# -key arg      - RSA file to use, PEM format assumed, key is in cert file
+#                 file if not specified by this option
+# -CApath arg   - PEM format directory of CA's
+# -CAfile arg   - PEM format file of CA's
+# -cipher       - preferred cipher to use, play with 'openssl ciphers'
+sub call_stime {
+
+  my ($time, $cipher, $ip, $port,
+      $requested_file, $server, $child, $emulation) = @_;
+
+  my @cmd;
+  push @cmd, STIME_APP;
+  push @cmd, " -connect $ip:$port";
+  #push @cmd, "-nbio";
+  push @cmd, "-new";
+  if ($requested_file) {
+    push @cmd, "-www /$requested_file";
+  }
+  push @cmd, "-time $time";
+  if ($cipher =~ "TLS")
+  {
+          push @cmd, "-ciphersuites $cipher";
+  }
+  else
+  {
+          push @cmd, "-cipher $cipher";
+  }
+  push @cmd, ">";
+  push @cmd, getStimeOutputFilename($server, $child);
+
+  my $cmd = join(' ', @cmd);
+  if ($emulation) {
+    print "$cmd\n";
+    exit 0;
+  }
+  else {
+    exec $cmd;
+  }
+}
+
+###############################################################################
+sub checkIfDefined {
+  my $Input = shift;
+  if (defined($Input)) {
+    return $Input;
+  }
+  return 0;
+}
+
+###############################################################################
+sub readRateFromChildOutput {
+  my $output = shift;
+  # Transfer rate:          4265.90 [Kbytes/sec] received
+  #$output =~ m/Transfer rate:\s*([.\d]+).*/;
+  #$output =~ /real seconds/;
+  # 101 connections in 2 real seconds, 3251722 bytes read per connection
+  $output =~ m/(\d*) connections in (\d*) real seconds, (\d*) bytes read per connection/;
+  my $conns = checkIfDefined($1);
+  my $secs = checkIfDefined($2);
+  my $bytes = checkIfDefined($3);
+  if ($conns == 0 or $secs == 0 or $bytes == 0) {
+    return 0;
+  }
+#  if ($bytes != 10485975)
+  if ($bytes < 10000000)
+  {
+        printf " Whole file not transferred\n\n";
+  }
+  return $bytes * $conns / $secs;
+}
+
+###############################################################################
+sub readLatencyFromChildOutput {
+  my $output = shift;
+  #               min  mean[+/-sd] median   max
+  # Connect:        0    0   0.0      0       0
+  $output =~ m/Connect:\s+(\d+)\s+(\d+)\s+(\d+\.\d+)\s+(\d+)\s+(\d+)/;
+  return checkIfDefined($2);
+}
+
+###############################################################################
+sub readServerResponseTimeFromChildOutput {
+  my $output = shift;
+  #               min  mean[+/-sd] median   max
+  # Processing:   281  286   3.6    287     293
+  $output =~ m/Processing:\s+(\d+)\s+(\d+)\s+(\d+\.\d+)\s+(\d+)\s+(\d+)/;
+  return checkIfDefined($2);
+}
+
+###############################################################################
+sub readServerConnectionsPerSecondFromChildOutput {
+  my $output = shift;
+  # 79 connections in 21 real seconds, 3251722 bytes read per connection
+  $output =~ m/(\d*) connections in (\d*) real seconds, (\d*) bytes read per connection/;
+  my $conns = checkIfDefined($1);
+  my $secs = checkIfDefined($2);
+  my $bytes = checkIfDefined($3);
+  if ($conns == 0 or $secs == 0 or $bytes == 0) {
+    return 0;
+  }
+  return $conns / $secs;
+}
+
+###############################################################################
+sub createResultsHash {
+  my $servers = shift;
+  my %results;
+  map {
+    $results{$_} = {
+      latency => 0,
+      stime => 0,
+      rate => 0,
+      cps => 0,
+    }
+  }
+    0..($servers-1);
+  return %results;
+}
+
+###############################################################################
+sub readResultsFromChildren {
+  my ($clients, $servers) = @_;
+  my %results = createResultsHash($servers);
+
+  for(my $child = 0; $child < $clients; $child++) {
+    my $server = $child % $servers;
+
+    my $childoutput =
+      readCompleteFile(getStimeOutputFilename($server, $child));
+
+    $results{$server}{rate} += readRateFromChildOutput($childoutput);
+    $results{$server}{latency} += readLatencyFromChildOutput($childoutput);
+    $results{$server}{stime} +=
+      readServerResponseTimeFromChildOutput($childoutput);
+    $results{$server}{cps} += readServerConnectionsPerSecondFromChildOutput($childoutput);
+  }
+  return %results;
+}
+
+###############################################################################
+sub showAggregatedResults {
+  my ($clients, %results) = @_;
+
+  my $rate = 0.0;
+  my $latency = 0.0;
+  my $servertime = 0.0;
+  my $cps = 0.0;
+
+  map {
+    $rate += $results{$_}{rate};
+    $latency += $results{$_}{latency};
+    $servertime += $results{$_}{stime};
+    $cps += $results{$_}{cps};
+  }
+    keys %results;
+
+  printf " Rate:$cipher:              %6.2f Gbps (total)\n", Bps2Gbps($rate);
+  printf " Latency:           %6.2f ms   (mean)\n", $latency / $clients;
+  printf " Processing:        %6.2f ms   (mean)\n", $servertime / $clients;
+  printf " Conns Per Second:  %6.2f cps  (total)\n", $cps;
+}
+
+###############################################################################
+sub showResultsPerServer {
+  my ($clients, %results) = @_;
+
+  printf "%16s%14s%13s%16s\n",
+         'Server',
+         'Rate(Gbps)',
+         'Latency(ms)',
+         'Processing(ms)';
+
+  my $servers = scalar keys %results;
+  foreach (sort keys %results) {
+
+    printf "%16s%8.2f%15.2f%16.2f\n",
+      "$results{$_}{ip}:$results{$_}{port}",
+      Bps2Gbps($results{$_}{rate}),
+      $results{$_}{latency} / $clients * $servers,
+      $results{$_}{stime} / $clients * $servers;
+  }
+}
+
+###############################################################################
+sub showResults {
+
+  my ($clients, $servers, $portbase, @ipaddresses) = @_;
+  my %results = readResultsFromChildren($clients, $servers);
+
+  foreach (sort keys %results) {
+    $results{$_}{ip} = $ipaddresses[$_ % scalar @ipaddresses];
+    $results{$_}{port} = $portbase + $_;
+  }
+
+  print "\n== Results per server =======================================\n\n";
+  showResultsPerServer($clients, %results);
+
+  print "\n== Total ====================================================\n\n";
+  showAggregatedResults($clients, %results);
+}
+
+###############################################################################
+sub calculate_number_clients {
+  my ($servers, $clients_per_server) = @_;
+
+  my $total_clients = $servers * $clients_per_server;
+  my $cpus = `nproc`;
+  chomp $cpus;
+  if ($total_clients > $cpus) {
+    print "WARNING: total_clients ($total_clients) exceeds num cpus ($cpus)\n";
+  }
+
+  return ($total_clients, 1);
+}
+
+# main
+###############################################################################
+
+# Mandatory arguments
+my $servers;
+
+# Optional arguments
+my $emulation       = 0;
+my $help            = 0;
+
+my @mandatory_args = (\$clients, \$portbase, \$time,
+                      \$servers, \$cipher);
+
+GetOptions(
+  'servers=i'   => \$servers,
+  'emulation'   => \$emulation,
+  'help'        => \$help,
+  'cipher=s'	=> \$cipher,
+  'clients=i'    => \$clients,
+  'time=i'      => \$time,
+)
+  or usage();
+`rm -r /tmp`;
+`mkdir -p /tmp/$cipher`;
+$STIME_OUTPUT_FILE="/tmp/" . $cipher .  "/stime_output";
+
+usage() if $help;
+
+usage('Mandatory argument missing')
+  unless check_mandatory_args(@mandatory_args);
+
+printVariables($servers);
+
+unlink glob $STIME_OUTPUT_FILE.'*';
+
+my ($processes, $concurrency) = calculate_number_clients($servers, $clients);
+
+my $ipindex = 0;
+my $portsperip = $servers / scalar @ipaddresses;
+my $portremainder = $servers % scalar @ipaddresses;
+my $portcntr = 0;
+my $cntrbase = 0;
+my $remUsed = 0;
+my $increment = 0;
+
+
+print "Ports per IP: $portsperip Remainder: $portremainder\n";
+
+for (my $child = 0; $child < $processes; $child++) {
+  my $ip = $ipaddresses[$ipindex];
+  my $port = $portbase;
+
+  $portcntr++;
+
+  if ($portcntr > ($portsperip + $cntrbase)) {
+    if ($portremainder != 0 && $remUsed == 0) {
+      $portremainder--;
+      $remUsed = 1;
+    }
+    else {
+      $ipindex++;
+      $ipindex = $ipindex % scalar @ipaddresses;
+      $ip = $ipaddresses[$ipindex];
+      $cntrbase = ($portcntr - 1);
+      $remUsed = 0;
+    }
+  }
+
+  # It's utilised all the available ports
+  if ($portcntr == $servers) {
+    $remUsed = 0;
+    $portcntr = 0;
+    $ipindex = 0;
+    $cntrbase = 0;
+    $portremainder = $servers % scalar @ipaddresses;
+
+  }
+      if ($increment == 1000)
+        {
+                $increment = 0;
+        }
+
+  my $pid = myfork();
+
+  if ($pid == 0) {
+	         call_stime($time, $cipher, $ip, $port, $file ."_" . ($increment) . ".html", $child % $servers, $child, $emulation);
+  }
+	$increment++
+}
+
+my $i = 0;
+while ($i < $processes  && (my $childpid = wait()) != -1) {
+  $i++;
+}
+
+unless ($emulation) {
+  @ipaddresses = ('server_ip');
+  showResults($processes, $servers,
+              $portbase, @ipaddresses);
+}
+```
+   * Before running any of the scripts, ensure to tune the clients.
+```bash
+source tune.sh
+```
+
+
+## Running Tests and Interpreting Results
+Two types of tests are run:
+   1. Connection-per-Second
+      1. Tests Asymmetric Performance (TLS Hanshaking)
+      1. No GET Request. Only connection establishment
+      1. Measured in how many TLS Handshakes on a per-second basis. The higher the results the better.
+```bash
+./connection.sh --servers 1 --cipher AES128-GCM-SHA256 --clients 2000 --time 400 #example
+```
+   1. Bulk-Throughput
+      1. Tests Symmetric Performance (16KB Record encryption)
+      1. Multiple GET Requests for 10mb_file_1.html ... 10mb_file_N.html where N is between 1 and inf.
+      1. Measured in how much data can be transferred with minimal TLS Handshaking. The higher the results the better.
+```bash
+./bulk.pl --servers 4 --cipher AES128-GCM-SHA256 --clients 250 --time 400 #example
+```
+
+# Mapping Test Types to Algorithms.
+Test Type|NGINX Algorithm Setting
+---------|-----------------------
+Max RSA2048 CPS|AES128-GCM-SHA256
+Max ECDHE-RSA2048 CPS|ECDHE-RSA-AES128-GCM-SHA256
+Max ECDHE-ECDSA CPS|ECDHE-ECDSA-AES128-GCM-SHA256
+Max AES128-CBC BULK| AES128-CBC
+Max AES128-GCM BULK|AES128-GCM-SHA256
+Max CHACHAPOLLY BULK|ECDHE-RSA-CHACHCA20-POLY1305
+
+
+
+# Appendix
+## Mellanox Debug
+If you are using Mellanox 5 series, you may need these.
+```bash
+sudo mlxconfig -e -d b1:00.1 set ADVANCED_POWER_SETTINGS=True
+sudo mlxconfig -e -d b1:00.1 set DISABLE_SLOT_POWER_LIMITER=True
+sudo mlxconfig -e -d b1:00.0 set ADVANCED_POWER_SETTINGS=True
+sudo mlxconfig -e -d b1:00.0 set DISABLE_SLOT_POWER_LIMITER=True
+```
+
+## Running OpenSSL Speed tests with Vectorized AES (VAES)
+OpenSSL Speed tests are an easy way to determine the low level micro-benchmarking performance of OpenSSL+QATEngine with VAES optimized GCM library. Below are the steps.
+
+### Prerequisites.
+1. A Xeon Generation Icelake or above.  Cascade Lake and below will not work with VAES.
+1. Ubuntu 18.04 or Ubuntu 20.04
+
+### Run the following scripts
+
+```bash
+#PREAMBLE
+cd /root/
+mkdir openssl_speed_tests/
+cd openssl_speed_tests/
+git clone https://github.com/intel/QAT_Engine.git
+git clone https://github.com/openssl/openssl.git
+git clone https://github.com/intel/intel-ipsec-mb.git
+wget --no-check-certificate https://www.nasm.us/pub/nasm/releasebuilds/2.14.02/nasm-2.14.02.tar.gz
+mkdir openssl_install/
+mv QAT_Engine qat_engine/
+mv intel-ipsec-mb intel_ipsec_mb/
+tar xf nasm-2.14.02.tar.gz
+mv nasm-2.14.02 nasm
+
+#NASM
+cd /root/openssl_speed_tests/nasm/
+./autogen.sh
+./configure
+make -j 20
+make install -j 20
+
+#OPENSSL
+export OPENSSL_ENGINES=/root/openssl_speed_tests/openssl_install/lib/engines-1.1/
+cd /root/openssl_speed_tests/openssl/
+git checkout OpenSSL_1_1_1h
+./config --prefix=/root/openssl_speed_tests/openssl_install
+make update
+make depend
+make -j 20 && make install -j 20
+
+#INTEL IPSEC
+cd /root/openssl_speed_tests/intel_ipsec_mb/
+git checkout v0.54
+make -j 20
+rm /usr/lib/libIPSec_MB.*
+rm /lib/x86_64-linux-gnu/libIPSec_MB.*
+ln -s /root/openssl_speed_tests/intel_ipsec_mb/intel-ipsec-mb.h  /root/openssl_speed_tests/intel_ipsec_mb/include/
+ln -s  /root/openssl_speed_tests/intel_ipsec_mb/libIPSec_MB.so.0 /usr/lib/
+ln -s  /root/openssl_speed_tests/intel_ipsec_mb/libIPSec_MB.so.0 /lib/x86_64-linux-gnu/
+ln -s  /root/openssl_speed_tests/intel_ipsec_mb/libIPSec_MB.so /lib/x86_64-linux-gnu/
+
+#QATENGINE
+cd /root/openssl_speed_tests/qat_engine/
+git checkout v0.6.1
+./autogen.sh
+./configure --enable-vaes_gcm  --enable-ipsec_offload --with-ipsec_install_dir=/root/openssl_speed_tests/intel_ipsec_mb/  --with-openssl_install_dir=/root/openssl_speed_tests/openssl_install/
+make -j 20
+make install -j 20
+```
+
+To run tests, follow the steps below.
+```bash
+cd /root/openssl_speed_tests/openssl_install/bin/
+taskset -c 1 ./openssl speed -multi 1 -evp aes-128-gcm #NON-VAES tests
+taskset -c 1 ./openssl speed -engine qatengine -multi 1 -evp aes-128-gcm #VAES tests
+```
+
+### Interpreting the Results.
+The results provided by OpenSSL Speed are in KB/s.  There are a number of columns of output, and each column represents a different sized buffer that was looped for a period of time using a crypto algorithm.  The higher the outputted number, the better.  This means that some number of bytes of dummy data was encrypted with a particular algorithm. For non-VAES GCM, we should see some number of bytes encrypted, and for VAES we should see some number of bytes encrypted that is higher than non-VAES. Note, the "-multi" argument and "taskset -c ??" argument should increase in lock-step.  We do this to provide some determinism and to prevent any potential thread migration. Also it is a good idea to disable P and C states in the bios to have  a stable core frequency.
+
+Below is an example of an output.
+```bash
+evp             100.0k  200.0k  300.0k  400.0k  500.0k  600.0k
+```
+The column performance will be mapped to buffer size as such...
+16B=100.0k
+64B=200.0k
+256B=300.0k
+1024B=400.0k
+8192B=500.00k
+16384B=600.0k
diff -Naru -x .git -x .hgtags nginx-release-1.20.1/test/README.md ../asynch_mode_nginx/test/README.md
--- nginx-release-1.20.1/test/README.md	1969-12-31 18:00:00.000000000 -0600
+++ ../asynch_mode_nginx/test/README.md	2022-03-15 13:23:40.572403121 -0500
@@ -0,0 +1,87 @@
+# Intel&reg; QuickAssist Technology (QAT) Async Mode Nginx
+# Copyright (C) Intel, Inc
+## Introduction
+  Nginx-test is a tool for testing whether Nginx can run normally. The tool supports both qat and dasync modes.
+
+## Run Nginx Basic Tests
+
+**Set the following environmental variables:**
+
+`NGINX_SRC_DIR` is the Nginx source code directory.<br/>
+`NGINX_INSTALL_DIR` is the Nginx install directory.<br/>
+`QATZIP_SRC_DIR` is the QATzip source code directory.<br/>
+`OPENSSL_SRC_DIR` is the openssl source code directory.<br/>
+`OPENSSL_LIB` is the openssl install directory.<br/>
+
+**Execute the Nginx test:**
+
+Choose one of the following commands to execute.
+Passing the 'qat' parameter means testing with the QATZip (https://github.com/intel/QATZip) and QAT engine (https://github.com/intel/QAT_Engine) loaded.
+Passing the 'dasync' parameter means testing with the OpenSSL built-in dasync engine loaded and no QATZip aceleration employed.
+
+```bash
+    ./nginx-test.sh qat
+```
+
+```bash
+    ./nginx-test.sh dasync
+```
+
+**View execution log**
+If the result contains ‘skipped’, it means that the conditions required for the test are missing.
+If the result in the log is PASS, it means that all the scripts that satisfy the test are successfully tested,
+otherwise the test fails.
+
+```bash
+    vim nginx-test.log
+```
+
+## nginx_qat_module
+Any 3rd party OpenSSL engine modules can be integrated into this framework. By default, a
+reference module `dasync_module` is provided in `src/engine/modules`
+and a QAT module `nginx_qat_module` is provided in `modules/nginx_qat_modules`.
+
+If the passed-in argument for the test is qat, the qat module 'ngx_ssl_engine_qat_module_for_test.so' needs to be loaded,
+and the 'qat_engine' block needs to be configured.
+If the passed-in argument for the test is dasync, just configure 'use_engine' directive as dasync.
+The variable parameters TEST_NGINX_SSL_ENGINE_MODULE and TEST_LOAD_MODULE in 'test-env.sh'
+change the configuration based on the parameters passed in.
+
+Passing the 'qat' parameter:
+```bash
+   load_module modules/ngx_ssl_engine_qat_module.so;
+   ...
+   ssl_engine {
+       use_engine qatengine;
+       default_algorithms ALL;
+           qat_engine {
+               qat_offload_mode async;
+               qat_notify_mode poll;
+               qat_poll_mode heuristic;
+           }
+   }
+```
+
+Passing the 'dasync' parameter:
+```bash
+   ssl_engine {
+        use_engine qat;
+        ...
+    }
+```
+For more details directives of `nginx_qat_module`, please refer to
+`modules/nginx_qat_modules/README`.
+
+## nginx_qatzip_module
+This module is developed for accelerating GZIP compression with QATzip in Nginx
+dynamic module framework.
+
+For more details directives of `nginx_qatzip_module`, please refer to
+`modules/nginx_qatzip_module/README`.
+
+Using QATZip for compression:
+```bash
+   load_module modules/ngx_http_qatzip_filter_module.so;
+   ...
+   qatzip_sw no;
+```
\ No newline at end of file
